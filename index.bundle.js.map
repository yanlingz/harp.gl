{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"THREE\"","webpack:///../@here/harp-utils/index.web.ts","webpack:///../@here/harp-datasource-protocol/index.ts","webpack:///../@here/harp-geoutils/index.ts","webpack:///../@here/harp-materials/index.ts","webpack:///../@here/harp-datasource-protocol/lib/Expr.ts","webpack:///../@here/harp-text-canvas/index.ts","webpack:///../@here/harp-geoutils/lib/coordinates/GeoCoordinates.ts","webpack:///../@here/harp-geoutils/lib/math/MathUtils.ts","webpack:///../@here/harp-materials/lib/Utils.ts","webpack:///../@here/harp-mapview/lib/Utils.ts","webpack:///../@here/harp-geoutils/lib/projection/EarthConstants.ts","webpack:///../@here/harp-geoutils/lib/math/Box3Like.ts","webpack:///../@here/harp-geoutils/lib/math/OrientedBox3Like.ts","webpack:///../@here/harp-geoutils/lib/projection/Projection.ts","webpack:///../@here/harp-mapview/index.ts","webpack:///../@here/harp-mapview/lib/text/TextElement.ts","webpack:///../@here/harp-text-canvas/lib/rendering/TextStyle.ts","webpack:///../@here/harp-mapview/lib/DecodedTileHelpers.ts","webpack:///../@here/harp-geoutils/lib/coordinates/GeoBox.ts","webpack:///../@here/harp-geoutils/lib/coordinates/GeoCoordinatesLike.ts","webpack:///../@here/harp-geoutils/lib/tiling/TilingScheme.ts","webpack:///../@here/harp-datasource-protocol/lib/ColorUtils.ts","webpack:///../@here/harp-text-canvas/lib/utils/UnicodeUtils.ts","webpack:///../@here/harp-mapview/lib/text/TextElementType.ts","webpack:///../@here/harp-mapview/lib/composing/Pass.ts","webpack:///../@here/harp-geoutils/lib/projection/MercatorProjection.ts","webpack:///../@here/harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.ts","webpack:///../@here/harp-geoutils/lib/tiling/TileKey.ts","webpack:///../@here/harp-datasource-protocol/lib/RGBA.ts","webpack:///../@here/harp-datasource-protocol/lib/StringEncodedNumeral.ts","webpack:///../@here/harp-datasource-protocol/lib/Env.ts","webpack:///../@here/harp-datasource-protocol/lib/InterpolatedPropertyDefs.ts","webpack:///../@here/harp-datasource-protocol/lib/Theme.ts","webpack:///../@here/harp-materials/lib/MapMeshMaterialsDefs.ts","webpack:///../@here/harp-mapview/lib/Tile.ts","webpack:///../@here/harp-mapview/lib/Statistics.ts","webpack:///../@here/harp-mapview/lib/MapObjectAdapter.ts","webpack:///../@here/harp-mapview/lib/text/TextElementsRenderer.ts","webpack:///../@here/harp-utils/lib/Logger/ILogger.ts","webpack:///../@here/harp-utils/lib/UrlUtils.ts","webpack:///../@here/harp-datasource-protocol/lib/Pixels.ts","webpack:///../@here/harp-datasource-protocol/lib/Techniques.ts","webpack:///../@here/harp-materials/lib/MapMeshMaterials.ts","webpack:///../@here/harp-materials/lib/ShaderChunks/LinesChunks.ts","webpack:///../@here/harp-text-canvas/lib/rendering/GlyphData.ts","webpack:///../@here/harp-text-canvas/lib/rendering/TextGeometry.ts","webpack:///../@here/harp-text-canvas/lib/utils/TypesettingUtils.ts","webpack:///../@here/harp-mapview/lib/ClipPlanesEvaluator.ts","webpack:///../@here/harp-mapview/lib/ColorCache.ts","webpack:///../@here/harp-mapview/lib/ConcurrentDecoderFacade.ts","webpack:///../@here/harp-mapview/lib/MapView.ts","webpack:///../@here/harp-mapview/lib/DataSource.ts","webpack:///../@here/harp-mapview/lib/geometry/TileGeometryCreator.ts","webpack:///../@here/harp-mapview/lib/MapMaterialAdapter.ts","webpack:///../@here/harp-mapview/lib/MapViewPoints.ts","webpack:///../@here/harp-mapview/lib/DebugContext.ts","webpack:///../@here/harp-mapview/lib/PickHandler.ts","webpack:///../@here/harp-mapview/lib/copyrights/CopyrightInfo.ts","webpack:///../@here/harp-lines/lib/HighPrecisionUtils.ts","webpack:///../@here/harp-omv-datasource/lib/OmvDecoderDefs.ts","webpack:///../@here/harp-omv-datasource/lib/OmvTile.ts","webpack:///../@here/harp-geoutils/lib/coordinates/GeoPointLike.ts","webpack:///../@here/harp-geoutils/lib/coordinates/LatLngLike.ts","webpack:///../@here/harp-geoutils/lib/projection/EquirectangularProjection.ts","webpack:///../@here/harp-geoutils/lib/projection/TransverseMercatorProjection.ts","webpack:///../@here/harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.ts","webpack:///../@here/harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.ts","webpack:///../@here/harp-geoutils/lib/tiling/SubTiles.ts","webpack:///../@here/harp-geoutils/lib/tiling/TileKeyUtils.ts","webpack:///../@here/harp-geoutils/lib/tiling/TileTreeTraverse.ts","webpack:///../@here/harp-mapview/lib/AnimatedExtrusionHandler.ts","webpack:///../@here/harp-utils/lib/Logger/ConsoleChannel.ts","webpack:///../@here/harp-utils/lib/Logger/Logger.ts","webpack:///../@here/harp-utils/lib/Logger/WorkerChannel.ts","webpack:///../@here/harp-datasource-protocol/lib/TechniqueParams.ts","webpack:///../@here/harp-datasource-protocol/lib/TechniqueDescriptor.ts","webpack:///../@here/harp-datasource-protocol/lib/PropertyValue.ts","webpack:///../@here/harp-datasource-protocol/lib/DecodedTile.ts","webpack:///../@here/harp-materials/lib/CopyMaterial.ts","webpack:///../@here/harp-materials/lib/ShaderChunks/AtmosphereChunks.ts","webpack:///../@here/harp-mapview/lib/CameraMovementDetector.ts","webpack:///../@here/harp-mapview/lib/geometry/LodMesh.ts","webpack:///../@here/harp-lrucache/index.ts","webpack:///../@here/harp-text-canvas/lib/rendering/TextMaterials.ts","webpack:///../@here/harp-text-canvas/lib/rendering/TextBufferObject.ts","webpack:///../@here/harp-text-canvas/lib/utils/MaterialUtils.ts","webpack:///../@here/harp-mapview/lib/composing/index.ts","webpack:///../@here/harp-mapview/lib/composing/MSAARenderPass.ts","webpack:///../@here/harp-mapview/lib/ConcurrentWorkerSet.ts","webpack:///../@here/harp-mapview/lib/workers/WorkerLoader.ts","webpack:///../@here/harp-mapview/lib/WorkerBasedDecoder.ts","webpack:///../@here/harp-mapview/lib/ConcurrentTilerFacade.ts","webpack:///../@here/harp-mapview/lib/WorkerBasedTiler.ts","webpack:///../@here/harp-mapview/lib/BackgroundDataSource.ts","webpack:///../@here/harp-datasource-protocol/lib/ExprPool.ts","webpack:///../@here/harp-geometry/lib/SubdivisionModifier.ts","webpack:///../@here/harp-mapview/lib/geometry/DisplacedBufferAttribute.ts","webpack:///../@here/harp-mapview/lib/geometry/DisplacedBufferGeometry.ts","webpack:///../@here/harp-mapview/lib/ThemeHelpers.ts","webpack:///../@here/harp-mapview/lib/DepthPrePass.ts","webpack:///../@here/harp-mapview/lib/geometry/overlayOnElevation.ts","webpack:///../@here/harp-mapview/lib/text/Placement.ts","webpack:///../@here/harp-mapview/lib/poi/PoiRenderer.ts","webpack:///../@here/harp-mapview/lib/image/MipMapGenerator.ts","webpack:///../@here/harp-mapview/lib/ScreenCollisions.ts","webpack:///../node_modules/rbush/rbush.min.js","webpack:///../@here/harp-mapview/lib/text/TextStyleCache.ts","webpack:///../@here/harp-mapview/lib/ElevationRangeSource.ts","webpack:///../@here/harp-mapview/lib/image/MapViewImageCache.ts","webpack:///../@here/harp-mapview/lib/image/ImageCache.ts","webpack:///../@here/harp-mapview/lib/MapAnchors.ts","webpack:///../@here/harp-mapview/lib/MapViewFog.ts","webpack:///../@here/harp-mapview/lib/poi/PoiManager.ts","webpack:///../@here/harp-mapview/lib/poi/PoiTableManager.ts","webpack:///../@here/harp-mapview/lib/PolarTileDataSource.ts","webpack:///../@here/harp-mapview/lib/SkyCubemapTexture.ts","webpack:///../@here/harp-mapview/lib/ThemeLoader.ts","webpack:///../@here/harp-mapview/lib/VisibleTileSet.ts","webpack:///../@here/harp-mapview/lib/copyrights/CopyrightCoverageProvider.ts","webpack:///../@here/harp-transfer-manager/index.ts","webpack:///../@here/harp-mapview/lib/geometry/TileGeometry.ts","webpack:///../@here/harp-lines/lib/TriangulateLines.ts","webpack:///../@here/harp-lines/lib/HighPrecisionLines.ts","webpack:///../@here/harp-mapview-decoder/lib/TileLoader.ts","webpack:///../@here/harp-omv-datasource/lib/OmvRestClient.ts","webpack:///./src/index.ts","webpack:///../@here/harp-geoutils/lib/coordinates/GeoBoxExtentLike.ts","webpack:///../@here/harp-geoutils/lib/projection/IdentityProjection.ts","webpack:///../@here/harp-geoutils/lib/projection/SphereProjection.ts","webpack:///../@here/harp-geoutils/lib/tiling/QuadTree.ts","webpack:///../@here/harp-geoutils/lib/tiling/HereTilingScheme.ts","webpack:///../@here/harp-geoutils/lib/tiling/WebMercatorTilingScheme.ts","webpack:///../@here/harp-geoutils/lib/tiling/MercatorTilingScheme.ts","webpack:///../@here/harp-geoutils/lib/tiling/PolarTilingScheme.ts","webpack:///../@here/harp-geoutils/lib/math/Vector3Like.ts","webpack:///../@here/harp-geoutils/lib/math/TransformLike.ts","webpack:///../@here/harp-geoutils/lib/math/OrientedBox3.ts","webpack:///../@here/harp-utils/index-common.ts","webpack:///../@here/harp-utils/lib/GroupedPriorityList.ts","webpack:///../@here/harp-utils/lib/Logger/index.ts","webpack:///../@here/harp-utils/lib/Logger/LoggerManager.ts","webpack:///../@here/harp-utils/lib/Logger/LoggerManagerImpl.ts","webpack:///../@here/harp-utils/lib/Logger/MultiChannel.ts","webpack:///../@here/harp-utils/lib/Math2D.ts","webpack:///../@here/harp-utils/lib/MathUtils.ts","webpack:///../@here/harp-utils/lib/Mixins.ts","webpack:///../@here/harp-utils/lib/assert.ts","webpack:///../@here/harp-utils/lib/ContextLogger.ts","webpack:///../@here/harp-utils/lib/PerformanceTimer.ts","webpack:///../@here/harp-utils/lib/ObjectUtils.ts","webpack:///../@here/harp-utils/lib/OptionsUtils.ts","webpack:///../@here/harp-utils/lib/UriResolver.ts","webpack:///../@here/harp-utils/lib/Functions.ts","webpack:///../@here/harp-utils/lib/SampleBilinear.ts","webpack:///../@here/harp-utils/lib/UrlPlatformUtils.web.ts","webpack:///../node_modules/csscolorparser/csscolorparser.js","webpack:///../@here/harp-datasource-protocol/lib/ExprEvaluator.ts","webpack:///../@here/harp-datasource-protocol/lib/operators/ArrayOperators.ts","webpack:///../@here/harp-datasource-protocol/lib/operators/CastOperators.ts","webpack:///../@here/harp-datasource-protocol/lib/operators/ColorOperators.ts","webpack:///../@here/harp-datasource-protocol/lib/operators/ComparisonOperators.ts","webpack:///../@here/harp-datasource-protocol/lib/operators/FeatureOperators.ts","webpack:///../@here/harp-datasource-protocol/lib/operators/FlowOperators.ts","webpack:///../@here/harp-datasource-protocol/lib/operators/MapOperators.ts","webpack:///../@here/harp-datasource-protocol/lib/operators/MathOperators.ts","webpack:///../@here/harp-datasource-protocol/lib/operators/MiscOperators.ts","webpack:///../@here/harp-datasource-protocol/lib/operators/ObjectOperators.ts","webpack:///../@here/harp-datasource-protocol/lib/operators/StringOperators.ts","webpack:///../@here/harp-datasource-protocol/lib/operators/TypeOperators.ts","webpack:///../@here/harp-datasource-protocol/lib/operators/VectorOperators.ts","webpack:///../@here/harp-datasource-protocol/lib/ExprInstantiator.ts","webpack:///../@here/harp-datasource-protocol/lib/ExprParser.ts","webpack:///../@here/harp-datasource-protocol/lib/WorkerServiceProtocol.ts","webpack:///../@here/harp-datasource-protocol/lib/WorkerTilerProtocol.ts","webpack:///../@here/harp-datasource-protocol/lib/WorkerDecoderProtocol.ts","webpack:///../@here/harp-datasource-protocol/lib/TechniqueAttr.ts","webpack:///../@here/harp-datasource-protocol/lib/ThemeVisitor.ts","webpack:///../@here/harp-materials/lib/CirclePointsMaterial.ts","webpack:///../@here/harp-materials/lib/DisplacementFeature.ts","webpack:///../@here/harp-materials/lib/EdgeMaterial.ts","webpack:///../@here/harp-materials/lib/ShaderChunks/ExtrusionChunks.ts","webpack:///../@here/harp-materials/lib/ShaderChunks/FadingChunks.ts","webpack:///../@here/harp-materials/lib/ShaderChunks/ShadowChunks.ts","webpack:///../@here/harp-materials/lib/GroundAtmosphereMaterial.ts","webpack:///../@here/harp-materials/lib/HighPrecisionLineMaterial.ts","webpack:///../@here/harp-materials/lib/HighPrecisionPointMaterial.ts","webpack:///../@here/harp-materials/lib/IconMaterial.ts","webpack:///../@here/harp-materials/lib/LuminosityHighPassShader.ts","webpack:///../@here/harp-materials/lib/MSAAMaterial.ts","webpack:///../@here/harp-materials/lib/SepiaShader.ts","webpack:///../@here/harp-materials/lib/SkyAtmosphereMaterial.ts","webpack:///../@here/harp-materials/lib/SolidLineMaterial.ts","webpack:///../@here/harp-materials/lib/VignetteShader.ts","webpack:///../@here/harp-text-canvas/lib/rendering/FontCatalog.ts","webpack:///../@here/harp-text-canvas/lib/rendering/GlyphTextureCache.ts","webpack:///../@here/harp-lrucache/lib/LRUCache.ts","webpack:///../@here/harp-text-canvas/lib/TextCanvas.ts","webpack:///../@here/harp-text-canvas/lib/typesetting/LineTypesetter.ts","webpack:///../@here/harp-text-canvas/lib/typesetting/PathTypesetter.ts","webpack:///../@here/harp-text-canvas/lib/utils/ContextualArabicConverter.ts","webpack:///../@here/harp-mapview/lib/text/TextElementGroup.ts","webpack:///../@here/harp-mapview/lib/text/TextElementGroupPriorityList.ts","webpack:///../@here/harp-mapview/lib/text/TileTextStyleCache.ts","webpack:///../@here/harp-mapview/lib/composing/MapRenderingManager.ts","webpack:///../@here/harp-mapview/lib/composing/LowResRenderPass.ts","webpack:///../@here/harp-mapview/lib/composing/Outline.ts","webpack:///../@here/harp-mapview/lib/composing/UnrealBloomPass.ts","webpack:///../@here/harp-mapview/lib/workers/WorkerBootstrapDefs.ts","webpack:///../@here/harp-mapview/lib/copyrights/CopyrightElementHandler.ts","webpack:///../@here/harp-geometry/lib/EdgeLengthGeometrySubdivisionModifier.ts","webpack:///../@here/harp-geometry/lib/SphericalGeometrySubdivisionModifier.ts","webpack:///../@here/harp-mapview/lib/geometry/DisplacedMesh.ts","webpack:///../@here/harp-mapview/lib/geometry/VertexCache.ts","webpack:///../@here/harp-mapview/lib/geometry/SolidLineMesh.ts","webpack:///../@here/harp-mapview/lib/PathBlockingElement.ts","webpack:///../@here/harp-mapview/lib/poi/BoxBuffer.ts","webpack:///../@here/harp-mapview/lib/poi/PixelPicker.ts","webpack:///../@here/harp-mapview/lib/text/PlacementStats.ts","webpack:///../@here/harp-mapview/lib/text/SimplePath.ts","webpack:///../@here/harp-mapview/lib/text/TextElementsRendererOptions.ts","webpack:///../@here/harp-mapview/lib/text/TextElementStateCache.ts","webpack:///../@here/harp-mapview/lib/text/TextElementGroupState.ts","webpack:///../@here/harp-mapview/lib/text/TextElementState.ts","webpack:///../@here/harp-mapview/lib/text/LayoutState.ts","webpack:///../@here/harp-mapview/lib/text/RenderState.ts","webpack:///../@here/harp-mapview/lib/text/UpdateStats.ts","webpack:///../@here/harp-mapview/lib/FrustumIntersection.ts","webpack:///../@here/harp-mapview/lib/MapTileCuller.ts","webpack:///../@here/harp-mapview/lib/geometry/TileGeometryManager.ts","webpack:///../@here/harp-mapview/lib/geometry/TileGeometryLoader.ts","webpack:///../@here/harp-mapview/lib/PickingRaycaster.ts","webpack:///../@here/harp-mapview/lib/poi/PoiRendererFactory.ts","webpack:///../@here/harp-datasource-protocol/index-decoder.ts","webpack:///../@here/harp-datasource-protocol/lib/StyleSetEvaluator.ts","webpack:///../@here/harp-datasource-protocol/lib/Outliner.ts","webpack:///../@here/harp-datasource-protocol/lib/ThreeBufferUtils.ts","webpack:///../@here/harp-mapview/lib/ScreenProjector.ts","webpack:///../@here/harp-mapview/lib/SkyBackground.ts","webpack:///../@here/harp-mapview/lib/SkyGradientTexture.ts","webpack:///../@here/harp-mapview/lib/text/FontCatalogLoader.ts","webpack:///../@here/harp-mapview/lib/text/MapViewState.ts","webpack:///../@here/harp-mapview/lib/text/TextCanvasFactory.ts","webpack:///../@here/harp-mapview/lib/copyrights/UrlCopyrightProvider.ts","webpack:///../@here/harp-transfer-manager/src/TransferManager.ts","webpack:///../@here/harp-transfer-manager/src/DeferredPromise.ts","webpack:///../@here/harp-mapview/lib/image/Image.ts","webpack:///../@here/harp-mapview/lib/MapViewAtmosphere.ts","webpack:///../@here/harp-mapview/lib/poi/Poi.ts","webpack:///../@here/harp-mapview/lib/TextureLoader.ts","webpack:///../@here/harp-mapview/lib/geometry/TileDataAccessor.ts","webpack:///../@here/harp-lines/index.ts","webpack:///../@here/harp-lines/lib/Lines.ts","webpack:///../@here/harp-lines/lib/HighPrecisionPoints.ts","webpack:///../@here/harp-omv-datasource/index.ts","webpack:///../@here/harp-omv-datasource/lib/OmvDataFilter.ts","webpack:///../@here/harp-omv-datasource/lib/OmvDataSource.ts","webpack:///../@here/harp-mapview-decoder/index.ts","webpack:///../@here/harp-mapview-decoder/lib/DataProvider.ts","webpack:///../@here/harp-mapview-decoder/lib/TileDataSource.ts","webpack:///../@here/harp-omv-datasource/lib/OmvDebugLabelsTile.ts","webpack:///../@here/harp-omv-datasource/lib/GeoJsonDataProvider.ts","webpack:///../@here/harp-examples/config.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","THREE","exprEvaluator","ExprEvaluator","exprInstantiator","ExprInstantiator","ExprDependencies","properties","Set","ComputeExprDependencies","expr","dependencies","accept","this","instance","context","add","args","forEach","childExpr","op","volatile","featureState","branches","_","branch","fallback","condition","input","defaultValue","stops","isJsonExpr","v","Array","isArray","length","ExprScope","Expr","code","ExprParser","parse","json","definitions","definitionExprCache","parseNode","undefined","lockedNames","cache","Map","env","scope","Value","ExprEvaluatorContext","m_dependencies","of","pool","ExprSerializer","serialize","m_isDynamic","exprIsDynamic","VarExpr","super","visitor","visitVarExpr","LiteralExpr","BooleanLiteralExpr","NumberLiteralExpr","StringLiteralExpr","NullLiteralExpr","ObjectLiteralExpr","Error","visitNullLiteralExpr","visitBooleanLiteralExpr","visitNumberLiteralExpr","m_promotedValue","RGBA","Pixels","visitStringLiteralExpr","visitObjectLiteralExpr","HasAttributeExpr","visitHasAttributeExpr","CallExpr","visitCallExpr","descriptor","getOperator","isDynamicOperator","some","e","isDynamic","MatchExpr","node","elementTy","every","visitMatchExpr","CaseExpr","visitCaseExpr","cond","StepExpr","visitStepExpr","InterpolateExpr","visitInterpolateExpr","Vector2","x","y","Vector3","z","Vector4","w","map","label","body","push","result","referenceResolverState","parseCall","slice","has","cachedEntry","definitionEntry","isLiteralDefinition","fromJSON","isBoxedDefinition","isInterpolatedPropertyDefinition","interpolatedPropertyDefinitionToJsonExpr","delete","set","resolveReference","makeCallExpr","parseGetExpr","parseHasExpr","obj","parseLiteralExpr","conditions","isValidMatchLabel","JSON","stringify","parseMatchExpr","caseFallback","parseCaseExpr","isInterpolationMode","isExpr","parseInterpolateExpr","parseStepExpr","GeoCoordinates","latitude","longitude","altitude","MathUtils","radToDeg","latLng","lat","lng","geoPoint","isGeoPointLike","fromGeoPoint","isGeoCoordinatesLike","fromDegrees","isLatLngLike","degToRad","isNaN","wrapped","sign","Math","other","normalizeAngleDeg","a","angleDistanceDeg","b","newEmptyBox3","min","Infinity","max","newVector3","copyVector3","from","to","clamp","normalizeLongitudeDeg","interpolateAnglesDeg","p0","p1","enableBlending","material","transparent","forcedBlending","blending","CustomBlending","premultipliedAlpha","blendSrc","OneFactor","blendDst","OneMinusSrcAlphaFactor","blendSrcAlpha","blendDstAlpha","SrcAlphaFactor","getShaderMaterialDefine","fallbackValue","defines","getShaderDefine","setShaderDefine","updated","DEFINE_BOOL_TRUE","currentValue","DEFINE_BOOL_FALSE","shaderContent","shaderName","insertedShaderName","addTab","tabChar","replace","NormalBlending","assert","needsUpdate","logger","LoggerManager","groundNormalPlanarProj","groundPlane","Plane","clone","groundSphere","Sphere","EarthConstants","EQUATORIAL_RADIUS","rayCaster","Raycaster","space","tangentSpace","quaternions","Quaternion","vector3","matrix4","Matrix4","transforms","xAxis","yAxis","zAxis","position","MapViewUtils","orbitFocusPoint","mapView","deltaAzimuthDeg","deltaTiltDeg","maxTiltAngleRad","MAX_TILT_RAD","target","sphericalCoordinates","extractSphericalCoordinatesFromLocation","camera","tilt","heading","azimuth","PI","lookAt","distance","targetDistance","getWorldTargetFromCamera","projection","elevation","cameraPos","copy","cameraLookAt","getWorldDirection","constant","radius","targetWorldPos","type","ProjectionType","Planar","ray","intersectPlane","intersectSphere","getCameraPositionFromTargetCoordinates","targetCoordinates","yawDeg","pitchDeg","pitchRad","cos","yawRad","projectPoint","groundDistance","sin","Spherical","normalize","projectOnPlane","setFromAxisAngle","applyQuaternion","setLength","height","cameraHeight","sqrt","wrapWorldPointsToView","points","cameraPosNormalized","point","angleTo","pointLen","getFitBoundsDistance","worldTarget","cameraRotationMatrix","extractRotation","matrixWorld","screenUpVector","applyMatrix4","screenSideVector","screenVertMidPlane","setFromCoplanarPoints","screenHorzMidPlane","halfVertFov","fov","halfHorzFov","aspect","halfVertFovTan","tan","halfHorzFovTan","cameraToTarget","sub","negate","cameraToTargetNormalized","offsetVector","cameraToPointOnRefPlane","pointOnRefPlane","checkAngle","referencePlane","maxAngle","fovFactor","viewAngle","cameraToPointLen","cameraToTargetLen","newCameraDistance","multiplyScalar","rayCastWorldCoordinates","pointOnScreenXinNDC","pointOnScreenYinNDC","pointInNDCPosition","multiplyMatrices","getInverse","projectionMatrix","pointInCameraSpace","worldPosition","panCameraAboveFlatMap","offsetX","offsetY","panCameraAroundGlobe","fromWorld","toWorld","setFromUnitVectors","inverse","makeRotationFromQuaternion","updateMatrixWorld","getCameraRotationAtTarget","transform","localTangentSpace","makeBasis","setFromRotationMatrix","multiply","extractCameraTilt","normal","surfaceNormal","cosTheta","dot","acos","targetGeoCoords","getGeoTargetFromCamera","extractTiltAngleFromLocation","warn","extractAttitude","options","setFromMatrixPosition","unprojectPoint","setFromMatrixColumn","yaw","pitch","roll","atan2","location","cross","calculateDistanceToGroundFromZoomLevel","zoomLevel","cameraPitch","tileSize","EQUATORIAL_CIRCUMFERENCE","pow","focalLength","estimateTextureSize","texture","objectSize","visitedObjects","image","uuid","imageBytes","width","heapSize","gpuSize","estimateMaterialSize","RawShaderMaterial","ShaderMaterial","rawMaterial","uniforms","uniform","Texture","MeshBasicMaterial","MapMeshBasicMaterial","meshMaterial","aoMap","specularMap","alphaMap","envMap","MapMeshStandardMaterial","standardMaterial","lightMap","emissiveMap","bumpMap","normalMap","displacementMap","roughnessMap","metalnessMap","LineBasicMaterial","LineDashedMaterial","estimateAttributeSize","attribute","attrName","generateUUID","attrBytes","bytesPerElement","array","BYTES_PER_ELEMENT","InterleavedBufferAttribute","BufferAttribute","count","itemSize","estimateGeometrySize","geometry","bufferGeometry","Geometry","vertices","faces","_bufferGeometry","BufferGeometry","attributes","index","getIsoLanguageCode","language","substring","MAX_TILT_DEG","DEG2RAD","zoomOnTargetPosition","targetNDCx","targetNDCy","maxTiltAngle","elevationProvider","getHeight","setZ","deltaTilt","newWorldTarget","getTargetAndDistance","distanceTo","cameraPosZ","level","geoLocation","heightAboveTerrain","unprojectAltitude","abs","getHeightAboveTerrain","cameraDir","fallbackTarget","wrapGeoPointsToScreen","startPosition","startIndex","fromObject","north","south","lonCenter","lonSpan","east","west","relToCenter","geoBoxToGeoPoints","box","center","getFitBoundsLookAtParams","geoTarget","worldPoints","params","startDistance","minDistance","tmpCamera","quaternion","getCameraCoordinatesFromTargetCoordinates","rotate","deltaYawDeg","deltaPitchDeg","rotateOnWorldAxis","newPitch","maxPitch","asin","rotateX","setRotation","geoCenter","dirVec","dirLen","error","divideScalar","getCameraFrustumPlanes","near","far","top","zoom","left","view","enabled","fullWidth","fullHeight","filmOffset","getFilmWidth","right","bottom","rayCastGeoCoordinates","worldCoordinates","calculateDistanceFromZoomLevel","calculateZoomLevelFromDistance","ceiling","ceil","snapToCeilingZoomLevel","log2","minZoomLevel","maxZoomLevel","calculateDepthFromClipDistance","clipDistance","perspCam","cameraRange","viewSpaceDistance","cameraToWorldDistance","calculateVerticalFovByHorizontalFov","hFov","atan","calculateHorizontalFovByVerticalFov","vFov","calculateFocalLengthByVerticalFov","calculateFovByFocalLength","calculateScreenSizeByFocalLength","worldSize","calculateWorldSizeByFocalLength","screenSize","estimateObject3dSize","parentSize","size","isObject3D","Scene","isMesh","isLine","isPoints","mesh","materials","geometries","featureData","userData","feature","getFeatureDataSize","estimateMeshSize","children","child","mapViewIsLoading","numTilesLoading","tileList","visibleTileSet","dataSourceTileList","tile","visibleTiles","tileLoader","isFinished","tileGeometryLoader","isLoading","textElementsRenderer","loading","poiTableManager","finishedLoading","allVisibleTilesLoaded","getBrowserLanguages","navigator","languages","languageList","lang","powerOfTwo","TileOffsetUtils","getKeyForTileKeyAndOffset","tileKey","offset","bitshift","shiftedOffset","offsetBits","totalOffsetsToStore","getShiftedOffset","mortonCode","extractOffsetAndMortonKeyFromKey","num","getParentKeyFromKey","calculatedKey","TileKey","fromMortonCode","parentMortonCode","MIN_ELEVATION","MAX_ELEVATION","MAX_BUILDING_HEIGHT","box3","obb","extents","unitScale","sourceProjection","worldPos","poiInfo","poiRenderBatch","LoadingState","TextElement","text","renderParams","layoutParams","priority","xOffset","yOffset","featureId","style","fadeNear","fadeFar","tileOffset","offsetDirection","visible","distanceScale","renderOrder","elevated","TextRenderStyle","renderStyle","TextLayoutStyle","layoutStyle","TextElementType","PoiLabel","PathLabel","mayOverlap","reserveSpace","m_poiInfo","path","LineMarker","poiRenderOrder","m_renderStyle","m_layoutStyle","min2","iconMinZoomLevel","textMinZoomLevel","max2","iconMaxZoomLevel","textMaxZoomLevel","HIGHEST_PRIORITY","Number","MAX_SAFE_INTEGER","FontUnit","FontStyle","FontVariant","VerticalAlignment","HorizontalAlignment","WrappingMode","DefaultTextStyle","hAlignFromPlacement","hP","vAlignFromPlacement","vP","VerticalPlacement","HorizontalPlacement","hA","vA","DEFAULT_FONT_NAME","DEFAULT_FONT_SIZE","unit","freeze","Pixel","backgroundSize","DEFAULT_FONT_STYLE","Regular","DEFAULT_FONT_VARIANT","DEFAULT_ROTATION","DEFAULT_COLOR","Color","DEFAULT_OPACITY","DEFAULT_BACKGROUND_COLOR","DEFAULT_BACKGROUND_OPACITY","DEFAULT_TRACKING","DEFAULT_LEADING","DEFAULT_MAX_LINES","DEFAULT_LINE_WIDTH","DEFAULT_CANVAS_ROTATION","DEFAULT_LINE_ROTATION","DEFAULT_WRAPPING_MODE","Word","DEFAULT_VERTICAL_ALIGNMENT","Above","DEFAULT_HORIZONTAL_ALIGNMENT","Left","DEFAULT_PLACEMENTS","m_params","fontName","fontSize","fontStyle","fontVariant","rotation","color","opacity","backgroundColor","backgroundOpacity","source","horizontalAlignment","verticalAlignment","placements","resolvePlacementAndAlignment","tracking","leading","maxLines","lineWidth","canvasRotation","lineRotation","wrappingMode","hAlignment","vAlignment","placementsOpt","h","getMaterialConstructor","technique","shadowsEnabled","isExtrudedLineTechnique","shading","SolidLineMaterial","PointsMaterial","CirclePointsMaterial","buildMetricValueEvaluator","metricUnit","endsWith","parseFloat","lookup","getPropertyValue","applySecondaryColorToMaterial","materialColor","techniqueColor","evaluateColorProperty","ColorUtils","hasAlphaInHex","removeAlphaFromHex","setHex","applyBaseColorToMaterial","colorValue","g","getRgbaFromHex","tech","evaluateProperty","setRGB","disableBlending","parsed","parseStringEncodedColor","getBaseColorPropName","techDescriptor","techniqueDescriptors","attrTransparencyColor","textureReadyCallback","Constructor","settings","HighPrecisionLineMaterial","fog","removeDiffuseLight","id","isExtrudedPolygonTechnique","flatShading","depthTest","isStandardTechnique","isTerrainTechnique","TEXTURE_PROPERTY_KEYS","texturePropertyName","textureProperty","onLoad","wrapS","toWrappingMode","wrapT","magFilter","toTextureFilter","minFilter","flipY","repeatU","repeat","repeatV","onError","textureUrl","isTextureBuffer","dataTextureProperties","textureDataType","toTextureDataType","textureBuffer","buffer","Uint8Array","UnsignedByteType","ByteType","Int8Array","ShortType","Int16Array","UnsignedShortType","Uint16Array","IntType","Int32Array","UnsignedIntType","Uint32Array","FloatType","Float32Array","HalfFloatType","getTextureBuffer","DataTexture","format","toPixelFormat","textureBlob","Blob","URL","createObjectURL","TextureLoader","load","isShaderTechnique","baseColorPropName","hasBaseColor","getOwnPropertyNames","filter","propertyName","TRANSPARENCY_PROPERTY_KEYS","indexOf","prop","techniqueAttrValue","applyTechniquePropertyToMaterial","propColor","applyShaderTechniqueToMaterial","MapMaterialAdapter","baseProps","pick","outlineWidth","dashSize","gapSize","vertexColors","getMainMaterialStyledProps","itemCount","normalized","elevationEnabled","DisplacedMesh","elevationRange","minElevation","maxElevation","Mesh","SolidLineMesh","raycast","Circles","Squares","LineSegments","primitive","Line","Points","Object3D","BASE_TECHNIQUE_NON_MATERIAL_PROPS","baseColorProp","getBaseColorProp","GeoBox","southWest","northEast","extent","latitudeSpan","longitudeSpan","minAltitude","altitudeSpan","maxAltitude","containsHelper","isFlat","isSameAltitude","isWithinAltitudeRange","subdivisionScheme","boundingBoxGenerator","FlatTileBoundingBoxGenerator","tileTreeTraverse","TileTreeTraverse","subTiles","TileKeyUtils","geoCoordinatesToTileKey","geoBox","geoRectangleToTileKeys","getGeoBox","getWorldBox","tmpColor","getHexFromRgba","floor","getHexFromRgb","getHexFromHsl","setHSL","getHex","hex","getAlphaFromHex","UnicodeUtils","Direction","whiteSpaceRanges","isWhiteSpace","codePoint","range","newLineRanges","isNewLine","nonPrintableRanges","isPrintable","rtlBlocks","neutralBidirectionalRanges","weakBidirectionalRanges","getDirection","block","weakRange","Weak","neutralRange","Neutral","find","element","RTL","LTR","rtlMirroredCodePoints","isRtlMirrored","Pass","renderToScreen","renderer","scene","writeBuffer","readBuffer","delta","setRenderTarget","render","shader","textureID","UniformsUtils","vertexShader","fragmentShader","fsQuad","FullScreenQuad","m_camera","OrthographicCamera","PlaneBufferGeometry","m_mesh","MercatorProjection","Projection","val","MercatorConstants","MAXIMUM_LATITUDE","log","latitudeProject","latitudeClamp","exp","worldPoint","cosh","Box3","geoPointLike","latitudeClampProject","latitudeInRadians","fromRadians","unprojectLatitude","worldCenter","worldNorth","worldSouth","worldYCenter","isBox3Like","isOrientedBox3Like","EPSILON","worldBox","minGeo","maxGeo","fromCoordinates","_worldPoint","webMercatorProjection","mercatorProjection","reprojectPoint","sy","projectBox","maxY","quadTreeSubdivisionScheme","row","column","quadkey","mask","parseInt","charAt","fromRowColumnLevel","quadKey64","quadKey","m_mortonCode","quadkey64","m_hereTile","coordX","coordY","totalWidth","totalHeight","rowsAtLevel","columnsAtLevel","changedLevelBy","toString","col","qnr","subQuad","fromQuadKey","fromHereTile","msb","lerp","StringEncodedNumeralType","StringEncodedMeters","Meters","regExp","decoder","encodedValue","match","exec","StringEncodedPixels","StringEncodedHex","Hex","StringEncodedMetricFormats","StringEncodedMetricFormatMaxSize","reduce","StringEncodedColorFormats","StringEncodedColorFormatMaxSize","StringEncodedNumeralFormats","StringEncodedNumeralFormatMaxSize","tmpBuffer","parseStringLiteral","formats","pixelToMeters","matchedFormat","components","parseCSSColor","numeral","Env","entries","parent","unmap","InterpolationMode","interpolationMode","values","zoomLevels","interpolation","step","exponent","def","bdef","styleDef","ExtrusionFeatureDefs","DEFAULT_RATIO_MIN","DEFAULT_RATIO_MAX","MIN_BUILDING_HEIGHT","TileLoaderState","numBytes","starts","objInfos","dataSource","objects","frameNumLastRequested","frameNumVisible","frameNumLastVisible","numFramesVisible","visibilityCounter","levelOffset","skipRendering","m_boundingBox","OrientedBox3","m_disposed","m_localTangentSpace","m_forceHasGeometry","m_textElementGroups","TextElementGroupPriorityList","m_pathBlockingElements","m_worldCenter","m_visibleArea","m_elevationRange","m_ownedTextures","WeakSet","getTilingScheme","updateBoundingBox","boundingBox","m_textStyleCache","TileTextStyleCache","m_offset","m_uniqueKey","frameNumber","m_resourceInfo","computeResourceInfo","group","groups","TextElementGroup","textElement","addTextElement","removeTextElement","textElementGroups","m_textElementsChanged","textElementsChanged","blockingElement","remove","changed","_zoomLevel","area","updatePriority","calculationStatus","elevateGeoBox","m_maxGeometryHeight","decodedTile","m_decodedTile","invalidateResourceInfo","forceHasGeometry","maxGeometryHeight","stats","PerformanceStatistics","decodeTime","currentFrame","addValue","copyrightHolderIds","copyrightInfo","requestUpdate","m_tileGeometryLoader","hasGeometry","basicGeometryLoaded","allGeometryLoaded","m_tileLoader","loadAndDecode","then","tileLoaderState","Ready","catch","Canceled","Failed","disposeMaterial","materialProperty","shouldDisposeTexture","dispose","disposeObject","shouldDisposeObjectGeometry","shouldDisposeObjectMaterial","rootObject","traverse","preparedTextPaths","clear","clearTextElements","hasTextElements","splice","callback","m_disposeCallback","chainCallbacks","cancel","worldExtent","LodMesh","setLevelOfDetail","newBoundingBox","num3dObjects","numTextElements","aggregatedObjSize","elements","tileInfo","numUserTextElements","RingBuffer","capacity","head","tail","data","next","enqOne","previous","Iterator","m_buffer","m_index","SimpleTimer","statistics","running","m_currentValue","PerformanceTimer","now","setValue","SampledTimer","numResets","maxNumSamples","samples","reset","getStats","computeArrayStats","asArray","sort","median","median75","median90","median95","median97","median99","median999","mid","round","sum","avg","numSamples","stages","stage","hasTimer","getTimer","currentStage","stop","start","timers","nullTimer","keepSamples","timer","addTimer","header","footer","maxNameLength","print","toFixed","simpleStats","FrameStats","messages","oldValue","message","FrameStatsArray","frameEntries","frameStats","currentSize","enq","maxNumFrames","appResults","configs","m_instance","m_frameEvents","clearFrames","webGlInfo","calls","lines","triangles","memory","textures","programs","window","performance","totalJSHeapSize","usedJSHeapSize","jsHeapSizeLimit","addFrame","onlyLastFrame","frames","plainObject","getAsPlainObject","simpleStatistics","MapObjectAdapter","m_lastUpdateFrameNumber","m_notCompletlyTransparent","kind","getObjectMaterials","mapAdapter","objData","install","ensureUpdated","updateMaterials","somethingChanged","DEFAULT_TEXT_DISTANCE_SCALE","LogLevel","Log","updateStats","placementStats","tempPosition","tempScreenPosition","tempScreenPoints","tempPoiScreenPosition","tmpTextBufferCreationParams","tmpAdditionParams","tmpBufferAdditionParams","TileTextElements","TextElementLists","lists","list","addTextToCanvas","canvas","screenPosition","pathOverflow","layer","letterCaseArray","glyphCaseArray","pickingData","addText","glyphs","isPlacementTimeExceeded","startTime","debug","m_viewState","m_viewCamera","m_viewUpdateCallback","m_screenCollisions","m_screenProjector","m_textCanvasFactory","m_poiManager","m_poiRendererFactory","m_fontCatalogLoader","m_theme","m_initialized","m_glyphLoadingCount","m_textRenderers","m_tmpVector","m_tmpVector3","m_cameraLookAt","m_overloaded","m_cacheInvalidated","m_forceNewLabelsPass","m_addNewLabels","m_textElementStateCache","TextElementStateCache","TextStyleCache","m_options","initializeDefaultOptions","setGlyphCountLimits","minNumGlyphs","maxNumGlyphs","disable","disableFading","delayLabelsUntilMovementFinished","delay","initialized","updateGlyphDebugMesh","textRenderer","textCanvas","invalidateCache","time","tileTextElementsChanged","renderedTiles","checkIfTextElementsChanged","textElementsAvailable","hasOverlayText","initialize","updateTextElements","renderedTilesChanged","clearVisited","findReplacements","anyTextGroupEvicted","update","prepopulateScreenWithBlockingElements","placeNewTextElements","placeTextElements","placeOverlayTextElements","updateTextRenderers","textElements","m_overlayTextElements","concat","pickResults","pickHandler","pickData","pickObjectType","isDuplicate","pickResult","pickText","PickObjectType","Text","poiRenderer","pickTextElements","Icon","waitInitialized","m_loadPromise","memoryUsage","getMemoryUsage","m_initPromise","initializing","initializeDefaultAssets","initializeTextCanvases","lookAtVector","boxes","renderListEntry","startLinePointProj","endLinePointProj","pathBlockingElement","blockingElements","project3","line","screenSpaceLines","end","lineWithBound","minX","maxX","minY","allocateIBoxes","groupState","maxNumPlacedLabels","pass","visited","shieldGroups","hiddenKinds","hiddenGeometryKinds","elevationMap","getDisplacementMap","textElementState","textElementStates","PersistentLabels","total","numRenderedTextElements","uninitialized","viewDistance","tooFar","elementVisible","NewLabels","textElementStyle","getTextElementStyle","hasOrIntersects","overlayTextElement","elementType","isPathLabelTooSmall","numNotVisible","dbgPathTooSmall","numPathTooSmall","forceNewPassOnLoaded","initializeGlyphs","getLayer","DEFAULT_TEXT_CANVAS_LAYER","storage","drawCount","numCannotAdd","textRenderStyle","textLayoutStyle","addPoiLabel","addLineMarkerLabel","addPathLabel","loadingState","Initialized","Requested","Loaded","newLoadPromise","fontCatalog","loadCharset","Promise","all","bounds","getGlyphs","defaultFontCatalogName","initializeDefaultTextElementStyle","loadCatalogs","catalog","loadedTextCanvas","createTextCanvas","createPoiRenderer","defaultTextCanvas","defaultPoiRenderer","initializeTextElementStyles","debugGlyphs","debugContext","getValue","m_debugGlyphTextureCacheMesh","initializeGlyphDebugMesh","m_debugGlyphTextureCacheWireMesh","defaultFontCatalog","planeGeometry","PlaneGeometry","textureSize","maxWidth","maxHeight","depthWrite","wireframe","WireframeGeometry","wireframeMaterial","clearTextCache","checkIfOverloaded","updateStartTime","overloaded","updateTextElementsFromSource","storageLevel","tileDataSource","tiles","sortedTiles","sortedGroups","createSortedGroupsForSorting","numTextElementsUpdated","textElementLists","selectTextElementsToUpdateByDistance","textElementGroup","maxViewDistance","found","getOrSet","checkReadyForPlacement","PrePlacementResult","Ok","deduplicateElement","Duplicate","totalLabels","results","totalGroups","newGroups","tilesToRender","shouldRenderText","groupedPriorityLists","foundGroup","farDistanceLimitRatio","maxDistanceRatioForTextLabels","maxDistanceRatioForPoiLabels","getMaxViewDistance","tileTextElements","prepareTextElementGroup","fadeAnimationRunning","placeStartTime","placeNew","maxNumPlacedTextElements","maxNumVisibleLabels","groupStates","sortedGroupStates","currentPriority","currentPriorityBegin","textElementGroupState","newPriority","placeTextElementGroup","beginGroupIndex","endGroupIndex","screenXOrigin","screenYOrigin","textPath","screenPoints","pt","pX","pY","SimplePath","LineCurve","lookAtDistance","factor","labelDistanceScaleMin","labelDistanceScaleMax","state","maxVisibilityDist","distanceFadeValue","textDistance","labelState","iconIndex","pointLabel","textRenderState","iconRenderStates","iconRenderState","pointToPlaneDistance","setViewDistance","iconRejected","renderIcon","isClamped","isValid","distanceScaleFactor","getDistanceScalingFactor","iconReady","prepareRender","placeIcon","PlacementResult","Invisible","Rejected","distanceFadeFactor","getDistanceFadingFactor","viewState","poiTextMaxDistance","ignoreDistance","iconIsOptional","shouldRenderPointText","placeResult","placePointLabel","numPoiTextsInvisible","textRejected","textIsOptional","startFadeOut","cameraIsMoving","renderTextDuringMovements","shouldRenderPoiText","isFading","startFadeIn","fadeFactor","scaleFactor","textBufferObject","createTextBufferObject","backgroundIsVisible","scale","addTextBufferObject","addTextBufferToCanvas","numRenderedPoiTexts","allocateSpace","renderPoi","renderDistance","numRenderedPoiIcons","getWorldPosition","project","addPointLabel","lineMarkerLabel","shieldGroup","shieldGroupIndex","lineTechnique","minDistanceSqr","pointIndex","tooClose","j","Math2D","distSquared","textMaxDistance","pathLabel","Path","SimpleLineCurve","getPoint","computeViewDistance","textRenderDistance","prevSize","placePathLabel","prevOpacity","prevBgOpacity","numTextElementsInScene","newOverloaded","parentUri","childUri","absoluteUrlWithOriginRe","test","startsWith","getUrlOrigin","substr","baseUrl","RegExp","url","idx","lastIndexOf","getUrlHostAndProtocol","protocol","host","urlOriginRe","RX","baseTechniqueParamsDescriptor","attrScopes","AttrScope","TechniqueGeometry","FeatureGeometry","transient","TechniqueRendering","pointTechniquePropTypes","mergeTechniqueDescriptor","enablePicking","squaresTechniquePropTypes","squares","circlesTechniquePropTypes","circles","lineMarkerTechniquePropTypes","useAbbreviation","useIsoCode","textMayOverlap","iconMayOverlap","textReserveSpace","iconReserveSpace","alwaysOnTop","showOnMap","stackMode","iconFadeTime","textFadeTime","iconXOffset","iconYOffset","iconScale","screenHeight","screenWidth","poiTable","poiName","poiNameField","imageTexture","imageTextureField","imageTexturePrefix","imageTexturePostfix","iconColor","iconBrightness","polygonalTechniqueDescriptor","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","lineColor","lineFadeFar","lineFadeNear","solidLineTechniqueDescriptor","clipping","secondaryRenderOrder","secondaryWidth","secondaryColor","lineTechniqueDescriptor","fillTechniqueDescriptor","fill","standardTechniqueDescriptor","roughness","metalness","alphaTest","emissive","emissiveIntensity","refractionRatio","mapProperties","normalMapProperties","displacementMapProperties","roughnessMapProperties","emissiveMapProperties","bumpMapProperties","metalnessMapProperties","alphaMapProperties","standard","extrudedPolygonTechniqueDescriptor","floorHeight","defaultColor","defaultHeight","constantHeight","boundaryWalls","footprint","maxSlope","enableDepthPrePass","animateExtrusionDuration","animateExtrusion","lineColorMix","textTechniqueDescriptor","shaderTechniqueDescriptor","isStandardExtrudedLineTechnique","isFillTechnique","dashes","textureCoordinateType","transferList","texturePropertyKey","ArrayBuffer","imageName","textureName","emptyTexture","visibilityRange","maximum","linkMixinWithMaterial","mixin","shaderDefines","shaderUniforms","linkMixinWithShader","assign","DisplacementFeature","FadingFeature","ExtrusionFeature","isEnabled","displacementMaterial","updateDisplacementFeature","useDisplacementMap","onBeforeCompile","insertShaderInclude","DisplacementFeatureMixin","m_displacementMap","setDisplacementMap","Uniform","displacementScale","displacementBias","fadingMaterial","DEFAULT_FADE_NEAR","DEFAULT_FADE_FAR","isDefined","patchGlobalShaderChunks","ShaderChunk","fading_pars_vertex","updateFadingFeature","useFading","addRenderHelper","viewRanges","updateUniforms","additionalCallback","onBeforeRender","FadingFeatureMixin","m_fadeNear","m_fadeFar","getFadeNear","setFadeNear","getFadeFar","setFadeFar","extrusionMaterial","extrusionRatio","extrusion_pars_vertex","updateExtrusionFeature","useExtrusion","ExtrusionFeatureMixin","m_extrusion","getExtrusionRatio","setExtrusionRatio","zFightingWorkaround","ZFIGHTING_WORKAROUND","addFadingProperties","applyFadingParameters","addExtrusionProperties","applyExtrusionParameters","addDisplacementProperties","applyDisplacementParameters","copyFadingParameters","copyExtrusionParameters","copyDisplacementParameters","MapMeshDepthMaterial","MeshDepthMaterial","MeshStandardMaterial","meshphysical_frag","simpleLightingShadowChunk","applyMixinsWithoutProperties","LineCapsModes","extrude_line_vert_func","round_edges_and_add_caps","CAPS_NONE","CAPS_SQUARE","CAPS_ROUND","CAPS_TRIANGLE_IN","CAPS_TRIANGLE_OUT","tile_clip_func","high_precision_vert_func","GlyphData","advanceX","u0","v0","u1","v1","font","positions","sourceTextureCoordinates","dynamicTextureCoordinates","copyIndex","isInCache","character","String","fromCodePoint","direction","metrics","lineHeight","MAX_CAPACITY","VERTEX_BUFFER_STRIDE","INDEX_BUFFER_STRIDE","VERTICES_PER_QUAD","INDICES_PER_QUAD","QUAD_VERTEX_MEMORY_FOOTPRINT","QUAD_INDEX_MEMORY_FOOTPRINT","backgroundMaterial","initialSize","m_currentCapacity","m_drawCount","m_updateOffset","m_pickingCount","m_vertexBuffer","InterleavedBuffer","setUsage","DynamicDrawUsage","m_positionAttribute","m_uvAttribute","m_colorAttribute","m_bgColorAttribute","m_indexBuffer","m_geometry","setAttribute","setIndex","m_pickingDataArray","m_bgMesh","frustumCulled","updateRange","setDrawRange","glyphData","corners","weight","bgWeight","mirrored","newSize","resizeBuffers","baseVertex","baseIndex","setXYZW","mirroredUVIdx","setX","vertexOffset","bgColor","bgOpacity","cosR","sinR","offsetZ","rotSign","red","green","blue","alpha","bgRed","bgGreen","bgBlue","bgAlpha","targetOffset","srcOffset","glyph","bw","startIdx","endIdx","pickCallback","positionIndex","getX","getY","info","newVertexBuffer","newIndexBuffer","TypesettingUtils","EM_TO_PX","PT_TO_PX","OBLIQUE_ANGLE","OBLIQUE_OFFSET","getPixelSize","originalSize","Em","Point","Percent","getSmallCapsScale","smallCapsTransformations","SmallCaps","xHeight","capHeight","computeGlyphTransform","localRotation","cosAngle","sinAngle","localCosAngle","localSinAngle","updateBounds","globalBounds","individualBounds","Box2","nearMin","nearMultiplier","nearFarMultiplier","farOffset","m_tmpVectors","m_tmpQuaternion","farMin","nearPlane","farPlane","extractBasis","fwd","fwdRot","addScaledVector","minimum","ElevationBasedClipPlanesEvaluator","m_minElevation","m_maxElevation","TopViewClipPlanesEvaluator","nearFarMarginRatio","farMaxRatio","nearFarMargin","m_minimumViewRange","evaluateDistanceSphericalProj","evaluateDistancePlanarProj","minimumViewRange","getCameraAltitude","farMax","cameraAltitude","cam","halfFovAngle","farTangent","getTangentBasedFarPlane","getFovBasedFarPlane","getOrthoBasedFarPlane","getTangentDistance","te","fovAngle","dVec","cameraFwdVec","tVec","cta","a2","r2","TiltViewClipPlanesEvaluator","halfPiLimit","cameraTilt","topAngleRad","bottomAngleRad","z1","z2","sinBeta","topDist","bottomDist","planesDist","getFrustumGroundIntersectionDist","cosHalfFov","PerspectiveCamera","cameraToOrigin","getCameraPitch","modifiedAlpha","getTiltedFovBasedFarPlane","cosAlpha","dSqr","cosAlpha1","minNear","minFarOffset","minFar","m_nearPlane","m_farPlane","fixedNear","invalidatePlanes","fixedFar","nearDist","farDist","createDefaultClipPlanesEvaluator","ColorCache","m_map","colorCode","padStart","ConcurrentDecoderFacade","decoderServiceType","scriptUrl","workerCount","workerSet","getWorkerSet","WorkerBasedDecoder","defaultScriptUrl","workerSets","ConcurrentWorkerSet","defaultWorkerCount","destroy","keys","MapViewEventNames","setLogLevelForAll","DEFAULT_FOV_CALCULATION","FALLBACK_RENDER_ORDER_OFFSET","UPDATE","Update","RENDER_EVENT","Render","DID_RENDER_EVENT","AfterRender","FIRST_FRAME_EVENT","FirstFrame","FRAME_COMPLETE_EVENT","FrameComplete","THEME_LOADED_EVENT","ThemeLoaded","ANIMATION_STARTED_EVENT","AnimationStarted","ANIMATION_FINISHED_EVENT","AnimationFinished","MOVEMENT_STARTED_EVENT","MovementStarted","MOVEMENT_FINISHED_EVENT","MovementFinished","CONTEXT_LOST_EVENT","ContextLost","CONTEXT_RESTORED_EVENT","ContextRestored","COPYRIGHT_CHANGED_EVENT","CopyrightChanged","vector2","frustumPoints","MapViewPowerPreference","MapViewDefaults","addBackgroundDatasource","maxVisibleDataSourceTiles","extendedFrustumCulling","tileCacheSize","resourceComputationType","ResourceComputationType","EstimationInMb","quadTreeSearchDistanceUp","quadTreeSearchDistanceDown","pixelRatio","devicePixelRatio","theme","MapView","EventDispatcher","m_renderLabels","ScreenCollisions","m_visibleTileSetLock","m_tileWrappingEnabled","m_zoomLevel","m_minZoomLevel","m_maxZoomLevel","m_minCameraHeight","m_screenCamera","m_rteCamera","m_yaw","m_pitch","m_roll","m_focalLength","m_targetDistance","m_targetGeoPos","m_targetWorldPos","m_viewRanges","m_scene","m_overlayScene","m_fog","MapViewFog","m_sceneRoot","m_overlaySceneRoot","m_mapAnchors","MapAnchors","m_animationCount","m_drawing","m_updatePending","m_frameNumber","m_forceCameraAspect","m_tileDataSources","m_connectedDataSources","m_failedDataSources","m_enablePolarDataSource","m_plane","m_sphere","m_themeIsLoading","m_firstFrameRendered","m_firstFrameComplete","m_initialTextPlacementDone","m_imageCache","MapViewImageCache","PoiManager","m_poiTableManager","PoiTableManager","m_lastTileIds","m_copyrightInfo","m_env","MapEnv","onWebGLContextLost","event","dispatchEvent","onWebGLContextRestored","m_renderer","clearColor","setClearColor","m_uriResolver","uriResolver","minCameraHeight","decoderUrl","resolveUri","decoderCount","m_visibleTileSetOptions","clipPlanesEvaluator","enablePolarDataSource","m_pixelRatio","maxFps","enableStatistics","m_languages","m_politicalView","politicalView","collisionDebugCanvas","m_collisionDebugCanvas","ScreenCollisionsDebug","handleRequestAnimationFrame","renderLoop","m_pickHandler","PickHandler","enablePickTechnique","tileWrappingEnabled","setupStats","addEventListener","WebGL1Renderer","WebGLRenderer","antialias","nativeWebglAntialiasEnabled","preserveDrawingBuffer","powerPreference","Default","autoClear","checkShaderErrors","autoReset","setupRenderer","fovCalculation","getCanvasClientSize","up","ScreenProjector","setupCamera","m_raycaster","PickingRaycaster","m_movementDetector","CameraMovementDetector","movementThrottleTimeout","movementStarted","movementFinished","mapPassAntialiasSettings","customAntialiasSettings","mapRenderingManager","MapRenderingManager","dynamicPixelRatio","m_tileGeometryManager","TileGeometryManager","enableMixedLod","m_enableMixedLod","m_visibleTiles","createVisibleTileSet","m_animatedExtrusionHandler","AnimatedExtrusionHandler","m_backgroundDataSource","BackgroundDataSource","addDataSource","styleSetName","polarStyleSetName","m_polarDataSource","PolarTileDataSource","geometryLevelOffset","polarGeometryLevelOffset","updatePolarDataSource","backgroundTilingScheme","setTilingScheme","initTheme","m_textElementsRenderer","createTextRenderer","m_createdLights","resetTextRenderer","m_movementFinishedUpdateTimerId","clearTimeout","m_animationFrameHandle","cancelAnimationFrame","removeEventListener","clearTileCache","clearRenderStates","getDataSourceCacheSize","numVisibleTiles","setDataSourceCacheSize","setNumberOfVisibleTiles","updateImages","updateLighting","updateSkyBackground","m_pointOfView","pointOfView","postEffectsFile","fetch","response","postEffects","m_postEffects","setPostEffects","ThemeLoader","isThemeLoaded","loadedTheme","sky","lights","clearAlpha","images","imageTextures","poiTables","loadPoiTables","textStyles","defaultTextStyle","fontCatalogs","priorities","labelPriorities","styles","setTheme","Date","setLanguages","pov","setPoliticalView","m_previousFrameTimeStamp","listener","rendererClearColor","getClearColor","rendererClearAlpha","getClearAlpha","setClearAlpha","lookAtImpl","enableNativeWebglAntialias","calculateFocalLength","getSize","updateCameras","dataSourceName","ds","ready","isVisible","getDataSourceByName","attach","setEnableElevationOverlay","m_elevationProvider","updateStorageLevelOffset","connect","resolve","resolveOnce","DataSourceConnect","dsIndex","detach","removeDataSource","addOverlayText","clearOverlayText","targetOrParams","tiltDeg","headingDeg","geoPos","limitedPitch","maxPitchRadWithCurvature","maxPitchDegWithCurvature","animating","isAnimating","m_pixelToWorld","pixelToWorld","getPixelRatio","setPixelRatio","ratio","lowResPixelRatio","pos","isVector3Like","setFromCamera","getNormalizedScreenCoordinates","getWorldPositionAt","intersectMapObjects","setSize","Resize","frameStartTime","startRenderLoop","clearCache","fun","forEachVisibleTile","forEachCachedTile","markTilesDirty","elevationSource","elevationRangeSource","m_elevationSource","m_elevationRangeSource","dataSources","setTileUpdateCallback","overlayOnElevation","bloom","outline","vignette","sepia","updateOutline","enableShadows","shadowMap","PCFSoftShadowMap","tangentSpaceMatrix","getOptionValue","geoPoints","isGeoBoxExtentLike","fromCenterAndExtents","setFromPoints","getCenter","scalePointToSurface","updateLookAtSettings","twinDataSource","setFovOnCamera","maxGeometryHeightScaled","getScaleFactor","updateClipPlanes","updateProjectionMatrix","setScalar","$zoom","$pixelToMeters","$frameNumber","vector","projectionMatrixInverse","viewPos","matrixWorldInverse","transformedPoints","ndcToView","directionalLight","isDirectionalLight","lightDirection","lightPosHyp","shadow","updateMatrices","pointsInLightSpace","viewToLightSpace","expandByPoint","synchronousRendering","fudgeTimeInMs","frameInterval","requestAnimationFrame","enabledDataSources","isDataSourceEnabled","currentFrameEvent","gatherStatistics","timeSincePreviousFrame","storeAndClearFrameInfo","setupTime","cullTime","textPlacementTime","drawTime","textDrawTime","endTime","m_thisFrameTilesChanged","updateEnv","updateLights","lockVisibleTileSet","viewRangesStatus","updateRenderList","getEnabledTileDataSources","viewRangesChanged","renderList","renderTileObjects","isDynamicFrame","checkCameraMoved","CameraPositionChanged","renderLabels","prepareRenderTextElements","m_skyBackground","updateCamera","finishRenderTextElements","disposePendingTiles","checkCopyrightUpdates","frameRenderTime","addWebGLInfo","addMemoryInfo","worldOffsetX","computeWorldOffsetX","willRender","mapObjectAdapter","processTileObject","displacement","setRotationFromMatrix","getRotationMatrix","_backupRenderOrder","isBuilding","includes","GeometryKind","Building","didRender","processTileObjectFeatures","Boolean","isBufferGeometry","getIndex","endOfLastGroup","clearGroups","featureIndex","getFeatureId","getFeatureState","$state","parentEnv","addGroup","placeText","renderText","themeName","resize","VisibleTileSet","FrustumIntersection","SkyBackground","updateSkyBackgroundColors","addNewSkyBackground","removeSkyBackGround","groundColor","background","updateTexture","light","m_overlayCreatedLights","DirectionalLight","lightDescription","createLight","clonedLight","setTimeout","tileIdList","newTileIds","join","checkIfTilesChanged","newCopyrightInfo","getRenderedTilesCopyrightInfo","allEqual","tileCopyrightInfo","CopyrightInfo","mergeArrays","poiManager","addImage","preload","atlas","addTextureAtlas","addImageTexture","enable","TextElementsRenderer","MapViewState","TextCanvasFactory","PoiRendererFactory","FontCatalogLoader","overlayText","limitFov","clientWidth","clientHeight","UPDATE_EVENT","DataSource","cacheable","useGeometryLoader","addGroundPlane","minDataLevel","maxDataLevel","minDisplayLevel","maxDisplayLevel","allowOverlappingTiles","exprPool","ExprPool","m_storageLevelOffset","m_featureStateMap","storageLevelOffset","uniqueNameCounter","m_styleSetName","m_mapView","styleSet","tmpVector3","tmpVector2","AttachmentCache","bufferAttributes","interleavedAttributes","MemoCallExpr","m_cachedProperties","m_deps","newValue","m_cachedValue","evaluate","AttachmentInfo","description","getBufferAttribute","getArrayConstructor","interleavedBuffer","stride","attrs","interleavedAttr","addToExtrudedMaterials","extrudedMaterials","TileGeometryCreator","enabledKinds","disabledKinds","techniques","_kindState","srcGeometry","createdOffsets","createObjects","preparePois","createTextElements","isPoiTechnique","isLineMarkerTechnique","isTextTechnique","createLabelRejectionElements","pathGeometries","addBlockingElement","PathBlockingElement","processPriorities","initDecodedTile","intern","geometryKind","mapAdapterParams","resetVisibilityCounter","textPathGeometries","textFilter","processedPaths","newPaths","pop","textStyleCache","discreteZoomLevel","discreteZoomEnv","prepareTextPaths","ContextualArabicConverter","convert","getRenderStyle","getLayoutStyle","pathLengthSqr","textGeometries","stringCatalog","numPositions","getZ","texts","techniqueFilter","animatedExtrusionHandler","attachment","getAttachments","groupCount","groupIndex","techniqueIndex","usesObject3D","extrusionAnimationEnabled","setAnimationProperties","onMaterialUpdated","addOwnedTexture","createMaterial","hasExtrusionFeature","techniqueKind","setupTerrainMaterial","vertexAttributes","vertexAttribute","interleavedVertexAttributes","attr","getInterleavedBufferAttributes","edgeIndex","getAttribute","needsVertexNormals","computeVertexNormals","isSolidLineTechnique","isHighPrecisionLineMaterial","lineMaterial","clipTileSize","setShaderMaterialDefine","hasSolidLinesOutlines","hasFeatureGroups","featureStarts","buildObject","geometryId","isCirclesTechnique","isSquaresTechnique","enableRayTesting","isLineTechnique","isSegmentsTechnique","fadingParams","getFadingParams","addUserData","castShadow","receiveShadow","isRenderDepthPrePassEnabled","depthPassMesh","createDepthPrePassMesh","registerTileObject","setDepthPrePassStencil","buildingTechnique","edgeGeometry","colorAttribute","extrusionAttribute","normalAttribute","uvAttribute","extrudedPolygonTechnique","getPolygonFadingParams","materialParams","colorMix","edgeMaterial","EdgeMaterial","edgeObj","customDepthMaterial","depthPacking","RGBADepthPacking","outlineGeometry","fillTechnique","outlineMaterial","outlineObj","outlineTechnique","secondaryCaps","caps","mainMaterialAdapter","outlineMaterialAdapter","frameMapView","mainLineWidth","currentStyledProperties","secondaryLineWidth","poiGeometries","addPois","createTexCoords","shouldSubdivide","tmpV","moveTileCenter","geom","posArray","sw","se","nw","ne","posAttr","toArray","normAttr","uvAttr","sphericalModifier","SphericalGeometrySubdivisionModifier","zoomLevelOffset","subdivision","zoomLevelGeometry","EdgeLengthGeometrySubdivisionModifier","SubdivisionMode","All","modify","createGroundPlaneMaterial","createGroundPlane","Background","mainAttachment","attachments","_category","_styleSet","computeRenderOrder","category","findIndex","entry","_secondaryCategory","terrainColor","tileDisplacementMap","xCountVertices","yCountVertices","LuminanceFormat","geometryType","DEFAULT_COLOR_MIX","styledProperties","m_dynamicProperties","propName","propDefinition","setupStaticProperties","updateDynamicProperties","updateBaseColor","applyMaterialGenericProp","applyMaterialBaseColor","rgbValue","actualOpacity","MapViewPoints","raycaster","intersects","screenCoords","origin","mouseCoords","indices","il","fromArray","pointInfo","getPointInfo","pointIsOnScreen","testPoint","absoluteScreenPosition","relativeScreenPosition","pickCoordinates","dx","dy","halfSize","isNode","DebugOption","SET_EVENT_TYPE","DebugContext","m_optionsMap","__debugContext","opt","hasEventListener","option","tmpOBB","raycasterFromScreenPoint","screenX","screenY","scenePosition","intersectsRay","intersectObjects","intersect","Unspecified","intersection","addObjInfo","GeometryType","ExtrudedLine","SolidLine","TextPath","Polygon","ExtrudedPolygon","Area","faceIndex","intersectIndex","objInfosIndex","featureStartIndex","sourceInfo","existingInfo","findItem","year","link","formatAsHtml","filtered","HighPrecisionUtils","doubleToFloatVec","fround","createHighPrecisionCameraPos","objectInverseWorldMatrix","mvp","eyePos","eyePosFloat","viewProjection","eyePosHi","eyePosLo","createAttributes","positionVec","positionVecLow","addHPValue","major","addHPVector","vec","positionHigh","Float32BufferAttribute","positionLow","addInterleavedAttributes3","positionOffset","newPositions","majorX","minorX","majorY","minorY","majorZ","minorZ","setPositions","makeFloatVec","minorVec","updateHpUniforms","shaderMaterial","highPrecisionCameraInfo","isMaterial","u_mvp","u_eyepos","u_eyepos_lowpart","convertPositions","vAny","returnPositions","createLine","linePositions","addCircles","wireFrame","triangulateLine","hpLineGeometry","hpPositions","positionAttribute","positionLowAttribute","hpSolidMaterial","lineObject","HPL","HighPrecisionWireFrameLine","HighPrecisionLine","setupForRendering","createPoints","pointPositions","materialParameters","hpPointsGeometry","hpPointsMaterial","isHighPrecisionPointMaterial","HighPrecisionPointMaterial","pointsObject","HPP","HighPrecisionPoints","FeatureModifierId","OmvFilterString","StringMatch","matchString","str","filterString","Any","Match","StartsWith","EndsWith","OmvGeometryType","OMV_TILE_DECODER_SERVICE_TYPE","OMV_TILER_SERVICE_TYPE","OmvTile","Tile","EquirectangularProjection","geoToWorldScale","worldToGeoScale","latitudeSpanInRadians","longitudeSpanInRadians","sizeX","sizeY","normalizedEquirectangularProjection","equirectangularProjection","TransverseMercatorProjection","m_phi0","m_lambda0","_unitScale","lon","TransverseMercatorUtils","POLE_RADIUS","rsq","POLE_RADIUS_SQ","nearestQuarter","deltaLon","deltaLat","distanceToPoleSq","distanceToPole","dir","offsetLon","clamped","clampGeoPoint","normalLon","phi","lambda","B","atanh","outScale","tau","nx","ny","D","sinh","pointsToCheck","E","POLE_EDGE_DEG","containsEastCut","containsCenterX","containsCenterY","alignLatitude","projected","vx","vy","vz","minZ","maxZ","lowerQ","upperQ","containsLowerQY","containsUpperQY","alignLongitude","latitudes","longitudes","altitudes","referencePoint","bad","good","POLE_EDGE","transverseMercatorProjection","tilingScheme","m_tilingScheme","m_worldBox","m_worldDimensions","levelDimensionX","getLevelDimensionX","levelDimensionY","getLevelDimensionY","originX","originY","unprojectBox","halfQuadTreeSubdivisionScheme","SubTiles","iterator","ZCurveIterator","RowColumnIterator","parentKey","worldCoordinatesToTileKey","cx","cy","worldSizeX","worldSizeY","wrap","lower","upper","minVal","maxVal","southWestLongitude","longitudeInRadians","southWestLatitude","northEastLongitude","northEastLatitude","minTileKey","maxTileKey","columnCount","minColumn","maxColumn","minRow","maxRow","m_subdivisionScheme","divX","getSubdivisionX","divY","getSubdivisionY","AnimatedExtrusionState","duration","m_forceEnabled","m_tileMap","m_state","None","m_startTime","force","forceEnabled","animateExtrusionValue","extrusionVisible","Started","resetAnimation","addDisposeCallback","removeTile","animated","skipAnimation","setTileExtrusionRatio","Finished","wasAnyAncestorAnimated","wasAnyDescendantAnimated","minLevel","getDataZoomLevel","distanceToMinLevel","levelsUp","lastTileKey","deltaUp","distanceToMaxLevel","levelsDown","nextTileKeys","childTileKeys","deltaDown","childTileKey","getSubTileKeys","currentTime","timeProgress","easeInOutCubic","resetTiles","optionalParams","console","trace","m_channel","Trace","prefix","Debug","Info","Warn","WORKERCHANNEL_MSG_TYPE","workerMessage","self","postMessage","StandardGeometryKind","GeometryKindSet","subset","elem","hasIntersection","TextureCoordinateType","PoiStackMode","PlacementToken","descriptors","Dynamic","parseStringEncodedNumeral","getFeatureName","basePropName","abbreviation","isoCode","projectionName","sphereProjection","attributeMap","$id","evaluateTechniqueAttr","CopyShader","tDiffuse","CopyMaterial","NoBlending","atmosphere_common_utils","atmosphere_vertex_utils","atmosphere_fragment_utils","m_throttlingTimeout","m_movementStartedFunc","m_movementFinishedFunc","m_lastCameraPos","m_newCameraPos","m_throttlingTimerId","m_movementDetectorDeadline","onDeadlineTimer","startMovementFinishedTimer","newAttitude","newCameraPos","m_lastAttitude","cameraMoved","equals","m_cameraMovedLastFrame","NaN","removeMovementFinishedTimer","remainingTime","m_geometries","disposeGeometries","SdfShaderChunks","sdf_attributes","sdf_varying","sdf_varying_computation","sdf_frag_uniforms","sdf_sampling_functions","GlyphClearMaterial","GlyphCopyMaterial","pageOffset","page0","DEFAULT_IMAGE","page1","page2","page3","page4","page5","page6","page7","SdfTextMaterial","vertexSource","fragmentSource","sdfTexture","sdfParams","distanceRange","MSDF","isMsdf","BG_TEXT","isBackground","side","DoubleSide","extensions","derivatives","characterBounds","MSAARenderPass","MSAASampling","samplingLevel","Level_1","m_renderTarget","m_localCamera","m_quadScene","m_quadUniforms","m_quadMaterial","MSAAMaterial","m_quad","WebGLRenderTarget","LinearFilter","RGBAFormat","offsets","OffsetVectors","oldClearColor","oldView","oldRenderTarget","getRenderTarget","setViewOffset","uniformCenteredDistribution","sampleWeight","isLoggingMessage","DEFAULT_WORKER_INITIALIZATION_TIMEOUT","m_workerChannelLogger","m_eventListeners","m_workers","m_availableWorkers","m_workerPromises","m_readyPromises","m_requests","m_workerRequestQueue","m_nextMessageId","m_stopped","m_referenceCount","onWorkerMessage","workerId","WorkerServiceProtocol","isResponseMessage","messageId","worker","checkWorkerRequestQueue","errorMessage","errorStack","stack","resolver","isInitializedMessage","readyPromise","getReadyPromise","service","eventHandler","m_workerCount","hardwareConcurrency","timeout","workerConnectionTimeout","workerPromise","WorkerLoader","startWorker","evt","waitForAllResponses","terminateWorkers","serviceId","ensureStarted","promise","request","requestController","reject","ServiceMessageName","Request","postRequestMessage","promises","buffers","signal","aborted","err","RequestController","unshift","workerEntry","terminate","newPromise","that","startWorkerImmediately","directlyFallbackToBlobBasedLoading","startWorkerBlob","pageUrl","href","fullScriptUrl","Worker","waitWorkerInitialized","fetchScriptSourceToBlobUrl","blobUrl","loadingPromise","sourceLoaderCache","scriptSource","blob","firstMessageCallback","isWorkerBootstrapRequest","resolvedDependencies","dependency","resolved","dependencyUrlMapping","cleanup","errorCallback","filename","lineno","timerId","nextUniqueServiceId","m_serviceCreated","addReference","broadcastRequest","WORKER_SERVICE_MANAGER_SERVICE_ID","Requests","DestroyService","targetServiceId","removeReference","CreateService","targetServiceType","tileKeyCode","WorkerDecoderProtocol","DecodeTileRequest","getProjectionName","invokeRequest","TileInfoRequest","DecoderMessageName","Configuration","broadcastMessage","ConcurrentTilerFacade","tilerServiceType","WorkerBasedTiler","indexId","WorkerTilerProtocol","RegisterIndex","UpdateIndex","TileRequest","DEFAULT_TILING_SCHEME","newScheme","removeDecodedTile","MIN_SAFE_INTEGER","webMercatorTilingScheme","m_booleanLiterals","m_numberLiterals","m_stringLiterals","m_objectLiterals","m_arrayLiterals","m_varExprs","m_hasAttributeExprs","m_matchExprs","m_caseExprs","m_interpolateExprs","m_stepExprs","m_callExprs","literal","candidate","branchesMatching","expressions","interp","tmpVectorA","tmpVectorB","tmpVectorC","positionAttr","uv","edgeAttr","edge","wallAttr","wall","indexAttr","middleVertex","lerpVectors","newIndices","shift","v2","shouldSplitTriangle","v3","DisplacedBufferAttribute","originalAttribute","m_normals","m_uvs","m_textureWidth","m_textureHeight","m_cache","VertexCache","MAX_CACHE_SIZE","m_lastPos","m_tmpNormal","resetTexture","normals","uvs","m_lastBufferIndex","getDisplacedCoordinate","m_texture","bufferIndex","displacePosition","fromBufferAttribute","u","sampleBilinear","tmpV1","tmpV2","tmpBox","displaceBox","displacementRange","displacementDir","tmpNormalMin","tmpNormalMax","translate","union","DisplacedBufferGeometry","originalGeometry","displacedPositions","m_originalBoundingBox","m_displacedPositions","resetAttributes","displacementRangeChanged","resetBoundingVolumes","computeBoundingBox","origBBox","boundingSphere","getBoundingSphere","needsBoundingBoxUpdate","computeBoundingSphere","drawRange","AlphaFormat","RGBFormat","LuminanceAlphaFormat","RGBEFormat","DepthFormat","DepthStencilFormat","RedFormat","dataType","ClampToEdgeWrapping","RepeatWrapping","MirroredRepeatWrapping","NearestFilter","NearestMipMapNearestFilter","NearestMipMapLinearFilter","LinearMipMapNearestFilter","LinearMipMapLinearFilter","AmbientLight","intensity","bias","mapSize","DEPTH_PRE_PASS_STENCIL_MASK","createDepthPrePassMaterial","baseMaterial","depthFunc","EqualDepth","colorWrite","enforceBlending","depthPassMaterial","isDepthPrepassMaterial","LessDepth","evaluateBaseColorProperty","depthPassGeometry","extrusionAxisAttribute","materialIndex","depthMesh","colorMesh","depthMaterial","stencilWrite","stencilFail","KeepStencilOp","stencilZFail","stencilZPass","ReplaceStencilOp","stencilFunc","AlwaysStencilFunc","stencilRef","stencilFuncMask","colorMaterial","ZeroStencilOp","EqualStencilFunc","overlayObject","mat","hasDisplacementFeature","overlayPosition","worldCoords","geoCoords","contains","sampleHeight","overlayPath","firstObject","Terrain","tmpPosition","tmpCameraDir","tmpPointDir","eyePosition","eyeLookAt","viewDistance0","viewDistance1","pointPos","planePos","planeNorm","tmpPlacementPosition","tmpPlacementBounds","viewCamera","updatePoiFromPoiTable","projectionType","checkViewDistance","TooFar","NotReady","tmpBoxes","tmpMeasurementParams","tmpCollisionBoxes","tmpCollisionBox","CollisionBox","tmpScreenPosition","tmpTextOffset","tmp2DBox","Box","tmpCenter","tmpSize","placePointLabelAtAnchor","placement","screenCollisions","isRejected","forceInvalidation","outScreenPosition","measureText","applyTextPlacement","outputCharacterBounds","expandByVector","persistentPointLabelTextMargin","textOffset","Right","Top","Center","Bottom","poiIsRenderable","computedWidth","computedHeight","hAlign","hPlacementFromAlignment","vAlign","vPlacementFromAlignment","hAlignDiff","vAlignDiff","relOffsetX","relOffsetY","computePointTextOffset","persistent","newPointLabelTextMarginPercent","isAllocated","textReservesSpace","allocate","textPlacement","PoiRenderer","computeIconScreenBox","multiAnchor","newLabel","lastPlacement","placePointLabelAtCurrentAnchor","placementsNum","matchIdx","allInvisible","anchorPlacement","isLastPlacement","placementResult","placePointLabelChoosingAnchor","candidateBoxes","checkGlyphCollision","search","checkGlyphVisible","isFullyVisible","glyphBox","collisionBox","intersectsDetails","DetailedCollisionBox","screenProjector","outScreenPoints","anyPointVisible","projectOnScreen","minScreenSpace","lengthSq","tmpOrientedBox","poiLabel","outWorldPosition","worldOffsetShiftValue","worldOffset","offsetDirectionVector","offsetDirectionRad","applyAxisAngle","tempPos","neutralColor","tmpIconColor","PoiRenderBufferBatch","imageItem","boxBuffer","setup","init","updateBufferGeometry","updateMemoryUsage","imageData","UVMapping","trilinear","mipMaps","mipmaps","premultiplyAlpha","m_material","IconMaterial","BoxBuffer","PoiRenderBuffer","batches","m_batchMap","imageTextureName","batchKey","mappedIndex","bufferBatch","batchSet","screenBox","batchIndex","registerPoi","uvBox","addBox","batch","pickBoxes","m_tempScreenBox","m_renderBuffer","centerX","centerY","preparePoi","allocateScreenSpace","addPoi","poiTableName","getImageTexture","m_missingTextureName","imageDefinition","imageCache","findImageByName","loaded","imageUrl","loadImage","loadedImageItem","setupPoiInfo","imageWidth","imageHeight","paddedSize","MipMapGenerator","getPaddedSize","trilinearFiltering","paddedImageWidth","paddedImageHeight","iconWidth","iconHeight","minS","maxS","minT","maxT","iconScaleH","iconScaleV","s0","t0","s1","t1","m_paddingCanvas","document","createElement","m_paddingContext","getContext","m_resizeCanvas","m_resizeContext","ceilPowerOfTwo","paddedWidth","paddedHeight","copyImageWithPadding","getImageData","previousImage","resizeImage","clearRect","ImageBitmap","drawImage","putImageData","paddedImage","RBush","detailBoxes","isLineWithBound","screenBounds","rtree","bbox","insert","containsBox","testBox","detailBox","boundedLine","intersectsLine","lineXDiffTransformed","signBL","signBR","signTL","signTR","lineYDiffTransformed","normalX","normalY","debugCanvas","m_renderContext","m_renderingEnabled","m_numAllocations","m_numSuccessfulTests","m_numFailedTests","m_numSuccessfulVisibilityTests","m_numFailedVisibilityTests","strokeStyle","strokeRect","boundsArray","collisionFound","padding","f","_maxEntries","_minEntries","leaf","_all","toBBox","collides","_build","_splitRoot","_insert","_condense","compareMinX","compareMinY","toJSON","apply","_chooseSubtree","_split","_adjustParentBBoxes","_chooseSplitAxis","_chooseSplitIndex","M","_allDistMargin","defaultTextRenderStyle","getColor","defaultTextLayoutStyle","parseAlignmentAndPlacements","placementsTokens","placementsString","toUpperCase","split","modifier","North","South","East","West","parseTechniquePlacementValue","parseTechniquePlacements","parseTechniqueHAlignValue","parseTechniqueVAlignValue","m_textStyles","m_defaultStyle","themedDefaultStyle","createTextElementStyle","textRenderers","styledTextRenderer","styleId","defaultRenderParams","defaultOpacity","hexColor","defaultBackgroundSize","hasBackgroundDefined","defaultBackgroundOpacity","hexBgColor","themeRenderParams","floorZoomLevel","defaultLayoutParams","textPlacements","wrapping","themeLayoutParams","styleName","fontCatalogName","CalculationStatus","m_name2Url","m_url2Name","hasName","oldNames","ImageCache","findImage","registerImage","startLoading","mipMapGenerator","m_images","imageCacheItem","findImageCacheItem","mapViews","itemsToRemove","mapViewIndex","keyToDelete","imageLoader","ImageLoader","renderImage","generateTextureAtlasMipMap","ex","errorEvent","createImageBitmap","imageBitmap","m_anchors","mapAnchor","cameraPosition","rootNode","overlayRootNode","anchor","geoPosition","overlay","m_enabled","Fog","m_fogIsDefined","m_cachedTheme","enableFog","startRatio","viewRange","horizontalDensity","verticalDensity","endRatio","density","smoothStep","setFogInRawShaderMaterials","Material","m_imageTextures","m_poiShieldGroups","m_missingPoiTableName","loadedOk","m_missingPoiName","assertExists","poiGeometry","addLineMarker","ok","statusText","jsonAtlas","imageTextureDef","reason","getPoiTable","notifyMissingPoiTable","poiTableEntry","getEntry","notifyMissingPoi","iconName","composeTechniqueTextureName","iconMinLevel","iconMaxLevel","textMinLevel","textMaxLevel","updateMinMaxZoomLevelsFromPoiInfo","groupKey","positionArray","checkCreateTextElement","techniqueTextureName","poiTechnique","offsetDirections","iconColorRaw","PoiTableEntry","jsonEntry","isOK","altNames","Show","Hide","ShowParent","PoiTable","useAltNamesForKey","poiList","poiDict","m_isLoading","m_loadedOk","entryIdx","poiTableUrl","jsonPoiTable","tableEntry","verifyJSON","newPoiEntry","altName","m_poiTables","loadPromises","poiTableRef","addTable","finally","finishLoading","debugTiles","polarTilingScheme","m_maxLatitude","m_geometryLevelOffset","m_debugTiles","m_northPoleEntry","m_southPoleEntry","m_styleSetEvaluator","$geometryType","$layer","getMatchingTechniques","StyleSetEvaluator","createTechiqueEntry","setStyleSet","createTileGeometry","latA","latB","lonA","lonB","isNorthPole","techniqueEntry","srcProjection","dstProjection","maxLat","poleLat","pBL","pBR","pTR","pTL","needsGeometryCut","isLeftHalf","poleX","poleY","pPole","pXX","lats","lmax","lmin","nearest","inPointB","inPointD","cutStart","intersectEdge","cutEnd","cutIndexStart","cutIndexEnd","Face3","fromGeometry","Water","SkyCubemapFaceId","SKY_CUBEMAP_FACE_COUNT","createCubemapFaceArray","m_skybox","CubeTextureLoader","CubeTexture","face","DEFAULT_MAX_THEME_INTHERITANCE_DEPTH","themeUrl","resolveReferenceUri","getAppBaseUrl","resolveUrls","convertFlatTheme","checkTechniqueSupport","resolveDefinitions","resolveBaseThemes","contextLoader","ContextLogger","resolveThemeReferences","extends","childUrlResolver","composeUriResolvers","RelativeUriResolver","resolveIncludes","resolveIncludeUris","baseTheme","resolveResourceUris","resolveResources","contextLogger","pushAttr","definitionName","isActualSelectorDefinition","resolvedDef","resolveStyle","resolveStyleSet","currentStyle","pushIndex","resolvedStyle","isJsonExprReference","cloneDeep","when","resolvedWhen","resolveExpressionReferences","resolvedValue","failed","resolveInternal","defName","maxInheritanceDepth","baseThemes","baseThemesMerged","actualBaseTheme","mergeThemes","currentStyleSets","incomingStyleSets","faceUrl","SearchDirection","DataSourceCache","cacheSize","rct","m_disposedTiles","m_resourceComputationType","m_tileCache","LRUCache","evictionCallback","canEvict","getKey","setCapacityAndMeasure","getKeyForTile","deleteByKey","shrinkToCapacity","evictAll","selector","evictSelected","inDataSource","m_frustumIntersection","m_cameraOverride","m_viewRange","m_coveringMap","m_dataSourceCache","computationType","setCapacity","evaluateClipPlanes","visibleTileKeysResult","getVisibleTileKeysForDataSources","visibleTileKeys","tileKeys","distanceDiff","minDiff","actuallyVisibleTiles","allDataSourceTilesLoaded","dataZoomLevel","tileEntry","getTile","skipOverlappedTiles","visibleArea","updateTiles","allVisibleTileLoaded","allBoundingBoxesFinal","populateRenderedTiles","disposeTile","oldViewRanges","newViewRanges","getTileImpl","dataSourceVisibleTileList","visibleLevel","visibleTileKey","getTileKey","searchLevelsUp","searchLevelsDown","getSearchDirection","parentTileKey","childLevel","markDataSourceTilesDirty","disposeTiles","listEntry","isFullyCovering","uniqueKey","searchDirection","BOTH","DOWN","UP","NONE","incompleteTiles","checkedTiles","findUp","findDown","childTileCode","childTile","nextLevelDiff","parentCode","exists","parentTile","foundUp","cacheOnly","updateTile","tileToUpdate","resultTile","tileCache","initTile","dataSourceCache","retainedTiles","markTileDirty","tileGeometryManager","dataSourceBuckets","bucket","updateFrustum","compute","calculationFinal","tileKeyEntry","tileKeyEntries","canGetTile","m_cachedTreePromise","getCopyrightCoverageData","coverageInfo","initRBush","matchingEntries","getTree","maxLevel","item","tree","alt","arg","isLineAccessor","isObject3dAccessor","BufferedGeometryAccessorBase","startCapSize","endCapSize","constructor","rawShaderMaterial","diffuse","BufferedGeometryAccessor","checkSetUp","positionsArray","subarray","getVertices","IndexedBufferedGeometryAccessor","reconstructLineWidth","k","UNIT_Z","POINTS","BEVEL_POINTS","STEP","addCircle","lineAngle","SECTORS_IN_CIRCLE","angle","startWithCircle","endWithCircle","angleVec","prevBt","bt","averageBt","p2","p3","N","useBevel","inclineWidth","inBuffer","startOffset","outBuffer","i2","xd","yd","zd","_renderer","_scene","_geometry","_material","_group","doUpdateMatrixWorldInverse","matrixWorldNeedsUpdate","TileLoader","dataProvider","tileDecoder","loadAbortController","AbortController","Loading","Decoding","donePromise","abort","onDone","myLoadCancellationToken","payload","onLoaded","resolveDonePromise","rejectedDonePromise","byteLength","startDecodeTile","decodeTile","onDecoded","doneState","getTileInfo","APIFormat","AuthenticationMethod","AuthenticationTypeBearer","method","AuthorizationHeader","AuthenticationTypeTomTomV1","QueryString","AuthenticationTypeAccessToken","downloadManager","TransferManager","urlParams","abortSignal","tileUrl","dataUrl","authenticationCode","getActualAuthenticationCode","applyAuthCode","addQueryParams","apiFormat","XYZJson","downloadJson","downloadArrayBuffer","getBearerToken","HereV1","MapboxV4","XYZOMV","XYZMVT","XYZSpace","TomtomV1","authMethod","authenticationMethod","getDefaultAuthMethod","headers","Headers","authType","append","authParams","queryParams","queryString","concatinator","s3Base","querySelector","getElementById","innerText","getFullYear","releases","date","hash","version","dropdown","res","release","appendChild","onchange","selected","omvDataSource","OmvDataSource","apikey","innerWidth","beginAnimation","main","IdentityProjection","identityProjection","getLongitudeQuadrant","oneOverPI","quadrantIndex","lengthOfVector3","makeBox3","halfEquatorialRadius","minLongitude","maxLongitude","minLongitudeQuadrant","maxLongitudeQuadrant","xMin","xMax","yMin","yMax","cosMaxLongitude","sinMaxLongitude","xCenter","xExtent","yCenter","yExtent","minLatitude","maxLatutide","zMax","zMin","zCenter","zExtent","SphereProjection","_minElevation","worldpoint","cosLatitude","parallelRadiusSq","parallelRadius","midX","midY","cosSouth","sinSouth","cosWest","sinWest","cosNorth","sinNorth","cosEast","sinEast","cosMidX","sinMidX","cosMidY","sinMidY","rMax","rMin","_worldBox","mx","my","gx","gy","cosLongitude","sinLongitude","sinLatitude","visitTileKey","subTileKey","hereTilingScheme","TilingScheme","mercatorTilingScheme","intersectsSlab","rayDir","axis","finv","t2","tmpVec","tmpT","rotationMatrix","newBox","matrix","frustumOrPlanes","planes","plane","distanceToPoint","dz","distanceToPointSquared","subVectors","lengths","getComponent","dd","PriorityListGroup","foundIndex","GroupedPriorityList","getGroup","findGroup","otherGroup","normalizedPriority","LoggerManagerImpl","m_loggers","channel","ConsoleChannel","WorkerChannel","loggerName","m_levelSetForAll","Logger","config","channels","ax","ay","bx","by","xmax","ymax","computeSquaredLineLength","squaredLineLength","xDiff","yDiff","distToSegmentSquared","px","py","l0x","l0y","l1x","l1y","lineLengthSuared","edge0","edge1","smootherStep","inMin","inMax","outMin","outMax","lowerBound","upperBound","startValue","endValue","derivedCtor","baseCtors","baseCtor","getOwnPropertyDescriptor","m_logger","headerMessage","m_headerLogged","createLogMethod","severity","rest","nowFunc","getTime","getNowFunc","cloneInternal","src","cached","flags","props","parameters","optionValue","uri","resolvers","originalUrl","f1","f2","maxXIndex","maxYIndex","xIndex","xIndexFloor","yIndex","yIndexFloor","swIndex","seIndex","nwIndex","neIndex","swElevation","seElevation","nwElevation","neElevation","xFrac","isInteger","xFracInverse","yFrac","yFracInverse","kCSSColorTable","clamp_css_byte","clamp_css_float","parse_css_int","parse_css_float","css_hue_to_rgb","m1","m2","css_str","iv","toLowerCase","ep","fname","operatorDescriptors","promoteValue","promotedValue","evaluator","cachedResult","fromValue","builtin","builtins","defineOperator","firstDynamicCondition","evaluatedCondition","evaluatedBody","wrapValue","partialEvaluate","param","i1","i0","iP","iN","tP","dt","wP","wN","pp","ppp","cP","c0","c1","cN","vN","cubicInterpolate","keyIndex","prevKey","prevValue","base","defineOperators","CastOperators","ComparisonOperators","MathOperators","StringOperators","ColorOperators","TypeOperators","MiscOperators","FlowOperators","ArrayOperators","ObjectOperators","FeatureOperators","MapOperators","VectorOperators","VALID_ELEMENT_TYPES","checkElementTypes","ty","checkArray","operators","checkArrayLength","at","rgba","rgbaToHex","rgb","rgbToHex","hsl","euclideanModulo","hslToHex","compare","strict","isEnv","conditionalCast","any","none","boolean","number","string","pixels","ppi","ln","ln2","log10","pi","coalesce","LookupMode","lookupMember","lookupMode","memberName","in","downcase","toLocaleLowerCase","upcase","toLocaleUpperCase","typeof","isVector","ctor","toVector","VectorCtor","_value","vector4","emptyEnv","_context","preserve","newBranch","newCondition","deps","Condition","instantiatedBranch","Character","Token","isSpace","codepoint","Tab","Lf","Cr","Space","isNumber","_0","_9","isLetter","A","Z","isIdentChar","isLetterOrNumber","Dollar","Dot","LBracket","RBracket","tokenSpell","token","Eof","Identifier","Comma","LParen","RParen","Exclaim","TildeEqual","CaretEqual","DollarEqual","EqualEqual","ExclaimEqual","Less","Greater","LessEqual","GreaterEqual","BarBar","AmpAmp","Lexer","m_token","m_char","m_text","yylex","codePointAt","yyinp","ch","SingleQuote","DoubleQuote","Equal","Caret","Tilde","Bar","Amp","getEqualityOp","getRelationalOp","lex","parseLogicalOr","yyexpect","hasAttribute","parseLiteral","parseUnary","parsePrimary","parseRelational","parseEquality","parseLogicalAnd","isUnknownServiceError","isRequestMessage","Response","isRegisterIndexRequest","isUpdateIndexRequest","isTileRequest","abortController","isConfigurationMessage","isDecodeTileRequest","isTileInfoRequest","attrValue","cachedExprResults","visitFunc","visit","shaderParams","DEFAULT_CIRCLE_SIZE","m_color","m_opacity","hasDisplacementMap","hasExtrusion","edgeColor","edgeColorMix","MIN_BUILDING_HEIGHT_SQUARED","extrusion_vertex","extrusion_normal_fragment_begin","extrusion_pars_fragment","extrusion_fragment","fading_vertex","fading_pars_fragment","fading_fragment","GroundAtmosphereShader","u_eyePositionWorld","u_lightDirectionWorld","u_modelViewProjection","u_atmosphereEnv","u_hsvCorrection","topColor","bottomColor","fogColor","fogNear","fogFar","GroundAtmosphereMaterial","FrontSide","enableLighting","cameraInfo","getCameraInfo","modelViewProjection","eyeHeight","cameraInSpace","outerRadius","needsUpdate0","needsUpdate1","reverse","modelMatrix","identity","viewMatrix","transpose","mvpMatrix","objectPos","updateTransparencyFeature","points_frag","DEFAULT_SIZE","DEFAULT_SCALE","uvTransform","Matrix3","LuminosityHighPassShader","luminosityThreshold","smoothWidth","AdditiveBlending","SepiaShader","amount","SkyAtmosphereShader","SkyAtmosphereMaterial","BackSide","LineCapsDefinesMapping","Square","Round","TriangleIn","TriangleOut","DefinesLineCapsMapping","lineCapsName","defineKey","LineDashesModes","LineDashesDefinesMapping","DASHES_SQUARE","DASHES_ROUND","Diamond","DASHES_DIAMOND","DefinesLineDashesMapping","lineDashesName","CAPS_MODE","DASHES_MODE","fogParam","opacityParam","merge","dashColor","outlineColor","extrusionWidth","DEFAULT_WIDTH","DEFAULT_OUTLINE_WIDTH","DEFAULT_OFFSET","DEFAULT_DRAW_RANGE_START","DEFAULT_DRAW_RANGE_END","DEFAULT_DASH_SIZE","DEFAULT_GAP_SIZE","UniformsLib","drawRangeStart","drawRangeEnd","invalidateFog","invalidateOpacity","capsMode","dashesMode","useTileClip","VignetteShader","darkness","FontCatalog","fonts","unicodeBlocks","maxCodePointCount","m_replacementGlyph","m_glyphTextureCache","GlyphTextureCache","m_loadingJson","m_loadingPages","m_loadingGlyphs","m_loadedJson","m_loadedPages","m_loadedGlyphs","loadJSON","replacementDirUrl","replacementJson","replacementTexture","loadTexture","replacementFont","replacementGlyph","chars","xadvance","xoffset","yoffset","supportedBlocks","rawJSON","loadPages","assetsPath","getAssetsPath","jsonPath","jsonPromise","pagePromises","page","pages","loadPage","pagePath","charset","AllCaps","glyphPromises","char","getFont","fontHash","glyphHash","fontGlyphMap","glyphPromise","createReplacementGlyph","charUnicodeBlock","loadAssets","loadedGlyph","shouldTransform","transformedCharacter","getGlyph","selectedFontName","textureBytes","loadedPage","loadBlock","sourceGlyphData","texturePath","pagePromise","fontStylePath","Bold","bold","Italic","italic","BoldItalic","boldItalic","entryWidth","entryHeight","nRows","m_cacheHeight","m_cacheWidth","m_textureSize","m_entryCache","initCacheEntries","m_rt","depthBuffer","stencilBuffer","m_copyTextureSet","m_copyTransform","m_copyPositions","m_copyMaterial","m_copyVertexBuffer","m_copyPositionAttribute","m_copyUVAttribute","m_copyGeometry","copyIndexBuffer","m_copyMesh","m_copyGeometryDrawCount","m_clearMaterial","m_clearPositionAttribute","m_clearGeometry","clearIndexBuffer","m_clearMesh","m_clearGeometryDrawCount","oldestEntry","oldest","clearCacheEntry","copyGlyphToCache","willClearGeometry","willCopyGeometry","srcPages","nCopies","pageIndex","dummyFont","lineGap","dummyGlyphData","dummyEntry","cacheLocation","copyTextureIndex","applyMatrix3","setXYZ","setXY","Entry","newer","older","cacheCapacity","sizeFunction","m_size","m_newest","m_oldest","m_capacity","m_sizeFunction","callbackfn","thisArg","newCapacity","evict","sizeMeasure","entrySize","valueSize","promoteEntry","newest","cb","entryOlder","deleteEntry","evictOldest","itemToRemove","isOk","tempTextPosition","tempTextBounds","tempVertexBuffer","TextCanvas","m_fontCatalog","minGlyphCount","maxGlyphCount","m_ownsMaterial","createSdfTextMaterial","m_ownsBgMaterial","m_bgMaterial","m_defaultLayer","TextGeometry","m_layers","m_currentTextRenderStyle","m_currentTextLayoutStyle","m_lineTypesetter","LineTypesetter","m_pathTypesetter","PathTypesetter","bgMaterial","backgroundMesh","oldTarget","layerId","outputBounds","upperCaseArray","pathOrigin","textPathOverflow","targetLayer","tempLayer","addLayer","prevDrawCount","updatePosition","addPickingData","glyphArray","smallCapsEnabled","textBounds","storeStyles","computeTextBuffer","TextBufferObject","glyphBounds","isPath","typesettingParams","smallCapsArray","vertexBuffer","arrangeGlyphs","m_tempTransform","m_tempCorners","m_tempLineDirection","m_tempRunDirection","m_tempPixelSize","m_tempPixelBgSize","m_tempScale","m_tempSmallCaps","m_currentParams","isOnlyMeasured","lineStartIdx","glyphWrapIdx","wordWrapIdx","lineStartX","lineCurrX","glyphWrapX","wordWrapX","lineCount","isBidirectionalLine","wrapPointIdx","wrapPointX","lineAlignment","placeLine","isBidirectional","placeRun","glyphDataArray","isRTL","runStart","neutralIdx","weakRunStart","weakGlyph","glyphFont","glyphFontMetrics","isBoldEmulated","isItalicEmulated","isSmallCaps","smallCapsScale","glyphScale","emulationWeight","isMirrored","verticalOffset","glyphVertexPosition","horizontalOffset","addToBuffer","m_tempPathPosition","m_tempPathLength","m_tempPathOffset","getLength","pathWidth","defaultGlyphRotation","normalDisplacement","textPoint","tangent","getTangent","ContextualForm","CombinedForm","m_singleCharactersMap","m_combinedCharactersMap","m_neutralCharacters","output","currentCodePoint","charCodeAt","isArabicCharacter","prevIndex","isNeutral","prevCodePoint","prevMap","getCharacterMap","Initial","Medial","nextIndex","nextCodePoint","nextMap","Final","combinedMap","getCombinedCharacterMap","fromCharCode","Connected","Isolated","textRenderStyles","textLayoutStyles","_index","styleCache","createRenderStyle","createLayoutStyle","DEFAULT_DYNAMIC_MSAA_SAMPLING_LEVEL","DEFAULT_STATIC_MSAA_SAMPLING_LEVEL","Level_4","antialiasSettings","msaaEnabled","strength","threshold","thickness","ghostExtrudedPolygons","m_width","m_height","m_renderPass","RenderPass","m_target1","m_target2","m_sepiaPass","ShaderPass","m_vignettePass","m_readBuffer","m_msaaPass","m_dynamicMsaaSamplingLevel","dynamicMsaaSamplingLevel","m_staticMsaaSamplingLevel","staticMsaaSamplingLevel","m_lowResPass","LowResRenderPass","isStaticFrame","usePostEffects","activeTarget","clearDepth","m_outlineEffect","OutlineEffect","nextEffectEnabled","m_bloomPass","BloomPass","m_savedWidth","m_savedHeight","m_defaultThickness","m_defaultColor","m_defaultAlpha","m_defaultKeepAlive","m_ghostExtrudedPolygons","m_removeThresholdCount","m_originalMaterials","m_originalOnBeforeRenders","m_shaderIDs","MeshLambertMaterial","MeshPhongMaterial","MeshToonMaterial","MeshPhysicalMaterial","m_uniformsChunk","outlineThickness","outlineAlpha","domElement","ghost","depth","stencil","updateStyle","setViewport","setScissor","setScissorTest","renderTarget","currentAutoClear","renderOutline","currentSceneAutoUpdate","autoUpdate","currentSceneBackground","currentShadowMapEnabled","setOutlineMaterial","restoreOriginalMaterial","cleanupCache","originalMaterial","createInvisibleMaterial","shaderID","originalVertexShader","originalUniforms","ShaderLib","isRawShaderMaterial","isShaderMaterial","isExtrusionMaterial","isFadingMaterial","vertexShaderChunk","vertexShaderChunk2","DECLARE_TRANSFORMED","USE_EXTRUSION","USE_FADING","skinning","morphTargets","morphNormals","used","keepAlive","getOutlineMaterialFromCache","updateOutlineMaterial","getOutlineMaterial","outlineParameters","outlineUniforms","BlurDirectionX","BlurDirectionY","resolution","m_renderTargetsHorizontal","m_renderTargetsVertical","m_nMips","m_separableBlurMaterials","m_basic","m_bloomTintColors","pars","resx","resy","m_renderTargetBright","generateMipmaps","renderTargetHorizonal","renderTargetVertical","m_highPassUniforms","m_materialHighPassFilter","kernelSizeArray","getSeperableBlurMaterial","m_compositeMaterial","getCompositeMaterial","m_copyUniforms","m_materialCopy","rt","inputRenderTarget","kernelRadius","KERNEL_RADIUS","SIGMA","colorTexture","texSize","nMips","NUM_MIPS","blurTexture1","blurTexture2","blurTexture3","blurTexture4","blurTexture5","dirtTexture","bloomStrength","bloomFactors","bloomTintColors","bloomRadius","CopyrightElementHandler","m_defaults","m_mapViews","mergedCopyrightInfo","staticInfo","m_element","display","defaults","deduped","innerHTML","htmlElement","VERTEX_POSITION_CACHE","SubdivisionModifier","subdivisionMode","m_projectedBox","m_maxLengthX","m_maxLengthY","m_maxLength","shouldSplitAB","shouldSplitEdge","shouldSplitBC","shouldSplitCA","ab","bc","ca","maxDistance","NoDiagonals","aa","bb","cc","beta","gamma","m_getDisplacementRange","m_raycastStrategy","firstMaterial","isDisplacementFeature","isDisplacementMaterial","isDataTexture","isDataTextureMap","displacedGeometry","getDisplacedPositionAttribute","Field","maxVertexCount","m_vertexCount","m_oldestIdx","m_newestIdx","Count","vertexId","vertex","vertexIdx","getVertex","setVertex","newerIdx","getNewerIdx","olderIdx","getOlderIdx","setOlderIdx","setNewerIdx","OlderIdx","NewerIdx","X","Y","tmpSphere","tmpInverseMatrix","tmpRay","Ray","tmpLine1","Line3","tmpPlane","tmpV3","tmpV4","computeFeatureBoundingSphere","featureBeginIndex","featureEndIndex","sphere","makeEmpty","intersectLine","vExtrusion","hWidth","hWidthSq","interPlane","outInterLine","extrLineT","intersectExtrudedLine","endCapT","startCapT","containsPoint","intersectClosestEndCap","distanceToSquared","closestPointToPoint","intersectFeature","localRay","halfWidth","lHalfWidth","lHalfWidthSq","beginIdx","bSphere","intersections","vExt","bitangent","intersectsSphere","manhattanLength","interLine","interLineWorld","singleFeatureStart","intersectGroup","firstFeatureIdx","groupEndIdx","bVolumes","boundingVolumes","isSolidLineMaterial","solidLineMaterial","localHalfWidth","localHalfWidthSq","featureIdx","lastFeatureIdx","bVolumeIdx","nextFeatureIdx","BoxBufferMesh","startElementCount","maxElementCount","resizeBuffer","pickInfos","internalMesh","indexAttribute","glyphCount","positionAttributeCount","colorAttributeCount","uvAttributeCount","indexAttributeCount","pickInfoCount","pickInfo","canAddElements","clearAttributes","isEmpty","pickInfoIndex","isPixelTransparent","forceResize","xScreenPos","yScreenPos","pixelIsTransparent","screenToUvCoordinates","pixel","getPixelFromImage","newPositionArray","newColorArray","newUvArray","numIndexValues","newIndexArray","getPixelFromImageBitmap","xPos","yPos","pixelData","getPixelFromImageData","imgData","strd","Uint8ClampedArray","getPixel","pickedColor","close","pixelsData","resortedGroups","numNotRendered","m_lengths","PathParam","curves","m_point","curve","lineCurve","curveLengths","getCurveLengths","diff","segmentLength","numSecondChanceLabels","tmpCachedDuplicate","getCacheKey","hasFeatureId","isBetterPathDuplicate","newCandidate","_newDistance","oldCandidate","_oldDistance","isBetterPointDuplicate","_newCandidate","newDistance","_oldCandidate","oldDistance","findDuplicateByText","elementState","candidates","maxSqDistError","getDedupSqDistTolerance","entryCount","elementPosition","duplicate","dupIndex","dupDistSquared","isBetterDuplicate","candidateEntry","cachedElement","areDiffType","areBothVisible","m_referenceMap","m_textMap","textElementFilter","updateElements","TextElementGroupState","m_sortedGroupStates","replaceCallback","replaceElement","anyEviction","updateFading","traverseVisibleElements","cacheResult","findDuplicate","cachedDuplicate","replacement","cachedEntries","duplicateIndex","findDuplicateById","m_visited","m_textElementStates","TextElementState","visibleElementsCallback","m_textRenderState","m_iconRenderStates","themeLayout","stateLayout","m_textLayoutState","isBaseTextPlacement","LayoutState","renderState","m_viewDistance","predecessor","initializeRenderStates","RenderState","_point","m_hAlign","m_vAlign","FadingState","DEFAULT_FADE_TIME","fadeTime","Undefined","FadingIn","FadingOut","FadedIn","FadedOut","fadingTime","tmpVectors3","tmpVector4","TileKeyEntry","m_extendedFrustumCulling","m_frustum","Frustum","m_viewProjectionMatrix","m_rootTileKeys","m_tileKeyEntries","m_mapTileCuller","MapTileCuller","projectionMatrixOverride","setFromProjectionMatrix","computeRequiredInitialRootTileKeys","viewportHeight","targetTileArea","useElevationRangeSource","obbIntersections","uniqueZoomLevels","tileBounds","getTileKeyEntry","workList","tileKeyAndOffset","subTileEntry","subTileKeyAndOffset","longitudeOffset","getElevationRange","FinalPrecise","computeTileAreaAndDistance","frustumIntersectsTileBox","intersectsBox","projectedPoint","rootTileKey","worldGeoPoint","totalAngleRad","worldLengthHorizontal","worldLeftPoint","worldLeftGeoPoint","offsetRange","SQRT2","m_globalFrustumMin","m_globalFrustumMax","m_frustumCorners","frustumCorners","getFrustumCorners","MAX_VALUE","frustumCorner","globalFrustumMin","globalFrustumMax","invProjMatrix","cornerIndex","addPoint","enableFilterByKind","m_visibilityCounter","kinds","incrementVisibilityCounter","TileGeometryLoader","geometryLoader","enabledGeometryKinds","disabledGeometryKinds","m_tileUpdateCallback","updateTileObjectVisibility","addOrRemoveToEnabledSet","enableDisableKinds","addOrRemoveToDisabledSet","addOrRemoveToHiddenSet","visibilityHasChanged","oneKind","visibilityChange","addRemove","visibleKinds","tileKinds","availableGeometryKinds","needUpdate","objectAdapter","nowVisible","addToSet","kindSet","kindsSet","m_tile","m_isFinished","foundSet","compileGeometryKind","Label","m_availableGeometryKinds","prepareAvailableGeometryKinds","discardNeedlessTile","finish","geometryCreationPending","compareGeometryKinds","processTechniques","setGeometryKinds","setDecodedTile","prepareForRender","m_enabledKinds","m_disabledKinds","m_timeout","loadingFinished","geometryCreator","createAllGeometries","geometryCreationTime","addMessage","disposed","enabledSame","disabledSame","enabledEmpty","disabledEmpty","emptyTechniqueDescriptor","StyleConditionClassifier","_whenExpr","savedStyle","switchStyle","_style","enclosingExpr","matched","matchVarStringComparison","_geometryType","saved","OptimizedSubSetKey","keyUpdateNeeded","envLayer","envGeometryType","updateKey","cachedStyleSet","makeDecodedTechnique","isVector2","isVector3","isVector4","m_techniques","m_exprPool","m_cachedResults","m_styleConditionClassifier","m_subStyleSetCache","m_definitionExprCache","m_tmpOptimizedSubSetKey","m_emptyEnv","m_featureDependencies","m_definitions","resolveStyleReferences","resolveReferences","techniqueRenderOrder","styleSetIndex","_styleSetIndex","computeDefaultRenderOrder","compileStyleSet","m_previousResult","m_previousEnv","optimizedSubSetKey","m_layer","m_geometryType","searchedStyleSet","getOptimizedStyleSet","currStyle","processStyle","techinque","subSetKey","optimizedStyleSet","createPreFilteredStyleSet","compileStyle","checkStyleDynamicAttributes","classify","_minZoomLevelExpr","_maxZoomLevelExpr","checkZoomLevel","getTechniqueForStyleMatch","final","_dynamicTechniques","dynamicAttributes","evaluateTechniqueProperties","getDynamicTechniqueKey","createTechnique","_staticTechnique","dynamicAttrKey","_attrName","_dynamicTechniqueAttributes","_dynamicFeatureAttributes","_dynamicForwardedAttributes","_staticAttributes","dynamicFeatureAttributes","dynamicTechniqueAttributes","dynamicForwardedAttributes","targetStaticAttributes","techniqueDescriptor","processAttribute","_usesFeatureState","attrScope","attrExpr","dynamicAttrs","currEdgeStart","currEdgeGoal","prevEdgeStart","prevEdgeGoal","indexBuffer","vertexStride","polygonContour","polygonContourEdges","isExtruded","addFootprintEdges","wallEdgeSlope","vFootprint0","vRoof0","vFootprint1","vRoof1","prevEdgeIdx","v0x","v0y","v1x","v1y","vFoot0","ThreeBufferUtils","getBufferElementType","fromThreeBufferAttribute","bufferAttribute","fromThreeInterleavedBufferAttribute","fromThreeBufferGeometry","attributeNames","isOnScreen","ndc","projectVector","tempV3","ndcToScreen","tempV2","m_sky","m_projectionType","m_skyTexture","SkyGradientTexture","SkyCubemapTexture","isSameSkyType","DEFAULT_TEXTURE_SIZE","DEFAULT_MONOMIAL_POWER","cameraRight","cameraUp","m_faceCount","m_faces","fillTextureData","monomialPower","unpackAlignment","m_farClipPlaneDividedVertically","m_groundPlane","m_bottomMidFarPoint","m_topMidFarPoint","m_horizonPosition","m_farClipPlaneCorners","setHorizonPosition","updateTexturePosition","faceIdx","upDir","unproject","skyRatio","DEFAULT_FONT_CATALOG_NAME","m_catalogsLoading","defaultFontCatalogUrl","catalogCallback","fontCatalogConfig","fontCatalogPromise","m_renderedTilesChangeCheck","m_lookAtVector","m_minGlyphCount","m_maxGlyphCount","UrlCopyrightProvider","CopyrightCoverageProvider","m_fetchURL","m_baseScheme","m_requestHeaders","m_transferManager","m_cachedCopyrightResponse","fetchFunction","maxRetries","activeDownloadCount","downloadQueue","activeDownloads","defaultInstance","retryCount","status","waitFor","retryTimeout","fetchRepeatedly","milliseconds","downloadAs","download","arrayBuffer","maxParallelDownloads","deferred","DeferredPromise","doDownload","onDownloadDone","execDeferredDownload","future","converter","cacheKey","pendingFetch","newFetch","executor","resolveFunc","rejectFunc","ImageItem","AtmosphereVariant","AtmosphereShadingVariant","AtmosphereLightMode","clipPlanes","MapViewAtmosphere","m_sceneCamera","m_projection","m_updateCallback","m_atmosphereVariant","SkyAndGround","m_materialVariant","ScatteringShader","m_clipPlanesEvaluator","m_lightDirection","Sky","createSkyGeometry","Ground","createGroundGeometry","addToMapAnchors","mapAnchors","SkyAtmosphereUserName","GroundAtmosphereUserName","m_skyMesh","m_groundMesh","isAdded","isPresent","removeFromMapAnchors","lightMode","dynamicLight","LightDynamic","m_groundMaterial","setDynamicLighting","m_skyMaterial","m_skyGeometry","m_groundGeometry","createMapAnchor","skyGeometry","SphereGeometry","SimpleColor","normalScale","setupSkyForRendering","groundGeometry","setupGroundForRendering","onBeforeCallback","overrideClipPlanes","onAfterRender","revertClipPlanes","rteCamera","sceneCam","pickable","ImageOrigin","m_textureLoader","requestHeaders","crossOrigin","loadWithThreeLoader","isJPEG","setCrossOrigin","m_wantsPoints","m_wantsLines","m_wantsAreas","m_wantsObject3D","wantsAll","wantsPoints","wantsLines","wantsAreas","wantsObject3D","visitObject","wantsFeature","visitMesh","BufferedGeometryLineAccessor","BufferedGeometryObject3dAccessor","IndexedBufferedGeometryLineAccessor","meshObject","geometryAccessor","featureStart","featureEnd","getBufferGeometry","getIndexedGeometryAccessor","getGeometryAccessor","getCount","setRange","visitPoint","visitLine","visitArea","visitObject3D","tmpNormal","tmpTangent0","tmpTangent1","tmpBitangent","LINE_VERTEX_ATTRIBUTES","NORMAL_UV_VERTEX_ATTRIBUTES","LINE_VERTEX_ATTRIBUTES_NUV","HP_LINE_VERTEX_ATTRIBUTES","HP_LINE_VERTEX_ATTRIBUTES_NUV","LineGeometry","getVertexDescriptor","hasNormalsAndUvs","highPrecision","createLineGeometry","polyline","colors","pointCount","segments","tangents","hasSegmentOffsets","hasTexCoords","sqrLength","lineCoverage","lineLength","isClosed","tmpVertices","addVertexPair","T1","T2","segment","extrusionCoord","highComp","lowComp","setComponent","computeBitangent","createSimpleLineGeometry","LineGroup","isSimple","vertexDescriptor","descr","createGeometry","isHighPrecisionPointsMaterial","dimensionality","setDimensionality","m_processLayersDefault","m_processPointsDefault","m_processLinesDefault","m_processPolygonsDefault","m_layersToProcess","m_layersToIgnore","m_pointsToProcess","m_ignoredPoints","m_linesToProcess","m_linesToIgnore","m_polygonsToProcess","m_polygonsToIgnore","m_kindsToProcess","m_kindsToIgnore","processLayersDefault","processPointsDefault","processLinesDefault","processPolygonsDefault","addItem","addItems","layersToProcess","layersToIgnore","pointsToProcess","pointsToIgnore","linesToProcess","linesToIgnore","polygonsToProcess","polygonsToIgnore","kindsToProcess","kindsToIgnore","items","layerName","matchLayer","geometryTypes","geomType","classes","featureClass","matchClass","featureAttribute","geomTypes","featureClasses","OmvGenericFeatureFilter","layerItems","layerItem","itemsToProcess","itemsToIgnore","defaultResult","filters","hasKindFilter","wantsLayer","wantsPointFeature","wantsLineFeature","wantsPolygonFeature","wantsKind","OmvGenericFeatureModifier","doProcessFeature","featureClassThing","matchItems","matchAttribute","getDataProvider","OmvRestClient","missingOmvDecoderServiceInfoEmitted","hereVectorTileBaseUrl","hereVectoTileDefaultOptions","defaultOptions","TileDataSource","tileFactory","TileFactory","concurrentDecoderServiceName","completedParams","completeDataSourceParameters","m_decoderOptions","showMissingTechniques","filterDescription","filterDescr","gatherFeatureAttributes","featureModifiers","featureModifierId","skipShortLabels","enableElevationOverlay","configureDecoder","configure","m_modelConstructor","m_tileFactory","m_isReady","m_decoder","getTileDecoder","concurrentDecoderScriptUrl","concurrentDecoderWorkerCount","copyrightProvider","getCopyrights","TileInfoLoader","loaderState","debugMaterial","linewidth","NeverDepth","debugCircleMaterial","debugBlackCircleMaterial","debugBlueCircleMaterial","PRIORITY_ALWAYS","OmvDebugLabelsTile","addLabelDebugInfo","debugTextPaths","debugTextPathsFull","debugTextPoisFull","tileGeometryCreator","colorMap","indexFilter","centerZ","pointScale","pointLabelIndex","bluePointGeometry","bluePointIndices","bluePointPositions","addedTextElements","pointSize","offsetXY","labelElement","_isDebug","bluePointMesh","lineGeometry","lineIndices","redPointGeometry","redPointIndices","redPointPositions","blackPointGeometry","blackPointIndices","blackPointPositions","elementIndex","zHeight","pathIndex","isRedPoint","lineMesh","redPointMesh","blackPointMesh","missingTilerServiceInfoEmitted","m_registered","m_tiler","tiler","getTiler","workerTilerUrl","registerIndex","updateIndex"],"mappings":"aACE,IAAIA,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUC,QAGnC,IAAIC,EAASJ,EAAiBE,GAAY,CACzCG,EAAGH,EACHI,GAAG,EACHH,QAAS,IAUV,OANAI,EAAQL,GAAUM,KAAKJ,EAAOD,QAASC,EAAQA,EAAOD,QAASF,GAG/DG,EAAOE,GAAI,EAGJF,EAAOD,QAKfF,EAAoBQ,EAAIF,EAGxBN,EAAoBS,EAAIV,EAGxBC,EAAoBU,EAAI,SAASR,EAASS,EAAMC,GAC3CZ,EAAoBa,EAAEX,EAASS,IAClCG,OAAOC,eAAeb,EAASS,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEZ,EAAoBkB,EAAI,SAAShB,GACX,oBAAXiB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAeb,EAASiB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAeb,EAAS,aAAc,CAAEmB,OAAO,KAQvDrB,EAAoBsB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQrB,EAAoBqB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFA1B,EAAoBkB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOrB,EAAoBU,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRzB,EAAoB6B,EAAI,SAAS1B,GAChC,IAAIS,EAAST,GAAUA,EAAOqB,WAC7B,WAAwB,OAAOrB,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAH,EAAoBU,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRZ,EAAoBa,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG/B,EAAoBkC,EAAI,GAIjBlC,EAAoBA,EAAoBmC,EAAI,K,gBClFrDhC,EAAOD,QAAUkC,O,iYCMjB,YACA,a,iYCaA,WACA,UACA,WACA,WACA,WACA,YACA,WACA,WACA,YACA,YACA,YACA,YACA,YACA,WACA,YACA,WACA,YACA,Y,iYCvBA,WACA,YACA,WACA,UACA,WACA,WACA,WACA,WACA,YACA,WACA,WACA,WACA,YACA,WACA,WACA,WACA,YACA,WACA,YACA,WACA,WACA,WACA,WACA,YACA,YACA,YACA,YACA,YACA,WACA,WACA,UACA,YACA,a,iYChCA,YACA,WACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,WACA,WACA,YACA,YACA,YACA,YACA,UACA,a,woBCvBA,eACA,SACA,SAEA,QAIA,QAEA,OACA,QACA,QAEA,WAEA,MAAMC,EAAgB,IAAI,EAAAC,cAEpBC,EAAmB,IAAI,EAAAC,iBAuB7B,MAAaC,EAAb,cAIa,KAAAC,WAAa,IAAIC,KAJ9B,qBAiBA,kBAAMC,EAUF,UAAUC,GACN,MAAMC,EAAe,IAAIL,EAEzB,OADAI,EAAKE,OAAOC,KAAKC,SAAUH,GACpBA,EAGX,qBAAqBD,EAAuBK,IAI5C,wBAAwBL,EAA0BK,IAIlD,uBAAuBL,EAAyBK,IAIhD,uBAAuBL,EAAyBK,IAIhD,uBAAuBL,EAAyBK,IAIhD,aAAaL,EAAeK,GACxBA,EAAQR,WAAWS,IAAIN,EAAKlC,MAGhC,sBAAsBkC,EAAwBK,GAC1CA,EAAQR,WAAWS,IAAIN,EAAKlC,MAGhC,cAAckC,EAAgBK,GAG1B,OAFAL,EAAKO,KAAKC,QAAQC,GAAaA,EAAUP,OAAOC,KAAME,IAE9CL,EAAKU,IACT,IAAK,qBACDL,EAAQM,UAAW,EACnB,MACJ,IAAK,gBACDN,EAAQO,cAAe,EACvBP,EAAQR,WAAWS,IAAI,UACvBD,EAAQR,WAAWS,IAAI,OACvB,MACJ,IAAK,KACDD,EAAQR,WAAWS,IAAI,OACvB,MACJ,IAAK,OACL,IAAK,kBACL,IAAK,2BACDD,EAAQR,WAAWS,IAAI,SACvB,MACJ,IAAK,gBACDD,EAAQR,WAAWS,IAAI,kBAOnC,eAAeN,EAAiBK,GAC5BL,EAAKxB,MAAM0B,OAAOC,KAAME,GACxBL,EAAKa,SAASL,QAAQ,EAAEM,EAAGC,KAAYA,EAAOb,OAAOC,KAAME,IAC3DL,EAAKgB,SAASd,OAAOC,KAAME,GAG/B,cAAcL,EAAgBK,GAC1BL,EAAKa,SAASL,QAAQ,EAAES,EAAWF,MAC/BE,EAAUf,OAAOC,KAAME,GACvBU,EAAOb,OAAOC,KAAME,KAExBL,EAAKgB,SAASd,OAAOC,KAAME,GAG/B,cAAcL,EAAgBK,GAC1BL,EAAKkB,MAAMhB,OAAOC,KAAME,GACxBL,EAAKmB,aAAajB,OAAOC,KAAME,GAC/BL,EAAKoB,MAAMZ,QAAQ,EAAEM,EAAGtC,KAAWA,EAAM0B,OAAOC,KAAME,IAG1D,qBAAqBL,EAAuBK,GACxCL,EAAKkB,MAAMhB,OAAOC,KAAME,GACxBL,EAAKoB,MAAMZ,QAAQ,EAAEM,EAAGtC,KAAWA,EAAM0B,OAAOC,KAAME,KAE9D,OA/FW,EAAAD,SAAW,IAAIL,EA+F1B,GAhGA,GAwHA,SAAgBsB,EAAWC,GACvB,OAAOC,MAAMC,QAAQF,IAAMA,EAAEG,OAAS,GAAqB,iBAATH,EAAE,GAexD,IAAYI,EAhBZ,eAgBA,SAAYA,GAIR,qBAKA,6BAKA,yBAdJ,CAAYA,EAAA,EAAAA,YAAA,EAAAA,UAAS,KAwBrB,MAAsBC,EAMlB,cAAcnD,GACV,OAAOA,aAAiBmD,EAU5B,aAAaC,GAGT,OAFe,IAAI,EAAAC,WAAWD,GACVE,QAyBxB,gBACIC,EACAC,EACAC,GAWA,OAAOC,EAAUH,OARGI,IAAhBH,EACM,CACIA,cACAI,YAAa,IAAItC,IACjBuC,MAAOJ,GAAuB,IAAIK,UAEtCH,GAed,SACII,EACAC,EAAmBd,EAAUe,MAC7BJ,GAEA,OAAOlC,KAAKD,OACRV,EACA,IAAI,EAAAkD,qBAAqBlD,EAAe+C,EAAKC,EAAOH,IAY5D,YAAYhC,GACR,OAAOF,KAAKD,OAAOR,EAAkBW,GAMzC,eAII,OAHKF,KAAKwC,iBACNxC,KAAKwC,eAAiB5C,EAAwB6C,GAAGzC,OAE9CA,KAAKwC,eAShB,OAAOE,GACH,OAAOA,EAAKvC,IAAIH,MAGpB,SACI,OAAO,IAAI2C,GAAiBC,UAAU5C,MAM1C,YAII,YAHyBgC,IAArBhC,KAAK6C,cACL7C,KAAK6C,YAAc7C,KAAK8C,iBAErB9C,KAAK6C,aA7HpB,SAsKA,MAAaE,UAAgBvB,EACzB,YAAqB7D,GACjBqF,QADiB,KAAArF,OAKrB,OAAwBsF,EAAuC/C,GAC3D,OAAO+C,EAAQC,aAAalD,KAAME,GAI5B,gBACN,OAAO,GAZf,YAmBA,MAAsBiD,UAAoB3B,EAMtC,iBAAiBnD,GACb,cAAeA,GACX,IAAK,UACD,OAAO,IAAI+E,EAAmB/E,GAClC,IAAK,SACD,OAAO,IAAIgF,EAAkBhF,GACjC,IAAK,SACD,OAAO,IAAIiF,EAAkBjF,GACjC,IAAK,SACD,OAAiB,OAAVA,EAAiBkF,EAAgBtD,SAAW,IAAIuD,EAAkBnF,GAC7E,QACI,MAAM,IAAIoF,MAAM,oCAAoCpF,OAOtD,gBACN,OAAO,GAzBf,gBAgCA,kBAAakF,UAAwBJ,EAKjC,cACIH,QAHK,KAAA3E,MAAe,KAOxB,OAAwB4E,EAAuC/C,GAC3D,OAAO+C,EAAQS,qBAAqB1D,KAAME,GAIpC,gBACN,OAAO,GAEf,OAjBW,EAAAD,SAAW,IAAIsD,EAiB1B,GAlBA,GAAa,EAAAA,kBAuBb,MAAaH,UAA2BD,EACpC,YAAqB9E,GACjB2E,QADiB,KAAA3E,QAKrB,OAAwB4E,EAAuC/C,GAC3D,OAAO+C,EAAQU,wBAAwB3D,KAAME,IAPrD,uBAcA,MAAamD,UAA0BF,EACnC,YAAqB9E,GACjB2E,QADiB,KAAA3E,QAKrB,OAAwB4E,EAAuC/C,GAC3D,OAAO+C,EAAQW,uBAAuB5D,KAAME,IAPpD,sBAcA,MAAaoD,UAA0BH,EAGnC,YAAqB9E,GACjB2E,QADiB,KAAA3E,QAOrB,oB,UAII,YAH6B2D,IAAzBhC,KAAK6D,kBACL7D,KAAK6D,gBAAoE,QAArD,EAAyB,QAAzB,EAAG,EAAAC,KAAKnC,MAAM3B,KAAK3B,cAAM,QAAI,EAAA0F,OAAOpC,MAAM3B,KAAK3B,cAAM,QAAI,MAEtD,QAA3B,EAAO2B,KAAK6D,uBAAe,aAAI7B,EAInC,OAAwBiB,EAAuC/C,GAC3D,OAAO+C,EAAQe,uBAAuBhE,KAAME,IAnBpD,sBA0BA,MAAasD,UAA0BL,EACnC,YAAqB9E,GACjB2E,QADiB,KAAA3E,QAIrB,qBACI,OAAO+C,MAAMC,QAAQrB,KAAK3B,OAI9B,OAAwB4E,EAAuC/C,GAC3D,OAAO+C,EAAQgB,uBAAuBjE,KAAME,IAXpD,sBAkBA,MAAagE,UAAyB1C,EAClC,YAAqB7D,GACjBqF,QADiB,KAAArF,OAKrB,OAAwBsF,EAAuC/C,GAC3D,OAAO+C,EAAQkB,sBAAsBnE,KAAME,GAIrC,gBACN,OAAO,GAZf,qBAmBA,MAAakE,UAAiB5C,EAG1B,YAAqBjB,EAAqBH,GACtC4C,QADiB,KAAAzC,KAAqB,KAAAH,OAS1C,eACI,OAAOJ,KAAKI,KAIhB,OAAwB6C,EAAuC/C,GAC3D,OAAO+C,EAAQoB,cAAcrE,KAAME,GAI7B,gBACN,MAAMoE,EAAatE,KAAKsE,YAAc,EAAAhF,cAAciF,YAAYvE,KAAKO,IAErE,SAAI+D,GAAcA,EAAWE,mBAAqBF,EAAWE,kBAAkBxE,QAIxEA,KAAKI,KAAKqE,KAAKC,GAAKA,EAAEC,cA7BrC,aAyCA,MAAaC,UAAkBpD,EAyB3B,YACanD,EACAqC,EACAG,GAETmC,QAJS,KAAA3E,QACA,KAAAqC,WACA,KAAAG,WAtBb,yBAAyBgE,GACrB,cAAeA,GACX,IAAK,SACL,IAAK,SACD,OAAO,EACX,IAAK,SACD,IAAKzD,MAAMC,QAAQwD,IAAyB,IAAhBA,EAAKvD,OAC7B,OAAO,EAEX,MAAMwD,SAAmBD,EAAK,GAC9B,OAAkB,WAAdC,GAAwC,WAAdA,IACnBD,EAAKE,MAAMzG,UAAYA,IAAMwG,GAG5C,QACI,OAAO,GAanB,OAAwB7B,EAAuC/C,GAC3D,OAAO+C,EAAQ+B,eAAehF,KAAME,GAI9B,gBACN,OACIF,KAAK3B,MAAMsG,aACX3E,KAAKU,SAAS+D,KAAK,EAAE9D,EAAGC,KAAYA,EAAO+D,cAC3C3E,KAAKa,SAAS8D,aA3C1B,cAmDA,MAAaM,UAAiBzD,EAC1B,YAAqBd,EAAwCG,GACzDmC,QADiB,KAAAtC,WAAwC,KAAAG,WAK7D,OAAwBoC,EAAuC/C,GAC3D,OAAO+C,EAAQiC,cAAclF,KAAME,GAI7B,gBACN,OACIF,KAAKU,SAAS+D,KAAK,EAAEU,EAAMvE,KAAYuE,EAAKR,aAAe/D,EAAO+D,cAClE3E,KAAKa,SAAS8D,aAd1B,aAsBA,MAAaS,UAAiB5D,EAC1B,YACaT,EACAC,EACAC,GAET+B,QAJS,KAAAjC,QACA,KAAAC,eACA,KAAAC,QAMb,OAAwBgC,EAAuC/C,GAC3D,OAAO+C,EAAQoC,cAAcrF,KAAME,GAI7B,gBACN,OACIF,KAAKe,MAAM4D,aACX3E,KAAKgB,aAAa2D,aAClB3E,KAAKiB,MAAMwD,KAAK,EAAE9D,EAAGtC,KAAWA,EAAMsG,cAnBlD,aAgCA,MAAaW,UAAwB9D,EACjC,YACajD,EACAwC,EACAE,GAET+B,QAJS,KAAAzE,OACA,KAAAwC,QACA,KAAAE,QAMb,OAAwBgC,EAAuC/C,GAC3D,OAAO+C,EAAQsC,qBAAqBvF,KAAME,GAIpC,gBACN,OAAOF,KAAKe,MAAM4D,aAAe3E,KAAKiB,MAAMwD,KAAK,EAAE9D,EAAGtC,KAAWA,EAAMsG,cAhB/E,oBAyBA,MAAMhC,EACF,UAAU9C,GACN,OAAOA,EAAKE,OAAOC,UAAMgC,GAG7B,qBAAqBnC,EAAuBK,GACxC,OAAO,KAGX,wBAAwBL,EAA0BK,GAC9C,OAAOL,EAAKxB,MAGhB,uBAAuBwB,EAAyBK,GAC5C,OAAOL,EAAKxB,MAGhB,uBAAuBwB,EAAyBK,GAC5C,OAAOL,EAAKxB,MAGhB,uBAAuBwB,EAAyBK,GAC5C,OAAIL,EAAKxB,iBAAiBe,EAAMoG,QACrB,CAAC,cAAe3F,EAAKxB,MAAMoH,EAAG5F,EAAKxB,MAAMqH,GACzC7F,EAAKxB,iBAAiBe,EAAMuG,QAC5B,CAAC,cAAe9F,EAAKxB,MAAMoH,EAAG5F,EAAKxB,MAAMqH,EAAG7F,EAAKxB,MAAMuH,GACvD/F,EAAKxB,iBAAiBe,EAAMyG,QAC5B,CAAC,cAAehG,EAAKxB,MAAMoH,EAAG5F,EAAKxB,MAAMqH,EAAG7F,EAAKxB,MAAMuH,EAAG/F,EAAKxB,MAAMyH,GAEzE,CAAC,UAAWjG,EAAKxB,OAG5B,aAAawB,EAAeK,GACxB,MAAO,CAAC,MAAOL,EAAKlC,MAGxB,sBAAsBkC,EAAwBK,GAC1C,MAAO,CAAC,MAAOL,EAAKlC,MAGxB,cAAckC,EAAgBK,GAC1B,MAAO,CAACL,EAAKU,MAAOV,EAAKO,KAAK2F,IAAIzF,GAAaN,KAAK4C,UAAUtC,KAGlE,eAAeT,EAAiBK,GAC5B,MAAMQ,EAAwB,GAC9B,IAAK,MAAOsF,EAAOC,KAASpG,EAAKa,SAC7BA,EAASwF,KAAKF,EAAOhG,KAAK4C,UAAUqD,IAExC,MAAO,CAAC,QAASjG,KAAK4C,UAAU/C,EAAKxB,UAAWqC,EAAUV,KAAK4C,UAAU/C,EAAKgB,WAGlF,cAAchB,EAAgBK,GAC1B,MAAMQ,EAAwB,GAC9B,IAAK,MAAOI,EAAWmF,KAASpG,EAAKa,SACjCA,EAASwF,KAAKlG,KAAK4C,UAAU9B,GAAYd,KAAK4C,UAAUqD,IAE5D,MAAO,CAAC,UAAWvF,EAAUV,KAAK4C,UAAU/C,EAAKgB,WAGrD,cAAchB,EAAgBK,GAC1B,MAAMiG,EAAoB,CAAC,QAO3B,OANAA,EAAOD,KAAKlG,KAAK4C,UAAU/C,EAAKkB,QAChCoF,EAAOD,KAAKlG,KAAK4C,UAAU/C,EAAKmB,eAChCnB,EAAKoB,MAAMZ,QAAQ,EAAE1B,EAAKN,MACtB8H,EAAOD,KAAKvH,GACZwH,EAAOD,KAAKlG,KAAK4C,UAAUvE,MAExB8H,EAGX,qBAAqBtG,EAAuBK,GACxC,MAAMiG,EAAoB,CAAC,cAAetG,EAAKtB,MAM/C,OALA4H,EAAOD,KAAKlG,KAAK4C,UAAU/C,EAAKkB,QAChClB,EAAKoB,MAAMZ,QAAQ,EAAE1B,EAAKN,MACtB8H,EAAOD,KAAKvH,GACZwH,EAAOD,KAAKlG,KAAK4C,UAAUvE,MAExB8H,GAIf,SAASpE,EACL8C,EACAuB,GAEA,GAAIhF,MAAMC,QAAQwD,GACd,OAaR,SAASwB,EAAUxB,EAAiBuB,GAChC,MAAM7F,EAAKsE,EAAK,GAEhB,GAAkB,iBAAPtE,EACP,MAAM,IAAIkD,MAAM,oCAGpB,OAAQlD,GACJ,IAAK,OACL,IAAK,MACD,OAAO,IAAI6D,EAAS,IAAK,CAACiC,EAAU,CAAC9F,EAAG+F,MAAM,MAAOzB,EAAKyB,MAAM,OAEpE,IAAK,MACD,OAiLZ,SAA0BzB,EAAiBuB,GACvC,GAAuB,iBAAZvB,EAAK,GACZ,MAAM,IAAIpB,MAAM,qCAEpB,QAA+BzB,IAA3BoE,EACA,MAAM,IAAI3C,MAAM,gCAEpB,MAAM9F,EAAOkH,EAAK,GAElB,GAAIuB,EAAuBnE,YAAYsE,IAAI5I,GACvC,MAAM,IAAI8F,MAAM,yBAAyB9F,MAG7C,KAAMA,KAAQyI,EAAuBvE,aACjC,MAAM,IAAI4B,MAAM,eAAe9F,gBAGnC,MAAM6I,EAAcJ,EAAuBlE,MAAMjE,IAAIN,GACrD,QAAoBqE,IAAhBwE,EACA,OAAOA,EAEX,IACIL,EADAM,EAAkBL,EAAuBvE,YAAYlE,GAEzD,GAAI,EAAA+I,oBAAoBD,GACpB,OAAOjF,EAAKmF,SAASF,GAClB,GAAI,EAAAG,kBAAkBH,GAAkB,CAC3C,GAAI,EAAAI,iCAAiCJ,EAAgBpI,OAGjD,OAAOmD,EAAKmF,SAAS,EAAAG,yCAAyCL,EAAgBpI,QAC3E,IAAI6C,EAAWuF,EAAgBpI,OAGlC,OAAOmD,EAAKmF,SAASF,EAAgBpI,OAFrCoI,EAAkBA,EAAgBpI,MAM1C,IAAI6C,EAAWuF,GAQX,MAAM,IAAIhD,MAAM,0BAA0B9F,KAP1CyI,EAAuBnE,YAAY9B,IAAIxC,GACvC,IACIwI,EAASpE,EAAU0E,EAAiBL,G,QAEpCA,EAAuBnE,YAAY8E,OAAOpJ,GAMlD,OADAyI,EAAuBlE,MAAM8E,IAAIrJ,EAAMwI,GAChCA,EAjOQc,CAAiBpC,EAAMuB,GAElC,IAAK,MACD,OAyBZ,SAAsBvB,EAAiBuB,GACnC,QAAgBpE,IAAZ6C,EAAK,GACL,OAAOqC,EAAa,MAAOrC,EAAMuB,GAErC,MAAMzI,EAAOkH,EAAK,GAClB,GAAoB,iBAATlH,EACP,MAAM,IAAI8F,MAAM,qCAEpB,OAAO,IAAIV,EAAQpF,GAjCJwJ,CAAatC,EAAMuB,GAE9B,IAAK,MACD,OAiCZ,SAAsBvB,EAAiBuB,GACnC,QAAgBpE,IAAZ6C,EAAK,GACL,OAAOqC,EAAa,MAAOrC,EAAMuB,GAErC,MAAMzI,EAAOkH,EAAK,GAClB,GAAoB,iBAATlH,EACP,MAAM,IAAI8F,MAAM,qCAEpB,OAAO,IAAIS,EAAiBvG,GAzCbyJ,CAAavC,EAAMuB,GAE9B,IAAK,UACD,OAyCZ,SAA0BvB,GACtB,MAAMwC,EAAMxC,EAAK,GACjB,GAAY,OAARwC,GAA+B,iBAARA,EACvB,MAAM,IAAI5D,MAAM,uCAEpB,OAAO,IAAID,EAAkB6D,GA9CdC,CAAiBzC,GAE5B,IAAK,QACD,OA8CZ,SACIA,EACAuB,GAEA,GAAIvB,EAAKvD,OAAS,EACd,MAAM,IAAImC,MAAM,wBAEpB,KAAMoB,EAAKvD,OAAS,GAChB,MAAM,IAAImC,MAAM,6CAEpB,MAAMpF,EAAQ0D,EAAU8C,EAAK,GAAIuB,GAC3BmB,EAAwC,GAC9C,IAAK,IAAInK,EAAI,EAAGA,EAAIyH,EAAKvD,OAAS,EAAGlE,GAAK,EAAG,CACzC,MAAM4I,EAAQnB,EAAKzH,GACnB,IAAKwH,EAAU4C,kBAAkBxB,GAC7B,MAAM,IAAIvC,MAAM,IAAIgE,KAAKC,UAAU1B,wCAEvC,MAAMnG,EAAOkC,EAAU8C,EAAKzH,EAAI,GAAIgJ,GACpCmB,EAAWrB,KAAK,CAACF,EAAOnG,IAE5B,MAAMgB,EAAWkB,EAAU8C,EAAKA,EAAKvD,OAAS,GAAI8E,GAClD,OAAO,IAAIxB,EAAUvG,EAAOkJ,EAAY1G,GAnEzB8G,CAAe9C,EAAMuB,GAEhC,IAAK,OACD,OAmEZ,SACIvB,EACAuB,GAEA,GAAIvB,EAAKvD,OAAS,EACd,MAAM,IAAImC,MAAM,wBAEpB,GAAIoB,EAAKvD,OAAS,EACd,MAAM,IAAImC,MAAM,4CAEpB,MAAM/C,EAAgC,GACtC,IAAK,IAAItD,EAAI,EAAGA,EAAIyH,EAAKvD,OAAS,EAAGlE,GAAK,EAAG,CACzC,MAAM0D,EAAYiB,EAAU8C,EAAKzH,GAAIgJ,GAC/BvG,EAAOkC,EAAU8C,EAAKzH,EAAI,GAAIgJ,GACpC1F,EAASwF,KAAK,CAACpF,EAAWjB,IAE9B,MAAM+H,EAAe7F,EAAU8C,EAAKA,EAAKvD,OAAS,GAAI8E,GACtD,OAAO,IAAInB,EAASvE,EAAUkH,GApFfC,CAAchD,EAAMuB,GAE/B,IAAK,cACD,OAmGZ,SACIvB,EACAuB,GAEA,MAAM7H,EAAwBsG,EAAK,GACnC,IApBJ,SAA6B/F,GACzB,IAAKsC,MAAMC,QAAQvC,GACf,OAAO,EAEX,OAAQA,EAAO,IACX,IAAK,WACL,IAAK,SACL,IAAK,QACL,IAAK,cACD,OAAO,EACX,QACI,OAAO,GASVgJ,CAAoBvJ,GACrB,MAAM,IAAIkF,MAAM,kCAEpB,GAAgB,gBAAZlF,EAAK,IAA2C,iBAAZA,EAAK,GACzC,MAAM,IAAIkF,MAAM,sDAEpB,MAAM1C,EAAQ8D,EAAK,GAAK9C,EAAU8C,EAAK,GAAIuB,QAA0BpE,EACrE,IAAKR,EAAKuG,OAAOhH,GACb,MAAM,IAAI0C,MAAM,2CAEpB,GAAoB,IAAhBoB,EAAKvD,UAAkBuD,EAAKvD,OAAS,GACrC,MAAM,IAAImC,MAAM,6BAGpB,MAAMxC,EAA+B,GACrC,IAAK,IAAI7D,EAAI,EAAGA,EAAIyH,EAAKvD,OAAS,EAAGlE,GAAK,EAAG,CACzC,MAAMuB,EAAMkG,EAAKzH,GACXiB,EAAQ0D,EAAU8C,EAAKzH,EAAI,GAAIgJ,GACrCnF,EAAMiF,KAAK,CAACvH,EAAKN,IAErB,OAAO,IAAIiH,EAAgB/G,EAAMwC,EAAOE,GA5HzB+G,CAAqBnD,EAAMuB,GAEtC,IAAK,OACD,OA4HZ,SACIvB,EACAuB,GAEA,GAAIvB,EAAKvD,OAAS,EACd,MAAM,IAAImC,MAAM,6CAEpB,GAAIoB,EAAKvD,OAAS,KAAOuD,EAAKvD,OAAS,GACnC,MAAM,IAAImC,MAAM,wBAEpB,MAAM1C,EAAQgB,EAAU8C,EAAK,GAAIuB,GAC3BpF,EAAee,EAAU8C,EAAK,GAAIuB,GAClCnF,EAA+B,GACrC,IAAK,IAAI7D,EAAI,EAAGA,EAAIyH,EAAKvD,OAAQlE,GAAK,EAAG,CACrC,MAAMuB,EAAMkG,EAAKzH,GACXiB,EAAQ0D,EAAU8C,EAAKzH,EAAI,GAAIgJ,GACrCnF,EAAMiF,KAAK,CAACvH,EAAKN,IAErB,OAAO,IAAI+G,EAASrE,EAAOC,EAAcC,GA9I1BgH,CAAcpD,EAAMuB,GAE/B,QACI,OAAOc,EAAa3G,EAAIsE,EAAMuB,IAlD3BC,CAAUxB,EAAMuB,GACpB,GAAa,OAATvB,EACP,OAAOtB,EAAgBtD,SACpB,GAAoB,kBAAT4E,EACd,OAAO,IAAIzB,EAAmByB,GAC3B,GAAoB,iBAATA,EACd,OAAO,IAAIxB,EAAkBwB,GAC1B,GAAoB,iBAATA,EACd,OAAO,IAAIvB,EAAkBuB,GAEjC,MAAM,IAAIpB,MAAM,qCAAqCgE,KAAKC,UAAU7C,MAsLxE,SAASqC,EACL3G,EACAsE,EACAuB,GAEA,OAAO,IAAIhC,EACP7D,EACAsE,EAAKyB,MAAM,GAAGP,IAAIzF,GAAayB,EAAUzB,EAAW8F,O,iYCv+B5D,YACA,WACA,WACA,WACA,YAEA,YACA,WACA,WACA,Y,sGCjBA,cACA,QACA,QAEA,OAUA,MAAa8B,EAgGT,YAAmBC,EAAyBC,EAA0BC,GAAnD,KAAAF,WAAyB,KAAAC,YAA0B,KAAAC,WAxFtE,mBAAmBF,EAAkBC,EAAmBC,GACpD,OAAO,IAAIH,EAAeC,EAAUC,EAAWC,GAUnD,mBAAmBF,EAAkBC,EAAmBC,GACpD,OAAO,IAAIH,EACP9I,EAAMkJ,UAAUC,SAASJ,GACzB/I,EAAMkJ,UAAUC,SAASH,GACzBC,GAYR,kBAAkBG,GACd,OAAO,IAAIN,EAAeM,EAAOC,IAAKD,EAAOE,KAmBjD,oBAAoBC,GAChB,OAAO,IAAIT,EAAeS,EAAS,GAAIA,EAAS,GAAIA,EAAS,IAiBjE,kBAAkBA,GACd,GAAI,EAAAC,eAAeD,GACf,OAAOT,EAAeW,aAAaF,GAChC,GAAI,EAAAG,qBAAqBH,GAC5B,OAAOT,EAAea,YAClBJ,EAASR,SACTQ,EAASP,UACTO,EAASN,UAEV,GAAI,EAAAW,aAAaL,GACpB,OAAOT,EAAea,YAAYJ,EAASF,IAAKE,EAASD,KAG7D,MAAM,IAAIjF,MAAM,oCAepB,wBACI,OAAOrE,EAAMkJ,UAAUW,SAASjJ,KAAKmI,UAMzC,yBACI,OAAO/I,EAAMkJ,UAAUW,SAASjJ,KAAKoI,WAOzC,wBACI,OAAOpI,KAAKmI,SAOhB,yBACI,OAAOnI,KAAKoI,UAMhB,UACI,OAAOpI,KAAKmI,SAMhB,UACI,OAAOnI,KAAKoI,UAMhB,UACI,OAAQc,MAAMlJ,KAAKmI,YAAce,MAAMlJ,KAAKoI,WAMhD,aACI,IAAI,SAAED,EAAQ,UAAEC,GAAcpI,KAE9B,GAAIkJ,MAAMf,IAAae,MAAMd,GACzB,OAAOpI,KAGX,GAAImI,EAAW,GAAI,CACf,IAAIgB,GAAWhB,EAAW,IAAM,IAC5BgB,GAAW,MACXf,GAAa,IACbe,EAAU,IAAMA,GAGpBhB,EAAWgB,EAAU,GAGzB,GAAIhB,GAAY,GAAI,CAChB,IAAIgB,GAAWhB,EAAW,IAAM,IAC5BgB,IAAY,MACZf,GAAa,IACbe,GAAW,IAAMA,GAGrBhB,EAAWgB,EAAU,GAGzB,GAAIf,GAAa,KAAOA,EAAY,IAAK,CACrC,MAAMgB,EAAOC,KAAKD,KAAKhB,GACvBA,GAAeA,EAAY,IAAO,IAAMgB,GAAQ,IAAO,IAAMA,EAGjE,OAAIjB,IAAanI,KAAKmI,UAAYC,IAAcpI,KAAKoI,UAC1CpI,KAGJ,IAAIkI,EAAeC,EAAUC,EAAWpI,KAAKqI,UAQxD,OAAOiB,GACH,OACItJ,KAAKmI,WAAamB,EAAMnB,UACxBnI,KAAKoI,YAAckB,EAAMlB,WACzBpI,KAAKqI,WAAaiB,EAAMjB,SAShC,KAAKiB,GAID,OAHAtJ,KAAKmI,SAAWmB,EAAMnB,SACtBnI,KAAKoI,UAAYkB,EAAMlB,UACvBpI,KAAKqI,SAAWiB,EAAMjB,SACfrI,KAMX,QACI,OAAO,IAAIkI,EAAelI,KAAKmI,SAAUnI,KAAKoI,UAAWpI,KAAKqI,UAMlE,WACI,MAAO,CAAEI,IAAKzI,KAAKmI,SAAUO,IAAK1I,KAAKoI,WAM3C,aACI,YAAyBpG,IAAlBhC,KAAKqI,SACN,CAACrI,KAAKoI,UAAWpI,KAAKmI,SAAUnI,KAAKqI,UACrC,CAACrI,KAAKoI,UAAWpI,KAAKmI,WA5OpC,oB,iGCXA,cAEA,SAAiBG,GAyGb,SAAgBiB,EAAkBC,GAK9B,OAJAA,GAAQ,KACA,IACJA,GAAQ,KAELA,EA6BX,SAAgBC,EAAiBD,EAAWE,GAIxC,MAAMhM,GAHN8L,EAAID,EAAkBC,KACtBE,EAAIH,EAAkBG,IAGtB,OAAIhM,EAAI,IACGA,EAAI,IACJA,IAAM,IACNA,EAAI,IAEJA,EA/IC,EAAAiM,aAAhB,WACI,MAAO,CACHC,IAAK,CAAEnE,EAAGoE,IAAUnE,EAAGmE,IAAUjE,EAAGiE,KACpCC,IAAK,CAAErE,GAAIoE,IAAUnE,GAAImE,IAAUjE,GAAIiE,OAoC/B,EAAAE,WAAhB,SAA2BtE,EAAWC,EAAWE,EAAWzE,GACxD,YAAUa,IAANb,EACO,CAAEsE,IAAGC,IAAGE,MAEnBzE,EAAEsE,EAAIA,EACNtE,EAAEuE,EAAIA,EACNvE,EAAEyE,EAAIA,EACCzE,IASK,EAAA6I,YAAhB,SAAwDC,EAAmBC,GAIvE,OAHAA,EAAGzE,EAAIwE,EAAKxE,EACZyE,EAAGxE,EAAIuE,EAAKvE,EACZwE,EAAGtE,EAAIqE,EAAKrE,EACLsE,GAUE,EAAAjB,SAAW7J,EAAMkJ,UAAUW,SAU3B,EAAAV,SAAWnJ,EAAMkJ,UAAUC,SAY3B,EAAA4B,MAAQ/K,EAAMkJ,UAAU6B,MAQrB,EAAAZ,kBAAiB,EAcjB,EAAAa,sBAAhB,SAAsCZ,GAKlC,OAJAA,EAAID,EAAkBC,IACd,MACJA,GAAQ,KAELA,GAeK,EAAAC,iBAAgB,EAqBhB,EAAAY,qBAAhB,SAAqCC,EAAYC,EAAYjM,GAOzD,OADWgM,EADDb,EAAiBc,EAAID,GACXhM,GAAK,KAtKjC,CAAiB,EAAAgK,YAAA,EAAAA,UAAS,M,+RCL1B,aACA,OAyEA,SAAgBkC,EACZC,GAEIA,EAASC,aAAeD,EAASE,iBAKrCF,EAASG,SAAWxL,EAAMyL,gBACU,IAAhCJ,EAASK,oBACTL,EAASM,SAAW3L,EAAM4L,UAC1BP,EAASQ,SAAW7L,EAAM8L,uBAC1BT,EAASU,cAAgB/L,EAAM4L,UAC/BP,EAASW,cAAgBhM,EAAM8L,yBAE/BT,EAASM,SAAW3L,EAAMiM,eAC1BZ,EAASQ,SAAW7L,EAAM8L,uBAC1BT,EAASU,cAAgB/L,EAAM4L,UAC/BP,EAASW,cAAgBhM,EAAM8L,yBAsFvC,SAAgBI,EACZb,EACA9L,EACA4M,GAAkC,GAElC,YAAyBvJ,IAArByI,EAASe,QACFD,EAEJE,EAAgBhB,EAASe,QAAS7M,GAgB7C,SAAgB+M,EACZF,EACA7M,EACAN,GAEA,IAAIsN,GAAU,EAYd,MAXqB,iBAAVtN,GACPsN,EAAUH,EAAQ7M,KAASN,EAC3BmN,EAAQ7M,GAAON,IACE,IAAVA,GACPsN,EAAUH,EAAQ7M,KAAS,EAAAiN,iBAC3BJ,EAAQ7M,GAAO,EAAAiN,mBACE,IAAVvN,QAAoC2D,IAAjBwJ,EAAQ7M,YAE3B6M,EAAQ7M,GACfgN,GAAU,GAEPA,EAWX,SAAgBF,EAAgBD,EAAiC7M,GAC7D,MAAMkN,EAAeL,EAAQ7M,GAO7B,OALIkN,IAAiB,EAAAC,oBAEXD,IAAiB,EAAAD,kBAEjBC,GAvOD,EAAAD,iBAAmB,GACnB,EAAAE,uBAAoB9J,EAUjC,+BACI+J,EACAC,EACAC,EACAC,GAEA,MAAMC,GAAqB,IAAXD,EAAkB,KAAO,GAOzC,OALeH,EAAcK,QACzB,aAAaJ,KACb,aAAaA,OACnBG,cAAoBF,OAsBtB,2BACIxB,GAEIA,EAASC,cAKbF,EAAeC,GACfA,EAASE,gBAAiB,IAe9B,mBA8BA,2BACIF,GAEIA,EAASC,aAAeD,EAASE,iBAKrCF,EAASG,SAAWxL,EAAMiN,iBA+B9B,mCACI5B,EACA9L,EACAN,GAEA,EAAAiO,YACyBtK,IAArByI,EAASe,QACT,6DAEJ,MACMe,EAAclO,IADEiN,EAAwBb,EAAU9L,GAGxD,QAAK4N,IAGLb,EAAgBjB,EAASe,QAAS7M,EAAKN,GACvCoM,EAAS8B,YAAcA,GAChB,IAkBX,4BAwBA,oBA4BA,qB,sHCtOA,aAEA,OASA,QACA,OACA,OAIA,QAEMC,EAAS,EAAAC,cAAcxM,SAASvB,OAAO,gBAevCgO,EAAyB,IAAItN,EAAMuG,QAAQ,EAAG,EAAG,GACjDgH,EAAc,IAAIvN,EAAMwN,MAAMF,EAAuBG,SACrDC,EAAe,IAAI1N,EAAM2N,YAAO/K,EAAW,EAAAgL,eAAeC,mBAC1DC,EAAY,IAAI9N,EAAM+N,UAMtBC,EAAQ,CACV3H,EAAG,IAAIrG,EAAMuG,QACbD,EAAG,IAAItG,EAAMuG,QACbC,EAAG,IAAIxG,EAAMuG,SAEX0H,EAAe,CACjB5H,EAAG,IAAIrG,EAAMuG,QACbD,EAAG,IAAItG,EAAMuG,QACbC,EAAG,IAAIxG,EAAMuG,SAEXzD,EAAQ,CACVoL,YAAa,CAAC,IAAIlO,EAAMmO,WAAc,IAAInO,EAAMmO,YAChDC,QAAS,CAAC,IAAIpO,EAAMuG,QAAW,IAAIvG,EAAMuG,QAAW,IAAIvG,EAAMuG,SAC9D8H,QAAS,CAAC,IAAIrO,EAAMsO,QAAW,IAAItO,EAAMsO,SACzCC,WAAY,CACR,CACIC,MAAO,IAAIxO,EAAMuG,QACjBkI,MAAO,IAAIzO,EAAMuG,QACjBmI,MAAO,IAAI1O,EAAMuG,QACjBoI,SAAU,IAAI3O,EAAMuG,YA6BhC,SAAiBqI,GA8Gb,SAAgBC,EACZC,EACAC,EACAC,EACAC,EAAkB,EAAAC,cAElB,MAAMC,EAASL,EAAQK,OACjBC,EAAuBC,EACzBP,EACAA,EAAQQ,OACRH,GAEEI,EAAOtF,KAAKS,IACdT,KAAKO,IACDxK,EAAMkJ,UAAUC,SAAS8F,GACzBD,EAAehP,EAAMkJ,UAAUC,SAASiG,EAAqBG,OAEjE,GAEEC,EACFxP,EAAMkJ,UAAUC,SAASiG,EAAqBK,QAAUxF,KAAKyF,IAAMX,EACvED,EAAQa,OAAO,CACXR,SACAS,SAAUd,EAAQe,eAClBN,OACAC,YAuCR,SAAgBM,EACZR,EACAS,EACAC,GAEA,MAAMC,EAAYnN,EAAMsL,QAAQ,GAAG8B,KAAKZ,EAAOX,UACzCwB,EAAeb,EAAOc,kBAAkBtN,EAAMsL,QAAQ,IAC5DN,EAAUlG,IAAIqI,EAAWE,QACPvN,IAAdoN,IACAzC,EAAY8C,UAAYL,EACxBtC,EAAa4C,QAAUN,GAE3B,MAAMO,EAAiB,IAAIvQ,EAAMuG,QAC3BQ,EACFgJ,EAAWS,OAAS,EAAAC,eAAeC,OAC7B5C,EAAU6C,IAAIC,eAAerD,EAAagD,GAC1CzC,EAAU6C,IAAIE,gBAAgBnD,EAAc6C,GAKtD,YAJkB3N,IAAdoN,IACAzC,EAAY8C,SAAW,EACvB3C,EAAa4C,OAAS,EAAA1C,eAAeC,mBAElC9G,EAuGX,SAAgB+J,EACZC,EACAnB,EACAoB,EACAC,EACAlB,EACAhJ,EAAwB,IAAI/G,EAAMuG,SAElC,MAAM2K,EAAWlR,EAAMkJ,UAAUW,SAASoH,GACpChI,EAAWgB,KAAKkH,IAAID,GAAYtB,EAChCwB,EAASpR,EAAMkJ,UAAUW,SAASmH,GACxCjB,EAAWsB,aAAaN,EAAmBhK,GAC3C,MAAMuK,EAAiB1B,EAAW3F,KAAKsH,IAAIL,GAC3C,GAAInB,EAAWS,OAAS,EAAAC,eAAeC,OACnC3J,EAAOV,EAAIU,EAAOV,EAAI4D,KAAKsH,IAAIH,GAAUE,EACzCvK,EAAOT,EAAIS,EAAOT,EAAI2D,KAAKkH,IAAIC,GAAUE,EACzCvK,EAAOP,EAAIO,EAAOP,EAAIyC,OACnB,GAAI8G,EAAWS,OAAS,EAAAC,eAAee,UAAW,CAOrDvD,EAAazH,EAAE0J,KAAKnJ,GAAQ0K,YAG5BxD,EAAa3H,EACRsB,IAAI,EAAG,EAAG,GACV8J,eAAezD,EAAazH,GAC5BiL,YAIL3O,EAAMoL,YAAY,GAAGyD,iBAAiB1D,EAAazH,EAAG4K,EAASnH,KAAKyF,IACpEzB,EAAa3H,EAAEsL,gBAAgB9O,EAAMoL,YAAY,IAGjDD,EAAa3H,EAAEuL,UAAUP,GAKzB,MAAMQ,EAASlC,EAAW3F,KAAKkH,IAAID,GACnCnK,EAAOhG,IAAIkN,EAAa3H,GAAGvF,IAAIkN,EAAazH,EAAEqL,UAAUC,IAExD,MAAM1H,EAAI,EAAAwD,eAAeC,kBAAoB5E,EACvCqB,EAAIL,KAAKsH,IAAIL,GAAYtB,EACzBmC,EAAe9H,KAAK+H,KAAK5H,EAAIA,EAAIE,EAAIA,GAC3CvD,EAAO8K,UAAUE,GAGrB,OAAOhL,EAmEX,SAAgBkL,EAAsBC,EAAyBjC,GAC3D,MAAMkC,EAAsBlC,EAAUxC,QAAQgE,YAC9C,IAAK,MAAMW,KAASF,EAChB,GAAIE,EAAMC,QAAQpC,GAAahG,KAAKyF,GAAK,EAAG,CAIxC,MAAM4C,EAAWF,EAAMlQ,SAEvBkQ,EAAMV,eAAeS,GAAqBN,UAAUS,IA0ChE,SAAgBC,EACZL,EACAM,EACAlD,GAEA,MAAMmD,EAAuB,IAAIzS,EAAMsO,QACvCmE,EAAqBC,gBAAgBpD,EAAOqD,aAC5C,MAAMC,EAAiB,IAAI5S,EAAMuG,QAAQ,EAAG,EAAG,GAAGsM,aAAaJ,GACzDK,EAAmB,IAAI9S,EAAMuG,QAAQ,EAAG,EAAG,GAAGsM,aAAaJ,GAC3DM,GAAqB,IAAI/S,EAAMwN,OAAQwF,sBACzC1D,EAAOX,SACP6D,EACAA,EAAY/E,QAAQ1M,IAAI6R,IAEtBK,GAAqB,IAAIjT,EAAMwN,OAAQwF,sBACzC1D,EAAOX,SACP6D,EACAA,EAAY/E,QAAQ1M,IAAI+R,IAGtB7C,EAAYnN,EAAMsL,QAAQ,GAChC6B,EAAUC,KAAKZ,EAAOX,UAEtB,MAAMuE,EAAclT,EAAMkJ,UAAUW,SAASyF,EAAO6D,IAAM,GACpDC,EAAcpT,EAAMkJ,UAAUW,SAAUyF,EAAO6D,IAAM,EAAK7D,EAAO+D,QAGjEC,EAAiB,EAAIrJ,KAAKsJ,IAAIL,GAC9BM,EAAiB,EAAIvJ,KAAKsJ,IAAIH,GAE9BK,EAAiB3Q,EAAMsL,QAAQ,GACrCqF,EACKvD,KAAKD,GACLyD,IAAIlB,GACJmB,SAEL,MAAMC,GAA2B,IAAI5T,EAAMuG,SAAU2J,KAAKuD,GAAgBhC,YAEpEoC,EAAe,IAAI7T,EAAMuG,QAEzBuN,EAA0B,IAAI9T,EAAMuG,QACpCwN,EAAkB,IAAI/T,EAAMuG,QAElC,SAASyN,EACL5B,EACA6B,EACAC,EACAC,GAEAF,EAAe5C,aAAae,EAAO2B,GACnCD,EACK5D,KAAKD,GACLyD,IAAIK,GACJJ,SAEL,MAAMS,EAAYX,EAAepB,QAAQyB,GAEzC,GAAIM,GAAaF,EACb,OAGJ,MAAMG,EAAmBP,EAAwB5R,SAC3CoS,EAAoBb,EAAevR,SAEnCqS,EACFF,GAAoBpK,KAAKsH,IAAI6C,GAAaD,EAAYlK,KAAKkH,IAAIiD,IAC/DE,EAEJT,EACK3D,KAAK0D,GACLY,eAAeF,EAAoBC,GAExCtE,EAAUlP,IAAI8S,GACdJ,EAAeC,IAAIG,GAGvB,IAAK,MAAMzB,KAASF,EAChB8B,EAAW5B,EAAOW,EAAoBG,EAAaI,GACnDU,EAAW5B,EAAOa,EAAoBG,EAAaI,GAGvD,OAAOC,EAAevR,SAiG1B,SAAgBuS,EACZ3F,EACA4F,EACAC,EACA3E,GAEA,MAAM4E,EAAqB9R,EAAMsL,QAAQ,GAAGxG,IACxC8M,EACAC,EACA,GAEE1E,EAAYnN,EAAMsL,QAAQ,GAAG8B,KAAKpB,EAAQQ,OAAOX,UAEvD7L,EAAMuL,QAAQ,GAAGqE,gBAAgB5D,EAAQQ,OAAOqD,aAIhD7P,EAAMuL,QAAQ,GAAGwG,iBACb/R,EAAMuL,QAAQ,GACdvL,EAAMuL,QAAQ,GAAGyG,WAAWhG,EAAQQ,OAAOyF,mBAG/C,MAAMC,EAAqBJ,EAAmB/B,aAAa/P,EAAMuL,QAAQ,IAEzEP,EAAUlG,IAAIqI,EAAW+E,EAAmBvD,kBAC1B7O,IAAdoN,IACAzC,EAAY8C,UAAYL,EACxBtC,EAAa4C,QAAUN,GAG3B,MAAMiF,EAAgB,IAAIjV,EAAMuG,QAC1BQ,EACF+H,EAAQiB,WAAWS,OAAS,EAAAC,eAAeC,OACrC5C,EAAU6C,IAAIC,eAAerD,EAAa0H,GAC1CnH,EAAU6C,IAAIE,gBAAgBnD,EAAcuH,GAMtD,YAJkBrS,IAAdoN,IACAzC,EAAY8C,SAAW,EACvB3C,EAAa4C,OAAS,EAAA1C,eAAeC,mBAElC9G,EAYX,SAAgBmO,EACZpG,EACAqG,EACAC,GAEAtG,EAAQQ,OAAOX,SAAStI,GAAK8O,EAC7BrG,EAAQQ,OAAOX,SAASrI,GAAK8O,EAYjC,SAAgBC,EACZvG,EACAwG,EACAC,GAEAzS,EAAMoL,YAAY,GACbsH,mBAAmBF,EAAU7D,YAAa8D,EAAQ9D,aAClDgE,UACL3S,EAAMuL,QAAQ,GAAGqH,2BAA2B5S,EAAMoL,YAAY,IAC9DY,EAAQQ,OAAOuD,aAAa/P,EAAMuL,QAAQ,IAC1CS,EAAQQ,OAAOqG,oBAgEnB,SAAgBC,EACZ7F,EACAZ,EACA6B,EACAC,EACAlK,EAA2B,IAAI/G,EAAMmO,YAErC,MAAM0H,EAAY/S,EAAMyL,WAAW,GAiBnC,OAhBAwB,EAAW+F,kBAAkB3G,EAAQ0G,GAErC/S,EAAMuL,QAAQ,GAAG0H,UAAUF,EAAUrH,MAAOqH,EAAUpH,MAAOoH,EAAUnH,OACvE3H,EAAOiP,sBAAsBlT,EAAMuL,QAAQ,IAE3CvL,EAAMoL,YAAY,GAAGyD,iBACjB7O,EAAMsL,QAAQ,GAAGxG,IAAI,EAAG,EAAG,GAC3B5H,EAAMkJ,UAAUW,SAASmH,IAE7BlO,EAAMoL,YAAY,GAAGyD,iBACjB7O,EAAMsL,QAAQ,GAAGxG,IAAI,EAAG,EAAG,GAC3B5H,EAAMkJ,UAAUW,SAASoH,IAG7BlK,EAAOkP,SAASnT,EAAMoL,YAAY,IAClCnH,EAAOkP,SAASnT,EAAMoL,YAAY,IAC3BnH,EAkCX,SAAgBmP,EAAkB5G,EAAsBS,GAKpD,GAAIA,EAAWS,OAAS,EAAAC,eAAeC,OAAQ,CAC3C,MAAMf,EAAwBL,EAAOc,kBAAkBtN,EAAMsL,QAAQ,IAAIqD,YACnE0E,EAAwBpG,EACzBqG,cAAc9G,EAAOX,SAAU7L,EAAMsL,QAAQ,IAC7CuF,SACC0C,EAAW1G,EAAO2G,IAAIH,GAC5B,OAAOlM,KAAKsM,KAAKvW,EAAMkJ,UAAU6B,MAAMsL,GAAW,EAAG,IAClD,CAEH,EAAAnJ,OAAO6C,EAAWS,OAAS,EAAAC,eAAee,WAE1C,MAAMgF,EAAkB5H,EAAa6H,uBAAuBnH,EAAQS,GAEpE,OAAwB,OAApByG,EACO5H,EAAa8H,6BAChB3G,EACAT,EACAkH,IAGJpJ,EAAOuJ,KACH,0DACA,EAAAzH,cAEG,EAAAA,eAiBnB,SAAgB0H,EACZC,EACAnX,GAGAoD,EAAMsL,QAAQ,GAAG0I,sBAAsBpX,EAAOiT,aAC9CkE,EAAQ9G,WAAW+F,kBAAkBe,EAAQ9G,WAAWgH,eAAejU,EAAMsL,QAAQ,IAAK,CACtFI,MAAOP,EAAa5H,EACpBoI,MAAOR,EAAa3H,EACpBoI,MAAOT,EAAazH,EACpBmI,SAAU7L,EAAMsL,QAAQ,KAE5BtL,EAAMuL,QAAQ,GAAG0H,UAAU9H,EAAa5H,EAAG4H,EAAa3H,EAAG2H,EAAazH,GAGxE1D,EAAMuL,QAAQ,GAAGyG,WAAWhS,EAAMuL,QAAQ,IAAI4H,SAASvW,EAAOiT,aAC9D3E,EAAM3H,EAAE2Q,oBAAoBlU,EAAMuL,QAAQ,GAAI,GAC9CL,EAAM1H,EAAE0Q,oBAAoBlU,EAAMuL,QAAQ,GAAI,GAC9CL,EAAMxH,EAAEwQ,oBAAoBlU,EAAMuL,QAAQ,GAAI,GAG9C,IAAI4I,EAAM,EACNC,EAAQ,EACRC,EAAO,EAGX,MAAM7Y,EAAI0P,EAAMxH,EAAE8P,IAAIxT,EAAMsL,QAAQ,GAAGxG,IAAI,EAAG,EAAG,IAmBjD,OAlBItJ,EAAI,OACAA,GAAI,QACJ2Y,EAAMhN,KAAKmN,MAAMpJ,EAAMxH,EAAEH,GAAI2H,EAAMxH,EAAEF,GACrC4Q,EAAQjN,KAAKsM,KAAKvI,EAAMxH,EAAEA,GAC1B2Q,EAAOlN,KAAKmN,MAAMpJ,EAAM3H,EAAEG,EAAGwH,EAAM1H,EAAEE,KAGrCyQ,GAAOhN,KAAKmN,OAAOpJ,EAAM1H,EAAED,EAAG2H,EAAM3H,EAAEA,GACtC6Q,EAAQ,IACRC,EAAO,IAIXF,EAAMhN,KAAKmN,OAAOpJ,EAAM1H,EAAED,EAAG2H,EAAM3H,EAAEA,GACrC6Q,EAAQ,EACRC,EAAO,GAGJ,CACHF,MACAC,QACAC,QAeR,SAAgB9H,EACZP,EACApP,EACA2X,GAEAvI,EAAQiB,WAAW+F,kBAAkBuB,EAAU,CAC3C7I,MAAOP,EAAa5H,EACpBoI,MAAOR,EAAa3H,EACpBoI,MAAOT,EAAazH,EACpBmI,SAAU7L,EAAMsL,QAAQ,KAG5B,IAAImB,EAAO,EACPE,EAAU,EAQd,OAJA3M,EAAMsL,QAAQ,GACT8B,KAAKxQ,EAAOiP,UACZ+E,IAAI5Q,EAAMsL,QAAQ,IAClBqD,YACD3O,EAAMsL,QAAQ,GAAGkI,IAAIrI,EAAazH,GAAK,QAEvCiJ,EAAUxF,KAAKyF,GAAKkH,EAAgB9H,EAASpP,GAAQuX,IAErDxH,EAAUxF,KAAKmN,MAAMnN,KAAKsH,IAAI9B,GAAUxF,KAAKkH,IAAI1B,IACjDF,EAAO,EACA,CAAEA,OAAME,aAEnBF,EAAOzM,EAAMsL,QAAQ,GAAGiE,QAAQpE,EAAazH,GAE7C1D,EAAMsL,QAAQ,GACT8B,KAAKxQ,EAAOiP,UACZ+E,IAAI5Q,EAAMsL,QAAQ,IAClBsD,eAAezD,EAAazH,GAC5BiL,YACLhC,EAAU3M,EAAMsL,QAAQ,GAAGiE,QAAQpE,EAAa3H,GAC5CxD,EAAMsL,QAAQ,GAAGkJ,MAAMrJ,EAAa3H,GAAGgQ,IAAIrI,EAAazH,GAAK,IAC7DiJ,GAAWA,GAER,CAAEF,OAAME,YAsHnB,SAAgB8H,EACZV,EACAW,GAEA,MAAMC,EAAcb,EAAgBC,EAASA,EAAQvH,QAAQ4H,MACvDQ,EAAW,EAAA9J,eAAe+J,yBAA2B1N,KAAK2N,IAAI,EAAGJ,GACvE,OAASX,EAAQgB,YAAcH,EAAY,IAAOzN,KAAKkH,IAAIsG,GA6N/D,SAASK,EACLC,EACAC,EACAC,GAEA,GAAIF,cAA+DnV,IAAlBmV,EAAQG,MACrD,OAGJ,QAAqBtV,IAAjBmV,EAAQI,OAA2D,IAArCF,EAAepZ,IAAIkZ,EAAQI,MACzD,OAEJF,EAAerQ,IAAImQ,EAAQI,MAAM,GAGjC,MAAMD,EAAQH,EAAQG,MAEhBE,EAAa,EAAIF,EAAMG,MAAQH,EAAMpG,OAC3CkG,EAAWM,UAAYF,EACvBJ,EAAWO,SAAWH,EAG1B,SAASI,EACLnN,EACA2M,EACAC,GAEA,QAAsBrV,IAAlByI,EAAS8M,OAA4D,IAAtCF,EAAepZ,IAAIwM,EAAS8M,MAK/D,GAFAF,EAAerQ,IAAIyD,EAAS8M,MAAM,GAG9B9M,aAAoBrL,EAAMyY,mBAC1BpN,aAAoBrL,EAAM0Y,eAC5B,CACE,MAAMC,EAActN,EACpB,IAAK,MAAM9M,KAAQoa,EAAYC,SAC3B,QAAmChW,IAA/B+V,EAAYC,SAASra,GAAqB,CAC1C,MAAMsa,EAAUF,EAAYC,SAASra,GACjCsa,aAAmB7Y,EAAM8Y,SACzBhB,EAAoBe,EAASb,EAAYC,SAIlD,GACH5M,aAAoBrL,EAAM+Y,mBAC1B1N,aAAoB,EAAA2N,qBACtB,CACE,MAAMC,EAAe5N,EACrByM,EAAoBmB,EAAatS,IAAKqR,EAAYC,GAClDH,EAAoBmB,EAAaC,MAAOlB,EAAYC,GACpDH,EAAoBmB,EAAaE,YAAanB,EAAYC,GAC1DH,EAAoBmB,EAAaG,SAAUpB,EAAYC,GACvDH,EAAoBmB,EAAaI,OAAQrB,EAAYC,QAClD,GAAI5M,aAAoB,EAAAiO,wBAAyB,CACpD,MAAMC,EAAmBlO,EAEzByM,EAAoByB,EAAiB5S,IAAKqR,EAAYC,GACtDH,EAAoByB,EAAiBC,SAAUxB,EAAYC,GAC3DH,EAAoByB,EAAiBL,MAAOlB,EAAYC,GACxDH,EAAoByB,EAAiBE,YAAazB,EAAYC,GAC9DH,EAAoByB,EAAiBG,QAAS1B,EAAYC,GAC1DH,EAAoByB,EAAiBI,UAAW3B,EAAYC,GAC5DH,EAAoByB,EAAiBK,gBAAiB5B,EAAYC,GAClEH,EAAoByB,EAAiBM,aAAc7B,EAAYC,GAC/DH,EAAoByB,EAAiBO,aAAc9B,EAAYC,GAC/DH,EAAoByB,EAAiBH,SAAUpB,EAAYC,GAC3DH,EAAoByB,EAAiBF,OAAQrB,EAAYC,QAEzD5M,aAAoBrL,EAAM+Z,mBAC1B1O,aAAoBrL,EAAMga,oBAI1B5M,EAAOuJ,KAAK,4CAA6CtL,GAIjE,SAAS4O,EACLC,EACAC,EACAnC,EACAC,GAOA,QAJuBrV,IAAnBsX,EAAU/B,OACV+B,EAAU/B,KAAOnY,EAAMkJ,UAAUkR,iBAGM,IAAvCnC,EAAepZ,IAAIqb,EAAU/B,MAC7B,OAEJF,EAAerQ,IAAIsS,EAAU/B,MAAM,GAEnC,IAAIkC,EAAY,EACZC,EAAkB,OACoB1X,IAAtCsX,EAAUK,MAAMC,oBAChBF,EAAkBJ,EAAUK,MAAMC,mBAGlCN,aAAqBla,EAAMya,4BAC3BP,aAAqBla,EAAM0a,gBAE3BL,EAAYC,EAAkBJ,EAAUS,MAAQT,EAAUU,SAE1DxN,EAAOuJ,KAAK,6CAA8CwD,GAG9DnC,EAAWM,UAAY+B,EA5+CW,GA6+ClCrC,EAAWO,SAAW8B,EAG1B,SAASQ,EACLC,EACA9C,EACAC,GAKA,UAFsBrV,IAAlBkY,EAAS3C,OAA4D,IAAtCF,EAAepZ,IAAIic,EAAS3C,OAG3D,OAIJ,IAAI4C,EAcJ,GAhBA9C,EAAerQ,IAAIkT,EAAS3C,MAAM,GAI9B2C,aAAoB9a,EAAMgb,UAE1BhD,EAAWM,UAAuC,GAA3BwC,EAASG,SAAS/Y,OAGzC8V,EAAWM,UAAoC,GAAxBwC,EAASI,MAAMhZ,OAEtC6Y,EAAkBD,EAAiBK,iBAC5BL,aAAoB9a,EAAMob,iBACjCL,EAAiBD,QAGElY,IAAnBmY,EAEA,OAGJ,MAAMM,EAAaN,EAAeM,WAClC,QAAmBzY,IAAfyY,EAAJ,CAKA,IAAK,MAAM1b,KAAY0b,OACUzY,IAAzByY,EAAW1b,IACXsa,EAAsBoB,EAAW1b,GAAWA,EAAUqY,EAAYC,GAG7C,OAAzB8C,EAAeO,OACfrB,EAAsBc,EAAeO,MAAO,QAAStD,EAAYC,QAVjE7K,EAAOuJ,KAAK,gDAAiDmE,GAkGrE,SAASS,EAAmBC,GACxB,OAAOA,EAASC,UAAU,EAAG,GAnjDpB,EAAAC,aAAe,GACf,EAAAxM,aAAe,EAAAwM,aAAe1b,EAAMkJ,UAAUyS,QAyC3C,EAAAC,qBAAhB,SACI9M,EACA+M,EACAC,EACAtE,EACAuE,EAAuB,EAAA7M,cAEvB,MAAM,kBAAE8M,EAAiB,OAAE1M,GAAWR,EAGhCkB,EAAYgM,EACZA,EAAkBC,UACdnN,EAAQiB,WAAWgH,eAAezH,EAAOX,UAnHhC,QAsHb/L,EAGA4P,EAAciC,EAAwB3F,EAAS+M,EAAYC,EAAY9L,GAEvE+B,EADiBwF,EAAuCzI,EAAS0I,IAChCxH,UAAa,GAYpD,GATIlB,EAAQiB,WAAWS,OAAS,EAAAC,eAAeC,OAC3CpB,EAAOX,SAASuN,KAAKnK,GACdjD,EAAQiB,WAAWS,OAAS,EAAAC,eAAee,WAClDlC,EAAOX,SAASkD,UAAU,EAAAjE,eAAeC,kBAAoBkE,GAM7DjD,EAAQiB,WAAWS,OAAS,EAAAC,eAAee,UAAW,CAItD,MACM2K,EADOjG,EAAkB5G,EAAQR,EAAQiB,YACtBgM,EACrBI,EAAY,GACZtN,EAAgBC,EAAS,EAAGqN,EAAWJ,GAK/C,MAAMK,EAAiB3H,EAAwB3F,EAAS+M,EAAYC,EAAY9L,GAC3EwC,GAAgB4J,IAIjBtN,EAAQiB,WAAWS,OAAS,EAAAC,eAAeC,QAG3C8B,EAAYkB,IAAI0I,GAChBlH,EAAsBpG,EAAS0D,EAAYnM,EAAGmM,EAAYlM,IACnDwI,EAAQiB,WAAWS,OAAS,EAAAC,eAAee,WAClD6D,EAAqBvG,EAAS0D,EAAa4J,KAYnC,EAAAvN,gBAAe,EAwCf,EAAA4H,uBAAhB,SACInH,EACAS,EACAC,GAMA,MAAMO,EAAiBT,EAAyBR,EAAQS,EAAYC,GACpE,OAAuB,OAAnBO,EACOR,EAAWgH,eAAexG,GAE9B,MAWK,EAAAT,yBAAwB,EAsDxB,EAAAuM,qBAAhB,SACItM,EACAT,EACA0M,GAEA,MAAMvE,EAAcb,EAAgB,CAAE7G,cAAcT,GAAQ4H,MAOtDlH,EAAYgM,EACZA,EAAkBC,UACdlM,EAAWgH,eAAezH,EAAOX,UA9SxB,QAiTb/L,EAIAuM,EACFsI,EAAc,EAAAvI,aAERY,EAAyBR,EAAQS,EAAYC,GAC7C,KACV,GAAe,OAAXb,EAAiB,CAEjB,MAAO,CAAEA,SAAQS,SADAN,EAAOX,SAAS2N,WAAWnN,IAEzC,CAIH,MAAMoN,EAtDd,SACIlF,EACAtH,EACAiM,EACAQ,GAEA,QAA0B5Z,IAAtBoZ,EAAiC,CACjC,MAAMS,EAAc1M,EAAWgH,eAAeM,GACxCqF,EAAqBV,EAAkBC,UAAUQ,EAAaD,GACpE,QAA2B5Z,IAAvB8Z,EAAkC,CAClC,MAAM5K,EAAS/B,EAAW4M,kBAAkBtF,GAAYqF,EACxD,OAAOzS,KAAKS,IAAIoH,EAAQ,IAGhC,OAAO7H,KAAK2S,IAAI7M,EAAWuB,eAAe+F,IAwCnBwF,CACfvN,EAAOX,SACPoB,EACAiM,EApUW,GA0UTpM,EACFG,EAAWS,OAAS,EAAAC,eAAeC,OAC7B6L,EAAatS,KAAKkH,IAAIlH,KAAKO,IAAIiN,EAAa,EAAAvI,eAC5CjF,KAAK+H,KACD/H,KAAK2N,IAAI2E,EAAa,EAAA3O,eAAeC,kBAAmB,GACpD5D,KAAK2N,IAAI,EAAAhK,eAAeC,kBAAmB,IAEvDiP,EAAYxN,EAAOc,kBAAkBtN,EAAMsL,QAAQ,IACzD0O,EAAUtI,eAAe5E,GACzB,MAAMmN,EAAiBja,EAAMsL,QAAQ,GAErC,OADA2O,EAAe7M,KAAKZ,EAAOX,UAAU5N,IAAI+b,GAClC,CAAE3N,OAAQ4N,EAAgBnN,cAiBzB,EAAAkB,uCAAsC,EAkEtC,EAAAkM,sBAAhB,SACI9K,EACA+K,GAEA,IAAIC,EAAa,OACKta,IAAlBqa,IACAA,EAAgB,EAAAnU,eAAeqU,WAAWjL,EAAO,IACjDgL,EAAa,GAEjB,IAAIE,EAAQH,EAAclU,SACtBsU,EAAQJ,EAAclU,SACtBuU,EAAY,EAAApU,UAAU8B,sBAAsBiS,EAAcjU,WAC1DuU,EAAU,EACVC,EAAOP,EAAcjU,UACrByU,EAAOR,EAAcjU,UAEzB,MAAMjC,EAA2B,GACjCA,EAAOD,KAAK,IAAI,EAAAgC,eAAesU,EAAOE,IACtC,IAAK,IAAItf,EAAIkf,EAAYlf,EAAIkU,EAAOhQ,OAAQlE,IAAK,CAC7C,MAAM8B,EAAI,EAAAgJ,eAAeqU,WAAWjL,EAAOlU,IACvC8B,EAAEiJ,SAAWqU,EACbA,EAAQtd,EAAEiJ,SACHjJ,EAAEiJ,SAAWsU,IACpBA,EAAQvd,EAAEiJ,UAGd,IAAIC,EAAY,EAAAE,UAAU8B,sBAAsBlL,EAAEkJ,WAElD,MAAM0U,EAAc,EAAAxU,UAAUmB,iBAAiBiT,EAAWtU,GAC1DA,EAAYsU,EAAYI,EACpBA,EAAc,IAAMA,EAAcH,EAAU,GAC5CC,EAAOvT,KAAKS,IAAI8S,EAAMF,EAAYI,GAClCH,EAAUC,EAAOC,EACjBH,GAAaE,EAAOC,GAAQ,GACrBC,EAAc,GAAKA,EAAcH,EAAU,IAClDE,EAAOxT,KAAKO,IAAIiT,EAAMzU,GACtBuU,EAAUC,EAAOC,EACjBH,GAAaE,EAAOC,GAAQ,GAEhC1W,EAAOD,KAAK,IAAI,EAAAgC,eAAehJ,EAAEiJ,SAAUC,IAE/C,OAAOjC,GAYK,EAAAkL,sBAAqB,EAuBrB,EAAA0L,kBAAhB,SAAkCC,GAC9B,MAAMC,EAASD,EAAIC,OACnB,MAAO,CACH,IAAI,EAAA/U,eAAe8U,EAAIR,MAAOQ,EAAIH,MAClC,IAAI,EAAA3U,eAAe8U,EAAIR,MAAOQ,EAAIJ,MAClC,IAAI,EAAA1U,eAAe+U,EAAO9U,SAAU6U,EAAIH,MACxC,IAAI,EAAA3U,eAAe+U,EAAO9U,SAAU6U,EAAIJ,MACxC,IAAI,EAAA1U,eAAe8U,EAAIP,MAAOO,EAAIH,MAClC,IAAI,EAAA3U,eAAe8U,EAAIP,MAAOO,EAAIJ,MAClC,IAAI,EAAA1U,eAAe8U,EAAIR,MAAOS,EAAO7U,WACrC,IAAI,EAAAF,eAAe8U,EAAIP,MAAOQ,EAAO7U,aAkB7B,EAAAuJ,qBAAoB,EA+GpB,EAAAuL,yBAAhB,SACIC,EACAvL,EACAwL,EACAC,GAEA,MAAM,KAAE1O,EAAI,QAAEC,EAAO,WAAEO,GAAekO,EAChCC,EAAgBD,EAAOE,YACvBC,EAAYH,EAAO3O,OAAO7B,QAiBhC,OAfAmI,EAA0B7F,EAAYgO,GAAYvO,EAASD,EAAM6O,EAAUC,YAC3EvN,EACIiN,EACAG,GACC1O,EACDD,EACAQ,EACAqO,EAAUzP,UAEdyP,EAAUzI,mBAAkB,GAExB5F,EAAWS,OAAS,EAAAC,eAAee,WACnCS,EAAsB+L,EAAaI,EAAUzP,UAG1C,CACHQ,OAAQ4O,EACRnO,SAHa2C,EAAqByL,EAAaxL,EAAa4L,GAI5D5O,UACAD,SAOQ,EAAA+O,0CAAhB,SACIvN,EACAnB,EACAoB,EACAC,EACAnC,GAEA,OAAOA,EAAQiB,WAAWgH,eACtBjG,EACIC,EACAnB,EACAoB,EACAC,EACAnC,EAAQiB,WACRjN,EAAMsL,QAAQ,MAiBV,EAAAqG,wBAAuB,EAoDvB,EAAAS,sBAAqB,EAkBrB,EAAAG,qBAAoB,EAsBpB,EAAAkJ,OAAhB,SACIzP,EACA0P,EACAC,EAAwB,EACxBxP,EAAkBhF,KAAKyF,GAAK,GAY5B,GATAZ,EAAQQ,OAAOoP,kBACX5P,EAAQiB,WAAWS,OAAS,EAAAC,eAAee,UACrC1O,EAAMsL,QAAQ,GAAG8B,KAAKpB,EAAQQ,OAAOX,UAAU8C,YAC/C3O,EAAMsL,QAAQ,GAAGxG,IAAI,EAAG,EAAG,GACjC5H,EAAMkJ,UAAUW,UAAU2U,IAE9B1P,EAAQQ,OAAOqG,oBAGO,IAAlB8I,EACA,OAEJ,MAAMvH,EAAQtI,EAAagI,gBAAgB9H,EAASA,EAAQQ,QAAQ4H,MAEpE,IAAIyH,EAAW3e,EAAMkJ,UAAU6B,MAC3BmM,EAAQlX,EAAMkJ,UAAUW,SAAS4U,GACjC,EACAxP,GAIJ,GAAIH,EAAQiB,WAAWS,OAAS,EAAAC,eAAee,UAAW,CAEtD,MAAMoN,EAAW3U,KAAK4U,KACjB,EAAAjR,eAAeC,kBAAoB5D,KAAKsH,IAAItH,KAAKyF,GAAKT,GACnDH,EAAQQ,OAAOX,SAASzM,UAEhCyc,EAAW1U,KAAKO,IAAImU,EAAUC,GAElC9P,EAAQQ,OAAOwP,QAAQH,EAAWzH,IAgBtB,EAAAtB,0BAAyB,EAuCzB,EAAAmJ,YAAhB,SAA4BjQ,EAAkBkC,EAAgBC,GAC1D2E,EACI9G,EAAQiB,WACRjB,EAAQkQ,UACRhO,EACAC,EACAnC,EAAQQ,OAAO+O,aAaP,EAAAnI,kBAAiB,EA8CjB,EAAAU,gBAAe,EA+Df,EAAAvH,wCAAuC,EAuDvC,EAAAqH,6BAAhB,SACI3G,EACArQ,EACA2X,GAEAtH,EAAW+F,kBAAkBuB,EAAU,CACnC7I,MAAOP,EAAa5H,EACpBoI,MAAOR,EAAa3H,EACpBoI,MAAOT,EAAazH,EACpBmI,SAAU7L,EAAMsL,QAAQ,KAI5B,MAAM6Q,EAASnc,EAAMsL,QAAQ,GAAG8B,KAAKxQ,EAAOiP,UAAU+E,IAAI5Q,EAAMsL,QAAQ,IAClE8Q,EAASD,EAAO/c,SACtB,GAAIgd,EAxjCI,KA0jCJ,OADA9R,EAAO+R,MAAM,sDACN,EAEXF,EAAOG,aAAaF,GAEpB,MAAM7I,EAAW4I,EAAO3I,IAAIrI,EAAazH,GACzC,OAAI6P,EAAW,OAEJ,EAEJpM,KAAKsM,KAAKvW,EAAMkJ,UAAU6B,MAAMsL,GAAW,EAAG,KAOzC,EAAAgJ,uBAAhB,SACI/P,GAEA,MAAMgQ,EAAOhQ,EAAOgQ,KACdC,EAAMjQ,EAAOiQ,IACnB,IAAIC,EAAOF,EAAOrV,KAAKsJ,IAAIvT,EAAMkJ,UAAUW,SAAS,GAAMyF,EAAO6D,MAAS7D,EAAOmQ,KAC7E3N,EAAS,EAAI0N,EACbnH,EAAQ/I,EAAO+D,OAASvB,EACxB4N,GAAQ,GAAMrH,EAElB,MAAMsH,EAAOrQ,EAAOqQ,KACpB,GAAa,OAATA,GAAiBA,EAAKC,QAAS,CAC/B,MAAMC,EAAYF,EAAKE,UACjBC,EAAaH,EAAKG,WAExBJ,GAASC,EAAKxK,QAAUkD,EAASwH,EACjCL,GAAQG,EAAKvK,QAAUtD,EAAUgO,EACjCzH,GAASsH,EAAKtH,MAAQwH,EACtB/N,GAAU6N,EAAK7N,OAASgO,EAM5B,OAFAJ,GAA8B,IAAtBpQ,EAAOyQ,WAAoBT,EAAOhQ,EAAOyQ,WAAczQ,EAAO0Q,eAAiB,EAEhF,CACHN,OACAO,MAAOP,EAAOrH,EACdmH,MACAU,OAAQV,EAAM1N,EACdwN,OACAC,QAcQ,EAAAY,sBAAhB,SACIrR,EACA4F,EACAC,GAEA,MAAMyL,EAAmB3L,EACrB3F,EACA4F,EACAC,GAGJ,OAAKyL,EAIEtR,EAAQiB,WAAWgH,eAAeqJ,GAH9B,MAcC,EAAA7I,uCAAsC,EAetC,EAAA8I,+BAAhB,SACIxJ,EACAW,GAEA,MAAME,EAAW,EAAA9J,eAAe+J,yBAA2B1N,KAAK2N,IAAI,EAAGJ,GACvE,OAAQX,EAAQgB,YAAcH,EAAY,KAkB9B,EAAA4I,+BAAhB,SACIzJ,EACAjH,GAEA,MAAM8H,EAAY,IAAM9H,EAAYiH,EAAQgB,YAM5C,OAjpCR,SAAgCL,GAC5B,MACM+I,EAAUtW,KAAKuW,KAAKhJ,GAC1B,OAAO+I,EAAU/I,EAFL,KAEuB+I,EAAU/I,EA8oClCiJ,CALWzgB,EAAMkJ,UAAU6B,MAC9Bd,KAAKyW,KAAK,EAAA9S,eAAe+J,yBAA2BD,GACpDb,EAAQ8J,aACR9J,EAAQ+J,gBAaA,EAAAC,+BAAhB,SACIC,EACAxR,GAEA,MAAMyR,EAAWzR,EACX0R,EAAcD,EAASxB,IAAMwB,EAASzB,KACtC2B,EAAoBH,EAAeC,EAASxB,IAElD,OAAQ,EAAMwB,EAASzB,KAAO2B,IAAsBF,EAASxB,IAAMyB,IAUvD,EAAAE,sBAAhB,SAAsCtR,EAAkBN,GAEpD,OAAOM,EADUN,EACUiQ,KASf,EAAA4B,oCAAhB,SAAoDC,EAAc/N,GAC9D,OAAO,EAAIpJ,KAAKoX,KAAKpX,KAAKsJ,IAAI6N,EAAO,GAAK/N,IAS9B,EAAAiO,oCAAhB,SAAoDC,EAAclO,GAC9D,OAAO,EAAIpJ,KAAKoX,KAAKpX,KAAKsJ,IAAIgO,EAAO,GAAKlO,IAS9B,EAAAmO,kCAAhB,SAAkDD,EAAczP,GAC5D,OAAOA,EAAS,EAAI7H,KAAKsJ,IAAIgO,EAAO,IASxB,EAAAE,0BAAhB,SAA0C5J,EAAqB/F,GAC3D,OAAO9R,EAAMkJ,UAAUC,SAAS,EAAIc,KAAKoX,KAAKvP,EAAS,EAAI+F,KAW/C,EAAA6J,iCAAhB,SACI7J,EACAjI,EACA+R,GAEA,OAAQ9J,EAAc8J,EAAa/R,GAWvB,EAAAgS,gCAAhB,SACI/J,EACAjI,EACAiS,GAEA,OAAQjS,EAAWiS,EAAchK,GAarB,EAAAiK,qBAAhB,SAAgBA,EACZpiB,EACAqiB,EACA9J,GAEA,MAAM+J,OACapf,IAAfmf,EACMA,EACA,CACIzJ,SAAU,EACVC,QAAS,GASvB,QANuB3V,IAAnBqV,IACAA,EAAiB,IAAIlV,KAkN7B,SACIrD,EACAsY,EACAC,GAEA,IAAKvY,EAAOuiB,YAAcviB,aAAkBM,EAAMkiB,MAC9C,OAGJ,QAAoBtf,IAAhBlD,EAAOyY,OAA0D,IAApCF,EAAepZ,IAAIa,EAAOyY,MACvD,OAIJ,GAFAF,EAAerQ,IAAIlI,EAAOyY,MAAM,GAE3BzY,EAAeyiB,QAAWziB,EAAe0iB,QAAW1iB,EAAe2iB,SAAU,CAE9E,IAAI/J,EAljDyB,IAmjD7B,MAAMC,EAAU,EAGV+J,EAAO5iB,EAGb,QAAsBkD,IAAlB0f,EAAKjX,SACL,GAAIrJ,MAAMC,QAAQqgB,EAAKjX,UAAW,CAC9B,MAAMkX,EAAYD,EAAKjX,SACvB,IAAK,MAAMA,KAAYkX,EACnB/J,EAAqBnN,EAAU2M,EAAYC,OAE5C,CAEHO,EADiB8J,EAAKjX,SACS2M,EAAYC,GAKnD,QAAwBrV,IAApB0f,EAAKE,WACL,IAAK,MAAM1H,KAAYwH,EAAKE,WACxB3H,EAAqBC,EAAU9C,EAAYC,aAEtBrV,IAAlB0f,EAAKxH,UACZD,EAAqByH,EAAKxH,SAAU9C,EAAYC,GAKpD,MAAMwK,OACkB7f,IAApBlD,EAAOgjB,SACAhjB,EAAOgjB,SAASC,aACjB/f,OAEUA,IAAhB6f,IACAnK,GAAY,EAAAsK,mBAAmBH,IAGnCzK,EAAWM,UAAYA,EACvBN,EAAWO,SAAWA,OAEtBnL,EAAOuJ,KAAK,wCAAyCjX,GAzQzDmjB,CAAiBnjB,EAAQsiB,EAAM/J,GAE3BvY,EAAOojB,SAAS5gB,OAAS,EACzB,IAAK,MAAM6gB,KAASrjB,EAAOojB,SACvBhB,EAAqBiB,EAAOf,EAAM/J,GAG1C,OAAO+J,GAUK,EAAAgB,iBAAhB,SAAiClU,GAC7B,IAAImU,EAAkB,EAEtB,IAAK,MAAMC,KAAYpU,EAAQqU,eAAeC,mBAAoB,CAC9DH,GAAmBC,EAASD,gBAE5B,IAAK,MAAMI,KAAQH,EAASI,kBACA1gB,IAApBygB,EAAKE,YAA6BF,EAAKE,WAAWC,YAClDP,SAE4BrgB,IAA5BygB,EAAKI,oBAAqCJ,EAAKI,mBAAmBD,YAClEP,IAIZ,IAAIS,EAAYT,EAAkB,EAWlC,YATqCrgB,IAAjCkM,EAAQ6U,uBACRD,EAAYA,GAAa5U,EAAQ6U,qBAAqBC,SAG1DF,EACIA,IACC5U,EAAQ+U,gBAAgBC,kBACxBhV,EAAQqU,eAAeY,sBAErBL,GAuOK,EAAAM,oBAAhB,WACI,QAA4BphB,IAAxBqhB,UAAUC,WAA2BD,UAAUC,UAAUhiB,OAAS,EAAG,CACrE,MAAMiiB,EAAe,GACrB,IAAK,MAAMC,KAAQH,UAAUC,UACzBC,EAAard,KAAKyU,EAAmB6I,IAEzC,OAAOD,EAEX,QAA2BvhB,IAAvBqhB,UAAUzI,SACV,MAAO,CAACD,EAAmB0I,UAAUzI,YA3iDjD,CAAiB,EAAA5M,eAAA,EAAAA,aAAY,KAyjD7B,MAAMyV,EAAa,CACf,EACA,EACA,EACA,EACA,GACA,GACA,GACA,IACA,IACA,IACA,KACA,KACA,KACA,KACA,MACA,MACA,MACA,OACA,OACA,OACA,QACA,QACA,QACA,QACA,SACA,SACA,SACA,UACA,UACA,UACA,WACA,WACA,WACA,WACA,YACA,YACA,YACA,aACA,aACA,aACA,cACA,cACA,cACA,cACA,eACA,eACA,eACA,eACA,gBACA,gBACA,gBACA,gBACA,mBAGJ,SAAiBC,GAcb,SAAgBC,EACZC,EACAC,EACAC,EAAmB,GAEnB,MAAMC,EA8DV,SAA0BF,EAAgBG,EAAqB,GAC3D,IAAI7d,EAAS,EACb,MAAM8d,EAAsBR,EAAWO,GAKvCH,GAAUI,EAAsB,EAChC,KAAOJ,EAAS,GACZA,GAAUI,EAEd,KAAOJ,GAAUI,GACbJ,GAAUI,EAGd,IAAK,IAAI7mB,EAAI,EAAGA,EAAI4mB,GAAcH,EAAS,EAAGzmB,IAI7B,EAATymB,IACA1d,GAAUsd,EAAW,GAAKO,EAAa5mB,IAE3CymB,KAAY,EAIhB,OADA,EAAAvX,OAAkB,IAAXuX,GACA1d,EAxFe+d,CAAiBL,EAAQC,GAC/C,OAAOF,EAAQO,aAAeJ,EAclC,SAAgBK,EAAiCzlB,EAAamlB,EAAmB,GAC7E,IAAID,EAAS,EACTM,EAAaxlB,EACbvB,EAAI,EAER,KAAOA,EAAI0mB,EAAU1mB,IAAK,CAGtB,MAAMinB,EAAMZ,EAAW,GAAKrmB,GACxB+mB,GAAcE,IACdF,GAAcE,EACdR,GAAUJ,EAAWK,EAAW,EAAI1mB,IAK5C,OADAymB,GAAUJ,EAAWK,EAAW,GACzB,CAAED,SAAQM,cApCL,EAAAR,0BAAyB,EAoBzB,EAAAS,iCAAgC,EA0BhC,EAAAE,oBAAhB,SAAoCC,EAAuBT,EAAmB,GAC1E,MAAM,OAAED,EAAM,WAAEM,GAAeC,EAAiCG,EAAeT,GAE/E,OAAOH,EADe,EAAAa,QAAQC,eAAe,EAAAD,QAAQE,iBAAiBP,IACtBN,EAAQC,IA/DhE,CAAiB,EAAAJ,kBAAA,EAAAA,gBAAe,M,qLC5sDhC,kBAAa1W,GAeb,OAbW,EAAA+J,yBAAmC,kBAGnC,EAAA9J,kBAA4B,QAG5B,EAAA0X,eAAyB,IAGzB,EAAAC,cAAwB,KAGxB,EAAAC,oBAA8B,IACzC,GAfA,GAAa,EAAA7X,kB,kGCsBb,sBAA2BlO,GACvB,MAAMgmB,EAAOhmB,EACb,YAAoBkD,IAAb8iB,EAAKlb,UAAkC5H,IAAb8iB,EAAKhb,M,0GCN1C,8BAAmChL,GAC/B,MAAMimB,EAAMjmB,EACZ,YACqBkD,IAAjB+iB,EAAIhX,eACU/L,IAAd+iB,EAAInX,YACU5L,IAAd+iB,EAAIlX,YACU7L,IAAd+iB,EAAIjX,YACY9L,IAAhB+iB,EAAIC,U,mHCvBZ,cAEA,QAQA,SAAYnV,GAIR,uBAKA,6BATJ,CAAY,EAAAA,iBAAA,EAAAA,eAAc,KAgB1B,mBAWI,YAAqBoV,GAAA,KAAAA,YA0CrB,kBACIzT,EACArL,GAUA,OARI,EAAA2C,qBAAqB0I,GACrBxR,KAAKyQ,aAAae,EAAOrL,EAAO4H,UAEhC,EAAAzF,UAAU0B,YAAYwH,EAAOrL,EAAO4H,UAExC,EAAAzF,UAAUyB,WAAW,EAAG,EAAG,EAAG5D,EAAOyH,OACrC,EAAAtF,UAAUyB,WAAW,EAAG,EAAG,EAAG5D,EAAO0H,OACrC,EAAAvF,UAAUyB,WAAW,EAAG,EAAG,EAAG5D,EAAO2H,OAC9B3H,EA2IX,eACI+e,EACAC,EACAhf,GAEA,OAAI+e,IAAqBllB,UACNgC,IAAXmE,EACO,CAAEV,EAAG0f,EAAS1f,EAAGC,EAAGyf,EAASzf,EAAGE,EAAGuf,EAASvf,IAEvDO,EAAOV,EAAI0f,EAAS1f,EACpBU,EAAOT,EAAIyf,EAASzf,EACpBS,EAAOP,EAAIuf,EAASvf,EACbO,GAEJnG,KAAKyQ,aAAayU,EAAiB/O,eAAegP,GAAWhf,M,iYC9O5E,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,YACA,WACA,YACA,YACA,YACA,WACA,YACA,WACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,WACA,YACA,YACA,WACA,WACA,YACA,YACA,YACA,WACA,WACA,WACA,YACA,YACA,YACA,WACA,YACA,YACA,WACA,YACA,WACA,WACA,Y,oIC9CA,aAQA,OAEA,OAIA,QAsKA,2BAAgCif,GAC5B,YAAkCpjB,IAA3BojB,EAAQC,gBAanB,SAAYC,GACR,6BACA,uBACA,iCAHJ,CAAY,EAAAA,eAAA,EAAAA,aAAY,KASxB,kBAAaC,EAsKT,YACaC,EACAlU,EACAmU,EACAC,EACFC,EAAW,EACXC,EAAkB,EAClBC,EAAkB,EAClBC,EACAC,EACAC,EACAC,EACEC,EACAC,GAZA,KAAAX,OACA,KAAAlU,SACA,KAAAmU,eACA,KAAAC,eACF,KAAAC,WACA,KAAAC,UACA,KAAAC,UACA,KAAAC,YACA,KAAAC,QACA,KAAAC,WACA,KAAAC,UACE,KAAAC,aACA,KAAAC,kBA1Kb,KAAAC,SAAmB,EAyCnB,KAAAC,cAAwB,GAoBxB,KAAAC,YAAuB,EAiBvB,KAAAC,UAAoB,EA8FZd,aAAwB,EAAAe,kBACxBxmB,KAAKymB,YAAchB,GAEnBC,aAAwB,EAAAgB,kBACxB1mB,KAAK2mB,YAAcjB,GAGvB1lB,KAAK4P,KACD0B,aAAkBlS,EAAMuG,QAAU,EAAAihB,gBAAgBC,SAAW,EAAAD,gBAAgBE,UAOrF,eACI,GAAI9mB,KAAKsR,kBAAkBlQ,MAAO,CAE9B,OADUpB,KAAKsR,OAAO,GAG1B,OAAOtR,KAAKsR,OAMhB,WACI,GAAItR,KAAKsR,kBAAkBlQ,MACvB,OAAOpB,KAAKsR,OAUpB,qBACI,OAA2B,IAApBtR,KAAK+mB,WAGhB,mBAAmBA,GACf/mB,KAAK+mB,WAAaA,EAStB,wBACI,OAA6B,IAAtB/mB,KAAKgnB,aAGhB,sBAAsBA,GAClBhnB,KAAKgnB,aAAeA,EAMxB,cACI,OAAOhnB,KAAKinB,UAGhB,YAAY7B,GAER,GADAplB,KAAKinB,UAAY7B,OACDpjB,IAAZojB,EAAuB,MACLpjB,IAAdhC,KAAKknB,OACLlnB,KAAK4P,KAAO,EAAAgX,gBAAgBO,YAEhC,MAAMC,OAAsCplB,IAArBhC,KAAKsmB,YAA4BtmB,KAAKsmB,YAAc,EAC3ElB,EAAQkB,YAAcc,GAO9B,kBACI,OAAOpnB,KAAKqnB,cAOhB,gBAAgBtB,GACZ/lB,KAAKqnB,cAAgBtB,EAMzB,kBACI,OAAO/lB,KAAKsnB,cAOhB,gBAAgBvB,GACZ/lB,KAAKsnB,cAAgBvB,EAGzB,eACI,YAA0B/jB,IAAnBhC,KAAK8lB,WAA8C,IAAnB9lB,KAAK8lB,UAQhD,yCACyB9jB,IAAjBhC,KAAKolB,eACqBpjB,IAAtBhC,KAAK+f,eACL/f,KAAK+f,aAAe,EAAAzX,UAAUif,KAC1BvnB,KAAKolB,QAAQoC,iBACbxnB,KAAKolB,QAAQqC,wBAGKzlB,IAAtBhC,KAAKggB,eACLhgB,KAAKggB,aAAe,EAAA1X,UAAUof,KAC1B1nB,KAAKolB,QAAQuC,iBACb3nB,KAAKolB,QAAQwC,qBAKjC,OAtToB,EAAAC,iBAAmBC,OAAOC,iBAsT9C,GA1TA,GAAa,EAAAxC,e,mZCnNb,aAKA,IAAYyC,EAmBAC,EAUAC,EASAC,EASAC,EAqCAC,EAgDKC,EApCjB,SAAgBC,EAAoBC,GAChC,OAAQA,EAQZ,SAAgBC,EAAoBC,GAChC,OAAQA,GA1GZ,SAAYV,GACR,eACA,qBACA,qBACA,yBAJJ,CAAYA,EAAA,EAAAA,WAAA,EAAAA,SAAQ,KAmBpB,SAAYC,GACR,yBACA,mBACA,uBACA,+BAJJ,CAAYA,EAAA,EAAAA,YAAA,EAAAA,UAAS,KAUrB,SAAYC,GACR,yBACA,yBACA,6BAHJ,CAAYA,EAAA,EAAAA,cAAA,EAAAA,YAAW,KASvB,SAAYC,GACR,qBACA,yBACA,sBAHJ,CAAYA,EAAA,EAAAA,oBAAA,EAAAA,kBAAiB,KAS7B,SAAYC,GACR,mBACA,yBACA,sBAHJ,CAAYA,EAAA,EAAAA,sBAAA,EAAAA,oBAAmB,KAS/B,SAAYO,GACR,iBACA,yBACA,wBAHJ,CAAY,EAAAA,oBAAA,EAAAA,kBAAiB,KAY7B,SAAYC,GACR,oBACA,yBACA,qBAHJ,CAAY,EAAAA,sBAAA,EAAAA,oBAAmB,KAgB/B,SAAYP,GACR,mBACA,6BACA,mBAHJ,CAAYA,EAAA,EAAAA,eAAA,EAAAA,aAAY,KAYxB,wBASA,wBAUA,mCAAwCQ,GACpC,OAAQA,GAQZ,mCAAwCC,GACpC,OAAQA,GAOZ,SAAiBR,GACA,EAAAS,kBAA4B,GAC5B,EAAAC,kBAA8B,CACvCC,KAAMnrB,OAAOorB,OAAOlB,EAASmB,OAC7B/H,KAAMtjB,OAAOorB,OAAO,IACpBE,eAAgBtrB,OAAOorB,OAAO,IAErB,EAAAG,mBAAgCpB,EAAUqB,QAC1C,EAAAC,qBAAoCrB,EAAYoB,QAChD,EAAAE,iBAA2B,EAC3B,EAAAC,cAA6B,IAAIrqB,EAAMsqB,MAAM,GAC7C,EAAAC,gBAA0B,EAC1B,EAAAC,yBAAwC,IAAIxqB,EAAMsqB,MAAM,GACxD,EAAAG,2BAAqC,EAErC,EAAAC,iBAA2B,EAC3B,EAAAC,gBAA0B,EAC1B,EAAAC,kBAA4BngB,IAC5B,EAAAogB,mBAA6BpgB,IAC7B,EAAAqgB,wBAAkC,EAClC,EAAAC,sBAAgC,EAChC,EAAAC,sBAAsC/B,EAAagC,KACnD,EAAAC,2BAAgDnC,EAAkBoC,MAClE,EAAAC,6BAAoDpC,EAAoBqC,KACxE,EAAAC,mBAAsC,GAxBvD,CAAiBpC,EAAA,EAAAA,mBAAA,EAAAA,iBAAgB,KA6CjC,MAAa9B,EAUT,YAAYnJ,EAA+B,IACvCrd,KAAK2qB,SAAW,CACZC,cACwB5oB,IAApBqb,EAAOuN,SACDvN,EAAOuN,SACPtC,EAAiBS,kBAC3B8B,cACwB7oB,IAApBqb,EAAOwN,SACD,OAAD,UAAMxN,EAAOwN,UACZ,CACI5B,KAAMX,EAAiBU,kBAAkBC,KACzC7H,KAAMkH,EAAiBU,kBAAkB5H,KACzCgI,eAAgBd,EAAiBU,kBAAkBI,gBAEjE0B,eACyB9oB,IAArBqb,EAAOyN,UACDzN,EAAOyN,UACPxC,EAAiBe,mBAC3B0B,iBAC2B/oB,IAAvBqb,EAAO0N,YACD1N,EAAO0N,YACPzC,EAAiBiB,qBAC3ByB,cACwBhpB,IAApBqb,EAAO2N,SAAyB3N,EAAO2N,SAAW1C,EAAiBkB,iBACvEyB,WACqBjpB,IAAjBqb,EAAO4N,MACD5N,EAAO4N,MAAMpe,QACbyb,EAAiBmB,cAAc5c,QACzCqe,aACuBlpB,IAAnBqb,EAAO6N,QAAwB7N,EAAO6N,QAAU5C,EAAiBqB,gBACrEwB,qBAC+BnpB,IAA3Bqb,EAAO8N,gBACD9N,EAAO8N,gBAAgBte,QACvByb,EAAiBsB,yBAAyB/c,QACpDue,uBACiCppB,IAA7Bqb,EAAO+N,kBACD/N,EAAO+N,kBACP9C,EAAiBuB,4BAOnC,aACI,OAAO7pB,KAAK2qB,SAEhB,WAAWtsB,GACP2B,KAAK2qB,SAAW,OAAH,wBAAQ3qB,KAAK2qB,UAAatsB,GAM3C,eACI,OAAO2B,KAAK2qB,SAASC,SAEzB,aAAavsB,GACT2B,KAAK2qB,SAASC,SAAWvsB,EAM7B,eACI,OAAO2B,KAAK2qB,SAASE,SAEzB,aAAaxsB,GACT2B,KAAK2qB,SAASE,SAAW,OAAH,UAAQxsB,GAMlC,gBACI,OAAO2B,KAAK2qB,SAASG,UAEzB,cAAczsB,GACV2B,KAAK2qB,SAASG,UAAYzsB,EAM9B,kBACI,OAAO2B,KAAK2qB,SAASI,YAEzB,gBAAgB1sB,GACZ2B,KAAK2qB,SAASI,YAAc1sB,EAMhC,eACI,OAAO2B,KAAK2qB,SAASK,SAEzB,aAAa3sB,GACT2B,KAAK2qB,SAASK,SAAW3sB,EAM7B,YACI,OAAO2B,KAAK2qB,SAASM,MAEzB,UAAU5sB,GACN2B,KAAK2qB,SAASM,MAAO3b,KAAKjR,GAM9B,sBACI,OAAO2B,KAAK2qB,SAASQ,gBAEzB,oBAAoB9sB,GAChB2B,KAAK2qB,SAASQ,gBAAiB7b,KAAKjR,GAMxC,cACI,OAAO2B,KAAK2qB,SAASO,QAEzB,YAAY7sB,GACR2B,KAAK2qB,SAASO,QAAU7sB,EAM5B,wBACI,OAAO2B,KAAK2qB,SAASS,kBAEzB,sBAAsB/sB,GAClB2B,KAAK2qB,SAASS,kBAAoB/sB,EAUtC,MAAMgf,EAA+B,IACjC,OAAO,IAAImJ,EAAgB,OAAD,wBAAMxmB,KAAK2qB,UAAatN,IAUtD,KAAKgO,GAWD,OATArrB,KAAK2qB,SAASC,SAAWS,EAAOT,SAChC5qB,KAAK2qB,SAASE,SAAW,OAAH,UAAQQ,EAAOR,UACrC7qB,KAAK2qB,SAASG,UAAYO,EAAOP,UACjC9qB,KAAK2qB,SAASI,YAAcM,EAAON,YACnC/qB,KAAK2qB,SAASK,SAAWK,EAAOL,SAChChrB,KAAK2qB,SAASM,MAAO3b,KAAK+b,EAAOJ,OACjCjrB,KAAK2qB,SAASQ,gBAAiB7b,KAAK+b,EAAOF,iBAC3CnrB,KAAK2qB,SAASO,QAAUG,EAAOH,QAC/BlrB,KAAK2qB,SAASS,kBAAoBC,EAAOD,kBAClCprB,MApLf,oBA2MA,MAAa0mB,EAUT,YAAYrJ,EAA+B,IAEvC,MAAM,oBAAEiO,EAAmB,kBAAEC,EAAiB,WAAEC,GAAeC,EAC3DpO,EAAOiO,oBACPjO,EAAOkO,kBACPlO,EAAOmO,YAEXxrB,KAAK2qB,SAAW,CACZe,cACwB1pB,IAApBqb,EAAOqO,SAAyBrO,EAAOqO,SAAWpD,EAAiBwB,iBACvE6B,aACuB3pB,IAAnBqb,EAAOsO,QAAwBtO,EAAOsO,QAAUrD,EAAiByB,gBACrE6B,cACwB5pB,IAApBqb,EAAOuO,SACDvO,EAAOuO,SACPtD,EAAiB0B,kBAC3B6B,eACyB7pB,IAArBqb,EAAOwO,UACDxO,EAAOwO,UACPvD,EAAiB2B,mBAC3B6B,oBAC8B9pB,IAA1Bqb,EAAOyO,eACDzO,EAAOyO,eACPxD,EAAiB4B,wBAC3B6B,kBAC4B/pB,IAAxBqb,EAAO0O,aACD1O,EAAO0O,aACPzD,EAAiB6B,sBAC3B6B,kBAC4BhqB,IAAxBqb,EAAO2O,aACD3O,EAAO2O,aACP1D,EAAiB8B,sBAC3BmB,oBACAD,sBACAE,cAOR,aACI,OAAOxrB,KAAK2qB,SAEhB,WAAWtsB,GACP2B,KAAK2qB,SAAW,OAAH,wBAAQ3qB,KAAK2qB,UAAatsB,GAM3C,eACI,OAAO2B,KAAK2qB,SAASe,SAEzB,aAAartB,GACT2B,KAAK2qB,SAASe,SAAWrtB,EAM7B,cACI,OAAO2B,KAAK2qB,SAASgB,QAEzB,YAAYttB,GACR2B,KAAK2qB,SAASgB,QAAUttB,EAM5B,eACI,OAAO2B,KAAK2qB,SAASiB,SAEzB,aAAavtB,GACT2B,KAAK2qB,SAASiB,SAAWvtB,EAM7B,gBACI,OAAO2B,KAAK2qB,SAASkB,UAEzB,cAAcxtB,GACV2B,KAAK2qB,SAASkB,UAAYxtB,EAM9B,qBACI,OAAO2B,KAAK2qB,SAASmB,eAEzB,mBAAmBztB,GACf2B,KAAK2qB,SAASmB,eAAiBztB,EAMnC,mBACI,OAAO2B,KAAK2qB,SAASoB,aAEzB,iBAAiB1tB,GACb2B,KAAK2qB,SAASoB,aAAe1tB,EAMjC,mBACI,OAAO2B,KAAK2qB,SAASqB,aAEzB,iBAAiB3tB,GACb2B,KAAK2qB,SAASqB,aAAe3tB,EAMjC,wBACI,OAAO2B,KAAK2qB,SAASY,kBAEzB,sBAAsBltB,GAClB2B,KAAK2qB,SAASY,kBAAoBltB,EAMtC,0BACI,OAAO2B,KAAK2qB,SAASW,oBAEzB,wBAAwBjtB,GACpB2B,KAAK2qB,SAASW,oBAAsBjtB,EAQxC,iBACI,OAAO2B,KAAK2qB,SAASa,WAEzB,eAAentB,GACX,MAAM,oBAAEitB,EAAmB,kBAAEC,EAAiB,WAAEC,GAAeC,EAC3DzrB,KAAKsrB,oBACLtrB,KAAKurB,kBACLltB,GAEJ2B,KAAK2qB,SAASW,oBAAsBA,EACpCtrB,KAAK2qB,SAASY,kBAAoBA,EAClCvrB,KAAK2qB,SAASa,WAAaA,EAU/B,MAAMnO,EAA+B,IACjC,OAAO,IAAIqJ,EAAgB,OAAD,wBAAM1mB,KAAK2qB,UAAatN,IAUtD,KAAK/T,GAED,OADAtJ,KAAKqd,OAAS,OAAH,UAAQ/T,EAAM+T,QAClBrd,MAef,SAAgByrB,EACZQ,EACAC,EACAC,G,MAOA,MAAMX,EACgC,QADtB,EACZW,aAAa,EAAbA,EAAepmB,IAAI5E,GAAM,OAAD,UAAMA,WAAI,QAClCmnB,EAAiBoC,mBAAmB3kB,IAAI5E,GAAM,OAAD,UAAMA,IAcvD,MAAO,CAAEmqB,oBATLE,EAAWlqB,OAAS,EACMkqB,EAAW,GAAGY,EAClCH,UAAc3D,EAAiBkC,6BAOXe,kBAJ1BC,EAAWlqB,OAAS,EACMkqB,EAAW,GAAGrqB,EAClC+qB,UAAc5D,EAAiBgC,2BAEQkB,cApOrD,oBA0MA,kC,gWC3kBA,aAqBA,OASA,OACA,OACA,SACA,SACA,QACA,QACA,SAGMhf,EAAS,EAAAC,cAAcxM,SAASvB,OAAO,sBA6V7C,SAAgB2tB,EACZC,EACAC,GAEA,QAAuBvqB,IAAnBsqB,EAAU3uB,KAId,OAAQ2uB,EAAU3uB,MACd,IAAK,gBACD,IAAK,EAAA6uB,wBAAwBF,GACzB,MAAM,IAAI7oB,MAAM,mCAEpB,MAA6B,aAAtB6oB,EAAUG,QACX,EAAA/T,wBACA,EAAAN,qBAEV,IAAK,WACL,IAAK,UACL,IAAK,mBACD,OAAO,EAAAM,wBAEX,IAAK,cACL,IAAK,aACD,OAAO,EAAAgU,kBAEX,IAAK,OACD,OAAOH,EAAiB,EAAA7T,wBAA0B,EAAAN,qBAEtD,IAAK,UACD,OAAOhZ,EAAMutB,eAEjB,IAAK,UACD,OAAO,EAAAC,qBAEX,IAAK,OACL,IAAK,WACD,OAAOxtB,EAAM+Z,kBAEjB,IAAK,SACD,OAAO/Z,EAAM0Y,eAEjB,IAAK,OACL,IAAK,eACL,IAAK,cACL,IAAK,uBACD,QAiHZ,SAAgB+U,EACZxuB,EACAyuB,GAEA,OAAIzuB,QACOA,GAEU,iBAAVA,IACHA,EAAM0uB,SAAS,OACfD,EAAa,QACbzuB,EAAQypB,OAAOkF,WAAW3uB,IACnBA,EAAM0uB,SAAS,OACtB1uB,EAAQypB,OAAOkF,WAAW3uB,KAGf,UAAfyuB,EACQ5sB,I,MAGJ,OAFqE,QAA/C,EAAAA,EAAQkC,IAAI6qB,OAAO,yBAA4B,QAAI,GACvD,EAAAC,iBAAiB7uB,EAAO6B,EAAQkC,MAI/C/D,GA0Hf,SAAgB8uB,EACZC,EACAC,EACAjrB,GAEA,IAAI/D,EAAQivB,EAAsBD,EAAgBjrB,QACpCJ,IAAV3D,IAGA,EAAAkvB,WAAWC,cAAcnvB,KACzBmO,EAAOuJ,KAAK,qEAGZ1X,EAAQ,EAAAkvB,WAAWE,mBAAmBpvB,IAG1C+uB,EAAcM,OAAOrvB,IAqBzB,SAAgBsvB,EACZljB,EACA2iB,EACAd,EACAe,EACAjrB,GAEA,MAAMwrB,EAAaN,EAAsBD,EAAgBjrB,GACzD,QAAmBJ,IAAf4rB,EACA,OAGJ,MAAM,EAAE1vB,EAAC,EAAE2vB,EAAC,EAAEnkB,EAAC,EAAEF,GAAM,EAAA+jB,WAAWO,eAAeF,GAG3CG,EAAOzB,EACb,IAAIpB,EAAU1hB,OACOxH,IAAjB+rB,EAAK7C,UACLA,GAAW8C,EAAiBD,EAAK7C,QAAS9oB,IAG9C8oB,EAAU9rB,EAAMkJ,UAAU6B,MAAM+gB,EAAS,EAAG,GAC5CzgB,EAASygB,QAAUA,EACnBkC,EAAca,OAAO/vB,EAAG2vB,EAAGnkB,GAEZwhB,GAAW,EAItB,EAAAgD,gBAAgBzjB,GAFhB,EAAAD,eAAeC,GAiBvB,SAASujB,EAAiB3vB,EAAY+D,GAIlC,YAHYJ,IAARI,GAAqB,EAAAZ,KAAKuG,OAAO1J,KACjCA,EAAQ,EAAA6uB,iBAAiB7uB,EAAO+D,IAE7B/D,EAcX,SAAgBivB,EAAsBjvB,EAAc+D,GAGhD,GAAI/D,OAFJA,EAAQ2vB,EAAiB3vB,EAAO+D,IAEhC,CAIA,GAAqB,iBAAV/D,EACP,OAAOA,EAGX,GAAqB,iBAAVA,EAAoB,CAC3B,MAAM8vB,EAAS,EAAAC,wBAAwB/vB,GACvC,QAAe2D,IAAXmsB,EACA,OAAOA,EAIf3hB,EAAO+R,MAAM,8BAA8BlgB,OA4B/C,SAASgwB,EAAqB/B,GAC1B,MAAMgC,EAAiB,EAAAC,qBAAqBjC,EAAU3uB,MACtD,YAA0BqE,IAAnBssB,EAA+BA,EAAeE,2BAAwBxsB,EAjvBjF,0BACIiU,EACAwY,GAEA,MAAMnC,EAAYrW,EAAQqW,UACpBoC,EAAcrC,EAAuBC,GAAsC,IAA3BrW,EAAQsW,gBAExDoC,EAAmC,GAEzC,QAAoB3sB,IAAhB0sB,EACA,OAIAA,EAAY1vB,qBAAqBI,EAAMyY,mBACvC6W,IAAgB,EAAAE,4BAEhBD,EAASE,IAAM5Y,EAAQ4Y,MAEI,IAA3B5Y,EAAQsW,gBAA8C,SAAnBD,EAAU3uB,OAC7CgxB,EAASG,oBAAqB,GAGlC,MAAMrkB,EAAW,IAAIikB,EAAYC,GAkHjC,YAhHqB3sB,IAAjBsqB,EAAUyC,KACVtkB,EAAS9M,KAAO2uB,EAAUyC,IAG1B,EAAAC,2BAA2B1C,KAC3B7hB,EAASwkB,aAAc,GAG3BxkB,EAASykB,UAAY,EAAAF,2BAA2B1C,KAAsC,IAAxBA,EAAU4C,WAGpE,EAAAC,oBAAoB7C,IACpB,EAAA8C,mBAAmB9C,IACnB,EAAA0C,2BAA2B1C,KAE3B,EAAA+C,sBAAsBhvB,QAASivB,IAC3B,MAAMC,EAAmBjD,EAAkBgD,GAC3C,QAAwBttB,IAApButB,EACA,OAGJ,MAAMC,EAAUrY,IACZ,MAAMzX,EAAc4sB,EAChBgD,EAAsB,mBAEPttB,IAAftC,SACyBsC,IAArBtC,EAAW+vB,QACXtY,EAAQsY,MAAQ,EAAAC,eAAehwB,EAAW+vB,aAErBztB,IAArBtC,EAAWiwB,QACXxY,EAAQwY,MAAQ,EAAAD,eAAehwB,EAAWiwB,aAEjB3tB,IAAzBtC,EAAWkwB,YACXzY,EAAQyY,UAAY,EAAAC,gBAAgBnwB,EAAWkwB,iBAEtB5tB,IAAzBtC,EAAWowB,YACX3Y,EAAQ2Y,UAAY,EAAAD,gBAAgBnwB,EAAWowB,iBAE1B9tB,IAArBtC,EAAWqwB,QACX5Y,EAAQ4Y,MAAQrwB,EAAWqwB,YAEJ/tB,IAAvBtC,EAAWswB,UACX7Y,EAAQ8Y,OAAOxqB,EAAI/F,EAAWswB,cAEPhuB,IAAvBtC,EAAWwwB,UACX/Y,EAAQ8Y,OAAOvqB,EAAIhG,EAAWwwB,UAGrCzlB,EAAiB6kB,GAAuBnY,EACzCA,EAAQ5K,aAAc,EACtB9B,EAAS8B,aAAc,EAEnBkiB,GACAA,EAAqBtX,IAIvBgZ,EAAW5R,IACb/R,EAAO+R,MAAM,4CAA6CA,IAG9D,IAAI6R,EACJ,GAA+B,iBAApBb,EACPa,EAAab,OACV,GAAI,EAAAc,gBAAgBd,GACvB,GAA6B,cAAzBA,EAAgB3f,KAAsB,CACtC,MAAMlQ,EAAa6vB,EAAgBe,sBACnC,QAAmBtuB,IAAftC,EAA0B,CAC1B,MAAM6wB,EAAqD7wB,EAAWkQ,KAChE,EAAA4gB,kBAAkB9wB,EAAWkQ,WAC7B5N,EACAyuB,EAopB9B,SACIC,EACAH,GAEA,QAAwBvuB,IAApBuuB,EACA,OAAO,IAAII,WAAWD,GAG1B,OAAQH,GACJ,KAAKnxB,EAAMwxB,iBACP,OAAO,IAAID,WAAWD,GAC1B,KAAKtxB,EAAMyxB,SACP,OAAO,IAAIC,UAAUJ,GACzB,KAAKtxB,EAAM2xB,UACP,OAAO,IAAIC,WAAWN,GAC1B,KAAKtxB,EAAM6xB,kBACP,OAAO,IAAIC,YAAYR,GAC3B,KAAKtxB,EAAM+xB,QACP,OAAO,IAAIC,WAAWV,GAC1B,KAAKtxB,EAAMiyB,gBACP,OAAO,IAAIC,YAAYZ,GAC3B,KAAKtxB,EAAMmyB,UACP,OAAO,IAAIC,aAAad,GAC5B,KAAKtxB,EAAMqyB,cACP,OAAO,IAAIP,YAAYR,GAG/B,MAAM,IAAIjtB,MAAM,iCA/qB0BiuB,CAClBnC,EAAgBmB,OAChBH,GAUJf,EAPgB,IAAIpwB,EAAMuyB,YACtBlB,EACA/wB,EAAW+X,MACX/X,EAAWwR,OACXxR,EAAWkyB,OAAS,EAAAC,cAAcnyB,EAAWkyB,aAAU5vB,EACvDuuB,SAIJJ,EAAQ,4CAET,CACH,MAAM2B,EAAc,IAAIC,KAAK,CAACxC,EAAgBmB,QAAS,CACnD9gB,KAAM2f,EAAgB3f,OAE1BwgB,EAAa4B,IAAIC,gBAAgBH,GAIrC1B,IACA,IAAIhxB,EAAM8yB,eAAgBC,KACtB/B,EACAZ,OACAxtB,EACAmuB,KAMZ,EAAAiC,kBAAkB9F,GAgY1B,SAAwCA,EAA4B7hB,GAC5D6hB,EAAU5hB,YACV,EAAAF,eAAeC,GAEf,EAAAyjB,gBAAgBzjB,GAIpB,MAAM4S,EAASiP,EAAUjP,OAEnBgV,EAAoBhE,EAAqB/B,GACzCgG,EAAeD,GAAqBA,KAAqB/F,EAAUjP,OAwBzE,GAvBcvf,OAAOy0B,oBAAoBlV,GAAQmV,OAAOC,IAEpD,GACIJ,IAAsBI,GACrBH,GAAgB,EAAAI,2BAA2BC,QAAQF,MAAmB,EACzE,CACE,OAAO,MAEX,MAAMG,EAAOH,EACb,GAAIG,IAAS,OAAQ,CAEjB,OAAO,MAEX,OAAO,OAILvyB,QAAQoyB,KA0BlB,SACIhoB,EACAgoB,EACAI,EACAzwB,GAEA,MAAM5E,EAAIiN,EACV,GAAIjN,EAAEi1B,aAAyBrzB,EAAMsqB,MACjCyD,EACI1iB,EAASgoB,GACTI,EACAzwB,OAED,CACH,MAAM/D,EAAQ2vB,EAAiB6E,EAAoBzwB,GACrC,OAAV/D,IACAb,EAAEi1B,GAAgBp0B,IAvCtBy0B,CAAiCroB,EAAUgoB,EAAcpV,EAAOoV,MAGhEH,EAAc,CACd,MAAMS,EAAYV,EAElB1E,EAAyBljB,EAAUA,EAASsoB,GAAYzG,EAAWjP,EAAO0V,KApa1EC,CAA+B1G,EAAW7hB,GAE1C,EAAAwoB,mBAAmBv0B,OAAO+L,EA8NlC,SAAoC6hB,G,MAChC,OAAQA,EAAU3uB,MACd,IAAK,cACL,IAAK,aAAc,CACf,MAAMu1B,EAA8B,EAAAC,KAAK7G,EAAW,CAChD,QACA,eACA,cACA,UACA,OACA,iBACA,eACA,SACA,YACA,gBACA,sBACA,uBA2BJ,OAzBA4G,EAAUrH,UAAYgB,EACC,QADwB,EAC3CP,EAAUT,iBAAS,QAAI,EAEvBS,EAAUQ,YAEdoG,EAAUE,aAAevG,EACrBP,EAAU8G,aAEV9G,EAAUQ,YAEdoG,EAAUG,SAAWxG,EACjBP,EAAU+G,SAEV/G,EAAUQ,YAEdoG,EAAUI,QAAUzG,EAChBP,EAAUgH,QAEVhH,EAAUQ,YAEdoG,EAAUrP,OAASgJ,EACfP,EAAUzI,OAEVyI,EAAUQ,YAEPoG,EAEX,IAAK,OACD,OAAO,EAAAC,KAAK7G,EAAW,CACnB,QACA,cACA,UACA,gBACA,sBACA,uBAER,IAAK,WACL,IAAK,UACL,IAAK,mBAAoB,CACrB,MAAM4G,EAA8B,EAAAC,KAAK7G,EAAW,CAChD,eACA,YACA,YACA,YACA,YACA,YACA,cACA,UACA,WACA,oBACA,kBACA,kBASJ,OAH+B,IAA3BA,EAAUiH,eACVL,EAAUjI,MAAQqB,EAAUrB,OAEzBiI,EAEX,IAAK,UACL,IAAK,UACD,OAAO,EAAAC,KAAK7G,EAAW,CAAC,QAAS,OAAQ,UAAW,gBACxD,IAAK,gBACD,OAAO,EAAA6G,KAAK7G,EAAW,CACnB,QACA,YACA,cACA,UACA,gBACA,sBACA,uBAER,IAAK,OACL,IAAK,WACD,OAAO,EAAA6G,KAAK7G,EAAW,CAAC,QAAS,cAAe,YACpD,QACI,MAAO,IA/TyBkH,CAA2BlH,IAE5D7hB,GASX,8BAAmC6O,GAC/B,OAAQA,EAAU1J,MACd,IAAK,QACD,OAAO,IAAIxQ,EAAM0a,gBACb,IAAI0X,aAAalY,EAAUoX,QAC3BpX,EAAUma,WAElB,IAAK,QACD,OAAO,IAAIr0B,EAAM0a,gBACb,IAAI6W,WAAWrX,EAAUoX,QACzBpX,EAAUma,UACVna,EAAUoa,YAElB,IAAK,SACD,OAAO,IAAIt0B,EAAM0a,gBACb,IAAIoX,YAAY5X,EAAUoX,QAC1BpX,EAAUma,UACVna,EAAUoa,YAElB,IAAK,SACD,OAAO,IAAIt0B,EAAM0a,gBACb,IAAIwX,YAAYhY,EAAUoX,QAC1BpX,EAAUma,UACVna,EAAUoa,YAElB,IAAK,OACD,OAAO,IAAIt0B,EAAM0a,gBACb,IAAIgX,UAAUxX,EAAUoX,QACxBpX,EAAUma,UACVna,EAAUoa,YAElB,IAAK,QACD,OAAO,IAAIt0B,EAAM0a,gBACb,IAAIkX,WAAW1X,EAAUoX,QACzBpX,EAAUma,UACVna,EAAUoa,YAElB,IAAK,QACD,OAAO,IAAIt0B,EAAM0a,gBACb,IAAIsX,WAAW9X,EAAUoX,QACzBpX,EAAUma,UACVna,EAAUoa,YAElB,QACI,MAAM,IAAIjwB,MAAM,8BAA8B6V,EAAU1J,UASpE,wBAA6B0c,GACzB,MAAM3uB,EAAO2uB,EAAU3uB,KACvB,YACaqE,IAATrE,GACS,SAATA,GACS,iBAATA,GACS,gBAATA,GACS,yBAATA,GAaR,uBACI2uB,EACApS,EACAzP,EACAgY,EACAkR,GAIA,OAFA,EAAArnB,YAA0BtK,IAAnBsqB,EAAU3uB,MAET2uB,EAAU3uB,MACd,IAAK,gBACL,IAAK,WACL,IAAK,mBACL,IAAK,OACD,OAAOg2B,EACD,IAAI,EAAAC,cAAc1Z,EAAUzP,EAAU,KAAM,CACxCb,IAAK6Y,EAAKoR,eAAeC,aACzBhqB,IAAK2Y,EAAKoR,eAAeE,gBAE7B,IAAI30B,EAAM40B,KAAK9Z,EAAUzP,GACnC,IAAK,UACD,OAAO,IAAIrL,EAAM40B,KAAK9Z,EAAUzP,GACpC,IAAK,cACL,IAAK,aACD,OAAOkpB,EACD,IAAI,EAAAC,cACA1Z,EACAzP,EACA,KAAM,CACFb,IAAK6Y,EAAKoR,eAAeC,aACzBhqB,IAAK2Y,EAAKoR,eAAeE,eAE7B,EAAAE,cAAcC,SAElB,IAAI,EAAAD,cAAc/Z,EAAUzP,GAEtC,IAAK,UACD,OAAO,IAAI,EAAA0pB,QAAQja,EAAUzP,GAEjC,IAAK,UACD,OAAO,IAAI,EAAA2pB,QAAQla,EAAUzP,GAEjC,IAAK,OAGL,IAAK,WACD,OAAO,IAAIrL,EAAMi1B,aAAana,EAAUzP,GAE5C,IAAK,SAGD,OAFA,EAAA6B,OAAO,EAAA8lB,kBAAkB9F,GAAY,qBAE7BA,EAAUgI,WACd,IAAK,OACD,OAAO,IAAIl1B,EAAMm1B,KAAKra,EAAUzP,GACpC,IAAK,WACD,OAAO,IAAIrL,EAAMi1B,aAAana,EAAUzP,GAC5C,IAAK,QACD,OAAO,IAAIrL,EAAMo1B,OAAOta,EAAUzP,GACtC,IAAK,OACD,OAAO,IAAIrL,EAAM40B,KAAK9Z,EAAUzP,IAKhD,OADA,EAAA6B,QAAO,EAAO,qBACP,IAAIlN,EAAMq1B,UAMR,EAAAC,kCAAoC,CAAC,OAAQ,KAAM,cAAe,aAc/E,2BA+JA,8BAuCA,qCAA0CpI,EAAsBlqB,GAC5D,MAAMuyB,EA0OV,SAA0BrI,GACtB,MAAM+F,EAAoBhE,EAAqB/B,GAC/C,QAA0BtqB,IAAtBqwB,EAAiC,CACjC,GAAK,EAAAD,kBAAkB9F,GAGhB,CAGH,OAFeA,EAAUjP,OACPgV,GAHlB,OAAO/F,EADW+F,GAQ1B,OAtPsBuC,CAAiBtI,GACvC,QAAsBtqB,IAAlB2yB,EACA,OAAOrH,EAAsBqH,EAAevyB,IAsGpD,kCAqCA,6BA8DA,2B,8FCrxBA,aAEA,OAKA,MAAayyB,EAoCT,YAAqBC,EAAoCC,GAApC,KAAAD,YAAoC,KAAAC,YA7BzD,uBAAuBD,EAA2BC,GAC9C,OAAO,IAAIF,EAAOC,EAAWC,GASjC,4BAA4B9X,EAAwB+X,GAChD,OAAO,IAAIH,EACP,IAAI,EAAA3sB,eACA+U,EAAO9U,SAAW6sB,EAAOC,aAAe,EACxChY,EAAO7U,UAAY4sB,EAAOE,cAAgB,GAE9C,IAAI,EAAAhtB,eACA+U,EAAO9U,SAAW6sB,EAAOC,aAAe,EACxChY,EAAO7U,UAAY4sB,EAAOE,cAAgB,IAgBtD,kBACI,QAAgClzB,IAA5BhC,KAAK80B,UAAUzsB,eAAsDrG,IAA5BhC,KAAK+0B,UAAU1sB,SAG5D,OAAOgB,KAAKO,IAAI5J,KAAK80B,UAAUzsB,SAAUrI,KAAK+0B,UAAU1sB,UAM5D,kBACI,QAAgCrG,IAA5BhC,KAAK80B,UAAUzsB,eAAsDrG,IAA5BhC,KAAK+0B,UAAU1sB,SAG5D,OAAOgB,KAAKS,IAAI9J,KAAK80B,UAAUzsB,SAAUrI,KAAK+0B,UAAU1sB,UAM5D,YACI,OAAOrI,KAAK80B,UAAU3sB,SAM1B,YACI,OAAOnI,KAAK+0B,UAAU5sB,SAM1B,WACI,OAAOnI,KAAK80B,UAAU1sB,UAM1B,WACI,OAAOpI,KAAK+0B,UAAU3sB,UAM1B,aACI,MAAMD,EAAuC,IAA3BnI,KAAKyc,MAAQzc,KAAKwc,QAC9B,KAAEK,EAAI,KAAED,GAAS5c,MACjB,YAAEm1B,EAAW,aAAEC,GAAiBp1B,KAEtC,IAAIqI,EAMJ,QAJoBrG,IAAhBmzB,QAA8CnzB,IAAjBozB,IAC7B/sB,EAAW8sB,EAA6B,GAAfC,GAGzBvY,EAAOD,EACP,OAAO,IAAI,EAAA1U,eAAeC,EAA0B,IAAf0U,EAAOD,GAAavU,GAG7D,IAAID,EAAkC,IAArB,IAAMwU,EAAOC,GAM9B,OAJIzU,EAAY,MACZA,GAAa,KAGV,IAAI,EAAAF,eAAeC,EAAUC,EAAWC,GAMnD,4BACI,OAAOjJ,EAAMkJ,UAAUW,SAASjJ,KAAKi1B,cAMzC,6BACI,OAAO71B,EAAMkJ,UAAUW,SAASjJ,KAAKk1B,eAMzC,mBACI,OAAOl1B,KAAKwc,MAAQxc,KAAKyc,MAG7B,mBACI,QAAyBza,IAArBhC,KAAKq1B,kBAAkDrzB,IAArBhC,KAAKm1B,YAG3C,OAAOn1B,KAAKq1B,YAAcr1B,KAAKm1B,YAMnC,oBACI,IAAI1d,EAAQzX,KAAK+0B,UAAU3sB,UAAYpI,KAAK80B,UAAU1sB,UAMtD,OAJIqP,EAAQ,IACRA,GAAS,KAGNA,EAOX,4BACI,OAAOzX,KAAKi1B,aAOhB,6BACI,OAAOj1B,KAAKk1B,cAQhB,SAAS1jB,GACL,QACuBxP,IAAnBwP,EAAMnJ,eACerG,IAArBhC,KAAKm1B,kBACgBnzB,IAArBhC,KAAKq1B,YAEL,OAAOr1B,KAAKs1B,eAAe9jB,GAG/B,MAAM+jB,EAASv1B,KAAKm1B,cAAgBn1B,KAAKq1B,YACnCG,EAAiBx1B,KAAKm1B,cAAgB3jB,EAAMnJ,SAC5CotB,EACFz1B,KAAKm1B,aAAe3jB,EAAMnJ,UAAYrI,KAAKq1B,YAAc7jB,EAAMnJ,SAKnE,SAAIktB,EAASC,EAAiBC,IACnBz1B,KAAKs1B,eAAe9jB,GASnC,QACI,OAAO,IAAIqjB,EAAO70B,KAAK80B,UAAW90B,KAAK+0B,WAQ3C,cAAcvjB,GACVxR,KAAK80B,UAAU3sB,SAAWkB,KAAKO,IAAI5J,KAAK80B,UAAU3sB,SAAUqJ,EAAMrJ,UAClEnI,KAAK80B,UAAU1sB,UAAYiB,KAAKO,IAAI5J,KAAK80B,UAAU1sB,UAAWoJ,EAAMpJ,WACpEpI,KAAK80B,UAAUzsB,cACiBrG,IAA5BhC,KAAK80B,UAAUzsB,eAA6CrG,IAAnBwP,EAAMnJ,SACzCgB,KAAKO,IAAI5J,KAAK80B,UAAUzsB,SAAUmJ,EAAMnJ,eACZrG,IAA5BhC,KAAK80B,UAAUzsB,SACfrI,KAAK80B,UAAUzsB,cACIrG,IAAnBwP,EAAMnJ,SACNmJ,EAAMnJ,cACNrG,EAEVhC,KAAK+0B,UAAU5sB,SAAWkB,KAAKS,IAAI9J,KAAK+0B,UAAU5sB,SAAUqJ,EAAMrJ,UAClEnI,KAAK+0B,UAAU3sB,UAAYiB,KAAKS,IAAI9J,KAAK+0B,UAAU3sB,UAAWoJ,EAAMpJ,WACpEpI,KAAK+0B,UAAU1sB,cACiBrG,IAA5BhC,KAAK+0B,UAAU1sB,eAA6CrG,IAAnBwP,EAAMnJ,SACzCgB,KAAKS,IAAI9J,KAAK+0B,UAAU1sB,SAAUmJ,EAAMnJ,eACZrG,IAA5BhC,KAAK+0B,UAAU1sB,SACfrI,KAAK+0B,UAAU1sB,cACIrG,IAAnBwP,EAAMnJ,SACNmJ,EAAMnJ,cACNrG,EAGN,eAAewP,GACnB,GAAIA,EAAMrJ,SAAWnI,KAAK80B,UAAU3sB,UAAYqJ,EAAMrJ,UAAYnI,KAAK+0B,UAAU5sB,SAC7E,OAAO,EAGX,MAAM,KAAE0U,EAAI,KAAED,GAAS5c,KAEvB,OAAI4c,EAAOC,EACArL,EAAMpJ,WAAayU,GAAQrL,EAAMpJ,UAAYwU,EAGjDpL,EAAMpJ,UAAYwU,GAAQpL,EAAMpJ,WAAayU,GAtP5D,Y,4GCSA,gCAAqC/d,GACjC,OACIA,GAC2B,iBAApBA,EAAOqJ,UACc,iBAArBrJ,EAAOsJ,YACc,iBAApBtJ,EAAOuJ,eAAoD,IAApBvJ,EAAOuJ,Y,oGClB9D,cAGA,QACA,QAKA,qBAUI,YAAqBqtB,EAA+CvmB,GAA/C,KAAAumB,oBAA+C,KAAAvmB,aAChEnP,KAAK21B,qBAAuB,IAAI,EAAAC,6BAA6B51B,MAC7DA,KAAK61B,iBAAmB,IAAI,EAAAC,iBAAiBJ,GASjD,eAAe9R,GACX,OAAO5jB,KAAK61B,iBAAiBE,SAASnS,GAS1C,WAAWjb,EAA8BiT,GACrC,OAAO,EAAAoa,aAAaC,wBAAwBj2B,KAAM2I,EAAUiT,GAShE,YAAYsa,EAAgBta,GACxB,OAAO,EAAAoa,aAAaG,uBAAuBn2B,KAAMk2B,EAAQta,GAQ7D,UAAUgI,GACN,OAAO5jB,KAAK21B,qBAAqBS,UAAUxS,GAS/C,YAAYA,EAAkBzd,GAC1B,OAAOnG,KAAK21B,qBAAqBU,YAAYzS,EAASzd,M,kGC1E9D,aACA,OACA,QAeMmwB,EAAW,IAAIl3B,EAAMsqB,OAiB3B,SAAiB6D,GAkBG,EAAAgJ,eAAhB,SAA+Br4B,EAAW2vB,EAAWnkB,EAAWF,GAG5D,OAFA,EAAA8C,OAAO9C,GAAK,GAAKA,GAAK,GAxCG,IAyCIH,KAAKmtB,MAzCT,IAyCehtB,IAlDb,GASF,IA4CnBtL,GApDY,GAQO,IA6CnB2vB,GApDc,EAOK,IA8CnBnkB,GApDa,GAiEP,EAAA+sB,cAAhB,SAA8Bv4B,EAAW2vB,EAAWnkB,GAIhD,OAHA,EAAA4C,OAAOpO,GAAK,GAAKA,GAAK,GACtB,EAAAoO,OAAOuhB,GAAK,GAAKA,GAAK,GACtB,EAAAvhB,OAAO5C,GAAK,GAAKA,GAAK,GA9DG,IAgEnBxL,GAxEY,GAQO,IAiEnB2vB,GAxEc,EAOK,IAkEnBnkB,GAxEa,GAoFP,EAAAgtB,cAAhB,SAA8BtK,EAAWjtB,EAAW9B,GAIhD,OAHA,EAAAiP,OAAO8f,GAAK,GAAKA,GAAK,GACtB,EAAA9f,OAAOnN,GAAK,GAAKA,GAAK,GACtB,EAAAmN,OAAOjP,GAAK,GAAKA,GAAK,GACfi5B,EAASK,OAAOvK,EAAGjtB,EAAG9B,GAAGu5B,UAcpB,EAAA9I,eAAhB,SAA+B+I,EAAatoB,EAAS,IAAI,EAAAzK,MAQrD,OAPA,EAAAwI,OAAkC,IAApB,EAANuqB,GAA6B,oBACrCtoB,EAAOrQ,GAAM24B,GA1GK,GAQO,SAmGzBtoB,EAAOsf,GAAMgJ,GA1GO,EAOK,SAoGzBtoB,EAAO7E,GAAMmtB,GA1GM,EAMM,SAqGzBtoB,EAAO/E,GArGkB,KAsGCqtB,GA/GC,GASF,UAwGlBtoB,GASK,EAAAif,cAAhB,SAA8BqJ,GAE1B,OADA,EAAAvqB,OAAkC,IAApB,EAANuqB,GAA6B,oBAC9BA,GA5HoB,IA4HU,GAUzB,EAAAC,gBAAhB,SAAgCD,GAE5B,OADA,EAAAvqB,OAAkC,IAApB,EAANuqB,GAA6B,qBA9HZ,KAgICA,GAzIC,IASF,UA2Ib,EAAApJ,mBAAhB,SAAmCoJ,GAE/B,OADA,EAAAvqB,OAAkC,IAApB,EAANuqB,GAA6B,oBA3IhB,SA4IdA,GAxHf,CAAiB,EAAAtJ,aAAA,EAAAA,WAAU,M,oGC/B3B,SAAiBwJ,GAsFb,IAAYC,EAjFC,EAAAC,iBAAmB,CAC5B,CAAC,EAAQ,GACT,CAAC,GAAQ,IACT,CAAC,KAAQ,MACT,CAAC,KAAQ,MACT,CAAC,KAAQ,MACT,CAAC,KAAQ,OACT,CAAC,KAAQ,MACT,CAAC,KAAQ,OAUG,EAAAC,aAAhB,SAA6BC,GACzB,IAAK,MAAMC,KAAS,EAAAH,iBAChB,GAAIE,GAAaC,EAAM,IAAMD,GAAaC,EAAM,GAC5C,OAAO,EAGf,OAAO,GAOE,EAAAC,cAAgB,CACzB,CAAC,GAAQ,IACT,CAAC,IAAQ,KACT,CAAC,KAAQ,OAUG,EAAAC,UAAhB,SAA0BH,GACtB,IAAK,MAAMC,KAAS,EAAAC,cAChB,GAAIF,GAAaC,EAAM,IAAMD,GAAaC,EAAM,GAC5C,OAAO,EAGf,OAAO,GAOE,EAAAG,mBAAqB,CAC9B,CAAC,EAAQ,IACT,CAAC,IAAQ,MAUG,EAAAC,YAAhB,SAA4BL,GACxB,IAAK,MAAMC,KAAS,EAAAG,mBAChB,GAAIJ,GAAaC,EAAM,IAAMD,GAAaC,EAAM,GAC5C,OAAO,EAGf,OAAO,GAMX,SAAYJ,GACR,yBACA,oBACA,iBACA,kBAJJ,CAAYA,EAAA,EAAAA,YAAA,EAAAA,UAAS,KAaR,EAAAS,UAAsB,CAC/B,SACA,gCACA,SACA,oBACA,oBACA,8BACA,8BACA,yCACA,sBACA,uBACA,SACA,oBACA,YACA,UACA,SACA,gBACA,MACA,QACA,mBAOS,EAAAC,2BAA6B,CACtC,CAAC,GAAQ,IACT,CAAC,GAAQ,IACT,CAAC,GAAQ,IACT,CAAC,IAAQ,MAQA,EAAAC,wBAA0B,CACnC,CAAC,GAAQ,IACT,CAAC,KAAQ,MACT,CAAC,KAAQ,OAWG,EAAAC,aAAhB,SAA6BT,EAAmBU,GAE5C,IAAK,MAAMC,KAAa,EAAAH,wBACpB,GAAIR,GAAaW,EAAU,IAAMX,GAAaW,EAAU,GACpD,OAAOd,EAAUe,KAGzB,IAAK,MAAMC,KAAgB,EAAAN,2BACvB,GAAIP,GAAaa,EAAa,IAAMb,GAAaa,EAAa,GAC1D,OAAOhB,EAAUiB,QAQzB,YAAYj2B,IAHA,EAAAy1B,UAAUS,KAAKC,GAChBA,IAAYN,GAGZb,EAAUoB,IAEVpB,EAAUqB,KASZ,EAAAC,sBAAwB,CACjC,GACA,GACA,GACA,GACA,GACA,GACA,IACA,KAUY,EAAAC,cAAhB,SAA8BpB,GAC1B,YAGWn1B,IAFP,EAAAs2B,sBAAsBJ,KAAKC,GAChBA,IAAYhB,IAzMnC,CAAiB,EAAAJ,eAAA,EAAAA,aAAY,M,uGCA7B,SAAYnQ,GACR,2BACA,6BACA,+BAHJ,CAAY,EAAAA,kBAAA,EAAAA,gBAAe,M,sHCH3B,aAoEA,MAAa4R,EAAb,cACI,KAAAxZ,SAAmB,EACnB,KAAAyZ,gBAA0B,EAE1B,QAAQhhB,EAAevG,IAIvB,OACIwnB,EACAC,EACAjqB,EACAkqB,EACAC,EACAC,KAdR,SAwBA,2BAAgCN,EAC5B,cACIx1B,QAIJ,OACI01B,EACAC,EACAjqB,EACAkqB,EACAC,GAEAH,EAASK,gBAAgB/4B,KAAKy4B,eAAiB,KAAOG,GACtDF,EAASM,OAAOL,EAAOjqB,KAQ/B,2BAAgC8pB,EAI5B,YAAYS,EAA8BC,EAAoB,YAC1Dl2B,QADsC,KAAAk2B,YAElCD,aAAkB75B,EAAM0Y,gBACxB9X,KAAKgY,SAAWihB,EAAOjhB,SACvBhY,KAAKyK,SAAWwuB,IAEhBj5B,KAAKgY,SAAW5Y,EAAM+5B,cAActsB,MAAMosB,EAAOjhB,UACjDhY,KAAKyK,SAAW,IAAIrL,EAAM0Y,eAAe,CACrCtM,QAAS,OAAF,UAAQytB,EAAeztB,SAC9BwM,SAAUhY,KAAKgY,SACfohB,aAAcH,EAAOG,aACrBC,eAAgBJ,EAAOI,kBAG/Br5B,KAAKs5B,OAAS,IAAIC,EAAev5B,KAAKyK,UAG1C,OACIiuB,EACAC,EACAjqB,EACAkqB,EACAC,EACAC,GAEI94B,KAAKgY,SAAShY,KAAKk5B,aACnBl5B,KAAKgY,SAAShY,KAAKk5B,WAAW76B,MAAQw6B,EAAW1hB,SAErDnX,KAAKs5B,OAAO7uB,SAAWzK,KAAKyK,SAC5BiuB,EAASK,gBAAgB/4B,KAAKy4B,eAAiB,KAAOG,GACtD54B,KAAKs5B,OAAON,OAAON,KAI3B,MAAMa,EAGF,YAAY9uB,GACRzK,KAAKw5B,SAAW,IAAIp6B,EAAMq6B,oBAAoB,EAAG,EAAG,GAAI,EAAG,EAAG,GAC9D,MAAMvf,EAAW,IAAI9a,EAAMs6B,oBAAoB,EAAG,GAClD15B,KAAK25B,OAAS,IAAIv6B,EAAM40B,KAAK9Z,EAAUzP,GAE3C,eACI,OAAOzK,KAAK25B,OAAOlvB,SAEvB,aAAapM,GACT2B,KAAK25B,OAAOlvB,SAAWpM,EAE3B,OAAOq6B,GACHA,EAASM,OAAQh5B,KAAK25B,OAA+B35B,KAAKw5B,a,sJCvKlE,cACA,OACA,QACA,QACA,OACA,QAGA,QACA,QAEA,OAEA,MAAMI,UAA2B,EAAAC,WAAjC,c,oBA0Ba,KAAAjqB,KAAuB,EAAAC,eAAeC,OAzBrC,aAAagqB,EAAalwB,EAAaE,GAC7C,OAAOT,KAAKO,IAAIP,KAAKS,IAAIF,EAAKkwB,GAAMhwB,GAG9B,qBAAqB3B,GAC3B,OAAOyxB,EAAmBzvB,MACtBhC,GACC4xB,EAAkBC,iBACnBD,EAAkBC,kBAIlB,uBAAuB7xB,GAC3B,OAAOkB,KAAK4wB,IAAI5wB,KAAKsJ,IAAc,IAAVtJ,KAAKyF,GAAuB,GAAX3G,IAAmBkB,KAAKyF,GAG9D,4BAA4B3G,GAChC,OAAOyxB,EAAmBM,gBAAgBN,EAAmBO,cAAchyB,IAGvE,yBAAyBzC,GAC7B,OAAO,EAAM2D,KAAKoX,KAAKpX,KAAK+wB,IAAI/wB,KAAKyF,GAAKpJ,IAAgB,GAAV2D,KAAKyF,GAOzD,eAAeurB,GACX,OAAOhxB,KAAKixB,KAAK,EAAIjxB,KAAKyF,IAAMurB,EAAW30B,EAAI1F,KAAKilB,UAAY,KAIpE,YACIkQ,EACAE,EACAlvB,GAWA,OATKA,IACDA,EAAU,IAAI/G,EAAMm7B,MAExBp0B,EAAOyD,IAAInE,EAAI,EACfU,EAAOyD,IAAIlE,EAAI,EACfS,EAAOyD,IAAIhE,EAAIuvB,EACfhvB,EAAO2D,IAAIrE,EAAIzF,KAAKilB,UACpB9e,EAAO2D,IAAIpE,EAAI1F,KAAKilB,UACpB9e,EAAO2D,IAAIlE,EAAIyvB,EACRlvB,EAIX,aACIq0B,EACAr0B,GAEA,IAAIwC,EAqBJ,OAlBIA,EADA6xB,aAAwB,EAAAtyB,eACbsyB,EAEA,IAAI,EAAAtyB,eACXsyB,EAAaryB,SACbqyB,EAAapyB,UACboyB,EAAanyB,UAIhBlC,IAEDA,EAAS,CAAEV,EAAG,EAAGC,EAAG,EAAGE,EAAG,IAE9BO,EAAOV,GAAMkD,EAASP,UAAY,KAAO,IAAOpI,KAAKilB,UACrD9e,EAAOT,GACoE,GAAtEk0B,EAAmBa,qBAAqB9xB,EAAS+xB,mBAA2B,IAC7E16B,KAAKilB,UACT9e,EAAOP,EAAI+C,EAASN,UAAY,EACzBlC,EAIX,eAAek0B,GAMX,OALiB,EAAAnyB,eAAeyyB,YAC5Bf,EAAmBgB,kBAA0D,GAAvCP,EAAW30B,EAAI1F,KAAKilB,UAAY,KACrEoV,EAAW50B,EAAIzF,KAAKilB,UAAa,EAAI5b,KAAKyF,GAAKzF,KAAKyF,GACrDurB,EAAWz0B,GAMnB,kBAAkBy0B,GACd,OAAOA,EAAWz0B,EAItB,WACIswB,EACA/vB,GAEA,MAAM00B,EAAc76B,KAAKyQ,aAAaylB,EAAOjZ,QACvC6d,GAC6E,GAA9ElB,EAAmBa,qBAAqBvE,EAAOnB,UAAU2F,mBACtD,IACJ16B,KAAKilB,UACH8V,GAC6E,GAA9EnB,EAAmBa,qBAAqBvE,EAAOpB,UAAU4F,mBACtD,IACJ16B,KAAKilB,UACH+V,EAA2C,IAA3BF,EAAaC,GAEnCF,EAAYn1B,EAAIs1B,EAEhB,MAAM/F,EAAe6F,EAAaC,EAC5B7F,EAAiBgB,EAAOhB,cAAgB,IAAOl1B,KAAKilB,UAI1D,GAHK9e,IACDA,EAAU,IAAI/G,EAAMm7B,MAEpB,EAAAU,WAAW90B,GAAS,CACpBA,EAAOyD,IAAInE,EAAIo1B,EAAYp1B,EAAoB,GAAhByvB,EAC/B/uB,EAAOyD,IAAIlE,EAAIm1B,EAAYn1B,EAAmB,GAAfuvB,EAC/B9uB,EAAO2D,IAAIrE,EAAIo1B,EAAYp1B,EAAoB,GAAhByvB,EAC/B/uB,EAAO2D,IAAIpE,EAAIm1B,EAAYn1B,EAAmB,GAAfuvB,EAC/B,MAAMG,EAAec,EAAOd,kBACPpzB,IAAjBozB,GACAjvB,EAAOyD,IAAIhE,EAAIi1B,EAAYj1B,EAAmB,GAAfwvB,EAC/BjvB,EAAO2D,IAAIlE,EAAIi1B,EAAYj1B,EAAmB,GAAfwvB,IAE/BjvB,EAAOyD,IAAIhE,EAAI,EACfO,EAAO2D,IAAIlE,EAAI,OAEhB,KAAI,EAAAs1B,mBAAmB/0B,GAW1B,MAAM,IAAI1C,MAAM,wBAVhB,EAAA6E,UAAUyB,WAAW,EAAG,EAAG,EAAG5D,EAAOyH,OACrC,EAAAtF,UAAUyB,WAAW,EAAG,EAAG,EAAG5D,EAAO0H,OACrC,EAAAvF,UAAUyB,WAAW,EAAG,EAAG,EAAG5D,EAAO2H,OACrC3H,EAAO4H,SAAStI,EAAIo1B,EAAYp1B,EAChCU,EAAO4H,SAASrI,EAAIm1B,EAAYn1B,EAChCS,EAAO4H,SAASnI,EAAIi1B,EAAYj1B,EAChCO,EAAO6e,QAAQvf,EAAoB,GAAhByvB,EACnB/uB,EAAO6e,QAAQtf,EAAmB,GAAfuvB,EACnB9uB,EAAO6e,QAAQpf,EAAIyD,KAAKS,IAAIge,OAAOqT,QAAsC,IAA5BjF,EAAOd,cAAgB,IAIxE,OAAOjvB,EAIX,aAAai1B,GACT,MAAMC,EAASr7B,KAAKmW,eAAeilB,EAASxxB,KACtC0xB,EAASt7B,KAAKmW,eAAeilB,EAAStxB,KAE5C,OADe,EAAA+qB,OAAO0G,gBAAgBF,EAAQC,GAKlD,eAAejB,GACX,OAAOA,EAAWz0B,EAItB,oBAAoBy0B,GAEhB,OADAA,EAAWz0B,EAAI,EACRy0B,EAIX,cAAcmB,EAA0BjmB,GAQpC,YAPevT,IAAXuT,EACAA,EAAS,CAAE9P,EAAG,EAAGC,EAAG,EAAGE,EAAG,IAE1B2P,EAAO9P,EAAI,EACX8P,EAAO7P,EAAI,EACX6P,EAAO3P,EAAI,GAER2P,EAIX,eACI2P,EACAC,EACAhf,GAOA,OACI+e,IAAqBllB,MACpBklB,IAAqB,EAAAuW,uBAAyBvW,IAAqB,EAAAwW,mBAcjE14B,MAAM24B,eAAezW,EAAkBC,EAAUhf,SAZrCnE,IAAXmE,IAEAA,EAAS,IAGbA,EAAOV,EAAI0f,EAAS1f,EACpBU,EAAOT,EAAI1F,KAAKilB,UAAYE,EAASzf,EACrCS,EAAOP,EAAIuf,EAASvf,EAEbO,IAsHnB,kBAAa4zB,GAGb,OADoB,EAAAC,iBAA2B,mBAC/C,GAHA,GAAa,EAAAD,oBAQA,EAAA2B,mBAAiC,IAAI9B,EAC9C,EAAA5sB,eAAe+J,0BAON,EAAA0kB,sBAAoC,IA/HjD,cAAoC7B,EAEhC,aACIY,EACAr0B,GAEA,IAAIwC,EAGAA,EADA6xB,aAAwB,EAAAtyB,eACbsyB,EAEA,IAAI,EAAAtyB,eACXsyB,EAAaryB,SACbqyB,EAAapyB,UACboyB,EAAanyB,UAchBlC,IAEDA,EAAS,CAAEV,EAAG,EAAGC,EAAG,EAAGE,EAAG,IAG9BO,EAAOV,GAAMkD,EAASP,UAAY,KAAO,IAAOpI,KAAKilB,UACrD,MAAM2W,EAAKvyB,KAAKsH,IAAIipB,EAAmBO,cAAcxxB,EAAS+xB,oBAG9D,OAFAv0B,EAAOT,GAAK,GAAM2D,KAAK4wB,KAAK,EAAI2B,IAAO,EAAIA,KAAQ,EAAIvyB,KAAKyF,KAAO9O,KAAKilB,UACxE9e,EAAOP,EAAI+C,EAASN,UAAY,EACzBlC,EAIX,eAAek0B,GACX,MAAM50B,EAAI40B,EAAW50B,EAAIzF,KAAKilB,UAAY,GACpCvf,EAAI,GAAM20B,EAAW30B,EAAI1F,KAAKilB,UAE9B7c,EAAY,IAAM3C,EAClB0C,EAAW,GAAM,IAAMkB,KAAKoX,KAAKpX,KAAK+wB,IAAS,GAAJ10B,EAAQ2D,KAAKyF,KAAQzF,KAAKyF,GAE3E,OAAO,IAAI,EAAA5G,eAAeC,EAAUC,EAAWiyB,EAAWz0B,GAI9D,WACIswB,EACA/vB,GAEA,MAAMjI,EAAI8E,MAAM64B,WAAW3F,EAAQ/vB,GACnC,GAAI,EAAA80B,WAAW/8B,GAAI,CAEf,MAAM49B,EAAO59B,EAAE4L,IAAIpE,EACnBxH,EAAE4L,IAAIpE,EAAI1F,KAAKilB,UAAY/mB,EAAE0L,IAAIlE,EACjCxH,EAAE0L,IAAIlE,EAAI1F,KAAKilB,UAAY6W,OACpB,EAAAZ,mBAAmBh9B,KAC1B,EAAAoK,UAAUyB,WAAW,EAAG,EAAG,EAAG7L,EAAE0P,OAChC,EAAAtF,UAAUyB,WAAW,GAAI,EAAG,EAAG7L,EAAE2P,OACjC,EAAAvF,UAAUyB,WAAW,EAAG,GAAI,EAAG7L,EAAE4P,OACjC5P,EAAE6P,SAASrI,EAAI1F,KAAKilB,UAAY/mB,EAAE6P,SAASrI,GAE/C,OAAOxH,EAIX,aAAak9B,GACT,MAAMC,EAASr7B,KAAKmW,eAAeilB,EAASxxB,KACtC0xB,EAASt7B,KAAKmW,eAAeilB,EAAStxB,KAK5C,OAJe,IAAI,EAAA+qB,OACf,IAAI,EAAA3sB,eAAeozB,EAAOnzB,SAAUkzB,EAAOjzB,UAAWizB,EAAOhzB,UAC7D,IAAI,EAAAH,eAAemzB,EAAOlzB,SAAUmzB,EAAOlzB,UAAWkzB,EAAOjzB,WAMrE,cAAcmzB,EAA0BjmB,GAQpC,YAPevT,IAAXuT,EACAA,EAAS,CAAE9P,EAAG,EAAGC,EAAG,EAAGE,GAAI,IAE3B2P,EAAO9P,EAAI,EACX8P,EAAO7P,EAAI,EACX6P,EAAO3P,GAAK,GAET2P,EAIX,kBACI/D,EACArL,GAUA,OARI,EAAA2C,qBAAqB0I,GACrBxR,KAAKyQ,aAAae,EAAOrL,EAAO4H,UAEhC,EAAAzF,UAAU0B,YAAYwH,EAAOrL,EAAO4H,UAExC,EAAAzF,UAAUyB,WAAW,EAAG,EAAG,EAAG5D,EAAOyH,OACrC,EAAAtF,UAAUyB,WAAW,GAAI,EAAG,EAAG5D,EAAO0H,OACtC,EAAAvF,UAAUyB,WAAW,EAAG,GAAI,EAAG5D,EAAO2H,OAC/B3H,IAqBX,EAAA6G,eAAe+J,2B,iHCxUN,EAAAglB,0BAA+C,IApB5D,MACI,kBACI,OAAO,EAEX,kBACI,OAAO,EAEX,mBAAmBngB,GAEf,OAAO,GAAKA,EAEhB,mBAAmBA,GAEf,OAAO,GAAKA,K,+FCdpB,MAAM6H,EAAa,CACf,EACA,EACA,EACA,EACA,GACA,GACA,GACA,IACA,IACA,IACA,KACA,KACA,KACA,KACA,MACA,MACA,MACA,OACA,OACA,OACA,QACA,QACA,QACA,QACA,SACA,SACA,SACA,UACA,UACA,UACA,WACA,WACA,WACA,WACA,YACA,YACA,YACA,aACA,aACA,aACA,cACA,cACA,cACA,cACA,eACA,eACA,eACA,eACA,gBACA,gBACA,gBACA,gBACA,kBAiCJ,MAAae,EA+JT,YAAqBwX,EAAsBC,EAAyBrgB,GAA/C,KAAAogB,MAAsB,KAAAC,SAAyB,KAAArgB,QAvJpE,0BAA0BogB,EAAaC,EAAgBrgB,GACnD,OAAO,IAAI4I,EAAQwX,EAAKC,EAAQrgB,GAWpC,mBAAmBsgB,GACf,MAAMtgB,EAAQsgB,EAAQ56B,OACtB,IAAI06B,EAAM,EACNC,EAAS,EAEb,IAAK,IAAI7+B,EAAI,EAAGA,EAAI8+B,EAAQ56B,SAAUlE,EAAG,CACrC,MAAM++B,EAAO,GAAK/+B,EACZM,EAAI0+B,SAASF,EAAQG,OAAOzgB,EAAQxe,EAAI,GAAI,IAC1C,EAAJM,IACAu+B,GAAUE,GAEN,EAAJz+B,IACAs+B,GAAOG,GAIf,OAAO3X,EAAQ8X,mBAAmBN,EAAKC,EAAQrgB,GAUnD,sBAAsB2gB,GAClB,IAAI3gB,EAAQ,EACRogB,EAAM,EACNC,EAAS,EACTO,EAAUD,EAEd,KAAOC,EAAU,GAAG,CAChB,MAAML,EAAe,GAAKvgB,EAEZ,EAAV4gB,IACAP,GAAUE,GAEA,EAAVK,IACAR,GAAOG,GAGXvgB,IACA4gB,GAAWA,GAAqB,EAAVA,IAAkB,EAG5C,MAAMr2B,EAASqe,EAAQ8X,mBAAmBN,EAAKC,EAAQrgB,GAEvD,OADAzV,EAAOs2B,aAAeF,EACfp2B,EAWX,oBAAoBu2B,GAChB,MAAMv2B,EAASqe,EAAQC,eAAe2X,SAASM,EAAW,KAE1D,OADAv2B,EAAOw2B,WAAaD,EACbv2B,EAWX,sBAAsByV,GAClB,OAAOvS,KAAK2N,IAAI,EAAG4E,GAWvB,mBAAmBA,GACf,OAAOvS,KAAK2N,IAAI,EAAG4E,GAavB,gBACIA,EACAghB,EACAC,EACAC,EACAC,GAEA,OAAOvY,EAAQ8X,mBACXjzB,KAAKmtB,MAAMqG,GAAUE,EAAcvY,EAAQwY,YAAYphB,KACvDvS,KAAKmtB,MAAMoG,GAAUE,EAAatY,EAAQyY,eAAerhB,KACzDA,GAYR,wBAAwBuI,GACpB,OAAO9a,KAAKmtB,MAAMrS,EAAa,GAwBnC,SACI,GAAmB,IAAfnkB,KAAK4b,MACL,MAAM,IAAInY,MAAM,8CAGpB,OAAO+gB,EAAQ8X,mBAAmBt8B,KAAKg8B,MAAQ,EAAGh8B,KAAKi8B,SAAW,EAAGj8B,KAAK4b,MAAQ,GAYtF,eAAekd,GACX,MAAMld,EAAQvS,KAAKS,IAAI,EAAG9J,KAAK4b,MAAQkd,GACvC,IAAIkD,EAAMh8B,KAAKg8B,IACXC,EAASj8B,KAAKi8B,OAWlB,OARInD,GAAS,GACTkD,IAAQlD,EACRmD,IAAWnD,IAEXkD,MAAUlD,EACVmD,MAAanD,GAGVtU,EAAQ8X,mBAAmBN,EAAKC,EAAQrgB,GAcnD,eAAeA,GACX,OAAO5b,KAAKk9B,eAAethB,EAAQ5b,KAAK4b,OAU5C,aACI,QAA0B5Z,IAAtBhC,KAAKy8B,aAA4B,CACjC,IAAIR,EAASj8B,KAAKi8B,OACdD,EAAMh8B,KAAKg8B,IAGX71B,EAASsd,EAAWzjB,KAAK4b,OAAS,GACtC,IAAK,IAAIxe,EAAI,EAAGA,EAAI4C,KAAK4b,QAASxe,EACjB,EAAT6+B,IACA91B,GAAUsd,EAAW,EAAIrmB,IAEnB,EAAN4+B,IACA71B,GAAUsd,EAAW,EAAIrmB,EAAI,IAEjC6+B,KAAY,EACZD,KAAS,EAIbh8B,KAAKy8B,aAAet2B,EAExB,OAAOnG,KAAKy8B,aAUhB,aAII,YAHwBz6B,IAApBhC,KAAK28B,aACL38B,KAAK28B,WAAa38B,KAAKmkB,aAAagZ,YAEjCn9B,KAAK28B,WAchB,YACI,IAAIx2B,EAAiB,GAGrB,IAAK,IAAI/I,EAAI4C,KAAK4b,MAAOxe,EAAI,IAAKA,EAAG,CACjC,MAAM++B,EAAO,GAAM/+B,EAAI,EAEjBggC,EAA+B,IAAxBp9B,KAAKi8B,OAASE,GACrBH,EAA4B,IAArBh8B,KAAKg8B,IAAMG,GAGpBh2B,GADAi3B,GAAOpB,EACG,IACHA,EACG,IACHoB,EACG,IAEA,IAKlB,OAAOj3B,EASX,OAAOk3B,GACH,OAAOr9B,KAAKg8B,MAAQqB,EAAIrB,KAAOh8B,KAAKi8B,SAAWoB,EAAIpB,QAAUj8B,KAAK4b,QAAUyhB,EAAIzhB,MASpF,YAAY9I,GACR,MAAMwqB,EAAU9Y,EAAQ+Y,YAA2B,IAAfzqB,EAAIxR,OAAe,IAAMwR,GACvDqP,EAAQniB,KAAKk9B,eAAeI,EAAQ1hB,OAC1C,OAAO4I,EAAQ8X,mBACXna,EAAM6Z,IAAMsB,EAAQtB,IACpB7Z,EAAM8Z,OAASqB,EAAQrB,OACvB9Z,EAAMvG,OAUd,iBAAiB9I,GACb,MAAMwqB,EAAU9Y,EAAQgZ,aAAa1qB,GAC/BqP,EAAQniB,KAAKk9B,eAAeI,EAAQ1hB,OAC1C,OAAO4I,EAAQ8X,mBACXna,EAAM6Z,IAAMsB,EAAQtB,IACpB7Z,EAAM8Z,OAASqB,EAAQrB,OACvB9Z,EAAMvG,OAsBd,eAAekd,GACX,MAEM2E,EAAM,GAAc,EAAR3E,EAIlB,OANY94B,KAAKmkB,aAGJsZ,EAAM,EAEWA,GAChBN,WAQlB,WACI,OAAO3Y,EAAQwY,YAAYh9B,KAAK4b,OAQpC,cACI,OAAO4I,EAAQyY,eAAej9B,KAAK4b,QA7X3C,a,4FCvFA,aACA,QACA,QAQA,MAAa9X,EAmBT,YACW5F,EAAY,EACZ2vB,EAAY,EACZnkB,EAAY,EACZF,EAAY,GAHZ,KAAAtL,IACA,KAAA2vB,IACA,KAAAnkB,IACA,KAAAF,IAjBX,aAAagc,GACT,MAAMyF,EAAQ,EAAAmD,wBAAwB5I,GAEtC,QAAcxjB,IAAVipB,EAIJ,OAAO,EAAAsC,WAAWO,eAAe7C,GAgBrC,QACI,OAAO,IAAInnB,EAAK9D,KAAK9B,EAAG8B,KAAK6tB,EAAG7tB,KAAK0J,EAAG1J,KAAKwJ,GAMjD,SACI,OAAO,EAAA+jB,WAAWgJ,eAAev2B,KAAK9B,EAAG8B,KAAK6tB,EAAG7tB,KAAK0J,EAAG1J,KAAKwJ,GAMlE,KAAK+E,EAAcjQ,GAKf,OAJA0B,KAAK9B,EAAI,EAAAoK,UAAUo1B,KAAK19B,KAAK9B,EAAGqQ,EAAOrQ,EAAGI,GAC1C0B,KAAK6tB,EAAI,EAAAvlB,UAAUo1B,KAAK19B,KAAK6tB,EAAGtf,EAAOsf,EAAGvvB,GAC1C0B,KAAK0J,EAAI,EAAApB,UAAUo1B,KAAK19B,KAAK0J,EAAG6E,EAAO7E,EAAGpL,GAC1C0B,KAAKwJ,EAAI,EAAAlB,UAAUo1B,KAAK19B,KAAKwJ,EAAG+E,EAAO/E,EAAGlL,GACnC0B,KAMX,SAEI,MAAO,QAAkB,IAATA,KAAK9B,GAAY,MAAgB,IAAT8B,KAAK6tB,GAAY,MAAgB,IAAT7tB,KAAK0J,GAAY,MAC7E1J,KAAKwJ,MAzDjB,U,iSCXA,aACA,QAGA,SAMA,IAAYm0B,GAAZ,SAAYA,GACR,uBACA,uBACA,iBAHJ,CAAYA,EAAA,EAAAA,2BAAA,EAAAA,yBAAwB,KAkBpC,MAAMC,EAAkD,CACpDhuB,KAAM+tB,EAAyBE,OAC/Bzc,KAAM,EACN0c,OAAQ,qCACRC,QAAS,CAACC,EAAsBzvB,KAC5B,MAAM0vB,EAAQL,EAAoBE,OAAOI,KAAKF,GAC9C,QAAOC,QAA2Cj8B,KAAlCuM,EAAO,GAAKuZ,OAAOmW,EAAM,OAG3CE,EAAkD,CACpDvuB,KAAM+tB,EAAyB55B,OAC/Bqd,KAAM,EACN+a,KAAM,EACN2B,OAAQ,sCACRC,QAAS,CAACC,EAAsBzvB,KAC5B,MAAM0vB,EAAQE,EAAoBL,OAAOI,KAAKF,GAC9C,OAAc,OAAVC,IAGJ1vB,EAAO,GAAKuZ,OAAOmW,EAAM,KAClB,KAGTG,EAA+C,CACjDxuB,KAAM+tB,EAAyBU,IAC/Bjd,KAAM,EACN0c,OAAQ,qDACRC,QAAS,CAACC,EAAsBzvB,KAC5B,MAAM0vB,EAAQG,EAAiBN,OAAOI,KAAKF,GAC3C,GAAc,OAAVC,EACA,OAAO,EAEX,MAAMpH,EAAMoH,EAAM,GACZ7c,EAAOyV,EAAIv1B,OAkBjB,OAhBA,EAAAgL,OAAgB,IAAT8U,GAAuB,IAATA,EAAY,sCAGpB,IAATA,GAEA7S,EAAO,GAAK6tB,SAASvF,EAAIwF,OAAO,GAAKxF,EAAIwF,OAAO,GAAI,IAAM,IAC1D9tB,EAAO,GAAK6tB,SAASvF,EAAIwF,OAAO,GAAKxF,EAAIwF,OAAO,GAAI,IAAM,IAC1D9tB,EAAO,GAAK6tB,SAASvF,EAAIwF,OAAO,GAAKxF,EAAIwF,OAAO,GAAI,IAAM,IAC1D9tB,EAAO,GAAc,IAAT6S,EAAagb,SAASvF,EAAIwF,OAAO,GAAKxF,EAAIwF,OAAO,GAAI,IAAM,IAAM,GAC7D,IAATjb,IAEP7S,EAAO,GAAK6tB,SAASvF,EAAIwF,OAAO,GAAKxF,EAAIwF,OAAO,GAAI,IAAM,IAC1D9tB,EAAO,GAAK6tB,SAASvF,EAAIwF,OAAO,GAAKxF,EAAIwF,OAAO,GAAI,IAAM,IAC1D9tB,EAAO,GAAK6tB,SAASvF,EAAIwF,OAAO,GAAKxF,EAAIwF,OAAO,GAAI,IAAM,IAC1D9tB,EAAO,GAAc,IAAT6S,EAAagb,SAASvF,EAAIwF,OAAO,GAAKxF,EAAIwF,OAAO,GAAI,IAAM,IAAM,IAE1E,IAQF,EAAAiC,2BAA2D,CACpEV,EACAO,GAGJ,MAAMI,EAAmC,EAAAD,2BAA2BE,OAChE,CAACh1B,EAAGE,IAAML,KAAKS,IAAIN,EAAGE,EAAE0X,MACxB,GAOS,EAAAqd,0BAA0D,CAACL,GAExE,MAAMM,EAAkC,EAAAD,0BAA0BD,OAC9D,CAACh1B,EAAGE,IAAML,KAAKS,IAAIN,EAAGE,EAAE0X,MACxB,GAQS,EAAAud,4BAA4D,IAClE,EAAAL,8BACA,EAAAG,2BAMM,EAAAG,kCAAoCv1B,KAAKS,IAClD40B,EACAH,GAGJ,MAAMM,EAAsB,IAAIz9B,MAAM,EAAAw9B,mCA4BtC,SAASE,EACLtZ,EACAuZ,EACAC,EAAwB,GAExB,MAAMC,EAAgBF,EAAQ7G,KAAKtG,KACxBA,EAAOmM,QAAQvY,EAAMqZ,IAGhC,QAAsB78B,IAAlBi9B,EAA6B,CAC7B,MAAMC,EAA8B,EAAAC,cAAc3Z,GAElD,OAAOpkB,MAAMC,QAAQ69B,KAAgBA,EAAWz6B,KAAKhH,GAAKyL,MAAMzL,IAC1D,EAAA8vB,WAAWgJ,eACP2I,EAAW,GAAK,IAChBA,EAAW,GAAK,IAChBA,EAAW,GAAK,IAChBA,EAAW,SAEfl9B,EAGV,OAAQi9B,aAAa,EAAbA,EAAervB,MACnB,KAAK+tB,EAAyB55B,OAC1B,OAAO86B,EAAU,GAAKG,EAC1B,KAAKrB,EAAyBU,IAC1B,OAAO,EAAA9Q,WAAWgJ,eACdsI,EAAU,GACVA,EAAU,GACVA,EAAU,GACVA,EAAU,IAElB,QACI,OAAOA,EAAU,IAnD7B,qCACIO,EACAJ,EAAwB,GAExB,OAAOF,EAAmBM,EAAS,EAAAT,4BAA6BK,IAUpE,mCAAwC/T,GACpC,OAAO6T,EAAmB7T,EAAO,EAAAwT,6B,oGC9GrC,MAAaY,EAMT,aAAavgC,GACT,OAAOA,aAAkBugC,EAQ7B,OAAO1hC,IAMP,QACI,MAAO,IAtBf,QA8CA,uBAA4B0hC,EACxB,YAAqBC,EAAoCC,GACrDv8B,QADiB,KAAAs8B,UAAoC,KAAAC,SASzD,OAAO5hC,GACH,GAAIqC,KAAKs/B,QAAQrgC,eAAetB,GAAO,CACnC,MAAMU,EAAQ2B,KAAKs/B,QAAQ3hC,GAC3B,QAAcqE,IAAV3D,EACA,OAAOA,EAGf,OAAO2B,KAAKu/B,OAASv/B,KAAKu/B,OAAOtS,OAAOtvB,QAAQqE,EAOpD,QACI,MAAMqF,EAAWrH,KAAKu/B,OAASv/B,KAAKu/B,OAAOC,QAAU,GACrD,IAAK,MAAM7gC,KAAOqB,KAAKs/B,QACft/B,KAAKs/B,QAAQrgC,eAAeN,KAC5B0I,EAAI1I,GAAOqB,KAAKs/B,QAAQ3gC,IAGhC,OAAO0I,K,uLC/Gf,SAAYo4B,GACR,2BACA,uBACA,qBACA,iCAJJ,CAAY,EAAAA,oBAAA,EAAAA,kBAAiB,KA+B7B,4CACIvgC,GAEA,SACIA,QACwB8C,IAAxB9C,EAAEwgC,mBACFt+B,MAAMC,QAAQnC,EAAEygC,SAChBzgC,EAAEygC,OAAOr+B,OAAS,QACFU,IAAhB9C,EAAEygC,OAAO,IACTv+B,MAAMC,QAAQnC,EAAE0gC,aAChB1gC,EAAE0gC,WAAWt+B,OAAS,QACFU,IAApB9C,EAAE0gC,WAAW,IACb1gC,EAAEygC,OAAOr+B,SAAWpC,EAAE0gC,WAAWt+B,SAYzC,oDACIvC,GAEA,QAA+BiD,IAA3BjD,EAAS8gC,eAA0D,aAA3B9gC,EAAS8gC,cAA8B,CAC/E,MAAMC,EAAiB,CAAC,OAAQ,CAAC,QAAS/gC,EAAS4gC,OAAO,IAC1D,IAAK,IAAIviC,EAAI,EAAGA,EAAI2B,EAAS6gC,WAAWt+B,SAAUlE,EAC9C0iC,EAAK55B,KAAKnH,EAAS6gC,WAAWxiC,GAAI2B,EAAS4gC,OAAOviC,IAEtD,OAAO0iC,EAEX,MAAMD,EAA0B,CAAC,eACjC,OAAQ9gC,EAAS8gC,eACb,IAAK,SACDA,EAAc35B,KAAK,CAAC,WACpB,MACJ,IAAK,QACD25B,EAAc35B,KAAK,CAAC,UACpB,MACJ,IAAK,cACD25B,EAAc35B,KAAK,CACf,mBACsBlE,IAAtBjD,EAASghC,SAAyBhhC,EAASghC,SAAW,IAE1D,MACJ,QACI,MAAM,IAAIt8B,MAAM,uBAAuB1E,EAAS8gC,mCAExDA,EAAc35B,KAAK,CAAC,SACpB,IAAK,IAAI9I,EAAI,EAAGA,EAAI2B,EAAS6gC,WAAWt+B,SAAUlE,EAC9CyiC,EAAc35B,KAAKnH,EAAS6gC,WAAWxiC,GAAI2B,EAAS4gC,OAAOviC,IAE/D,OAAOyiC,I,kLC3FX,aACA,QA4MA,6BAAkCG,GAC9B,MAAMC,EAAOD,EACb,MACoB,iBAATC,GACE,OAATA,IACsB,iBAAdA,EAAKrwB,WAA0C,IAAdqwB,EAAKrwB,QACvB,iBAAfqwB,EAAK5hC,OACa,iBAAf4hC,EAAK5hC,OACU,kBAAf4hC,EAAK5hC,OACZ,EAAAwI,iCAAiCo5B,EAAK5hC,QACtC,EAAA6C,WAAW++B,EAAK5hC,SAI5B,+BAAoC2hC,GAChC,MAAsB,iBAARA,GAAmC,iBAARA,GAAmC,kBAARA,GAsKxE,+BAAoC3hC,GAChC,OACI+C,MAAMC,QAAQhD,IACG,IAAjBA,EAAMiD,QACO,QAAbjD,EAAM,IACc,iBAAbA,EAAM,IAoBrB,sCAA2C2hC,GACvC,MAAME,EAAWF,EACjB,MACwB,iBAAbE,GACM,OAAbA,IACC9+B,MAAMC,QAAQ6+B,IACe,iBAAvBA,EAAS5T,Y,4GClaxB,SAAiB6T,GAIA,EAAAC,kBAA4B,EAI5B,EAAAC,kBAA4B,EAO5B,EAAAC,oBAAsB,IAfvC,CAAiB,EAAAH,uBAAA,EAAAA,qBAAoB,M,mICArC,aACA,OACA,OAIA,QAIA,QACA,QACA,SACA,SACA,SACA,QAEM3zB,EAAS,EAAAC,cAAcxM,SAASvB,OAAO,QA0E7C,IAAY6hC,EAjBZ,8BAAmC1e,GAC/B,IAAI2e,EAN+B,IAgBnC,YAR2Bx+B,IAAvB6f,EAAY4e,SACZD,GAAwC,EAA5B3e,EAAY4e,OAAOn/B,aAENU,IAAzB6f,EAAY6e,WAEZF,GAdqC,GAczB3e,EAAY6e,SAASp/B,QAG9Bk/B,GAMX,SAAYD,GACR,iCACA,yBACA,uBACA,2BACA,qBACA,2BACA,uBAPJ,CAAYA,EAAA,EAAAA,kBAAA,EAAAA,gBAAe,KA6F3B,aAsII,YACaI,EACA/c,EACTC,EAAiB,EACjB3O,GAHS,KAAAyrB,aACA,KAAA/c,UApIJ,KAAAgd,QAAwB,GAMxB,KAAA9gC,aAAyB,IAAIsB,MAmBtC,KAAAy/B,uBAAiC,EAKjC,KAAAC,iBAA2B,EAO3B,KAAAC,qBAA+B,EAK/B,KAAAC,iBAA2B,EAO3B,KAAAC,mBAA6B,EAW7B,KAAAC,YAAsB,EAQtB,KAAAC,eAAgB,EAYC,KAAAC,cAAgB,IAAI,EAAAC,aAE7B,KAAAC,YAAsB,EAEtB,KAAAC,qBAAsB,EAEtB,KAAAC,wBAA0Cx/B,EAQ1C,KAAAy/B,oBAAsB,IAAI,EAAAC,6BAGjB,KAAAC,uBAAgD,GAOhD,KAAAC,cAAgB,IAAIxiC,EAAMuG,QACnC,KAAAk8B,cAAwB,EAEf,KAAAC,iBAAmC,CAAEhO,aAAc,EAAGC,aAAc,GAO7E,KAAAgO,gBAA0C,IAAIC,QAsBlDhiC,KAAKk2B,OAASl2B,KAAK2gC,WAAWsB,kBAAkB7L,UAAUp2B,KAAK4jB,SAC/D5jB,KAAKkiC,oBACLliC,KAAK4hC,cAActyB,KAAKtP,KAAKmiC,YAAYp0B,UACzC/N,KAAKuhC,yBAA4Cv/B,IAAtBkT,GAAkCA,EAC7DlV,KAAKoiC,iBAAmB,IAAI,EAAAC,mBAAmBriC,MAC/CA,KAAKsiC,SAAWze,EAChB7jB,KAAKuiC,YAAc,EAAA7e,gBAAgBC,0BAA0B3jB,KAAK4jB,QAAS5jB,KAAK6jB,QAOpF,gBAKI,OAAO7jB,KAAK6gC,uBAAyB7gC,KAAK2gC,WAAWzyB,QAAQs0B,YAAc,EAG/E,cAAcpc,GACVpmB,KAAK6gC,sBAAwBza,EAAUpmB,KAAK2gC,WAAWzyB,QAAQs0B,aAAe,EAMlF,iBACI,OAAOxiC,KAAK2gC,WAAWxxB,WAM3B,cACI,OAAOnP,KAAK2gC,WAAWzyB,QAS3B,wBACI,OAAOlO,KAAKuhC,oBAMhB,kBAII,YAH4Bv/B,IAAxBhC,KAAKyiC,gBACLziC,KAAK0iC,sBAEF1iC,KAAKyiC,eAAgB/qB,SAMhC,aACI,OAAO1X,KAAK4hC,cAUhB,gBACI,OAAO5hC,KAAKuiC,YAOhB,aACI,OAAOviC,KAAKsiC,SAQhB,WAAWze,GACH7jB,KAAKsiC,WAAaze,IAClB7jB,KAAKuiC,YAAc,EAAA7e,gBAAgBC,0BAA0B3jB,KAAK4jB,QAASC,IAE/E7jB,KAAKsiC,SAAWze,EASpB,kBAII,YAH4B7hB,IAAxBhC,KAAKyiC,gBACLziC,KAAK0iC,sBAEF1iC,KAAKyiC,eAOhB,yBACIziC,KAAKyiC,oBAAiBzgC,EAQ1B,gBAAgBmV,GACZnX,KAAK+hC,gBAAgB5hC,IAAIgX,GAU7B,uBACI,IAAIwrB,EAAQ3iC,KAAKyhC,oBAAoBmB,OAAO3kC,IAAI,EAAAsnB,YAAYsC,kBAK5D,YAJc7lB,IAAV2gC,IACAA,EAAQ,IAAI,EAAAE,iBAAiB,EAAAtd,YAAYsC,kBACzC7nB,KAAKyhC,oBAAoBmB,OAAO57B,IAAI27B,EAAMhd,SAAUgd,IAEjDA,EAcX,mBAAmBG,GACfA,EAAYnd,SAAW,EAAAJ,YAAYsC,iBACnC7nB,KAAK+iC,eAAeD,GAWxB,sBAAsBA,GAElB,OADAA,EAAYnd,SAAW,EAAAJ,YAAYsC,iBAC5B7nB,KAAKgjC,kBAAkBF,GAclC,eAAeA,GACX9iC,KAAKijC,kBAAkB9iC,IAAI2iC,IAEQ,IAA/B9iC,KAAKkjC,wBAILljC,KAAKyhC,oBAAsBzhC,KAAKijC,kBAAkBp2B,SAEtD7M,KAAKmjC,qBAAsB,EAS/B,mBAAmBC,GACfpjC,KAAK2hC,uBAAuBz7B,KAAKk9B,GAarC,kBAAkBN,GACd,MAAMF,EAAS5iC,KAAKijC,kBACpB,QAAKL,EAAOS,OAAOP,MAGgB,IAA/B9iC,KAAKkjC,wBAILljC,KAAKyhC,oBAAsBmB,EAAO/1B,SAEtC7M,KAAKmjC,qBAAsB,GACpB,GAUX,wBACI,OAAOnjC,KAAKyhC,oBAShB,0B,MACI,OAAiC,QAAjC,EAAOzhC,KAAKkjC,6BAAqB,SAGrC,wBAAwBI,GACpBtjC,KAAKkjC,sBAAwBI,EAMjC,kBACI,OAAOtjC,KAAKyhC,oBAAoB1nB,QAAU,EAM9C,uBACI,OAAO/Z,KAAK2hC,uBAUhB,WAAW4B,GACP,OAAQvjC,KAAKmhC,cAMjB,aAOA,kBACI,OAAOnhC,KAAK6hC,cAGhB,gBAAgB2B,GACZxjC,KAAK6hC,cAAgB2B,OACGxhC,IAApBhC,KAAK2iB,YACL3iB,KAAK2iB,WAAW8gB,eAAeD,GAQvC,qBACI,OAAOxjC,KAAK8hC,iBAShB,mBAAmBjO,G,MAEXA,EAAeC,eAAiB9zB,KAAK8hC,iBAAiBhO,cACtDD,EAAeE,eAAiB/zB,KAAK8hC,iBAAiB/N,cACtDF,EAAe6P,oBAAsB1jC,KAAK8hC,iBAAiB4B,oBAK/D1jC,KAAK8hC,iBAAiBhO,aAAeD,EAAeC,aACpD9zB,KAAK8hC,iBAAiB/N,aAAeF,EAAeE,aACpD/zB,KAAK8hC,iBAAiB4B,kBAAoB7P,EAAe6P,kBACzD1jC,KAAK2jC,qBAI4B3hC,IAA7BhC,KAAK4jC,sBACL,EAAAt3B,YAAyCtK,KAAlB,QAAhB,EAAAhC,KAAK6jC,mBAAW,eAAE1B,cACzBniC,KAAKkiC,sBAOb,kBACI,OAAOliC,KAAK8jC,cAShB,gBAAgBD,G,MAIZ,GAHA7jC,KAAK8jC,cAAgBD,EACrB7jC,KAAK+jC,8BAEe/hC,IAAhB6hC,EACA,OAGkC,IAAlCA,EAAYjiB,WAAWtgB,QACvBtB,KAAKgkC,kBAAiB,GAM1BhkC,KAAK4jC,oBAAsBC,EAAY1B,iBACjCngC,EAC6B,QAA9B,EAAC6hC,EAAYI,yBAAiB,QAAI,EACvCjkC,KAAK2jC,gBACL3jC,KAAKkiC,kBAAkB2B,EAAY1B,aAEnC,MAAM+B,EAAQ,EAAAC,sBAAsBlkC,SAChCikC,EAAMllB,cAAsChd,IAA3B6hC,EAAYO,aAC7BF,EAAMG,aAAaC,SAAS,sBAAuBT,EAAYO,YAC/DF,EAAMG,aAAaC,SAAS,sBAAuB,SAGhBtiC,IAAnC6hC,EAAYU,qBACZvkC,KAAKwkC,cAAgBX,EAAYU,mBAAmBx+B,IAAIgpB,IAAM,CAAGA,SAGrE/uB,KAAK2gC,WAAW8D,gBAMpB,oBACIzkC,KAAK8jC,mBAAgB9hC,EACrBhC,KAAK+jC,yBAWT,mBAYA,4BAA4BjlC,GACxB,OAAO,EAWX,4BAA4BA,GACxB,OAAO,EAUX,qBAAqBqY,GACjB,OAAOnX,KAAK+hC,gBAAgBx7B,IAAI4Q,GAMpC,eACI,OAAOnX,KAAKshC,WAMhB,yBACI,OAAOthC,KAAK0kC,qBAShB,uBAAuB7hB,GACnB7iB,KAAK0kC,qBAAuB7hB,EAMhC,0BACI,YAAqC7gB,IAA9BhC,KAAK0kC,qBACN1kC,KAAK2kC,YACL3kC,KAAK0kC,qBAAqBE,qBAAuB5kC,KAAK0kC,qBAAqB9hB,WAMrF,wBACI,YAAqC5gB,IAA9BhC,KAAK0kC,qBACN1kC,KAAK2kC,YACL3kC,KAAK0kC,qBAAqBG,mBAAqB7kC,KAAK0kC,qBAAqB9hB,WASnF,kBACI,YAAgC5gB,IAA5BhC,KAAKwhC,mBAC0B,IAAxBxhC,KAAK4gC,QAAQt/B,OAEbtB,KAAKwhC,mBASpB,iBAAiBnjC,GACb2B,KAAKwhC,mBAAqBnjC,EAO9B,yBACI2B,KAAKihC,mBAAqB,EAM9B,iBACI,OAAOjhC,KAAK8kC,aAShB,eAAeniB,GACX3iB,KAAK8kC,aAAeniB,EAMxB,OACI,MAAMA,EAAa3iB,KAAK2iB,gBACL3gB,IAAf2gB,GAIJA,EACKoiB,gBACAC,KAAKC,IACF,EAAA34B,OAAO24B,IAAoB1E,EAAgB2E,OAC3C,MAAMrB,EAAclhB,EAAWkhB,YAC/B7jC,KAAK6jC,YAAcA,IAEtBsB,MAAMF,IAECA,IAAoB1E,EAAgB6E,UACpCH,IAAoB1E,EAAgB8E,QAEpC74B,EAAO+R,MAAM,gBAAkB0mB,KAS/C,qBACI,OAAOjlC,KAAKoiC,iBAWhB,QACI,MAAMkD,EAAmB76B,IACrB3M,OAAOy0B,oBAAoB9nB,GAAUpK,QAAStB,IAC1C,MAAMwmC,EAAoB96B,EAAiB1L,GAC3C,QAAyBiD,IAArBujC,GAAkCA,aAA4BnmC,EAAM8Y,QAAS,CAC7E,MAAMf,EAAUouB,EACZvlC,KAAKwlC,qBAAqBruB,IAC1BA,EAAQsuB,aAIpBh7B,EAASg7B,WAGPC,EAAiB5mC,IACnB,GAAIkB,KAAK2lC,4BAA4B7mC,UACTkD,IAApBlD,EAAOob,UACPpb,EAAOob,SAASurB,eAGMzjC,IAAtBlD,EAAO8iB,YACP,IAAK,MAAM1H,KAAYpb,EAAO8iB,WAC1B1H,EAASurB,eAKGzjC,IAApBlD,EAAO2L,UAA0BzK,KAAK4lC,4BAA4B9mC,KAC9DA,EAAO2L,oBAAoBrJ,MAC3BtC,EAAO2L,SAASpK,QAASoK,SACJzI,IAAbyI,GACA66B,EAAgB76B,KAIxB66B,EAAgBxmC,EAAO2L,YAKnCzK,KAAK4gC,QAAQvgC,QAASwlC,IAClBA,EAAWC,SAAUhnC,IACjB4mC,EAAc5mC,KAGlB4mC,EAAcG,KAElB7lC,KAAK4gC,QAAQt/B,OAAS,EAElBtB,KAAK+lC,oBACL/lC,KAAK+lC,kBAAoB,IAG7B/lC,KAAKoiC,iBAAiB4D,QACtBhmC,KAAKimC,oBACLjmC,KAAK+jC,yBAMT,oBACS/jC,KAAKkmC,oBAGVlmC,KAAKmjC,qBAAsB,EAC3BnjC,KAAK2hC,uBAAuBwE,OAAO,GACnCnmC,KAAKijC,kBAAkB+C,SAS3B,mBAAmBI,GACfpmC,KAAKqmC,kBAAoB,EAAAC,eAAetmC,KAAKqmC,kBAAmBD,GAMpE,UACQpmC,KAAKshC,aAGLthC,KAAK8kC,eACL9kC,KAAK8kC,aAAayB,SAClBvmC,KAAK8kC,kBAAe9iC,QAEUA,IAA9BhC,KAAK0kC,uBACL1kC,KAAK0kC,qBAAqBe,UAC1BzlC,KAAK0kC,0BAAuB1iC,GAEhChC,KAAKgmC,QACLhmC,KAAKshC,YAAa,EAElBthC,KAAK6gC,sBAAwB,EACzB7gC,KAAKqmC,mBACLrmC,KAAKqmC,kBAAkBrmC,OAS/B,sBACI,OAAOA,KAAKmP,WAAWq3B,YAAY,EAAG,GAAG18B,IAAIrE,EAAIzF,KAAK6jB,OAO1D,OAAOjN,GACH,IAAK,MAAM9X,KAAUkB,KAAK4gC,QAClB9hC,aAAkB,EAAA2nC,SAClB3nC,EAAO4nC,iBAAiB9vB,EAAY5W,KAAK4jB,QAAQhI,OAQ7D,kBACI,OAAO5b,KAAKohC,cAQR,kBAAkBuF,GAClBA,GACA3mC,KAAKohC,cAAc9xB,KAAKq3B,GACxB3mC,KAAK4hC,cAActyB,KAAKtP,KAAKmiC,YAAYp0B,WAEzC/N,KAAKmP,WAAW0sB,WAAW77B,KAAKk2B,OAAQl2B,KAAKmiC,aAO7C,gB,MACJniC,KAAKk2B,OAAOpB,UAAUzsB,SAAWrI,KAAK8hC,iBAAiBhO,aACvD9zB,KAAKk2B,OAAOnB,UAAU1sB,SAClBrI,KAAK8hC,iBAAiB/N,cAAwC,QAAzB,EAAC/zB,KAAK4jC,2BAAmB,QAAI,GAGlE,sBACJ,IAAIlsB,EAAW,EACXkvB,EAAe,EACfC,EAAkB,EAEtB,MAAMC,EAAoB,CACtBpvB,SAAU,EACVC,QAAS,GAKPN,EAAuC,IAAIlV,IAEjD,IAAK,MAAMrD,KAAUkB,KAAK4gC,QAClB9hC,EAAOsnB,SACPwgB,IAEJ,EAAA54B,aAAakT,qBAAqBpiB,EAAQgoC,EAAmBzvB,GAGjE,IAAK,MAAMsrB,KAAS3iC,KAAKijC,kBAAkBL,OACvCiE,GAAmBlE,EAAM,GAAGoE,SAASzlC,OAKzCoW,GAA8B,IAAlBmvB,OAEe7kC,IAAvBhC,KAAK8jC,oBAA+D9hC,IAAhChC,KAAK8jC,cAAckD,WACvDF,EAAkBpvB,UAAY1X,KAAK8jC,cAAckD,SAASxG,UAG9DxgC,KAAKyiC,eAAiB,CAClB/qB,SAAUovB,EAAkBpvB,SAAWA,EACvCC,QAASmvB,EAAkBnvB,QAC3BivB,eACAC,kBACAI,oBAAqB,M,+PCjkCjC,aAGMz6B,EAAS,EAAAC,cAAcxM,SAASvB,OAAO,cAM7C,MAAawoC,EAWT,YAAqBC,GAAA,KAAAA,WACjBnnC,KAAK0wB,OAAS,IAAItvB,MAAM+lC,GACxBnnC,KAAKmnC,SAAWA,EAChBnnC,KAAKonC,KAAOpnC,KAAKqnC,KAAOrnC,KAAKohB,KAAO,EAMxC,QACIphB,KAAKonC,KAAOpnC,KAAKqnC,KAAOrnC,KAAKohB,KAAO,EAQxC,OAAOkmB,GACH,IAAIC,EAAOvnC,KAAKonC,KAAO,EACnBG,GAAQvnC,KAAKmnC,WACbI,EAAO,GAEPvnC,KAAKohB,KAAOphB,KAAKmnC,UACjBnnC,KAAKohB,OAGTphB,KAAK0wB,OAAO1wB,KAAKonC,MAAQE,EACzBtnC,KAAKonC,KAAOG,EAERvnC,KAAKohB,OAASphB,KAAKmnC,WACnBnnC,KAAKqnC,KAAOrnC,KAAKonC,MASzB,OAAOE,GACH,IAAK,MAAMnmC,KAAKmmC,EACZtnC,KAAKwnC,OAAOrmC,GAQpB,MACI,GAAkB,IAAdnB,KAAKohB,KACL,MAAM,IAAI3d,MAAM,uBAGpB,MAAM6jC,EAAOtnC,KAAK0wB,OAAO1wB,KAAKqnC,MAC9B,IAAIE,EAAOvnC,KAAKqnC,KAAO,EASvB,OARIE,GAAQvnC,KAAKmnC,WACbI,EAAO,GAEPvnC,KAAKohB,KAAO,GACZphB,KAAKohB,OAGTphB,KAAKqnC,KAAOE,EACLD,EAOX,UACI,GAAkB,IAAdtnC,KAAKohB,KACL,MAAM,IAAI3d,MAAM,uBAGpB,OAAOzD,KAAK0wB,OAAO1wB,KAAKqnC,MAO5B,aACI,GAAkB,IAAdrnC,KAAKohB,KACL,MAAM,IAAI3d,MAAM,uBAGpB,IAAIgkC,EAAWznC,KAAKonC,KAAO,EAI3B,OAHIK,EAAW,IACXA,EAAWznC,KAAKmnC,SAAW,GAExBnnC,KAAK0wB,OAAO+W,GAMvB,WACI,OAAO,IAAIP,EAAWQ,SAAY1nC,MAMtC,UACI,MAAM2Z,EAAQ,IAAIvY,MAClB,IAAK,IAAIhE,EAAI,EAAGA,EAAI4C,KAAKohB,KAAMhkB,IAC3Buc,EAAMzT,KAAKlG,KAAK0wB,QAAQ1wB,KAAKqnC,KAAOjqC,GAAK4C,KAAKmnC,WAElD,OAAOxtB,GA1Hf,eA8HA,SAAiButB,GAIA,EAAAQ,SAAb,MAOI,YAAoBC,EAAiCC,EAAkB,GAAnD,KAAAD,WAAiC,KAAAC,UAMrD,YACI,OAAO5nC,KAAK2nC,SAASjX,QAChB1wB,KAAK2nC,SAASN,KAAOrnC,KAAK4nC,SAAW5nC,KAAK2nC,SAASR,UAS5D,OAEI,OADAnnC,KAAK4nC,UACE5nC,KAAK4nC,QAAU5nC,KAAK2nC,SAASvmB,OA9BhD,CAAiB8lB,EAAA,EAAAA,aAAA,EAAAA,WAAU,KA8E3B,MAAaW,EAMT,YAAmBC,EAAiCnqC,GAAjC,KAAAmqC,aAAiC,KAAAnqC,OAJpD,KAAAoqC,SAAU,EAUV,YACI,OAAO/nC,KAAKgoC,eAShB,SAASlO,GACL95B,KAAKgoC,eAAiBlO,EAM1B,QACI95B,KAAKgoC,oBAAiBhmC,EAM1B,QACI,IAAKhC,KAAK8nC,WAAW9oB,QACjB,OAAQ,EAEZ,GAAIhf,KAAK+nC,QACL,MAAM,IAAItkC,MAAM,UAAYzD,KAAKrC,KAAO,wBAG5C,OADAqC,KAAK+nC,SAAU,EACP/nC,KAAKgoC,eAAiB,EAAAC,iBAAiBC,MAMnD,OACI,IAAKloC,KAAK8nC,WAAW9oB,QACjB,OAAQ,EAEZ,GAAKhf,KAAK+nC,QAEH,CAEH,MAAMzpC,EAAI,EAAA2pC,iBAAiBC,OAASloC,KAAKgoC,gBAAkB,GAI3D,OAHAhoC,KAAKgoC,eAAiB1pC,EACtB0B,KAAKmoC,SAAS7pC,GACd0B,KAAK+nC,SAAU,EACRzpC,EAPP,MAAM,IAAImF,MAAM,UAAYzD,KAAKrC,KAAO,0BAgBhD,MACI,IAAKqC,KAAK8nC,WAAW9oB,QACjB,OAAQ,EAEZ,GAAKhf,KAAK+nC,QAEH,CAEH,OADU,EAAAE,iBAAiBC,OAASloC,KAAKgoC,gBAAkB,GAF3D,MAAM,IAAIvkC,MAAM,UAAYzD,KAAKrC,KAAO,2BA5EpD,gBAmJA,MAAayqC,UAAqBP,EAuB9B,YAAmBC,EAAiCnqC,GAChDqF,MAAM8kC,EAAYnqC,GADH,KAAAmqC,aAAiC,KAAAnqC,OAnBpD,KAAA0qC,UAAY,EAMZ,KAAAC,cAAgB,IAKhB,KAAAC,QAAU,IAAIrB,EAAmBlnC,KAAKsoC,eAgBtC,QACItlC,MAAMwlC,QACNxoC,KAAKyoC,WACLzoC,KAAKuoC,QAAQvC,QACbhmC,KAAKqoC,YAST,SAASvO,GACL92B,MAAMmlC,SAASrO,QAEH93B,IAAR83B,GACA95B,KAAKuoC,QAAQf,OAAO1N,GAQ5B,WACI,OAAO4O,EAAkB1oC,KAAKuoC,QAAQI,YAc9C,SAAgBD,EAAkBH,GAC9B,GAAuB,IAAnBA,EAAQjnC,OACR,OAGJinC,EAAQK,KAAK,CAACp/B,EAAWE,IACdF,EAAIE,GAGf,MAAME,EAAc2+B,EAAQ,GACtBz+B,EAAcy+B,EAAQA,EAAQjnC,OAAS,GAC7C,IAAIunC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAEJ,GAAuB,IAAnBZ,EAAQjnC,OACRwnC,EAAWC,EAAWC,EAAWC,EAAWC,EAAWC,EAAYN,EAASN,EAAQ,QACjF,GAAuB,IAAnBA,EAAQjnC,OACfunC,EAAsB,GAAbN,EAAQ,GAAwB,GAAbA,EAAQ,GACpCO,EAAWC,EAAWC,EAAWC,EAAWC,EAAWC,EAAYZ,EAAQ,OACxE,CACH,MAAMa,EAAM//B,KAAKmtB,MAAM+R,EAAQjnC,OAAS,GACxCunC,EACIN,EAAQjnC,OAAS,GAAM,EAAuB,GAAnBinC,EAAQa,EAAM,GAA0B,GAAfb,EAAQa,GAAab,EAAQa,GAGrFN,EAAWP,EADGl/B,KAAKggC,MAAuB,IAAjBd,EAAQjnC,QAAiB,GAGlDynC,EAAWR,EADGl/B,KAAKggC,MAAuB,GAAjBd,EAAQjnC,QAAgB,GAGjD0nC,EAAWT,EADGl/B,KAAKggC,MAAuB,IAAjBd,EAAQjnC,QAAiB,GAGlD2nC,EAAWV,EADGl/B,KAAKggC,MAAuB,IAAjBd,EAAQjnC,QAAiB,GAGlD4nC,EAAWX,EADGl/B,KAAKggC,MAAuB,IAAjBd,EAAQjnC,QAAiB,GAGlD6nC,EAAYZ,EADGl/B,KAAKggC,MAAuB,KAAjBd,EAAQjnC,QAAkB,GAIxD,IAAIgoC,EAAM,EAEV,IAAK,IAAIlsC,EAAI,EAAGC,EAAIkrC,EAAQjnC,OAAQlE,EAAIC,EAAGD,IACvCksC,GAAOf,EAAQnrC,GAKnB,MAAO,CACHwM,MACAE,MACAy/B,IALQD,EAAMf,EAAQjnC,OAMtBunC,SACAC,WACAC,WACAC,WACAC,WACAC,WACAC,YACAK,WAAYjB,EAAQjnC,QArI5B,iBAuEA,sBA2EA,+BAAoCinC,GAChC,GAAuB,IAAnBA,EAAQjnC,OACR,OAGJ,IAAIgoC,EAAM,EAEV,IAAK,IAAIlsC,EAAI,EAAGC,EAAIkrC,EAAQjnC,OAAQlE,EAAIC,EAAGD,IACvCksC,GAAOf,EAAQnrC,GAKnB,OAFYksC,EAAMf,EAAQjnC,QAa9B,wBAUI,YAAoBwmC,EAAiCnqC,EAAqB8rC,GACtE,GADgB,KAAA3B,aAAiC,KAAAnqC,OAAqB,KAAA8rC,SAClEA,EAAOnoC,OAAS,EAChB,MAAM,IAAImC,MAAM,gCAGpBgmC,EAAOppC,QAAQqpC,IACX,IAAK5B,EAAW6B,SAASD,GACrB,MAAM,IAAIjmC,MAAM,kBAAoBimC,KAShD,YACI,OAAO1pC,KAAK8nC,WAAW8B,SAAS5pC,KAAKypC,OAAOzpC,KAAKypC,OAAOnoC,OAAS,IAAIjD,MAMzE,QACS2B,KAAK8nC,WAAW9oB,SAGrBhf,KAAKypC,OAAOppC,QAAQqpC,IAChB1pC,KAAK8nC,WAAW8B,SAASF,GAAOlB,UAOxC,QAGI,OAFAxoC,KAAK0pC,MAAQ1pC,KAAKypC,OAAO,GAElBzpC,KAAK8nC,WAAW8B,SAAS5pC,KAAKypC,OAAO,IAAIprC,QAAU,EAO9D,OAEI,OADA2B,KAAK0pC,WAAQ1nC,OACSA,IAAfhC,KAAK3B,MAAsB2B,KAAK3B,OAAS,EAMpD,YACI,OAAO2B,KAAK6pC,aAUhB,UAAUH,GACF1pC,KAAK6pC,eAAiBH,IAItB1pC,KAAK8nC,WAAW9oB,cAAiChd,IAAtBhC,KAAK6pC,cAChC7pC,KAAK8nC,WAAW8B,SAAS5pC,KAAK6pC,cAAcC,OAGhD9pC,KAAK6pC,aAAeH,EAEhB1pC,KAAK8nC,WAAW9oB,cAAiChd,IAAtBhC,KAAK6pC,cAChC7pC,KAAK8nC,WAAW8B,SAAS5pC,KAAK6pC,cAAcE,WASxD,mBAWI,YAAmBpsC,EAAsBqhB,GAAU,GAAhC,KAAArhB,OAAsB,KAAAqhB,UACrChf,KAAKgqC,OAAS,IAAI7nC,IAClBnC,KAAKiqC,UAAY,IAAIpC,EAAY7nC,KAAM,UAQ3C,YAAYrC,EAAcusC,GAAc,GACpC,MAAMC,EAAQD,EAAc,IAAI9B,EAAapoC,KAAMrC,GAAQ,IAAIkqC,EAAY7nC,KAAMrC,GAEjF,OAAOqC,KAAKoqC,SAASD,GAQzB,SAASA,GACL,QAAoCnoC,IAAhChC,KAAKgqC,OAAO/rC,IAAIksC,EAAMxsC,MACtB,MAAM,IAAI8F,MAAM,0BAA4B0mC,EAAMxsC,KAAO,KAK7D,OAFAqC,KAAKgqC,OAAOhjC,IAAImjC,EAAMxsC,KAAMwsC,GAErBA,EAQX,SAASxsC,GACL,IAAKqC,KAAKgf,QACN,OAAOhf,KAAKiqC,UAGhB,MAAM3rC,EAAI0B,KAAKgqC,OAAO/rC,IAAIN,GAC1B,YAAaqE,IAAN1D,EAAkB0B,KAAKiqC,UAAY3rC,EAS9C,SAASX,GAEL,YAAaqE,IADHhC,KAAKgqC,OAAO/rC,IAAIN,GAO9B,QACIqC,KAAKgqC,OAAO3pC,QAAS8pC,IACjBA,EAAM3B,UAUd,IAAI6B,EAAiBC,QACFtoC,IAAXqoC,QAAsCroC,IAAdhC,KAAKrC,MAC7B6O,EAAOytB,SAAej4B,IAAXqoC,EAAuBA,EAASrqC,KAAKrC,MAGpD,IAAI4sC,EAAgB,EAEpBvqC,KAAKgqC,OAAO3pC,QAAS8pC,IACjBI,EAAgBlhC,KAAKS,IAAIygC,EAAeJ,EAAMxsC,KAAK2D,UAIvD,MAAMkpC,EAASrpC,QACEa,IAANb,EAAkBA,EAAEspC,QAAQ,GAAK,IAG5CzqC,KAAKgqC,OAAO3pC,QAAS8pC,IACjB,IAAIhrC,EAAIgrC,EAAMxsC,KAAO,KAAO,IAAIsyB,OAAOsa,EAAgBJ,EAAMxsC,KAAK2D,QAIlE,GAHAnC,GAAKqrC,EAAML,EAAM9rC,OAGb8rC,aAAiB/B,EAAc,CAC/B,MAAMsC,EAAcP,EAAM1B,gBACNzmC,IAAhB0oC,IACAvrC,GACI,WAAWqrC,EAAME,EAAY9gC,aAAa4gC,EAAME,EAAY5gC,SAC5D,OAAO0gC,EAAME,EAAYnB,aAAaiB,EAAME,EAAY7B,YACxD,SAAS2B,EAAME,EAAY1B,oBAAoBwB,EAC3CE,EAAYxB,cAEhB,KAAKsB,EAAME,EAAYlB,iBAGnCh9B,EAAOytB,IAAI96B,UAGA6C,IAAXsoC,GACA99B,EAAOytB,IAAIqQ,KAQvB,MAAaK,EAAb,cACa,KAAArL,QAA+B,IAAIn9B,IAC5C,KAAAyoC,cAAsB5oC,EAStB,SAASrE,GACL,OAAOqC,KAAKs/B,QAAQrhC,IAAIN,GAS5B,SAASA,EAAcU,GACnB2B,KAAKs/B,QAAQt4B,IAAIrJ,EAAMU,GAU3B,SAASV,EAAcU,GACnB,MAAMwsC,EAAW7qC,KAAKs/B,QAAQrhC,IAAIN,GAClCqC,KAAKs/B,QAAQt4B,IAAIrJ,EAAMU,QAAsB2D,IAAb6oC,EAAyB,EAAIA,IAQjE,WAAWC,QACe9oC,IAAlBhC,KAAK4qC,WACL5qC,KAAK4qC,SAAW,IAEpB5qC,KAAK4qC,SAAS1kC,KAAK4kC,GAMvB,QACI9qC,KAAKs/B,QAAQj/B,QAAQ,CAAChC,EAAeV,KACjCqC,KAAKs/B,QAAQt4B,IAAIrJ,EAAM,KAG3BqC,KAAK4qC,cAAW5oC,GAzDxB,eAoEA,MAAa+oC,EAIT,YAAqB5D,EAAmB,GAAnB,KAAAA,WAHZ,KAAA6D,aAAgD,IAAI7oC,IAIzDnC,KAAK4qC,SAAW,IAAI1D,EAAiCC,GAGzD,aACI,OAAOnnC,KAAK4qC,SAASxpB,KAGzB,QACIphB,KAAKgrC,aAAa3qC,QAAQ,CAACqwB,EAA4B/yB,KACnD+yB,EAAOsV,UAEXhmC,KAAK4qC,SAAS5E,QAGlB,SAASiF,GACL,MAAMC,EAAclrC,KAAKsB,OACnB0pC,EAAehrC,KAAKgrC,aAE1BC,EAAW3L,QAAQj/B,QAAQ,CAAChC,EAAeV,KACvC,IAAI+yB,EAASsa,EAAa/sC,IAAIN,GAE9B,QAAeqE,IAAX0uB,EAAsB,CAItBA,EAAS,IAAIwW,EAAmBlnC,KAAKmnC,UACrC,IAAK,IAAI/pC,EAAI,EAAGA,EAAI8tC,EAAa9tC,IAC7BszB,EAAO8W,OAAO,GAElBxnC,KAAKgrC,aAAahkC,IAAIrJ,EAAM+yB,GAEhCA,EAAO8W,OAAOnpC,KAGlB2B,KAAK4qC,SAASO,IAAIF,EAAWL,UAMjC,MACI,IAAIL,EAAgB,EACpBvqC,KAAKgrC,aAAa3qC,QAAQ,CAACqwB,EAA4B/yB,KACnD4sC,EAAgBlhC,KAAKS,IAAIygC,EAAe5sC,EAAK2D,UAIjD,MAAMkpC,EAASrpC,QACEa,IAANb,EAAkBA,EAAEspC,QAAQ,GAAK,IAG5CzqC,KAAKgrC,aAAa3qC,QAAQ,CAACqwB,EAA4B/yB,KACnD,IAAIwB,EAAIxB,EAAO,KAAO,IAAIsyB,OAAOsa,EAAgB5sC,EAAK2D,QAEtD,MAAMopC,EAAchC,EAAkBhY,EAAOiY,gBACzB3mC,IAAhB0oC,IACAvrC,GACI,WAAWqrC,EAAME,EAAY9gC,aAAa4gC,EAAME,EAAY5gC,SAC5D,OAAO0gC,EAAME,EAAYnB,aAAaiB,EAAME,EAAY7B,YACxD,SAAS2B,EAAME,EAAY1B,oBAAoBwB,EAAME,EAAYxB,cACjE,KAAKsB,EAAME,EAAYlB,iBAE/Bh9B,EAAOytB,IAAI96B,MAnEvB,oBAkGA,kBAAaglC,EAsET,YAAmBnlB,GAAU,EAAaosB,EAAe,KAAtC,KAAApsB,UAAuB,KAAAosB,eAvCjC,KAAA/G,aAA2B,IAAIsG,EAkB/B,KAAAU,WAAkC,IAAIlpC,IAStC,KAAAmpC,QAA+B,IAAInpC,IAaxCgiC,EAAsBoH,WAAavrC,KACnCA,KAAKwrC,cAAgB,IAAIT,EAAgBK,GAhE7C,aACI,OAAOprC,KAAKwrC,cAAclqC,QAAUtB,KAAKorC,aAM7C,sBAII,YAHyCppC,IAArCmiC,EAAsBoH,aACtBpH,EAAsBoH,WAAa,IAAIpH,GAAsB,EAAO,IAEjEA,EAAsBoH,WAoBjC,kBACI,OAAOvrC,KAAKwrC,cAwChB,QACIxrC,KAAKyrC,cACLzrC,KAAKsrC,QAAQtF,QACbhmC,KAAKqrC,WAAWrF,QAQpB,cACIhmC,KAAKwrC,cAAchD,QACnBxoC,KAAKqkC,aAAamE,QAOtB,aAAakD,QACgB1pC,IAArB0pC,EAAU1S,SACVh5B,KAAKqkC,aAAa8D,SACd,cAC2B,OAA3BuD,EAAU1S,OAAO2S,MAAiB,EAAID,EAAU1S,OAAO2S,OAE3D3rC,KAAKqkC,aAAa8D,SACd,eAC4B,OAA5BuD,EAAU1S,OAAO1nB,OAAkB,EAAIo6B,EAAU1S,OAAO1nB,QAE5DtR,KAAKqkC,aAAa8D,SACd,cAC2B,OAA3BuD,EAAU1S,OAAO4S,MAAiB,EAAIF,EAAU1S,OAAO4S,OAE3D5rC,KAAKqkC,aAAa8D,SACd,kBAC+B,OAA/BuD,EAAU1S,OAAO6S,UAAqB,EAAIH,EAAU1S,OAAO6S,iBAG1C7pC,IAArB0pC,EAAUI,SACV9rC,KAAKqkC,aAAa8D,SACd,mBACgC,OAAhCuD,EAAUI,OAAOlqB,WAAsB,EAAI8pB,EAAUI,OAAOlqB,YAEhE5hB,KAAKqkC,aAAa8D,SACd,iBAC8B,OAA9BuD,EAAUI,OAAOC,SAAoB,EAAIL,EAAUI,OAAOC,gBAGvC/pC,IAAvB0pC,EAAUM,UACVhsC,KAAKqkC,aAAa8D,SACd,iBACuB,OAAvBuD,EAAUM,SAAoB,EAAIN,EAAUM,SAAS1qC,QASjE,gBACI,QAAeU,IAAXiqC,aAA+CjqC,IAAvBiqC,OAAOC,YAA2B,CAC1D,MAAMJ,EAAUG,OAAOC,YAAoBJ,YAC5B9pC,IAAX8pC,IACA9rC,KAAKqkC,aAAa8D,SAAS,yBAA0B2D,EAAOK,iBAC5DnsC,KAAKqkC,aAAa8D,SAAS,wBAAyB2D,EAAOM,gBAC3DpsC,KAAKqkC,aAAa8D,SAAS,yBAA0B2D,EAAOO,mBAWxE,yBACI,QAAIrsC,KAAKwrC,cAAclqC,QAAUtB,KAAKorC,gBAItCprC,KAAKwrC,cAAcc,SAAStsC,KAAKqkC,cAEjCrkC,KAAKqkC,aAAamE,SACX,GASX,IAAI6B,EAAiBC,GACjB99B,EAAOytB,SAAej4B,IAAXqoC,EAAuBA,EAAS,yBAExBrqC,KAAKqrC,WACbhrC,QAAQ,CAAChC,EAAeV,KAC/B6O,EAAOytB,IAAIt8B,EAAMU,KAEL2B,KAAKsrC,QACbjrC,QAAQ,CAAChC,EAAeV,KAC5B6O,EAAOytB,IAAIt8B,EAAMU,KAErB2B,KAAKwrC,cAAcvR,WAEJj4B,IAAXsoC,GACA99B,EAAOytB,IAAIqQ,GAQnB,iBAAiBiC,GAAyB,GACtC,MAAMlB,EAAkB,GAClBC,EAAe,GACfkB,EAAc,GACdC,EAAmB,CACrBnB,UACAD,aACAmB,UAaJ,GAVwBxsC,KAAKqrC,WACbhrC,QAAQ,CAAChC,EAAeV,KACpC0tC,EAAW1tC,GAAQU,IAGF2B,KAAKsrC,QACbjrC,QAAQ,CAAChC,EAAeV,KACjC2tC,EAAQ3tC,GAAQU,IAGhBkuC,EACA,IAAK,MAAO5uC,EAAM+yB,KAAW1wB,KAAKwrC,cAAcR,aAC5CwB,EAAO7uC,GAAQ+yB,EAAOpR,YAG1B,IAAK,MAAO3hB,EAAM+yB,KAAW1wB,KAAKwrC,cAAcR,aAC5CwB,EAAO7uC,GAAQ+yB,EAAOiY,UAI9B,OADA8D,EAAY7B,SAAW5qC,KAAKwrC,cAAcZ,SAASjC,UAC5C8D,EAOX,yBACI,OAAOzsC,KAAK0sC,kBAAiB,GAOjC,2BAA2BH,GAAyB,GAChD,MAAMjB,EAA+B,IAAInpC,IACnCkpC,EAAkC,IAAIlpC,IACtCqqC,EAAyC,IAAIrqC,IAE7CwqC,EAA0C,CAC5CrB,UACAD,aACAmB,SACA5B,SAAU5qC,KAAKwrC,cAAcZ,SAASjC,WAa1C,GAVwB3oC,KAAKqrC,WACbhrC,QAAQ,CAAChC,EAAeV,KACpC0tC,EAAWrkC,IAAIrJ,EAAMU,KAGJ2B,KAAKsrC,QACbjrC,QAAQ,CAAChC,EAAeV,KACjC2tC,EAAQtkC,IAAIrJ,EAAMU,KAGlBkuC,EACA,IAAK,MAAO5uC,EAAM+yB,KAAW1wB,KAAKwrC,cAAcR,aAC5CwB,EAAOxlC,IAAIrJ,EAAM+yB,EAAOpR,aAG5B,IAAK,MAAO3hB,EAAM+yB,KAAW1wB,KAAKwrC,cAAcR,aAC5CwB,EAAOxlC,IAAIrJ,EAAM+yB,EAAOiY,WAGhC,OAAOgE,GAEf,OA7PmB,EAAApB,gBAAqCvpC,EA6PxD,GAnRA,GAAa,EAAAmiC,yB,wGCl5Bb,cAsBA,MAAayI,EA2CT,YAAY9tC,EAAwBue,GAH5B,KAAAwvB,yBAA2B,EAC3B,KAAAC,2BAA4B,EAGhC9sC,KAAKlB,OAASA,EACdkB,KAAKssB,UAAYjP,EAAOiP,UACxBtsB,KAAK+sC,KAAO1vB,EAAO0vB,KACnB/sC,KAAK8sC,0BAA4B9sC,KAAKgtC,qBAAqBvoC,KACvDgG,GAAYA,EAASygB,QAAU,GA5CvC,WAAWpsB,G,MACP,OAAsB,QAAf,EAAAA,EAAOgjB,gBAAQ,eAAEmrB,sBAAsBL,EACxC9tC,EAAOgjB,SAASmrB,gBAChBjrC,EAGV,eAAekrC,GAIX,OAHKA,EAAQpuC,OAAOgjB,WAChBorB,EAAQpuC,OAAOgjB,SAAW,IAEtBorB,EAAQpuC,OAAOgjB,SAASmrB,WAAaC,EAGjD,cAAcpuC,EAAwBue,GAClC,OAAOuvB,EAAiBO,QAAQ,IAAIP,EAAiB9tC,EAAQue,IAGjE,qBAAqBve,EAAwBoB,G,QACzC,OAA0D,QAA1D,EAAmC,QAAnC,EAAO0sC,EAAiB3uC,IAAIa,UAAO,eAAEsuC,cAAcltC,UAAO,SAoC9D,SACI,MAAO,CAAE6sC,KAAM/sC,KAAK+sC,KAAMzgB,UAAWtsB,KAAKssB,WAe9C,cAAcpsB,GACV,OAAIF,KAAK6sC,0BAA4B3sC,EAAQsiC,cAG7CxiC,KAAK6sC,wBAA0B3sC,EAAQsiC,YAEhCxiC,KAAKqtC,gBAAgBntC,IAMhC,YACI,OAAOF,KAAKlB,OAAOsnB,SAAWpmB,KAAK8sC,0BAG/B,gBAAgB5sC,GACpB,IAAIotC,GAA4B,EAChC,MAAM3rB,EAAY3hB,KAAKgtC,qBACvB,IAAK,MAAMviC,KAAYkX,EAAW,CAC9B,MAAM2hB,EAAU,EAAArQ,mBAAmBma,cAAc3iC,EAAUvK,GAC3DotC,EAAmBA,GAAoBhK,EAK3C,OAHIgK,IACAttC,KAAK8sC,0BAA4BnrB,EAAUld,KAAKgG,GAAYA,EAASygB,QAAU,IAE5EoiB,EAGH,qBACJ,MAAMxuC,EAASkB,KAAKlB,OACpB,OAAOsC,MAAMC,QAAQvC,EAAO2L,UACtB3L,EAAO2L,cACazI,IAApBlD,EAAO2L,SACP,CAAC3L,EAAO2L,UACR,IA7Gd,sB,0ICzBA,aAUA,OAQA,OAIA,QACA,SACA,QAUA,SAeA,GAFA,OAEA,QAGA,QAGA,SAKA,SACA,QACA,SACA,OAUA,IAAK+tB,GAAL,SAAKA,GACD,2CACA,6BAFJ,CAAKA,MAAI,KASI,EAAA+U,4BAA8B,GAQ3C,MA0BM/gC,EAAS,EAAAC,cAAcxM,SAASvB,OAAO,uBAAwB,CAAEkd,MAAO,EAAA4xB,SAASC,MAIjFC,OAAiE1rC,EACjE2rC,OAAuE3rC,EAEvE4rC,EAAe,IAAIxuC,EAAMuG,QACzBkoC,EAAqB,IAAIzuC,EAAMoG,QAC/BsoC,EAAoC,GACpCC,EAAwB,IAAI3uC,EAAMoG,QAClCwoC,EAA4D,GAC5DC,EAAwC,GACxCC,EAAwD,GAE9D,MAAMC,EACF,YAAqB1rB,EAAqBkgB,GAArB,KAAAlgB,OAAqB,KAAAkgB,SAG9C,MAAMyL,EACF,YAAqBC,GAAA,KAAAA,QAErB,eAGI,OAFA,EAAA/hC,OAAOtM,KAAKquC,MAAM/sC,OAAS,GAEpBtB,KAAKquC,MAAM,GAAG1L,MAAMhd,SAK/B,QACI,IAAI9mB,EAAI,EACR,IAAK,MAAMyvC,KAAQtuC,KAAKquC,MACpBxvC,GAAKyvC,EAAK3L,MAAMoE,SAASzlC,OAE7B,OAAOzC,GAmBf,SAAS0vC,EACLzL,EACA0L,EACAC,EACAvnB,EACAwnB,GAEAT,EAAkB/mB,KAAOA,EACzB+mB,EAAkBS,aAAeA,EACjCT,EAAkBU,MAAQ7L,EAAYxc,YACtC2nB,EAAkBW,gBAAkB9L,EAAY+L,eAChDZ,EAAkBa,YAAchM,EAAYhhB,SAAWghB,OAAc9gC,EACrEwsC,EAAOO,QAAQjM,EAAYkM,OAASP,EAAgBR,GAiGxD,SAASgB,EAAwBC,GAE7B,QAAkBltC,IAAdktC,EACA,OAAO,EAIX,OAFgB,EAAAjH,iBAAiBC,MACHgH,EA3KA,KA6K1B1iC,EAAO2iC,MAAM,mCACN,GASf,6BA6CI,YACYC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACR55B,GAVQ,KAAAm5B,cACA,KAAAC,eACA,KAAAC,uBACA,KAAAC,qBACA,KAAAC,oBACA,KAAAC,sBACA,KAAAC,eACA,KAAAC,uBACA,KAAAC,sBACA,KAAAC,UAtDJ,KAAAC,eAAyB,EAEzB,KAAAC,oBAA8B,EAK9B,KAAAC,gBAAwC,GAQxC,KAAAC,YAAc,IAAI7wC,EAAMoG,QACxB,KAAA0qC,aAAe,IAAI9wC,EAAMuG,QACzB,KAAAwqC,eAAiB,IAAI/wC,EAAMuG,QAC3B,KAAAyqC,cAAwB,EACxB,KAAAC,oBAA8B,EAC9B,KAAAC,sBAAgC,EAChC,KAAAC,gBAA0B,EAEjB,KAAAC,wBAAiD,IAAI,EAAAC,sBAkClEzwC,KAAKoiC,iBAAmB,IAAI,EAAAsO,eAAe1wC,KAAK6vC,SAEhD7vC,KAAK2wC,UAAY,OAAH,UAAQ16B,GACtB,EAAA26B,yBAAyB5wC,KAAK2wC,WAE9B3wC,KAAKyvC,oBAAoBoB,oBACrB7wC,KAAK2wC,UAAUG,aACf9wC,KAAK2wC,UAAUI,cAQvB,kBAAkBC,GACdhxC,KAAK2wC,UAAUM,cAAgBD,EAGnC,oBACI,OAAwC,IAAjChxC,KAAK2wC,UAAUM,cAG1B,iBACI,OAAOjxC,KAAKoiC,iBAGhB,uCACI,OAA2D,IAApDpiC,KAAK2wC,UAAUO,iCAG1B,qCAAqCC,GACjCnxC,KAAK2wC,UAAUO,iCAAmCC,EAQtD,WAAWziC,GACP,GAAK1O,KAAKoxC,YAAV,CAIApxC,KAAKqxC,uBAEL,IAAK,MAAMC,KAAgBtxC,KAAKgwC,gBAC5BsB,EAAaC,WAAWvY,OAAOtqB,IAOvC,kBACI1O,KAAKqwC,oBAAqB,EAM9B,kBACQrwC,KAAKkxC,mCACLlxC,KAAKuwC,gBAAiB,GAO9B,mBACIvwC,KAAKwxC,kBACDxxC,KAAKkxC,mCACLlxC,KAAKuwC,gBAAiB,GAQ9B,iBACI,OAAOvwC,KAAKowC,aAQhB,UAAU5tB,EAA0CivB,GAChD,MAAMC,EApSd,SAAoClvB,GAChC,IAAI2gB,GAAsB,EAW1B,OATA3gB,EAAmBniB,QAAQ,EAAGsxC,oBAC1BA,EAActxC,QAAQoiB,IACdA,EAAK0gB,sBACL1gB,EAAK0gB,qBAAsB,EAC3BA,GAAsB,OAK3BA,EAwR6ByO,CAA2BpvB,GAErDqvB,EAAwB7xC,KAAK8xC,kBAAoBJ,EACvD,IAAK1xC,KAAK+xC,WAAWF,GACjB,OAGJ,MAAMG,EACFhyC,KAAKqwC,oBACLqB,GACA1xC,KAAKovC,YAAY6C,qBAErBzlC,EAAO2iC,MACH,UAAUnvC,KAAKovC,YAAY5M,4BAA4BxiC,KAAKovC,YAAYx4B,aAGxEo7B,GAAsBhyC,KAAKuwC,iBAC3BvwC,KAAKwwC,wBAAwB0B,eAC7BlyC,KAAKgyC,mBAAmBxvB,IAE5B,MAAM2vB,EAAmBH,GAAsBhyC,KAAKuwC,eAC9C6B,EAAsBpyC,KAAKwwC,wBAAwB6B,OACrDZ,EACAzxC,KAAK2wC,UAAUM,cACfkB,EACAnyC,KAAKovC,YAAYx4B,WAGrB5W,KAAKwoC,QACDxoC,KAAKuwC,gBACLvwC,KAAKsyC,sCAAsC9vB,GAS/C,MAAM+vB,GACDP,GAAsBI,IAAwBpyC,KAAKuwC,eACxDvwC,KAAKwyC,kBAAkBf,EAAMc,GAC7BvyC,KAAKyyC,2BACLzyC,KAAK0yC,sBAQT,eAAeC,GACiB,IAAxBA,EAAarxC,SAGjBtB,KAAK4yC,2BAC8B5wC,IAA/BhC,KAAK4yC,sBACCD,EAAarsC,QACbtG,KAAK4yC,sBAAsBC,OAAOF,IAQhD,mBACI3yC,KAAK4yC,sBAAwB,GAMjC,iBACI,YAAsC5wC,IAA/BhC,KAAK4yC,uBAAuC5yC,KAAK4yC,sBAAsBtxC,OAAS,EAG3F,kBACI,OAAOtB,KAAK4yC,sBAchB,iBAAiBnE,EAA+BqE,GAC5C,MAAMC,EAAc,CAACC,EAA2BC,KAC5C,MAAMnQ,EAAckQ,EAEpB,QAAoBhxC,IAAhB8gC,EACA,OAGJ,IAAIoQ,GAAc,EAElB,QAA8BlxC,IAA1B8gC,EAAYhd,YACZotB,EAAcJ,EAAYruC,KAAK0uC,QAERnxC,IAAfmxC,GACAF,IAAmBE,EAAWvjC,YACH5N,IAAzBmxC,EAAWrtB,WACTqtB,EAAWrtB,YAAcgd,EAAYhd,gBACZ9jB,IAAxBmxC,EAAWrxB,UACRqxB,EAAWrxB,WAAaghB,EAAYhhB,YAI/CoxB,GAAa,CACd,MAAMC,EAA6B,CAC/BvjC,KAAMqjC,EACNzhC,MAAOi9B,EACPz/B,SAAU,EACV8W,UAAWgd,EAAYhd,UACvBhE,SAAUghB,EAAYhhB,SACtB0D,KAAMsd,EAAYtd,MAGtBstB,EAAY5sC,KAAKitC,KAK7B,IAAK,MAAM7B,KAAgBtxC,KAAKgwC,gBAC5BsB,EAAaC,WAAW6B,SAAS3E,EAAiBuE,IAC9CD,EAAYC,EAAU,EAAAK,eAAeC,QAEzChC,EAAaiC,YAAYC,iBACrB/E,EACCuE,IACGD,EAAYC,EAAU,EAAAK,eAAeI,QASrD,cACI,OAAOzzC,KAAK4vC,oBAAoB5sB,SAAWhjB,KAAK+vC,oBAAsB,EAM1E,mBAEI,cAD0B/vC,KAAK0zC,yBAIJ1xC,IAAvBhC,KAAK2zC,sBAGH3zC,KAAK2zC,eACJ,IAUX,oBACI3zC,KAAKwwC,wBAAwBxK,QAQjC,iBACI,MAAM4N,EAAc,CAChBl8B,SAAU,EACVC,QAAS,GAGb,IAAK,MAAM+gB,KAAY14B,KAAKgwC,gBACxBtX,EAAS6Y,WAAWsC,eAAeD,GACnClb,EAAS6a,YAAYM,eAAeD,GAGxC,OAAOA,EAGX,kBACI,OAAO5zC,KAAK8vC,cAGhB,mBACI,YAA8B9tC,IAAvBhC,KAAK8zC,cAOhB,wBACI,QAAI9zC,KAAKoxC,eAIJpxC,KAAK+zC,qBAGJ/zC,KAAK8zC,eACJ,GAQH,WAAWjC,GAUf,OATK7xC,KAAKoxC,aAAgBpxC,KAAK+zC,eAAgBlC,IAC3C7xC,KAAKg0C,0BACLh0C,KAAK8zC,cAAgB9zC,KAAKi0C,yBAAyBjP,KAAK,KACpDhlC,KAAK8vC,eAAgB,EACrB9vC,KAAK8zC,mBAAgB9xC,EACrBhC,KAAKwxC,kBACLxxC,KAAKsvC,0BAGNtvC,KAAKoxC,YAMR,QACJpxC,KAAKmwC,eAAe7gC,KAAKtP,KAAKovC,YAAY8E,cAC1Cl0C,KAAKuvC,mBAAmB/G,QACxB,IAAK,MAAM8I,KAAgBtxC,KAAKgwC,gBAC5BsB,EAAaC,WAAWvL,QACxBsL,EAAaiC,YAAY/K,QAOzB,sBACJ,IAAK,MAAM8I,KAAgBtxC,KAAKgwC,gBAC5BsB,EAAaiC,YAAYlB,SASzB,sCAAsC7vB,GAC1C,MAAM2xB,EAAgB,GACtB3xB,EAAmBniB,QAAQ+zC,IACvB,MAAMC,EAAqB,IAAIj1C,EAAMuG,QAC/B2uC,EAAmB,IAAIl1C,EAAMuG,QACnC,IAAK,MAAM8c,KAAQ2xB,EAAgBzC,cAAchS,SAC7C,IAAK,MAAM4U,KAAuB9xB,EAAK+xB,iBACnC,KAAID,EAAoBjjC,OAAOhQ,OAAS,GAAxC,CAGAtB,KAAKwvC,kBAAkBiF,SACnBF,EAAoBjjC,OAAO,GAC3B+iC,GAEJ,IAAK,IAAIj3C,EAAI,EAAGA,EAAIm3C,EAAoBjjC,OAAOhQ,OAAQlE,IAAK,CACxD4C,KAAKwvC,kBAAkBiF,SACnBF,EAAoBjjC,OAAOlU,GAC3Bk3C,GAEJ,MAAMI,EAAOH,EAAoBI,iBAAiBv3C,EAAI,GACtDs3C,EAAK3K,MAAMz6B,KAAK+kC,GAChBK,EAAKE,IAAItlC,KAAKglC,GACd,MAAMO,EAA+B,CACjCC,KAAMzrC,KAAKO,IAAIyqC,EAAmB5uC,EAAG6uC,EAAiB7uC,GACtDsvC,KAAM1rC,KAAKS,IAAIuqC,EAAmB5uC,EAAG6uC,EAAiB7uC,GACtDuvC,KAAM3rC,KAAKO,IAAIyqC,EAAmB3uC,EAAG4uC,EAAiB5uC,GACtDo2B,KAAMzyB,KAAKS,IAAIuqC,EAAmB3uC,EAAG4uC,EAAiB5uC,GACtDgvC,QAEJP,EAAMjuC,KAAK2uC,GACXR,EAAmB/kC,KAAKglC,OAKxCt0C,KAAKuvC,mBAAmB0F,eAAed,GAOnC,sBACJe,EACAzvB,EACA0vB,EACAC,GAKA,GAFA,EAAA9oC,OAAO4oC,EAAWG,SAEkB,IAAhCr1C,KAAKgwC,gBAAgB1uC,OAErB,OADAkL,EAAOuJ,KAAK,mCACL,EAGX,MAAMu/B,EAA2B,GAC3BC,EAAcv1C,KAAKovC,YAAYoG,oBAC/BrmC,EAAanP,KAAKovC,YAAYjgC,WAC9BiM,EAAoBpb,KAAKovC,YAAYh0B,kBACrCq6B,EAAer6B,aAAiB,EAAjBA,EAAmBs6B,mBAAmBR,EAAWtxB,SAEtE,IAAK,MAAM+xB,KAAoBT,EAAWU,kBAAmB,CACzD,GAAIR,IAAS5c,EAAKqd,iBACVlI,KACEA,EAAemI,WAIpB,GACDX,GAAsB,GACtB1vB,EAAaswB,yBAA2BZ,EAGxC,OADA3oC,EAAO2iC,MAAM,oCACN,EAKX,IAAKwG,EAAiBvE,YAAa,CAC3BzD,KACEA,EAAeqI,cAErB,SAEJ,QAAsCh0C,IAAlC2zC,EAAiBM,aAA4B,CACzCtI,KACEA,EAAeuI,OAErB,SAGJ,MAAMC,EAAiBR,EAAiBvvB,QACxC,GACKgvB,IAAS5c,EAAKqd,mBAAqBM,GACnCf,IAAS5c,EAAK4d,WAAaD,EAE5B,SAGJ,MAAMrT,EAAc6S,EAAiBxd,QAG/Bke,EAAmBr2C,KAAKoiC,iBAAiBkU,oBAAoBxT,EAAY/c,OACzEwrB,EAAa8E,EAAiB9E,WAC9BgC,EAAc8C,EAAiB9C,YACrC,QAAmBvxC,IAAfuvC,QAA4CvvC,IAAhBuxC,EAA2B,CACvD/mC,EAAOuJ,KAAK,0CACZ,SAKJ,QACoB/T,IAAhBuzC,QACqBvzC,IAArB8gC,EAAYiK,MACZwI,EAAYgB,gBAAgBzT,EAAYiK,MAExC,SAGJ,QAA0B/qC,IAAtBoZ,IAAoC0nB,EAAYvc,SAAU,CAC1D,IAAKkvB,EAAc,CACfz1C,KAAKsvC,uBACLtvC,KAAKswC,sBAAuB,EAC5B,SAEJ,EAAAkG,mBAAmB1T,EAAa1nB,EAAmBq6B,EAActmC,GAErE,MAAMsnC,EAAc3T,EAAYlzB,KAIhC,GAHoB6mC,IAAgB,EAAA7vB,gBAAgBE,WAI5C,EAAA4vB,oBAAoB5T,EAAa9iC,KAAKwvC,kBAAmB1B,GAAmB,CACxEH,GACAA,EAAegJ,iBAEiB,IAAhC7T,EAAY8T,iBACRjJ,GACAA,EAAekJ,kBAGvBlB,EAAiBnN,QACjB,SAIR,MAAMsO,GAAuB,EAG7B,IAAK92C,KAAK+2C,iBAAiBjU,EAAauT,EAAkBS,GACtD,SAGJ,MAAMnI,EAAQ4C,EAAWyF,SAASlU,EAAYxc,aAAe,EAAA2wB,2BAG7D,QAAcj1C,IAAV2sC,GACIA,EAAMuI,QAAQC,UAAYrU,EAAYkM,OAAQ1tC,OAASqtC,EAAMuI,QAAQ/P,SACjEwG,KACEA,EAAeyJ,aAErB5qC,EAAOuJ,KAAK,+CAapB,OAHAw7B,EAAW8F,gBAAkBvU,EAAYrc,YACzC8qB,EAAW+F,gBAAkBxU,EAAYnc,YAEjC8vB,GACJ,KAAK,EAAA7vB,gBAAgBC,SACjB7mB,KAAKu3C,YAAY5B,EAAkBpC,EAAahC,EAAY9rB,GAC5D,MACJ,KAAK,EAAAmB,gBAAgBO,WACjBnnB,KAAKw3C,mBACD7B,EACApC,EACA+B,EACA/D,EACA9rB,GAEJ,MACJ,KAAK,EAAAmB,gBAAgBE,UACjB9mB,KAAKy3C,aAAa9B,EAAkB7H,EAAkByD,EAAY9rB,IAG9E,OAAO,EAGH,iBACJqd,EACAuT,EACAS,GAGA,GAAIhU,EAAY4U,eAAiB,EAAApyB,aAAaqyB,YAC1C,OAAO,EAGX,EAAArrC,YAAuCtK,IAAhCq0C,EAAiB9E,YACxB,MAAMA,EAAa8E,EAAiB9E,WAEpC,QAAiCvvC,IAA7B8gC,EAAY4U,aAgBZ,GAfA5U,EAAY4U,aAAe,EAAApyB,aAAasyB,eAER51C,IAA5B8gC,EAAYrc,cACZqc,EAAYrc,YAAc,IAAI,EAAAD,gBAAgB,OAAD,wBACtC6vB,EAAiB5wB,cACjBqd,EAAYrd,qBAGSzjB,IAA5B8gC,EAAYnc,cACZmc,EAAYnc,YAAc,IAAI,EAAAD,gBAAgB,OAAD,wBACtC2vB,EAAiB3wB,cACjBod,EAAYpd,gBAIE,KAArBod,EAAYtd,KACZsd,EAAY4U,aAAe,EAAApyB,aAAauyB,WACrC,CACH,MAAMC,EAAiBvG,EAAWwG,YAC7BC,YAAYlV,EAAYtd,KAAMsd,EAAYrc,aAC1Cue,KAAK,OACAhlC,KAAK+vC,oBACPjN,EAAY4U,aAAe,EAAApyB,aAAauyB,OAGxC73C,KAAKswC,qBACDtwC,KAAKswC,sBAAwBwG,EACjC92C,KAAKsvC,yBAEoB,IAA7BtvC,KAAK+vC,sBACL/vC,KAAK2zC,mBAAgB3xC,KAEvBhC,KAAK+vC,oBAEP/vC,KAAK2zC,mBACsB3xC,IAAvBhC,KAAK2zC,cACCmE,EACAG,QAAQC,IAAI,CAACl4C,KAAK2zC,cAAemE,IAmBnD,OAhBIhV,EAAY4U,eAAiB,EAAApyB,aAAauyB,SAC1CtG,EAAW8F,gBAAkBvU,EAAYrc,YACzC8qB,EAAW+F,gBAAkBxU,EAAYnc,YACzCmc,EAAY+L,eAAiB,GAC7B/L,EAAYqV,YAASn2C,EACrB8gC,EAAYkM,OAASuC,EAAWwG,YAAYK,UACxCtV,EAAYtd,KACZ+rB,EAAW8F,gBACXvU,EAAY+L,gBAEhB/L,EAAY4U,aAAe,EAAApyB,aAAaqyB,kBAMd31C,IAAvB8gC,EAAYkM,OAGf,0BACJ,MAAMqJ,EAAyBr4C,KAAK4vC,oBAAoBmC,WACpD/xC,KAAK2wC,UAAUoH,aAEnB/3C,KAAKoiC,iBAAiBkW,kCAAkCD,GAGpD,+BAWJ,OAAOr4C,KAAK4vC,oBAAoB2I,aAVR,CAAC56C,EAAc66C,KACnC,MAAMC,EAAmBz4C,KAAKyvC,oBAAoBiJ,iBAAiBF,GAEnEx4C,KAAKgwC,gBAAgB9pC,KAAK,CACtB6xC,YAAap6C,EACb4zC,WAAYkH,EACZlF,YAAavzC,KAAK2vC,qBAAqBgJ,kBAAkBF,OAIHzT,KAAK,KAE/D,IAAI4T,EACJ54C,KAAKgwC,gBAAgB3vC,QAAQixC,SACCtvC,IAAtB42C,IACAA,EAAoBtH,EAAaC,cAGzC,MAAMsH,EAAqB74C,KAAK2vC,qBAAqBgJ,kBACjDC,GAGJ54C,KAAKoiC,iBAAiB0W,4BAClBD,EACAD,EACA54C,KAAKgwC,mBAKT,uBACJ,MAAM+I,EAAc,EAAAC,aAAaC,SAAS,qBACtBj3C,IAAhB+2C,IAIAA,QAAqD/2C,IAAtChC,KAAKk5C,8BACpBl5C,KAAKm5C,2BAET,EAAA7sC,YAA6CtK,IAAtChC,KAAKk5C,8BACZ,EAAA5sC,YAAiDtK,IAA1ChC,KAAKo5C,kCAEZp5C,KAAKk5C,6BAA8B9yB,QAAU2yB,EAC7C/4C,KAAKo5C,iCAAkChzB,QAAU2yB,GAG7C,2BACJ,MAAMM,EAAqBr5C,KAAKgwC,gBAAgB,GAAGuB,WAAWwG,YAGxDuB,EAAgB,IAAIl6C,EAAMm6C,cAC5BF,EAAmBG,YAAY/hC,MAAQ,IACvC4hC,EAAmBG,YAAYtoC,OAAS,IACxCmoC,EAAmBG,YAAY/hC,MAAQ4hC,EAAmBI,SAC1DJ,EAAmBG,YAAYtoC,OAASmoC,EAAmBK,WAEzDjvC,EAAW,IAAIrL,EAAM+Y,kBAAkB,CACzCzN,aAAa,EACbivC,YAAY,EACZzqB,WAAW,EACXnpB,IAAKszC,EAAmBliC,UAE5BnX,KAAKk5C,6BAA+B,IAAI95C,EAAM40B,KAAKslB,EAAe7uC,GAClEzK,KAAKk5C,6BAA6B5yB,YAAc,IAChDtmB,KAAKk5C,6BAA6B9yB,SAAU,EAE5CpmB,KAAKk5C,6BAA6Bv7C,KAAO,aAEzC,MAAMi8C,EAAY,IAAIx6C,EAAMy6C,kBAAkBP,GACxCQ,EAAoB,IAAI16C,EAAM+Z,kBAAkB,CAClDzO,aAAa,EACbugB,MAAO,SACP0uB,YAAY,EACZzqB,WAAW,IAEflvB,KAAKo5C,iCAAmC,IAAIh6C,EAAMi1B,aAC9CulB,EACAE,GAEJ95C,KAAKo5C,iCAAiC9yB,YAAc,KACpDtmB,KAAKo5C,iCAAiChzB,SAAU,EAEhDpmB,KAAKo5C,iCAAiCz7C,KAAO,aAE7CqC,KAAKgwC,gBAAgB,GAAGuB,WACnByF,SAAS,EAAAC,2BACTC,QAAQve,MAAMx4B,IACXH,KAAKk5C,6BACLl5C,KAAKo5C,kCAiBT,mBAAmB52B,GACvBhW,EAAO2iC,MAAM,sBAETzB,GACAA,EAAY1H,QAGhBhmC,KAAKwwC,wBAAwBuJ,iBAC7B/5C,KAAKqwC,oBAAqB,EAE1BrwC,KAAKg6C,kBAAkBx3B,GAGvB,MAAMy3B,EACFj6C,KAAKk6C,YAAcl6C,KAAKovC,YAAYzqC,UAAY,EAAAsjC,iBAAiBC,WAAQlmC,EAU7EwgB,EAAmBniB,QAAQiiB,IACvBtiB,KAAKm6C,6BACD73B,EAASqe,WACTre,EAAS83B,aACTh5C,MAAM6I,KAAKqY,EAASqvB,cAAchS,UAClCsa,KAIJvM,GACAA,EAAYzT,MAIZ,6BACJogB,EACAD,EACA13B,EACAu3B,GAEIvM,IACAA,EAAY4M,OAAS53B,EAAaphB,QAEtC,MAAMi5C,EAAc73B,EAGpB63B,EAAY3R,KAAK,CAACp/B,EAASE,IAChBF,EAAEoa,QAAQO,aAAeza,EAAEka,QAAQO,cAG9C,MAAMq2B,EAAmC,GACzCx6C,KAAKy6C,6BAA6BJ,EAAgBD,EAAcG,EAAaC,GAE7E,IAAIE,EAAyB,EAE7B,IAAK,MAAMC,KAAoBH,EAI3B,GAHAx6C,KAAK46C,qCAAqCD,QAGlB34C,IAApBi4C,EAA+B,CAK3B,GAFgB,EAAAhS,iBAAiBC,MACH+R,EA5hCf,EA6hC+B,CAC1CztC,EAAO2iC,MAAM,+BACb,MAOR,GADAuL,GAA0BC,EAAiB5gC,QACvC2gC,GA9iCiB,IA8iCuC,CACxDluC,EAAO2iC,MAAM,gCACb,QAMR,wBACJ0L,EACAj3B,EACAk3B,GAEA,GAAyC,IAArCD,EAAiB9T,SAASzlC,OAC1B,OAGJ,MA6BO,CAAEy5C,GAAS/6C,KAAKwwC,wBAAwBwK,SAC3CH,EACAj3B,EA9BA+xB,IAEA,IAAI,OAAExvC,EAAM,aAAE8vC,GAAiB,EAAAgF,uBAC3BtF,EAAiBxd,QACjBn4B,KAAKovC,YACLpvC,KAAKqvC,aACLrvC,KAAK0vC,aACLoL,GAkBJ,OAdI30C,IAAW,EAAA+0C,mBAAmBC,IAC7Bn7C,KAAKwwC,wBAAwB4K,mBAC1Bp7C,KAAKovC,YAAYx4B,UACjB++B,KAGJxvC,EAAS,EAAA+0C,mBAAmBG,UAC5BpF,OAAej0C,GAGf0rC,IACAA,EAAY4N,cACZ5N,EAAY6N,QAAQp1C,MAEjB8vC,IASPvI,MACEA,EAAY8N,YACTT,KACCrN,EAAY+N,WAKlB,6BACJpB,EACAD,EACAG,EACAC,GAEA,GAA2B,IAAvBD,EAAYj5C,OACZ,OAGJ,MAAMo6C,EAAwB,GAE9B,IAAK,MAAMj5B,KAAQ83B,EACXF,EAAesB,iBAAiBvB,EAAc33B,EAAKmB,UACnD83B,EAAcx1C,KAAKuc,GAI3B,MAAMm5B,EAAsD,IAAIz5C,IAEhE,IAAK,MAAMsgB,KAAQi5B,EACf,IAAK,MAAM/Y,KAASlgB,EAAKwgB,kBAAkBL,OAAOjD,SAAU,CACxD,GAA8B,IAA1BgD,EAAMoE,SAASzlC,OACf,SAGJ,MAAMu6C,EAAaD,EAAqB39C,IAAI0kC,EAAMhd,eAC/B3jB,IAAf65C,EACAD,EAAqB50C,IACjB27B,EAAMhd,SACN,IAAIyoB,EAAiB,CAAC,IAAID,EAAiB1rB,EAAMkgB,MAGrDkZ,EAAWxN,MAAMnoC,KAAK,IAAIioC,EAAiB1rB,EAAMkgB,IAK7D,GAAkC,IAA9BiZ,EAAqBx6B,KACrB,OAGJ,IAAK,MAAMyM,KAAK+tB,EAAsB,CAClC,MAAMvN,EAAQxgB,EAAE,GAChB2sB,EAAat0C,KAAKmoC,GAGtBmM,EAAa5R,KAAK,CAACp/B,EAAqBE,IAC7BA,EAAEic,SAAWnc,EAAEmc,UAkBtB,qCAAqCg1B,GACzC,MAAMmB,EAAwBzyC,KAAKS,IAC/B9J,KAAK2wC,UAAUoL,8BACf/7C,KAAK2wC,UAAUqL,8BAEblB,EAAkB,EAAAmB,mBAAmBj8C,KAAKovC,YAAa0M,GAE7D,IAAK,MAAMI,KAAoBvB,EAAiBtM,MAC5CruC,KAAKm8C,wBACDD,EAAiBvZ,MACjBuZ,EAAiBz5B,KAAKmB,QACtBk3B,GAKJ,kBAAkBrJ,EAAcc,GACpC,MAAM9sB,EAA6B,CAC/BswB,wBAAyB,EACzBqG,sBAAsB,EACtB3K,QAGE4K,EACFr8C,KAAKk6C,YAAcl6C,KAAKovC,YAAYzqC,UAAY,EAAAsjC,iBAAiBC,WAAQlmC,EAM7E,GAJI2rC,GACAA,EAAe3H,QAGuB,IAAtChmC,KAAKwwC,wBAAwBpvB,KAE7B,YADA5U,EAAO2iC,MAAM,6BAIjB,MAAMmN,EAAWt8C,KAAKswC,sBAAwBiC,EAC1CvyC,KAAKswC,uBACAiC,GACD/lC,EAAO2iC,MAAM,wBAEjBnvC,KAAKswC,sBAAuB,GAEhC,MAAMiM,EAA2Bv8C,KAAK2wC,UAAU6L,oBAI1CC,EAAcz8C,KAAKwwC,wBAAwBkM,kBACjD,IAAIC,EAA0BF,EAAY,GAAG92B,SACzCi3B,EAA+B,EAEnC,IAAK,IAAIx/C,EAAI,EAAGA,EAAIq/C,EAAYn7C,SAAUlE,EAAG,CACzC,MAAMy/C,EAAwBJ,EAAYr/C,GACtCuwC,KACEA,EAAe6N,YAGrB,MAAMsB,EAAcD,EAAsBl3B,SAC1C,GAAI22B,GAAYK,IAAoBG,EAAa,CAI7C,GADA98C,KAAKuyC,qBAAqBqK,EAAsBx/C,EAAGqoB,GAC/CwpB,EAAwBoN,GACxB,MAEJM,EAAkBG,EAClBF,EAAuBx/C,EAE3B,IACK4C,KAAK+8C,sBACFF,EACAp3B,EACA82B,EACA/jB,EAAKqd,kBAGT,MAGJ,GAAI5G,EAAwBoN,GACxB,MAIJC,GAEAt8C,KAAKuyC,qBAAqBqK,EAAsBH,EAAYn7C,OAAQmkB,GAGpEkoB,IACAA,EAAeoI,wBAA0BtwB,EAAaswB,wBACtDpI,EAAe1T,OAGfxU,EAAa22B,sBACbp8C,KAAKsvC,uBAIL,qBACJ0N,EACAC,EACAx3B,GAEA,MAAMg3B,EAAcz8C,KAAKwwC,wBAAwBkM,kBACjD,IAAK,IAAIt/C,EAAI4/C,EAAiB5/C,EAAI6/C,GAEzBj9C,KAAK+8C,sBACFN,EAAYr/C,GACZqoB,EACAzlB,KAAK2wC,UAAU6L,oBACfhkB,EAAK4d,aANkCh5C,IAc/C,2BACJ,QAAmC4E,IAA/BhC,KAAK4yC,uBAA6E,IAAtC5yC,KAAK4yC,sBAAsBtxC,OACvE,OAGJ,MAAM2f,EAAajhB,KAAKiwC,YAAYjpC,IAChChH,KAAKwvC,kBAAkB/3B,MACvBzX,KAAKwvC,kBAAkBt+B,QAErBgsC,GAAiBj8B,EAAWxJ,MAAQ,EACpC0lC,EAAgBl8B,EAAW/P,OAAS,EAG1C,IAAK,MAAM4xB,KAAe9iC,KAAK4yC,sBAAwB,CAEnD,MAAMyD,EAAmBr2C,KAAKoiC,iBAAiBkU,oBAAoBxT,EAAY/c,OACzEwrB,EAAa8E,EAAiB9E,WACpC,QAAmBvvC,IAAfuvC,EACA,SAGJ,MAAMuF,GAAuB,EAG7B,GAFA92C,KAAK+2C,iBAAiBjU,EAAauT,EAAkBS,GAEjDhU,EAAY4U,eAAiB,EAAApyB,aAAaqyB,YAC1C,SAGJ,MAAMhJ,EAAQ4C,EAAWyF,SAASlU,EAAYxc,aAAe,EAAA2wB,2BAG7D,QAAcj1C,IAAV2sC,GACIA,EAAMuI,QAAQC,UAAYrU,EAAYkM,OAAQ1tC,OAASqtC,EAAMuI,QAAQ/P,SACrE,SASR,IAAIiW,EACJ,GALA7L,EAAW8F,gBAAkBvU,EAAYrc,YACzC8qB,EAAW+F,gBAAkBxU,EAAYnc,YAInCmc,EAAYlzB,OAAS,EAAAgX,gBAAgBE,UAEvC+mB,EAAmBpoC,EAAIy3C,EAAgBpa,EAAY/0B,SAAStI,EAAIwb,EAAWxJ,MAC3Eo2B,EAAmBnoC,EAAIy3C,EAAgBra,EAAY/0B,SAASrI,EAAIub,EAAW/P,YAC/ClP,IAAxB8gC,EAAYld,UACZioB,EAAmBpoC,GAAKq9B,EAAYld,cAEZ5jB,IAAxB8gC,EAAYjd,UACZgoB,EAAmBnoC,GAAKo9B,EAAYjd,SAGxC+nB,EAAanoC,EAAIooC,EAAmBpoC,EACpCmoC,EAAaloC,EAAImoC,EAAmBnoC,EACpCkoC,EAAahoC,EAAI,EACjB2oC,EAAgBzL,EAAayO,EAAY3D,OACtC,CAEHC,EAAmBpoC,EAAIy3C,EACvBrP,EAAmBnoC,EAAIy3C,OACKn7C,IAAxB8gC,EAAYld,UACZioB,EAAmBpoC,GAAKq9B,EAAYld,cAEZ5jB,IAAxB8gC,EAAYjd,UACZgoB,EAAmBnoC,GAAKo9B,EAAYjd,SAMxC,MAAMw3B,EAAgC,GACtC,IAAK,MAAMC,KAAMxa,EAAY5b,KAAO,CAChC,MAAMq2B,EAAK1P,EAAmBpoC,EAAI63C,EAAG73C,EAAIwb,EAAWxJ,MAC9C+lC,EAAK3P,EAAmBnoC,EAAI43C,EAAG53C,EAAIub,EAAW/P,OACpDmsC,EAAan3C,KAAK,IAAI9G,EAAMoG,QAAQ+3C,EAAIC,IAE5CJ,EAAW,IAAI,EAAAK,WACf,IAAK,IAAIrgD,EAAI,EAAGA,EAAIigD,EAAa/7C,OAAS,IAAKlE,EAC3CggD,EAASj9C,IAAI,IAAIf,EAAMs+C,UAAUL,EAAajgD,GAAIigD,EAAajgD,EAAI,KAEvEmxC,EAAgBzL,EAAayO,EAAY3D,EAAcwP,GAAU,KAKrE,yBACJp3C,EACAgJ,EACA2uC,GAQA,IAAIC,EAASD,EAAiB3uC,EAO9B,OAJA4uC,EAAS,GAAOA,EAAS,GAAO53C,EAAMqgB,cAEtCu3B,EAASv0C,KAAKS,IAAI8zC,EAAQ59C,KAAK2wC,UAAUkN,uBACzCD,EAASv0C,KAAKO,IAAIg0C,EAAQ59C,KAAK2wC,UAAUmN,uBAClCF,EAGH,wBACJ53C,EACA+3C,EACAC,GAEA,IAAIC,EAAoB,EACxB,MAAMC,EAAeH,EAAM9H,aAE3B,QAAqBj0C,IAAjBk8C,QAAgDl8C,IAAlBgE,EAAMigB,SAAyBjgB,EAAMigB,QAAU,EAAK,CAClF,MAAMD,OAA8BhkB,IAAnBgE,EAAMggB,SAAyB,EAAMhgB,EAAMggB,SACtDC,EAAUjgB,EAAMigB,QAClBA,EAAUD,IACVi4B,EACI,EACA7+C,EAAMkJ,UAAU6B,OACX+zC,EAAeF,EAAoBh4B,IAAaC,EAAUD,GAC3D,EACA,IAIhB,OAAOi4B,EAGH,cACJE,EACApwC,EACA0gC,EACA8E,EACAhC,EACA9rB,EACA24B,GAEA,MAAMC,EAA0BF,EAAWhmB,QACrCmmB,EAA2CH,EAAWG,gBAE5D,EAAAhyC,YAAqBtK,IAAdo8C,QAA2Dp8C,IAAhCm8C,EAAWI,kBAC7C,MAAMC,OACYx8C,IAAdo8C,EACMD,EAAWI,iBAAkBH,GAC7BD,EAAWK,gBACrB,EAAAlyC,YAA2BtK,IAApBw8C,GAGP3Q,EAAmBpoC,EAAIsoC,EAAsBtoC,EAAIgpC,EAAehpC,EAChEooC,EAAmBnoC,EAAIqoC,EAAsBroC,EAAI+oC,EAAe/oC,EAGhE,MAAMw4C,EAAe,EAAAO,qBACjB1wC,EACA/N,KAAKovC,YAAYvU,YACjB76B,KAAKmwC,gBAET,QAC2BnuC,IAAvBq8C,EAAWp4B,UACVo4B,EAAWp4B,SAAW,GACnBo4B,EAAWp4B,QAAUjmB,KAAKovC,YAAY4O,kBAAoBE,GAO9D,OAHIvQ,KACEA,EAAeuI,QAEd,EAEXiI,EAAWO,gBAAgBR,GAG3B,MAAM94B,EAAUi5B,EAAWj5B,QAC3B,IAAIu5B,GAAe,EAGnB,MAAMC,OACU58C,IAAZojB,GACA,EAAA9c,UAAUu2C,UACN7+C,KAAKovC,YAAYx4B,UACjBwO,EAAQoC,iBACRpC,EAAQuC,oBAES,IAArBvC,EAAS05B,QAEPC,EAAsB/+C,KAAKg/C,yBAC7BX,EACAH,EACAl+C,KAAKovC,YAAYuO,gBAEfsB,EAAYL,GAAcrL,EAAY2L,cAAcb,EAAYr+C,KAAKovC,YAAYhtC,KAEvF,GAAI68C,EAAW,CACX,MAAM94C,EAAS,EAAAg5C,UACXX,EACAp5B,EACA2oB,EACAgR,EACA/+C,KAAKovC,YAAYhtC,IACjBpC,KAAKuvC,oBAET,GAAIppC,IAAW,EAAAi5C,gBAAgBC,UAM3B,OALAb,EAAgBhW,QAEZmF,KACEA,EAAegJ,eAEd,EAEXgI,EAAex4C,IAAW,EAAAi5C,gBAAgBE,cACnCV,IAAmC,IAArBx5B,EAAS05B,UAG9B9+C,KAAKswC,sBAAuB,GAGhC,MAAMiP,EAAqBv/C,KAAKw/C,wBAC5BnB,EACAF,EACAn+C,KAAKovC,YAAY4O,mBAMrB,GAz4CR,SACIG,EACAsB,EACAxpC,GAEA,MAAMqoC,EAA2CH,EAAWG,gBACtDt4C,EAAQm4C,EAAWhmB,QACnB/S,EAAUpf,EAAMof,QAKtB,GAHA,EAAA9Y,OAAOtG,EAAM4J,OAAS,EAAAgX,gBAAgBE,kBAEF9kB,IAApBs8C,GAAgD,KAAft4C,EAAMwf,MAEnD,OAAO,EAWX,UAPgBxjB,IAAZojB,QACwBpjB,IAAxBy9C,EAAU7oC,WACV,EAAAtO,UAAUu2C,UACNY,EAAU7oC,UACVwO,EAAQoC,iBACRpC,EAAQuC,mBAGZ,OAAO,EAGX,MAAM+3B,EAAqB,EAAAzD,mBAAmBwD,EAAWxpC,EAAQ+lC,8BAKjE,UAH6B,IAAzBh2C,EAAM25C,qBACsB39C,IAA5Bm8C,EAAWlI,cACXkI,EAAWlI,aAAeyJ,UAMX19C,IAAZojB,IAA6C,IAApBA,EAAQ05B,UAA+C,IAA3B15B,EAAQw6B,gBA+1C7CC,CAAsB1B,EAAYn+C,KAAKovC,YAAapvC,KAAK2wC,WAI5D,CAGZ,MAAMmP,EAAc,EAAAC,gBAChB5B,EACAtQ,EACAkR,EACAxN,EACAvxC,KAAKovC,YAAYhtC,IACjBpC,KAAKuvC,mBACLoP,EACA/Q,OACc5rC,IAAdo8C,GAEJ,GAAI0B,IAAgB,EAAAV,gBAAgBC,UAKhC,OAJI1R,GACAA,EAAeqS,uBAEnB7B,EAAW3V,SACJ,EAGX,MAAMyX,EAAeH,IAAgB,EAAAV,gBAAgBE,SACrD,IAAKX,EAAc,CACf,MAAMuB,OACqBl+C,IAAvBq8C,EAAWj5B,UAA+D,IAAtCi5B,EAAWj5B,QAAQ86B,eAC3DvB,EAAesB,IAAiBC,EAGhCD,GACA3B,EAAiB6B,aAAa16B,EAAagsB,QAIzCwO,GAl4ClB,SAA6B9B,EAA8BsB,GAGvD,MAAMr6B,EAAU+4B,EAAWhmB,QAAQ/S,QAEnC,OACKq6B,EAAUW,qBACCp+C,IAAZojB,IACsC,IAAtCA,EAAQi7B,0BA03CkBC,CAAoBnC,EAAYn+C,KAAKovC,cACvDkP,EAAiBiC,cAGZN,GACD3B,EAAiBkC,YAAY/6B,EAAagsB,MAE9ChsB,EAAa22B,qBACT32B,EAAa22B,sBAAwBkC,EAAiBiC,WA19C1E,SACI5K,EACAnH,EACAC,EACAgS,EACAC,GAEA,MAAM5d,EAAc6S,EAAiBxd,QAE/BjN,EADkByqB,EAAiB2I,gBACRpzB,QAAUu1B,EAAa3d,EAAYrc,YAAayE,QAEjF,GAAgB,IAAZA,EACA,OAAO,EAIX8iB,EAA4BY,gBAAkB9L,EAAY+L,oBACrB7sC,IAAjC8gC,EAAY6d,mBACZ7d,EAAY6d,iBAAmBnS,EAAOoS,uBAClC9d,EAAYkM,OACZhB,IAGR,MAAM6S,EACF/d,EAAYrc,YAAa2E,kBAAoB,GAC7CojB,EAAO6I,gBAAgBxsB,SAASzB,eAAiB,EAWrD,OATA8kB,EAAwBS,MAAQ7L,EAAYxc,YAC5C4nB,EAAwBngC,SAAW0gC,EACnCP,EAAwB4S,MAAQJ,EAChCxS,EAAwBhjB,QAAUA,EAClCgjB,EAAwB9iB,kBAAoBy1B,EACtC3S,EAAwBhjB,QAAU4X,EAAYrc,YAAa2E,kBAC3D,EACN8iB,EAAwBY,YAAchM,EAAYhhB,SAAWghB,OAAc9gC,EAC3EwsC,EAAOuS,oBAAoBje,EAAY6d,iBAAmBzS,IACnD,EAw7CS8S,CACI7C,EACA5M,EACA3D,EACA2R,EACAR,IAEJpR,GAEAA,EAAesT,uBAK3B,GAAIhC,EAAW,CACPN,EACAH,EAAiB2B,aAAa16B,EAAagsB,MAE3C+M,EAAiBgC,YAAY/6B,EAAagsB,MAG9ChsB,EAAa22B,qBACT32B,EAAa22B,sBAAwBoC,EAAiB+B,WAE1D,MAAMr1B,EAAUszB,EAAgBtzB,QAAUq0B,EAC1C,GAAIr0B,EAAU,EAAG,CAIb,MAAMg2B,GAA0C,IAA1B97B,EAAS4B,eAA2B23B,EAC1DpL,EAAY4N,UACR/7B,EACA2oB,EACA/tC,KAAKuvC,mBACL4O,EAAWiD,eACXrC,EACAmC,EACAh2B,EACAlrB,KAAKovC,YAAYhtC,KAGjBurC,GACAA,EAAe0T,uBAK3B,OADA57B,EAAaswB,2BACN,EAGH,YACJoI,EACA5K,EACAhC,EACA9rB,GAEA,MAAMpR,EAAgB,EAAAitC,iBAClBnD,EAAWhmB,QACXn4B,KAAKovC,YAAYjgC,WACjBnP,KAAKovC,YAAYhtC,IACjBpC,KAAKkwC,cAGT,YAA0EluC,IAAtEhC,KAAKwvC,kBAAkB+R,QAAQltC,EAAew5B,IAI3C7tC,KAAKwhD,cACRrD,EACA9pC,EACAw5B,EACA0F,EACAhC,EACA9rB,GAIA,mBACJ04B,EACA5K,EACA+B,EACA/D,EACA9rB,GAEA,MAAMg8B,EAAkBtD,EAAWhmB,QAC7BjR,EAAOu6B,EAAgBnwC,OAGvB8T,EAAUq8B,EAAgBr8B,QAChC,GACoB,IAAhB8B,EAAK5lB,SACJiyC,EAAY2L,cAAcuC,EAAiBzhD,KAAKovC,YAAYhtC,KAE7D,OAIJ,IAAIs/C,OAC6B1/C,IAA7BojB,EAAQu8B,mBACRD,EAAcpM,EAAalwB,EAAQu8B,uBACf3/C,IAAhB0/C,IACAA,EAAc,GACdpM,EAAalwB,EAAQu8B,kBAAoBD,IAIjD,MAAME,EAAgBx8B,EAAQkH,UACxBu1B,OAC4B7/C,IAA9B4/C,EAAcrkC,YACRqkC,EAAcrkC,YAAcqkC,EAAcrkC,YAC1C,EAGV,GAAIskC,EAAiB,QAAqB7/C,IAAhB0/C,EACtB,IAAK,IAAII,EAAa,EAAGA,EAAa56B,EAAK5lB,SAAUwgD,EAAY,CAC7D,MAAMtwC,EAAQ0V,EAAK46B,GAEnB,QAAkE9/C,IAA9DhC,KAAKwvC,kBAAkB+R,QAAQ/vC,EAAOq8B,GAAmC,CAEzE,IAAIkU,GAAW,EACf,IAAK,IAAIC,EAAI,EAAGA,EAAIN,EAAYpgD,OAAQ0gD,GAAK,EAAG,CAQ5C,GADAD,EANoB,EAAAE,OAAOC,YACvBR,EAAYM,GACZN,EAAYM,EAAI,GAChBnU,EAAmBpoC,EACnBooC,EAAmBnoC,GAEEm8C,EACrBE,EACA,MAMHA,GAEG/hD,KAAKwhD,cACDrD,EACA3sC,EACAq8B,EACA0F,EACAhC,EACA9rB,EACAq8B,IAGJJ,EAAYx7C,KAAK2nC,EAAmBpoC,EAAGooC,EAAmBnoC,SAQ1E,IAAK,IAAIo8C,EAAa,EAAGA,EAAa56B,EAAK5lB,SAAUwgD,EAAY,CAC7D,MAAMtwC,EAAQ0V,EAAK46B,QAE+C9/C,IAA9DhC,KAAKwvC,kBAAkB+R,QAAQ/vC,EAAOq8B,IACtC7tC,KAAKwhD,cACDrD,EACA3sC,EACAq8B,EACA0F,EACAhC,EACA9rB,EACAq8B,IAOZ,aACJ3D,EACAd,EACA9L,EACA9rB,GAGA,MAAM08B,EAAkB,EAAAlG,mBACpBj8C,KAAKovC,YACLpvC,KAAK2wC,UAAUoL,+BAEbqG,EAAYjE,EAAWhmB,QAG7B,MAEqC,IAA7BiqB,EAAUzC,qBACkB39C,IAA5Bm8C,EAAWlI,cACXkI,EAAWlI,aAAekM,GAO9B,OAJIxU,KACEA,EAAeuI,OAErBiI,EAAWG,gBAAiB9V,SACrB,EAGX,QAC0BxmC,IAAtBogD,EAAUn8B,UACTm8B,EAAUn8B,SAAW,GAClBm8B,EAAUn8B,QAAUjmB,KAAKovC,YAAY4O,kBAAoBG,EAAWiD,gBAQxE,OAJIzT,KACEA,EAAeuI,OAErBiI,EAAWG,gBAAiB9V,SACrB,EAKX,IAAI4U,EAAW,IAAIh+C,EAAMijD,KACzBxU,EAAmBv+B,KAAK+tC,EAAa,IACrC,IAAK,IAAIjgD,EAAI,EAAGA,EAAIigD,EAAa/7C,OAAS,IAAKlE,EAC3CggD,EAASj9C,IAAI,IAAI,EAAAmiD,gBAAgBjF,EAAajgD,GAAIigD,EAAajgD,EAAI,KAGvE,GAAIggD,EAASmF,SAAS,IAAK98C,EAAI23C,EAASmF,SAAS,KAAM98C,EAAI,EAAG,CAC1DooC,EAAmBv+B,KAAK+tC,EAAaA,EAAa/7C,OAAS,IAC3D87C,EAAW,IAAIh+C,EAAMijD,KACrB,IAAK,IAAIjlD,EAAIigD,EAAa/7C,OAAS,EAAGlE,EAAI,IAAKA,EAC3CggD,EAASj9C,IAAI,IAAI,EAAAmiD,gBAAgBjF,EAAajgD,GAAIigD,EAAajgD,EAAI,KAK3E+gD,EAAWO,gBACP,EAAA8D,oBAAoBJ,EAAWpiD,KAAKovC,YAAYvU,YAAa76B,KAAKmwC,iBAEtE,MAAMsS,GAAsBtE,EAAWiD,eAGjCrC,EAAsB/+C,KAAKg/C,yBAC7BoD,EACAK,EACAziD,KAAKovC,YAAYuO,gBAEf+E,EAAWnR,EAAW8F,gBAAgBxsB,SAASzJ,KAGrD,GAFAmwB,EAAW8F,gBAAgBxsB,SAASzJ,MAAQ29B,EAGxC,EAAA4D,eACIxE,EACAf,EACAvP,EACA0D,EACAvxC,KAAKuvC,sBACH,EAAA6P,gBAAgBjE,GAOtB,OALA5J,EAAW8F,gBAAgBxsB,SAASzJ,KAAOshC,EACvC/U,KACEA,EAAegJ,cAErBwH,EAAWG,gBAAiB9V,SACrB,EAGX2V,EAAWG,gBAAiBkC,YAAY/6B,EAAagsB,MAErD,IAAIvmB,EAAUk3B,EAAU37B,YAAayE,QAOrC,GALIizB,EAAWG,gBAAiBiC,aAC5Br1B,GAAWizB,EAAWG,gBAAiBpzB,QACvCzF,EAAa22B,sBAAuB,GAGI,IAAxC+B,EAAWG,gBAAiBpzB,QAE5B,OADAqmB,EAAW8F,gBAAgBxsB,SAASzJ,KAAOshC,GACpC,EAGX,MAAME,EAAcrR,EAAW8F,gBAAgBnsB,QACzC23B,EAAgBtR,EAAW8F,gBAAgBjsB,kBAC3Cm0B,EAAqBv/C,KAAKw/C,wBAC5B4C,EACAjE,EACAn+C,KAAKovC,YAAY4O,mBAerB,OAbAzM,EAAW8F,gBAAgBnsB,QAAUA,EAAUq0B,EAC/ChO,EAAW8F,gBAAgBjsB,kBACvBmmB,EAAW8F,gBAAgBnsB,QAAUk3B,EAAU37B,YAAa2E,kBAEhEwiB,EAAahoC,EAAIu4C,EAAWiD,eAE5B7S,EAAgB6T,EAAW7Q,EAAY3D,EAAcwP,GACrD33B,EAAaswB,0BAGbxE,EAAW8F,gBAAgBxsB,SAASzJ,KAAOshC,EAC3CnR,EAAW8F,gBAAgBnsB,QAAU03B,EACrCrR,EAAW8F,gBAAgBjsB,kBAAoBy3B,GACxC,EAGH,kBAAkBrgC,GAGtB,IAAIsgC,EAAyB,EAE7BtgC,EAAmBniB,QAAQ+zC,IACvB,IAAK,MAAM3xB,KAAQ2xB,EAAgBzC,cAAchS,SAC7CmjB,GAA0BrgC,EAAKwgB,kBAAkBlpB,UAGzD,MAAMgpC,EAAgBD,EAj3DD,IAu3DrB,OAJIC,IAAkB/iD,KAAKowC,cACvB5jC,EAAO2iC,MAAM,4BAEjBnvC,KAAKowC,aAAe2S,EACb/iD,KAAKowC,gB,gHC58DpB,SAAY5C,GACR,qBACA,qBACA,iBACA,mBACA,mBACA,qBANJ,CAAY,EAAAA,WAAA,EAAAA,SAAQ,KAYpB,yB,4JCaA,+BAAoCwV,EAA+BC,GAC/D,GAAIC,EAAwBC,KAAKF,GAC7B,OAAOA,EACJ,GAAIA,EAASG,WAAW,KAAM,CAEjC,OADeC,EAAaL,GACZC,EAMhB,OAJIA,EAASG,WAAW,QACpBH,EAAWA,EAASK,OAAO,IAETC,EAAQP,GACPC,GAI/B,MAAMC,EAA0B,IAAIM,OAAO,uCAAwC,KAmBnF,SAAgBD,EAAQE,GACpB,QAAYzhD,IAARyhD,EACA,MAAO,KAEX,IAAIC,EAAMD,EAAI9wB,QAAQ,KAStB,OARa,IAAT+wB,IACAD,EAAMA,EAAIn9C,MAAM,EAAGo9C,IAEvBA,EAAMD,EAAI9wB,QAAQ,MACL,IAAT+wB,IACAD,EAAMA,EAAIn9C,MAAM,EAAGo9C,IAEvBA,EAAMD,EAAIE,YAAY,MACT,IAATD,EACO,KAEAD,EAAI5oC,UAAU,EAAG6oC,EAAM,GAetC,SAAgBL,EAAaI,GACzB,QAAYzhD,IAARyhD,EACA,MAAO,GAEX,MAAMt1B,EAASy1B,EAAsBH,GACrC,MAAwB,UAApBt1B,EAAO01B,SACA,UACA11B,EAAO21B,MAAQ31B,EAAO01B,SACtB11B,EAAO01B,SAAW,KAAO11B,EAAO21B,KAChC31B,EAAO21B,KACP,KAAO31B,EAAO21B,KACd31B,EAAO01B,SACP11B,EAAO01B,SAAW,KAElB,GAOf,SAAgBD,EACZH,GAKA,MAAMM,EAAc,IAAIP,OAAO,8BAA+B,KAExDvlB,EAAQwlB,EAAIxlB,MAAM8lB,GACxB,IAAK9lB,EACD,MAAM,IAAIx6B,MAAM,+CAA+CggD,MAEnE,MAAO,CACHI,SAAU5lB,EAAM,GAChB6lB,KAAM7lB,EAAM,IAlEpB,YA+BA,iBAqBA,2B,8FCpHA,MAAM+lB,EAAK,sCAQX,MAAajgD,EAmBT,YAAqB1F,GAAA,KAAAA,QAbrB,aAAamnB,GACT,MAAMyY,EAAQ+lB,EAAG9lB,KAAK1Y,GACtB,GAAc,OAAVyY,EAGJ,OAAO,IAAIl6B,EAAO+jB,OAAOmW,EAAM,KAUnC,SACI,MAAO,GAAGj+B,KAAK3B,WAtBvB,Y,81BCRA,cAsBA,QAUa,EAAAgxB,sBAAwB,CACjC,MACA,YACA,kBACA,eACA,cACA,WACA,eACA,WAOS,EAAAqD,2BAA6B,CAAC,UAAW,eAsBzC,EAAAnE,qBAAoD,GAGpD,EAAA01B,8BAA0E,CAGnFz1B,sBAAuB,QACvB01B,WAAY,CACR59B,YAAa,EAAA69B,UAAUC,kBACvBplC,QAAS,EAAAmlC,UAAUE,gBACnBtX,KAAM,EAAAoX,UAAUC,kBAChBE,UAAW,EAAAH,UAAUC,kBACrBn+B,QAAS,EAAAk+B,UAAUI,mBACnBv+B,SAAU,EAAAm+B,UAAUI,qBAKf,EAAAC,wBAA0B,EAAAC,yBACnC,EAAAR,8BACA,CACIC,WAAY,CACR/sC,QAAS,EAAAgtC,UAAUC,kBACnBM,cAAe,EAAAP,UAAUC,kBACzBn5B,MAAO,EAAAk5B,UAAUI,mBACjB75C,YAAa,EAAAy5C,UAAUI,mBACvBr5B,QAAS,EAAAi5B,UAAUC,qBAclB,EAAAO,0BAA4B,EAAAF,yBACrC,EAAAR,8BACA,EAAAO,yBAEJ,EAAAj2B,qBAAqBq2B,QAAU,EAAAD,0BAWlB,EAAAE,0BAA4B,EAAAJ,yBACrC,EAAAR,8BACA,EAAAO,yBAEJ,EAAAj2B,qBAAqBu2B,QAAU,EAAAD,0BAkB/B,MAAME,EAA+B,EAAAN,yBACjC,EAAAR,8BACA,CACIC,WAAY,CACR1+B,KAAM,EAAA2+B,UAAUE,gBAChBr+C,MAAO,EAAAm+C,UAAUE,gBACjBW,gBAAiB,EAAAb,UAAUE,gBAC3BY,WAAY,EAAAd,UAAUE,gBACtB1+B,SAAU,EAAAw+B,UAAUC,kBACpB38B,iBAAkB,EAAA08B,UAAUC,kBAC5Bx8B,iBAAkB,EAAAu8B,UAAUC,kBAC5B58B,iBAAkB,EAAA28B,UAAUC,kBAC5Bz8B,iBAAkB,EAAAw8B,UAAUC,kBAC5B/9B,cAAe,EAAA89B,UAAUC,kBACzBc,eAAgB,EAAAf,UAAUC,kBAC1Be,eAAgB,EAAAhB,UAAUC,kBAC1BgB,iBAAkB,EAAAjB,UAAUC,kBAC5BiB,iBAAkB,EAAAlB,UAAUC,kBAC5B/D,0BAA2B,EAAA8D,UAAUC,kBACrCkB,YAAa,EAAAnB,UAAUC,kBACvBlE,eAAgB,EAAAiE,UAAUC,kBAC1BmB,UAAW,EAAApB,UAAUC,kBACrBoB,UAAW,EAAArB,UAAUC,kBACrB7mC,YAAa,EAAA4mC,UAAUC,kBACvBxE,eAAgB,EAAAuE,UAAUC,kBAC1BqB,aAAc,EAAAtB,UAAUC,kBACxBsB,aAAc,EAAAvB,UAAUC,kBACxBx+B,QAAS,EAAAu+B,UAAUC,kBACnBv+B,QAAS,EAAAs+B,UAAUC,kBACnBuB,YAAa,EAAAxB,UAAUC,kBACvBwB,YAAa,EAAAzB,UAAUC,kBACvByB,UAAW,EAAA1B,UAAUC,kBACrB0B,aAAc,EAAA3B,UAAUC,kBACxB2B,YAAa,EAAA5B,UAAUC,kBACvB4B,SAAU,EAAA7B,UAAUC,kBACpB6B,QAAS,EAAA9B,UAAUE,gBACnB6B,aAAc,EAAA/B,UAAUC,kBACxB+B,aAAc,EAAAhC,UAAUE,gBACxB+B,kBAAmB,EAAAjC,UAAUC,kBAC7BiC,mBAAoB,EAAAlC,UAAUC,kBAC9BkC,oBAAqB,EAAAnC,UAAUC,kBAC/BmC,UAAW,EAAApC,UAAUI,mBACrBiC,eAAgB,EAAArC,UAAUI,mBAC1Bx+B,MAAO,EAAAo+B,UAAUC,kBACjBx5B,SAAU,EAAAu5B,UAAUC,kBACpBt5B,UAAW,EAAAq5B,UAAUC,kBACrBr5B,YAAa,EAAAo5B,UAAUC,kBACvBp5B,SAAU,EAAAm5B,UAAUC,kBACpB14B,SAAU,EAAAy4B,UAAUC,kBACpBz4B,QAAS,EAAAw4B,UAAUC,kBACnBx4B,SAAU,EAAAu4B,UAAUC,kBACpBv4B,UAAW,EAAAs4B,UAAUC,kBACrBt4B,eAAgB,EAAAq4B,UAAUC,kBAC1Br4B,aAAc,EAAAo4B,UAAUC,kBACxBp4B,aAAc,EAAAm4B,UAAUC,kBACxBn4B,WAAY,EAAAk4B,UAAUC,kBACtBl4B,WAAY,EAAAi4B,UAAUC,kBACtB54B,WAAY,EAAA24B,UAAUC,kBACtBj5B,gBAAiB,EAAAg5B,UAAUI,mBAC3Bn7B,eAAgB,EAAA+6B,UAAUI,mBAC1Bn5B,kBAAmB,EAAA+4B,UAAUI,mBAC7Bt5B,MAAO,EAAAk5B,UAAUI,mBACjBr5B,QAAS,EAAAi5B,UAAUI,mBACnBnjC,KAAM,EAAA+iC,UAAUI,sBAI5B,EAAAh2B,qBAAqB,eAAiBw2B,EACtC,EAAAx2B,qBAAqB,gBAAkBw2B,EAUvC,MAAM0B,EAA8E,CAChFvC,WAAY,CACRwC,cAAe,EAAAvC,UAAUI,mBACzBoC,oBAAqB,EAAAxC,UAAUI,mBAC/BqC,mBAAoB,EAAAzC,UAAUI,mBAC9BsC,UAAW,EAAA1C,UAAUI,mBACrBuC,YAAa,EAAA3C,UAAUI,mBACvBwC,aAAc,EAAA5C,UAAUI,qBA8BnB,EAAAyC,6BAA+B,EAAAvC,yBACxC,EAAAR,8BACAwC,EACA,CACIvC,WAAY,CACR+C,SAAU,EAAA9C,UAAUC,kBACpB8C,qBAAsB,EAAA/C,UAAUC,kBAChCn5B,MAAO,EAAAk5B,UAAUI,mBACjBr5B,QAAS,EAAAi5B,UAAUI,mBACnB75C,YAAa,EAAAy5C,UAAUI,mBACvB14B,UAAW,EAAAs4B,UAAUI,mBACrB4C,eAAgB,EAAAhD,UAAUI,mBAC1B6C,eAAgB,EAAAjD,UAAUI,mBAC1BlxB,SAAU,EAAA8wB,UAAUI,mBACpBjxB,QAAS,EAAA6wB,UAAUI,sBAI/B,EAAAh2B,qBAAqB,cAAgB,EAAAy4B,6BAErC,EAAAz4B,qBAAqB,eAAiB,EAAAy4B,6BAWzB,EAAAK,wBAA0B,EAAA5C,yBACnC,EAAAR,8BACA,CACIC,WAAY,CAERj5B,MAAO,EAAAk5B,UAAUI,mBACjBr5B,QAAS,EAAAi5B,UAAUI,mBACnB75C,YAAa,EAAAy5C,UAAUI,mBACvB14B,UAAW,EAAAs4B,UAAUE,mBAKjC,EAAA91B,qBAAqBmmB,KAAO,EAAA2S,wBAU5B,MAAMC,EAA0B,EAAA7C,yBAC5B,EAAAR,8BACAwC,EACA,CACIvC,WAAY,CACRj5B,MAAO,EAAAk5B,UAAUI,mBACjBr5B,QAAS,EAAAi5B,UAAUI,mBACnB75C,YAAa,EAAAy5C,UAAUI,mBACvB14B,UAAW,EAAAs4B,UAAUI,sBAIjC,EAAAh2B,qBAAqBg5B,KAAOD,EAS5B,MAAME,EAA8B,EAAA/C,yBAChC,EAAAR,8BACA,CACIC,WAAY,CACRj5B,MAAO,EAAAk5B,UAAUE,gBACjB9wB,aAAc,EAAA4wB,UAAUE,gBACxBzK,UAAW,EAAAuK,UAAUI,mBACrBkD,UAAW,EAAAtD,UAAUI,mBACrBmD,UAAW,EAAAvD,UAAUI,mBACrBoD,UAAW,EAAAxD,UAAUI,mBACrBr1B,UAAW,EAAAi1B,UAAUI,mBACrB75C,YAAa,EAAAy5C,UAAUI,mBACvBr5B,QAAS,EAAAi5B,UAAUI,mBACnBqD,SAAU,EAAAzD,UAAUI,mBACpBsD,kBAAmB,EAAA1D,UAAUI,mBAC7BuD,gBAAiB,EAAA3D,UAAUI,mBAC3Bx+C,IAAK,EAAAo+C,UAAUC,kBACf2D,cAAe,EAAA5D,UAAUC,kBACzBrrC,UAAW,EAAAorC,UAAUC,kBACrB4D,oBAAqB,EAAA7D,UAAUC,kBAC/BprC,gBAAiB,EAAAmrC,UAAUC,kBAC3B6D,0BAA2B,EAAA9D,UAAUC,kBACrCnrC,aAAc,EAAAkrC,UAAUC,kBACxB8D,uBAAwB,EAAA/D,UAAUC,kBAClCvrC,YAAa,EAAAsrC,UAAUC,kBACvB+D,sBAAuB,EAAAhE,UAAUC,kBACjCtrC,QAAS,EAAAqrC,UAAUC,kBACnBgE,kBAAmB,EAAAjE,UAAUC,kBAC7BlrC,aAAc,EAAAirC,UAAUC,kBACxBiE,uBAAwB,EAAAlE,UAAUC,kBAClC5rC,SAAU,EAAA2rC,UAAUC,kBACpBkE,mBAAoB,EAAAnE,UAAUC,qBAI1C,EAAA71B,qBAAqBg6B,SAAWf,EAWhC,MAAMgB,EAAqC,EAAA/D,yBACvC,EAAAR,8BACAuD,EACA,CACItD,WAAY,CACRhzC,OAAQ,EAAAizC,UAAUE,gBAClBoE,YAAa,EAAAtE,UAAUE,gBACvBp5B,MAAO,EAAAk5B,UAAUE,gBACjBqE,aAAc,EAAAvE,UAAUE,gBACxBsE,cAAe,EAAAxE,UAAUE,gBACzBuE,eAAgB,EAAAzE,UAAUE,gBAC1BwE,cAAe,EAAA1E,UAAUE,gBACzByE,UAAW,EAAA3E,UAAUE,gBACrB0E,SAAU,EAAA5E,UAAUE,gBACpB2E,mBAAoB,EAAA7E,UAAUC,kBAC9B6E,yBAA0B,EAAA9E,UAAUC,kBACpC8E,iBAAkB,EAAA/E,UAAUI,mBAC5Br5B,QAAS,EAAAi5B,UAAUI,mBACnB75C,YAAa,EAAAy5C,UAAUI,mBACvB14B,UAAW,EAAAs4B,UAAUI,mBACrBwC,aAAc,EAAA5C,UAAUI,mBACxBuC,YAAa,EAAA3C,UAAUI,mBACvB4E,aAAc,EAAAhF,UAAUC,kBACxByC,UAAW,EAAA1C,UAAUI,sBAIjC,EAAAh2B,qBAAqB,oBAAsBi6B,EAS3C,MAAMY,EAA0B,EAAA3E,yBAC5B,EAAAR,8BACA,CACIC,WAAY,CACR1+B,KAAM,EAAA2+B,UAAUE,gBAChBr+C,MAAO,EAAAm+C,UAAUE,gBACjBW,gBAAiB,EAAAb,UAAUE,gBAC3BY,WAAY,EAAAd,UAAUE,gBAEtBtkC,aAAc,EAAAokC,UAAUC,kBACxBpkC,aAAc,EAAAmkC,UAAUC,kBACxB/9B,cAAe,EAAA89B,UAAUC,kBACzBr9B,WAAY,EAAAo9B,UAAUC,kBACtBp9B,aAAc,EAAAm9B,UAAUC,kBACxBsB,aAAc,EAAAvB,UAAUC,kBACxBx+B,QAAS,EAAAu+B,UAAUC,kBACnBv+B,QAAS,EAAAs+B,UAAUC,kBACnBr+B,MAAO,EAAAo+B,UAAUC,kBACjBx5B,SAAU,EAAAu5B,UAAUC,kBACpBt5B,UAAW,EAAAq5B,UAAUC,kBACrBr5B,YAAa,EAAAo5B,UAAUC,kBACvBp5B,SAAU,EAAAm5B,UAAUC,kBACpB14B,SAAU,EAAAy4B,UAAUC,kBACpBz4B,QAAS,EAAAw4B,UAAUC,kBACnBx4B,SAAU,EAAAu4B,UAAUC,kBACpBv4B,UAAW,EAAAs4B,UAAUC,kBACrBt4B,eAAgB,EAAAq4B,UAAUC,kBAC1Br4B,aAAc,EAAAo4B,UAAUC,kBACxBp4B,aAAc,EAAAm4B,UAAUC,kBACxBn4B,WAAY,EAAAk4B,UAAUC,kBACtBl4B,WAAY,EAAAi4B,UAAUC,kBACtBj5B,gBAAiB,EAAAg5B,UAAUI,mBAC3Bn7B,eAAgB,EAAA+6B,UAAUI,mBAC1Bn5B,kBAAmB,EAAA+4B,UAAUI,mBAC7Bt5B,MAAO,EAAAk5B,UAAUI,mBACjBr5B,QAAS,EAAAi5B,UAAUI,mBACnB5+B,SAAU,EAAAw+B,UAAUI,mBACpBnjC,KAAM,EAAA+iC,UAAUI,sBAI5B,EAAAh2B,qBAAqB/I,KAAO4jC,EAU5B,MAAMC,EAA4B,EAAA5E,yBAC9B,EAAAR,8BACA,CACIC,WAAY,CACR5vB,UAAW,EAAA6vB,UAAUC,kBACrB/mC,OAAQ,EAAA8mC,UAAUI,sBAuK9B,SAAgB/3B,EACZF,GAEA,MAA0B,kBAAnBA,EAAU3uB,KAerB,SAAgB2rD,EACZh9B,GAEA,OAAOE,EAAwBF,IAAoC,aAAtBA,EAAUG,QAM3D,SAAgB88B,EAAgBj9B,GAC5B,MAA0B,SAAnBA,EAAU3uB,KAMrB,SAAgBqxB,EACZ1C,GAEA,MAA0B,qBAAnBA,EAAU3uB,KAMrB,SAAgBwxB,EAAoB7C,GAChC,MAA0B,aAAnBA,EAAU3uB,KAMrB,SAAgByxB,EAAmB9C,GAC/B,MAA0B,YAAnBA,EAAU3uB,KAarB,SAAgBy0B,EAAkB9F,GAC9B,MAA0B,WAAnBA,EAAU3uB,KAnOrB,EAAA4wB,qBAAqB0K,OAASowB,EAiG9B,8BAAmC/8B,GAC/B,MAA0B,YAAnBA,EAAU3uB,MAMrB,8BAAmC2uB,GAC/B,MAA0B,YAAnBA,EAAU3uB,MAMrB,0BAA+B2uB,GAC3B,MAA0B,iBAAnBA,EAAU3uB,MAMrB,iCAAsC2uB,GAClC,MAA0B,gBAAnBA,EAAU3uB,MAMrB,2BAAgC2uB,GAC5B,MAA0B,SAAnBA,EAAU3uB,MAMrB,gCAAqC2uB,GACjC,MAA0B,eAAnBA,EAAU3uB,MAA4C,gBAAnB2uB,EAAU3uB,MAQxD,wCACI2uB,GAEA,OACwB,eAAnBA,EAAU3uB,MAA4C,gBAAnB2uB,EAAU3uB,YACzBqE,IAArBsqB,EAAUk9B,QACW,WAArBl9B,EAAUk9B,QAOlB,+BAAoCl9B,GAChC,MAA0B,aAAnBA,EAAU3uB,MAOrB,4BASA,wCACI2uB,GAEA,OAAOE,EAAwBF,IAAoC,UAAtBA,EAAUG,SAM3D,oCASA,oBAOA,+BASA,wBAOA,uBAOA,2BAAgCH,GAC5B,MAA0B,SAAnBA,EAAU3uB,MAMrB,sBAIA,yCACI2uB,GAEA,MAA0B,yBAAnBA,EAAU3uB,MAOrB,8BAAmC2uB,GAC/B,OACIi9B,EAAgBj9B,IAChB6C,EAAoB7C,IACpB8C,EAAmB9C,IACnBg9B,EAAgCh9B,IAOxC,iCAAsCA,GAClC,OAAI6C,EAAoB7C,IAEb0C,EAA2B1C,IAE3B8C,EAAmB9C,IAEnB8F,EAAkB9F,GALlBA,EAAUm9B,2BAQjB,GAOR,oCAAyCn9B,EAAsBo9B,GAC3D,GACIv6B,EAAoB7C,IACpB0C,EAA2B1C,IAC3B8C,EAAmB9C,GAEnB,IAAK,MAAMq9B,KAAsB,EAAAt6B,sBAAuB,CACpD,MAAME,EAAmBjD,EAAkBq9B,GACvC,EAAAt5B,gBAAgBd,IACZA,EAAgBmB,kBAAkBk5B,aAClCF,EAAaxjD,KAAKqpB,EAAgBmB,UAetD,uCACIm5B,EACAv9B,GAEA,IAAIw9B,EAAcD,EAOlB,MAN4C,iBAAjCv9B,EAAU+5B,qBACjByD,EAAcx9B,EAAU+5B,mBAAqByD,GAEJ,iBAAlCx9B,EAAUg6B,sBACjBwD,GAA4Bx9B,EAAUg6B,qBAEnCwD,I,8RC/wBX,aACA,OAEA,OAGA,QACA,SACA,SACA,SAEMC,EAAe,IAAI3qD,EAAM8Y,QA6I/B,SAASoI,EAAsBtR,EAAkBg7C,GAC7C,OAAOh7C,EAAWg7C,EAAgBC,QAWtC,SAASC,EACLC,EACA1/C,QAKyBzI,IAArByI,EAASe,UACTf,EAASe,QAAU,IAIvB2+C,EAAMC,cAAgB3/C,EAASe,aAIFxJ,IAAzBmoD,EAAME,iBACNF,EAAME,eAAiB,IAkB/B,SAASC,EAAoBH,EAA8BlxB,GACvDn7B,OAAOysD,OAAOtxB,EAAOjhB,SAAUmyC,EAAME,gBACrCF,EAAME,eAAiBpxB,EAAOjhB,SA8ClC,IAAUwyC,EAoLOC,EAqUAC,EA7fjB,+BAAoCjgD,GAChC,MAAO,mBAAoBA,GAG/B,SAAU+/C,GAMN,SAAgBG,EAAUC,GACtB,OAAgD,OAAzCA,EAAqB5xC,gBADhB,EAAA2xC,UAAS,EAUT,EAAAE,0BAAhB,SACID,GAEA,EAAAt+C,YAA8CtK,IAAvC4oD,EAAqBR,eAC5B,EAAA99C,YAA+CtK,IAAxC4oD,EAAqBP,gBAE5B,MAAMS,EAAqBH,EAAUC,GAG/Br+C,EAAc,EAAAb,gBAChBk/C,EAAqBR,cACrB,sBACAU,GAKJ,GAHAF,EAAqBr+C,YAAcA,EAG/Bu+C,EAAoB,CACpB,MAAM3zC,EAAUyzC,EAAqB5xC,gBACrC7B,EAAQ5K,aAAc,EACtBq+C,EAAqBP,eAAgBrxC,gBAAgB3a,MAAQ8Y,OACtD5K,IACPq+C,EAAqBP,eAAgBrxC,gBAAgB3a,MAAQ0rD,IAarD,EAAAgB,gBAAhB,SACIH,EACA3xB,GAEK0xB,EAAUC,KAGf,EAAAt+C,YAA+CtK,IAAxC4oD,EAAqBP,gBAO5BC,EAAoBM,EAAsB3xB,GAG1CA,EAAOG,aAAeH,EAAOG,aAAahtB,QACtC,6BACA,mGAKJ6sB,EAAOG,aAAe,EAAA4xB,oBAClB/xB,EAAOG,aACP,kBACA,+BAGJH,EAAOG,aAAe,EAAA4xB,oBAClB/xB,EAAOG,aACP,kBACA,0BACA,KArFZ,CAAUoxB,MAAmB,KA0F7B,MAAaS,EAAb,cAOY,KAAAC,kBAA0C,KAIlD,sBACI,OAAOlrD,KAAKkrD,kBAKhB,oBAAoBnlD,GAChB/F,KAAKmrD,mBAAmBplD,GAGlB,qBACN,OAAO/F,KAAKkrD,kBAGN,mBAAmBnlD,GACrBA,IAAQ/F,KAAKkrD,oBACblrD,KAAKkrD,kBAAoBnlD,EACzBykD,EAAoBK,0BAA0B7qD,OAM5C,4BACNlC,OAAOC,eAAeiC,KAAM,kBAAmB,CAC3C/B,IAAK,IACM+B,KAAK01C,qBAEhB1uC,IAAK8yB,IACD95B,KAAKmrD,mBAAmBrxB,MAQ1B,4BAA4Bzc,GAClC6sC,EAAsBlqD,KAAMA,MAE5B,EAAAsM,YAA8BtK,IAAvBhC,KAAKoqD,eACZ,EAAA99C,YAA+BtK,IAAxBhC,KAAKqqD,gBAIZ,MAAMryC,EAAWhY,KAAKqqD,eACtBryC,EAASgB,gBAAkB,IAAI5Z,EAAMgsD,QAAQrB,GAC7C/xC,EAASqzC,kBAAoB,IAAIjsD,EAAMgsD,QAAQ,GAC/CpzC,EAASszC,iBAAmB,IAAIlsD,EAAMgsD,QAAQ,QAG/BppD,IAAXqb,QAC+Brb,IAA3Bqb,EAAOrE,iBACPhZ,KAAKmrD,mBAAmB9tC,EAAOrE,iBAIvChZ,KAAK+qD,gBAAkB,EAAAzkB,eAAetmC,KAAK+qD,gBAAkB9xB,IACzDuxB,EAAoBO,gBAAgB/qD,KAAMi5B,KAI9Cj5B,KAAKuM,YAAci+C,EAAoBG,UAAU3qD,MAQ3C,2BAA2BqrB,GAEjC,OADArrB,KAAKmrD,mBAAmB9/B,EAAOrS,iBACxBhZ,MAnFf,6BA0FA,SAAiByqD,GAcb,SAAgBE,EAAUY,GAGtB,YACgCvpD,IAA5BupD,EAAevlC,eACYhkB,IAA3BupD,EAAetlC,SACfslC,EAAetlC,QAAU,EAnBpB,EAAAulC,mBAA6B,EAC7B,EAAAC,kBAA4B,EAYzB,EAAAd,UAAS,EAkBT,EAAAe,UAAhB,SAA0BH,GACtB,YAAmCvpD,IAA5BupD,EAAevlC,eAAqDhkB,IAA3BupD,EAAetlC,SAMnD,EAAA0lC,wBAAhB,gBACiD3pD,IAAzC5C,EAAMwsD,YAAYC,oBAClB/tD,OAAOysD,OAAOnrD,EAAMwsD,YAAa,YAUzB,EAAAE,oBAAhB,SAAoCP,GAChC,EAAAj/C,YAAwCtK,IAAjCupD,EAAenB,eACtB,EAAA99C,YAAyCtK,IAAlCupD,EAAelB,gBAMtB,MAAM0B,EAAYpB,EAAUY,GACtBh/C,EAAc,EAAAb,gBAChB6/C,EAAenB,cACf,kBACA2B,GAIJR,EAAeh/C,YAAcA,EAG7B,EAAAD,YACgDtK,IAA5CupD,EAAelB,eAAgBrkC,eACgBhkB,IAA3CupD,EAAelB,eAAgBpkC,SAInC8lC,GACAR,EAAelB,eAAgBrkC,SAAS3nB,MAAQktD,EAAevlC,SAC/DulC,EAAelB,eAAgBpkC,QAAQ5nB,MAAQktD,EAAetlC,QAC1D1Z,GACA,EAAA/B,eAAe+gD,IAIdh/C,IACLg/C,EAAelB,eAAgBrkC,SAAS3nB,MAAQosD,EAAce,kBAC9DD,EAAelB,eAAgBpkC,QAAQ5nB,MAAQosD,EAAcgB,iBAC7D,EAAAv9B,gBAAgBq9B,KAaR,EAAAR,gBAAhB,SAAgCQ,EAA+BtyB,GACtD0xB,EAAUY,KAGf,EAAAj/C,YAAyCtK,IAAlCupD,EAAelB,gBAQtBC,EAAoBiB,EAAgBtyB,GAIpCA,EAAOG,aAAe,EAAA4xB,oBAClB/xB,EAAOG,aACP,kBACA,sBAGJH,EAAOG,aAAe,EAAA4xB,oBAClB/xB,EAAOG,aACP,aACA,iBACA,GAGJH,EAAOI,eAAiB,EAAA2xB,oBACpB/xB,EAAOI,eACP,oBACA,wBAGJJ,EAAOI,eAAiB,EAAA2xB,oBACpB/xB,EAAOI,eACP,eACA,mBACA,KAoBQ,EAAA2yB,gBAAhB,SACIltD,EACAmtD,EACAjmC,EACAC,EACAimC,EACAC,GAMArtD,EAAOstD,eAAiB,EAAA9lB,eACpBxnC,EAAOstD,eACP,CACI1zB,EACAC,EACAjqB,EACAwL,EACAzP,EACAk4B,KAEA,MAAM4oB,EAAiB9gD,EAEvB8gD,EAAevlC,cACEhkB,IAAbgkB,GAA0BA,IAAaykC,EAAce,kBAC/Cf,EAAce,kBACdlrC,EAAsB0F,EAAUimC,GAE1CV,EAAetlC,aACCjkB,IAAZikB,GAAyBA,IAAYwkC,EAAcgB,iBAC7ChB,EAAcgB,iBACdnrC,EAAsB2F,EAASgmC,QAEdjqD,IAAvBmqD,GACAA,EAAmBzzB,EAAUjuB,MAlMjD,CAAiBggD,EAAA,EAAAA,gBAAA,EAAAA,cAAa,KAgN9B,MAAa4B,EAAb,cAOY,KAAAC,WAAqB7B,EAAce,kBACnC,KAAAe,UAAoB9B,EAAcgB,iBAKhC,cACN,OAAOzrD,KAAKssD,WAKN,YAAYjuD,GACEA,IAAU2B,KAAKssD,aAE/BtsD,KAAKssD,WAAajuD,EAClBosD,EAAcqB,oBAAoB9rD,OAOhC,aACN,OAAOA,KAAKusD,UAKN,WAAWluD,GACGA,IAAU2B,KAAKusD,YAE/BvsD,KAAKusD,UAAYluD,EACjBosD,EAAcqB,oBAAoB9rD,OAQhC,sBACNlC,OAAOC,eAAeiC,KAAM,WAAY,CACpC/B,IAAK,IACM+B,KAAKwsD,cAEhBxlD,IAAK8yB,IACD95B,KAAKysD,YAAY3yB,MAGzBh8B,OAAOC,eAAeiC,KAAM,UAAW,CACnC/B,IAAK,IACM+B,KAAK0sD,aAEhB1lD,IAAK8yB,IACD95B,KAAK2sD,WAAW7yB,MAUlB,sBAAsBzc,GAE5B6sC,EAAsBlqD,KAAMA,MAE5B,EAAAsM,YAA8BtK,IAAvBhC,KAAKoqD,eACZ,EAAA99C,YAA+BtK,IAAxBhC,KAAKqqD,gBAIZrqD,KAAKqqD,eAAgBrkC,SAAW,IAAI5mB,EAAMgsD,QAAQX,EAAce,mBAChExrD,KAAKqqD,eAAgBpkC,QAAU,IAAI7mB,EAAMgsD,QAAQX,EAAcgB,uBAGhDzpD,IAAXqb,SACwBrb,IAApBqb,EAAO2I,UACPhmB,KAAKysD,YAAYpvC,EAAO2I,eAELhkB,IAAnBqb,EAAO4I,SACPjmB,KAAK2sD,WAAWtvC,EAAO4I,UAI/BjmB,KAAK+qD,gBAAkB,EAAAzkB,eAAetmC,KAAK+qD,gBAAkB9xB,IACzDwxB,EAAcM,gBAAgB/qD,KAAMi5B,KAGxCj5B,KAAKuM,YAAck+C,EAAcE,UAAU3qD,MAQrC,qBAAqBqrB,GAO3B,OANArrB,KAAKysD,iBACmBzqD,IAApBqpB,EAAOrF,SAAyBykC,EAAce,kBAAoBngC,EAAOrF,UAE7EhmB,KAAK2sD,gBACkB3qD,IAAnBqpB,EAAOpF,QAAwBwkC,EAAcgB,iBAAmBpgC,EAAOpF,SAEpEjmB,MAjHf,uBAqHA,SAAiB0qD,GAMb,SAAgBC,EAAUiC,GACtB,YACyC5qD,IAArC4qD,EAAkBC,gBAClBD,EAAkBC,gBAAkB,EAAA1sB,qBAAqBC,kBAHjD,EAAAuqB,UAAS,EAUT,EAAAgB,wBAAhB,gBACoD3pD,IAA5C5C,EAAMwsD,YAAYkB,uBAClBhvD,OAAOysD,OAAOnrD,EAAMwsD,YAAa,YASzB,EAAAmB,uBAAhB,SAAuCH,GACnC,EAAAtgD,YAA2CtK,IAApC4qD,EAAkBxC,eACzB,EAAA99C,YAA4CtK,IAArC4qD,EAAkBvC,gBAGzB,MAAM2C,EAAerC,EAAUiC,GAGzBrgD,EAAc,EAAAb,gBAChBkhD,EAAkBxC,cAClB,qBACA4C,GAGJJ,EAAkBrgD,YAAcA,EAG5BygD,EACAJ,EAAkBvC,eAAgBwC,eAAexuD,MAC7CuuD,EAAkBC,eAGjBtgD,IACLqgD,EAAkBvC,eAAgBwC,eAAexuD,MAC7C,EAAA8hC,qBAAqBE,oBAajB,EAAA0qB,gBAAhB,SAAgC6B,EAAqC3zB,GAC5D0xB,EAAUiC,KAGf,EAAAtgD,YAA4CtK,IAArC4qD,EAAkBvC,gBAOzBC,EAAoBsC,EAAmB3zB,GAEvCA,EAAOG,aAAe,EAAA4xB,oBAClB/xB,EAAOG,aACP,SACA,yBAGJH,EAAOG,aAAe,EAAA4xB,oBAClB/xB,EAAOG,aACP,eACA,oBACA,GAGJH,EAAOI,eAAiB,EAAA2xB,oBACpB/xB,EAAOI,eACP,oBACA,2BAGJJ,EAAOI,eAAiBJ,EAAOI,eAAejtB,QAC1C,mCACA,8CAGJ6sB,EAAOI,eAAiB,EAAA2xB,oBACpB/xB,EAAOI,eACP,eACA,sBACA,KAzGZ,CAAiBqxB,EAAA,EAAAA,mBAAA,EAAAA,iBAAgB,KAuHjC,MAAauC,EAAb,cAOY,KAAAC,YAAsB,EAAA/sB,qBAAqBE,kBAKzC,oBACN,OAAOrgC,KAAKktD,YAKN,kBAAkB7uD,GACJA,IAAU2B,KAAKktD,cAE/BltD,KAAKktD,YAAc7uD,EACnBqsD,EAAiBqC,uBAAuB/sD,OAOtC,yBACNlC,OAAOC,eAAeiC,KAAM,iBAAkB,CAC1C/B,IAAK,IACM+B,KAAKmtD,oBAEhBnmD,IAAK8yB,IACD95B,KAAKotD,kBAAkBtzB,MAQzB,yBAAyBzc,GAE/B6sC,EAAsBlqD,KAAMA,MAE5B,EAAAsM,YAA8BtK,IAAvBhC,KAAKoqD,eACZ,EAAA99C,YAA+BtK,IAAxBhC,KAAKqqD,gBAERhtC,IAAyC,IAA/BA,EAAOgwC,sBACjBrtD,KAAKoqD,cAAckD,qBAAuB,IAK9CttD,KAAKqqD,eAAgBwC,eAAiB,IAAIztD,EAAMgsD,QAC5C,EAAAjrB,qBAAqBE,wBAIVr+B,IAAXqb,QAC8Brb,IAA1Bqb,EAAOwvC,gBACP7sD,KAAKotD,kBAAkB/vC,EAAOwvC,gBAItC7sD,KAAK+qD,gBAAkB,EAAAzkB,eAAetmC,KAAK+qD,gBAAkB9xB,IACzDyxB,EAAiBK,gBAAgB/qD,KAAMi5B,KAG3Cj5B,KAAKuM,YAAcm+C,EAAiBC,UAAU3qD,MAQxC,wBAAwBqrB,GAI9B,YAH8BrpB,IAA1BqpB,EAAOwhC,gBACP7sD,KAAKotD,kBAAkB/hC,EAAOwhC,gBAE3B7sD,MAnFf,0BAgGA,MAAaoY,UAA6BhZ,EAAM+Y,kBAO5C,YACIkF,GAKAra,MAAMqa,GAENotC,EAAckB,0BAEd3rD,KAAKutD,sBACLvtD,KAAKwtD,sBAAsBnwC,GAE3BqtC,EAAiBiB,0BAEjB3rD,KAAKytD,yBACLztD,KAAK0tD,yBAAyB,OAAD,wBAAMrwC,GAAM,CAAEgwC,qBAAqB,KAEhErtD,KAAK2tD,4BACL3tD,KAAK4tD,4BAA4BvwC,GAKrC,QACI,OAAO,IAAIjF,GAAuB9I,KAAKtP,MAK3C,KAAKqrB,GAKD,OAJAroB,MAAMsM,KAAK+b,GACXrrB,KAAK6tD,qBAAqBxiC,GAC1BrrB,KAAK8tD,wBAAwBziC,GAC7BrrB,KAAK+tD,2BAA2B1iC,GACzBrrB,KAWX,eACI,OAAOyqD,EAAce,kBAGzB,aAAantD,IAIb,cACI,OAAOosD,EAAcgB,iBAGzB,YAAYptD,IAIZ,qBACI,OAAO,EAAA8hC,qBAAqBE,kBAGhC,mBAAmBhiC,IAInB,sBACI,OAAO,KAIX,oBAAoBA,IAKpB,mBAAmBA,IAIT,uBAKA,sBAAsBgf,IAKtB,qBAAqBgO,IAIrB,0BAKA,yBAAyBhO,IAKzB,wBAAwBgO,IAIxB,6BAKA,4BAA4BhO,IAK5B,2BAA2BgO,KAjIzC,yBAuIA,MAAa2iC,UAA6B5uD,EAAM6uD,kBAC5C,YAAY5wC,GACRra,MAAMqa,GAENqtC,EAAiBiB,0BAEjB3rD,KAAKytD,yBAKLztD,KAAK0tD,yBAAyB,OAAD,wBAAMrwC,GAAM,CAAEgwC,qBAAqB,KAChErtD,KAAKivB,aAAc,EAUvB,qBACI,OAAO,EAAAkR,qBAAqBE,kBAGhC,mBAAmBhiC,IAIT,0BAKA,yBAAyBgf,IAKzB,wBAAwBgO,KAxCtC,yBAuDA,MAAa3S,UAAgCtZ,EAAM8uD,qBAS/C,YACI7wC,GAKAra,MAAMqa,GAENotC,EAAckB,0BAEd3rD,KAAKutD,sBACLvtD,KAAKwtD,sBAAsBnwC,GAE3BqtC,EAAiBiB,0BAEjB3rD,KAAKytD,yBACLztD,KAAK0tD,yBAAyB,OAAD,wBAAMrwC,GAAM,CAAEgwC,qBAAqB,MAE7B,KAA/BhwC,aAAM,EAANA,EAAQyR,sBACR9uB,KAAK+qD,gBAAkB,EAAAzkB,eAAetmC,KAAK+qD,gBAAiB9xB,IACxDA,EAAOI,eAAiBj6B,EAAMwsD,YAAYuC,kBAAkB/hD,QACxD,2CACA,EAAAgiD,8BAQhB,QACI,OAAO,IAAI11C,GAA0BpJ,KAAKtP,MAK9C,KAAKqrB,GAID,OAHAroB,MAAMsM,KAAK+b,GACXrrB,KAAK6tD,qBAAqBxiC,GAC1BrrB,KAAK8tD,wBAAwBziC,GACtBrrB,KAIX,sBACI,YAAiCgC,IAA1BgB,MAAMgW,gBAAgC,KAAOhW,MAAMgW,gBAI9D,oBAAoBjT,GACZA,IAAQ/F,KAAKgZ,kBAIZjT,GAAQ/F,KAAKgZ,kBACdhZ,KAAKuM,aAAc,GAGnBxG,IACAA,EAAIwG,aAAc,GAEtBvJ,MAAMgW,gBAAkBjT,GAW5B,eACI,OAAO0kD,EAAce,kBAGzB,aAAantD,IAIb,cACI,OAAOosD,EAAcgB,iBAGzB,YAAYptD,IAIZ,qBACI,OAAO,EAAA8hC,qBAAqBE,kBAGhC,mBAAmBhiC,IAWnB,yBACI,OAAO,EAGX,uBAAuBy7B,IAIb,uBAKA,sBAAsBzc,IAKtB,qBAAqBgO,IAIrB,0BAKA,yBAAyBhO,IAKzB,wBAAwBgO,KAhJtC,4BA0JA,EAAAgjC,6BAA6Bj2C,EAAsB,CAACi0C,IACpD,EAAAgC,6BAA6B31C,EAAyB,CAAC2zC,IACvD,EAAAgC,6BAA6Bj2C,EAAsB,CAAC60C,IACpD,EAAAoB,6BAA6B31C,EAAyB,CAACu0C,IACvD,EAAAoB,6BAA6BL,EAAsB,CAACf,IACpD,EAAAoB,6BAA6Bj2C,EAAsB,CAAC6yC,K,6BClyCpD,IAAYqD,E,wEAAZ,SAAYA,GACR,6BACA,iCACA,+BACA,2CACA,6CALJ,CAAYA,EAAA,EAAAA,gBAAA,EAAAA,cAAa,KAQzB,UAAe,CACXC,uBAAwB,2+BA4BxBC,yBAA0B,uBACVF,EAAcG,kCACZH,EAAcI,mCACfJ,EAAcK,wCACRL,EAAcM,+CACbN,EAAcO,qnDAoCtCC,eAAgB,sRAQhBC,yBAA0B,kV,iGCzF9B,aAEA,QAOA,MAAaC,EAyDT,YACa73B,EACAU,EACApgB,EACAvG,EACA+9C,EACA16C,EACAC,EACT06C,EACAC,EACAC,EACAC,EACSl4C,EACAm4C,GAZA,KAAAn4B,YACA,KAAAU,QACA,KAAApgB,QACA,KAAAvG,SACA,KAAA+9C,WACA,KAAA16C,UACA,KAAAC,UAKA,KAAA2C,UACA,KAAAm4C,OAxDb,KAAAC,UAA6B,GAM7B,KAAAC,yBAA4C,GAM5C,KAAAC,0BAA6C,GAK7C,KAAAC,UAAoB,EAKpB,KAAAC,WAAqB,EAoCjB3vD,KAAK4vD,UAAYC,OAAOC,cAAc34B,GACtCn3B,KAAK+vD,UAAY,EAAAh5B,aAAaa,aAAaT,EAAWU,GAEtD,MAAM/Y,EAAO9e,KAAKuU,QACZ8K,EAAQP,EAAO9e,KAAKyX,MACpBmH,EAAM0wC,EAAKU,QAAQC,WAAajwD,KAAKwU,QACrC8K,EAASV,EAAM5e,KAAKkR,OAE1BlR,KAAKuvD,UAAUrpD,KACX,IAAI9G,EAAMuG,QAAQmZ,EAAMQ,EAAQ,GAChC,IAAIlgB,EAAMuG,QAAQ0Z,EAAOC,EAAQ,GACjC,IAAIlgB,EAAMuG,QAAQmZ,EAAMF,EAAK,GAC7B,IAAIxf,EAAMuG,QAAQ0Z,EAAOT,EAAK,IAGlC5e,KAAKwvD,yBAAyBtpD,KAC1B,IAAI9G,EAAMoG,QAAQ0pD,EAAIC,GACtB,IAAI/vD,EAAMoG,QAAQ4pD,EAAID,GACtB,IAAI/vD,EAAMoG,QAAQ0pD,EAAIG,GACtB,IAAIjwD,EAAMoG,QAAQ4pD,EAAIC,IAG1BrvD,KAAKyvD,0BAA0BvpD,KAC3B,IAAI9G,EAAMoG,QAAQ,EAAK,GACvB,IAAIpG,EAAMoG,QAAQ,EAAK,GACvB,IAAIpG,EAAMoG,QAAQ,EAAK,GACvB,IAAIpG,EAAMoG,QAAQ,EAAK,IAS/B,QACI,OAAO,IAAIwpD,EACPhvD,KAAKm3B,UACLn3B,KAAK63B,MACL73B,KAAKyX,MACLzX,KAAKkR,OACLlR,KAAKivD,SACLjvD,KAAKuU,QACLvU,KAAKwU,QACLxU,KAAKwvD,yBAAyB,GAAG/pD,EACjCzF,KAAKwvD,yBAAyB,GAAG9pD,EACjC1F,KAAKwvD,yBAAyB,GAAG/pD,EACjCzF,KAAKwvD,yBAAyB,GAAG9pD,EACjC1F,KAAKmX,QACLnX,KAAKsvD,OAzHjB,e,oQCVA,aAOa,EAAAY,aAAe,MACf,EAAAC,qBAAuB,GACvB,EAAAC,oBAAsB,EACtB,EAAAC,kBAAoB,EACpB,EAAAC,iBAAmB,EACnB,EAAAC,6BAA+B,EAAAF,kBAAoB,EAAAF,qBACnD,EAAAK,4BAA8B,EAAAF,iBAAmB,EAAAF,oBAyB9D,qBAsDI,YACaz3B,EACTluB,EACAgmD,EACAC,EACAvpB,GAJS,KAAAxO,QAMT34B,KAAKmnC,SAAW99B,KAAKO,IAAIu9B,EAAU,EAAA+oB,cACnClwD,KAAK2wD,kBAAoBtnD,KAAKO,IAAI8mD,EAAavpB,GAC/CnnC,KAAK4wD,YAAc,EACnB5wD,KAAK6wD,eAAiB,EACtB7wD,KAAK8wD,eAAiB,EAEtB9wD,KAAK+wD,eAAiB,IAAI3xD,EAAM4xD,kBAC5B,IAAIx/B,aAAaxxB,KAAK2wD,kBAAoB,EAAAJ,8BAC1C,EAAAJ,sBAEJnwD,KAAK+wD,eAAeE,SAAS7xD,EAAM8xD,kBACnClxD,KAAKmxD,oBAAsB,IAAI/xD,EAAMya,2BAA2B7Z,KAAK+wD,eAAgB,EAAG,GACxF/wD,KAAKoxD,cAAgB,IAAIhyD,EAAMya,2BAA2B7Z,KAAK+wD,eAAgB,EAAG,GAClF/wD,KAAKqxD,iBAAmB,IAAIjyD,EAAMya,2BAA2B7Z,KAAK+wD,eAAgB,EAAG,GACrF/wD,KAAKsxD,mBAAqB,IAAIlyD,EAAMya,2BAA2B7Z,KAAK+wD,eAAgB,EAAG,IAEvF/wD,KAAKuxD,cAAgB,IAAInyD,EAAM0a,gBAC3B,IAAIwX,YAAYtxB,KAAK2wD,kBAAoB,EAAAH,6BACzC,EAAAJ,qBAEJpwD,KAAKuxD,cAAcN,SAAS7xD,EAAM8xD,kBAElClxD,KAAKwxD,WAAa,IAAIpyD,EAAMob,eAC5Bxa,KAAKwxD,WAAWC,aAAa,WAAYzxD,KAAKmxD,qBAC9CnxD,KAAKwxD,WAAWC,aAAa,KAAMzxD,KAAKoxD,eACxCpxD,KAAKwxD,WAAWC,aAAa,QAASzxD,KAAKqxD,kBAC3CrxD,KAAKwxD,WAAWC,aAAa,UAAWzxD,KAAKsxD,oBAC7CtxD,KAAKwxD,WAAWE,SAAS1xD,KAAKuxD,eAE9BvxD,KAAK2xD,mBAAqB,IAAIvwD,MAAMpB,KAAK2wD,mBAEzC3wD,KAAK25B,OAAS,IAAIv6B,EAAM40B,KAAKh0B,KAAKwxD,WAAY/mD,GAC9CzK,KAAK4xD,SAAW,IAAIxyD,EAAM40B,KAAKh0B,KAAKwxD,WAAYf,GAChDzwD,KAAK25B,OAAOrT,YAAcwB,OAAOC,iBACjC/nB,KAAK4xD,SAAStrC,YAAcwB,OAAOC,iBAAmB,EACtD/nB,KAAK25B,OAAOk4B,eAAgB,EAC5B7xD,KAAK4xD,SAASC,eAAgB,EAC9B7xD,KAAK24B,MAAMx4B,IAAIH,KAAK4xD,SAAU5xD,KAAK25B,QA9FvC,gBACI,OAAO35B,KAAK4wD,YAMhB,WACI,OAAO5wD,KAAK25B,OAMhB,qBACI,OAAO35B,KAAK4xD,SAqFhB,UACI5xD,KAAK24B,MAAM0K,OAAOrjC,KAAK4xD,SAAU5xD,KAAK25B,QACtC35B,KAAKwxD,WAAW/rB,UAMpB,QACIzlC,KAAK4wD,YAAc,EACnB5wD,KAAK6wD,eAAiB,EACtB7wD,KAAK8wD,eAAiB,EAM1B,SACQ9wD,KAAKm3C,UAAYn3C,KAAK6wD,iBACtB7wD,KAAK+wD,eAAexkD,aAAc,EAClCvM,KAAK+wD,eAAee,YAAYjuC,OAC5B7jB,KAAK6wD,eAAiB,EAAAN,6BAC1BvwD,KAAK+wD,eAAee,YAAY/3C,OAC3B/Z,KAAK4wD,YAAc5wD,KAAK6wD,gBAAkB,EAAAN,6BAC/CvwD,KAAKuxD,cAAchlD,aAAc,EACjCvM,KAAKuxD,cAAcO,YAAYjuC,OAC3B7jB,KAAK6wD,eAAiB,EAAAL,4BAC1BxwD,KAAKuxD,cAAcO,YAAY/3C,OAC1B/Z,KAAK4wD,YAAc5wD,KAAK6wD,gBAAkB,EAAAL,6BAEnDxwD,KAAK6wD,eAAiB7wD,KAAK4wD,YAC3B5wD,KAAKwxD,WAAWO,aAAa,EAAG/xD,KAAK4wD,YAAc,EAAAN,kBAevD,IACI0B,EACAC,EACAC,EACAC,EACAC,EACArsC,GAEA,GAAI/lB,KAAK4wD,aAAe5wD,KAAKmnC,SACzB,OAAO,EACJ,GAAInnC,KAAK4wD,aAAe5wD,KAAK2wD,kBAAmB,CACnD,MAAM0B,EAAUhpD,KAAKO,IAA6B,EAAzB5J,KAAK2wD,kBAAuB3wD,KAAKmnC,UAC1DnnC,KAAKsyD,cAAcD,GAGvB,MAAME,EAAavyD,KAAK4wD,YAAc,EAAAP,kBAChCmC,EAAYxyD,KAAK4wD,YAAc,EAAAN,iBAErC,IAAK,IAAIlzD,EAAI,EAAGA,EAAI,EAAAizD,oBAAqBjzD,EAAG,CACxC4C,KAAKmxD,oBAAoBsB,QACrBF,EAAan1D,EACb60D,EAAQ70D,GAAGqI,EACXwsD,EAAQ70D,GAAGsI,EACXusD,EAAQ70D,GAAGwI,GACVwsD,GAAY,EAAM,GAAOrsC,EAAMiF,UAEpC,MAAM0nC,EAAgBN,GAAah1D,EAAI,GAAK,EAAyB,EAApBiM,KAAKmtB,MAAMp5B,EAAI,GAASA,EACzE4C,KAAKoxD,cAAcqB,QACfF,EAAan1D,EACb40D,EAAUvC,0BAA0BiD,GAAejtD,EACnDusD,EAAUvC,0BAA0BiD,GAAehtD,EACnDwsD,EACAC,GAEJnyD,KAAKqxD,iBAAiBoB,QAClBF,EAAan1D,EACb2oB,EAAMkF,MAAM/sB,EACZ6nB,EAAMkF,MAAM4C,EACZ9H,EAAMkF,MAAMvhB,EACZqc,EAAMmF,SAEVlrB,KAAKsxD,mBAAmBmB,QACpBF,EAAan1D,EACb2oB,EAAMoF,gBAAgBjtB,EACtB6nB,EAAMoF,gBAAgB0C,EACtB9H,EAAMoF,gBAAgBzhB,EACtBqc,EAAMqF,mBAYd,OARAprB,KAAKuxD,cAAcoB,KAAKH,EAAWD,GACnCvyD,KAAKuxD,cAAcoB,KAAKH,EAAY,EAAGD,EAAa,GACpDvyD,KAAKuxD,cAAcoB,KAAKH,EAAY,EAAGD,EAAa,GACpDvyD,KAAKuxD,cAAcoB,KAAKH,EAAY,EAAGD,EAAa,GACpDvyD,KAAKuxD,cAAcoB,KAAKH,EAAY,EAAGD,EAAa,GACpDvyD,KAAKuxD,cAAcoB,KAAKH,EAAY,EAAGD,EAAa,KAElDvyD,KAAK4wD,aACA,EAeX,YACIlgC,EACA7M,EACAmuC,EACAC,EACAC,EACAC,EACAC,EACArsC,GAEA,IAAK,IAAI3oB,EAAI,EAAGA,EAAI,EAAAizD,oBAAqBjzD,EAAG,CACxC,MAAMw1D,EAAe/uC,EAAS,EAAAssC,qBAAuB/yD,EACrDszB,EAAOkiC,GAAgBX,EAAQ70D,GAAGqI,EAClCirB,EAAOkiC,EAAe,GAAKX,EAAQ70D,GAAGsI,EACtCgrB,EAAOkiC,EAAe,GAAKX,EAAQ70D,GAAGwI,EACtC8qB,EAAOkiC,EAAe,IAAMR,GAAY,EAAM,GAAOrsC,EAAMiF,SAE3D,MAAM0nC,EAAgBN,GAAah1D,EAAI,GAAK,EAAyB,EAApBiM,KAAKmtB,MAAMp5B,EAAI,GAASA,EACzEszB,EAAOkiC,EAAe,GAAKZ,EAAUvC,0BAA0BiD,GAAejtD,EAC9EirB,EAAOkiC,EAAe,GAAKZ,EAAUvC,0BAA0BiD,GAAehtD,EAC9EgrB,EAAOkiC,EAAe,GAAKV,EAC3BxhC,EAAOkiC,EAAe,GAAKT,EAE3BzhC,EAAOkiC,EAAe,GAAK7sC,EAAMkF,MAAM/sB,EACvCwyB,EAAOkiC,EAAe,GAAK7sC,EAAMkF,MAAM4C,EACvC6C,EAAOkiC,EAAe,IAAM7sC,EAAMkF,MAAMvhB,EACxCgnB,EAAOkiC,EAAe,IAAM7sC,EAAMmF,QAElCwF,EAAOkiC,EAAe,IAAM7sC,EAAMoF,gBAAgBjtB,EAClDwyB,EAAOkiC,EAAe,IAAM7sC,EAAMoF,gBAAgB0C,EAClD6C,EAAOkiC,EAAe,IAAM7sC,EAAMoF,gBAAgBzhB,EAClDgnB,EAAOkiC,EAAe,IAAM7sC,EAAMqF,mBAmB1C,oBACIu1B,EACA5yC,EACA+yC,EACA91B,EACAC,EACAC,EACA2nC,EACAC,GAEA,GAAI9yD,KAAK4wD,YAAcjQ,EAAiB3R,OAAO1tC,QAAUtB,KAAKmnC,SAC1D,OAAO,EACJ,GAAInnC,KAAK4wD,YAAcjQ,EAAiB3R,OAAO1tC,QAAUtB,KAAK2wD,kBAAmB,CACpF,MAAM0B,EAAUhpD,KAAKO,IAA6B,EAAzB5J,KAAK2wD,kBAAuB3wD,KAAKmnC,UAC1DnnC,KAAKsyD,cAAcD,GAGvB,MAAMlzD,EAAI2hD,GAAS,EACb5iD,EAAI8sB,GAAY,EAChB+nC,EAAO1pD,KAAKkH,IAAIrS,GAChB80D,EAAO3pD,KAAKsH,IAAIzS,GAChBqW,OAAuBvS,IAAb+L,EAAyBA,EAAStI,EAAI,EAChD+O,OAAuBxS,IAAb+L,EAAyBA,EAASrI,EAAI,EAChDutD,OAAuBjxD,IAAb+L,EAAyBA,EAASnI,EAAI,EAEhD8qB,EAASiwB,EAAiBjwB,OAG1BwiC,EADMxiC,EAAO,GACG,GAAK,EAAM,EAE3ByiC,OAAgBnxD,IAAVipB,EAAsBA,EAAM/sB,EAAIwyB,EAAO,GAC7C0iC,OAAkBpxD,IAAVipB,EAAsBA,EAAM4C,EAAI6C,EAAO,GAC/C2iC,OAAiBrxD,IAAVipB,EAAsBA,EAAMvhB,EAAIgnB,EAAO,IAC9C4iC,OAAoBtxD,IAAZkpB,EAAwBA,EAAUwF,EAAO,IACjD6iC,OAAoBvxD,IAAZ6wD,EAAwBA,EAAQ30D,EAAIwyB,EAAO,IACnD8iC,OAAsBxxD,IAAZ6wD,EAAwBA,EAAQhlC,EAAI6C,EAAO,IACrD+iC,OAAqBzxD,IAAZ6wD,EAAwBA,EAAQnpD,EAAIgnB,EAAO,IACpDgjC,OAAwB1xD,IAAd8wD,EAA0BA,EAAYpiC,EAAO,IAEvDijC,EAAe3zD,KAAK4wD,YAAc,EAAAP,kBACxC,IAAK,IAAIjzD,EAAI,EAAGA,EAAIujD,EAAiB3R,OAAO1tC,SAAUlE,EAAG,CACrD,MAAMw2D,EAAYx2D,EAAI,EAAAmzD,6BAEhBsD,EAAQlT,EAAiB3R,OAAO5xC,GACtC,IAAKy2D,EAAMlE,UACP,OAAO,EAGX,MAAMyC,EAAW1hC,EAAOkjC,EAAY,GAAKljC,EAAOkjC,EAAY,EAAAzD,qBAAuB,GAC7ErqD,EAAI4qB,EAAOkjC,EAAY,GACvBE,EAAKpjC,EAAOkjC,EAAY,GAE9B,IAAK,IAAI5R,EAAI,EAAGA,EAAI,EAAAqO,oBAAqBrO,EAAG,CACxC,MAAMv8C,EAAIirB,EAAOkjC,EAAY5R,EAAI,EAAAmO,sBAC3BzqD,EAAIgrB,EAAOkjC,EAAY5R,EAAI,EAAAmO,qBAAuB,GACxDnwD,KAAKmxD,oBAAoBsB,QACrBkB,EAAev2D,EAAI,EAAAizD,kBAAoBrO,EACvCv8C,EAAItG,EAAI4zD,EAAOrtD,EAAIvG,GAAK6zD,EAAOz+C,EAC/B9O,EAAItG,EAAI6zD,EAAOttD,EAAIvG,EAAI4zD,EAAOv+C,EAC9Bkc,EAAOkjC,EAAY5R,EAAI,EAAAmO,qBAAuB,GAAK8C,EACnDviC,EAAOkjC,EAAY5R,EAAI,EAAAmO,qBAAuB,GAAK+C,EAAUh1D,GAEjE,MAAMw0D,EAAgBN,GAAapQ,EAAI,GAAK,EAAyB,EAApB34C,KAAKmtB,MAAMwrB,EAAI,GAASA,EACzEhiD,KAAKoxD,cAAcqB,QACfkB,EAAev2D,EAAI,EAAAizD,kBAAoBrO,EACvC6R,EAAMpE,0BAA0BiD,GAAejtD,EAC/CouD,EAAMpE,0BAA0BiD,GAAehtD,EAC/CI,GACCguD,EAAKhuD,GAAK3G,EAAI2G,GAEnB9F,KAAKqxD,iBAAiBoB,QAClBkB,EAAev2D,EAAI,EAAAizD,kBAAoBrO,EACvCmR,EACAC,EACAC,EACAC,GAEJtzD,KAAKsxD,mBAAmBmB,QACpBkB,EAAev2D,EAAI,EAAAizD,kBAAoBrO,EACvCuR,EACAC,EACAC,EACAC,GAIR1zD,KAAKuxD,cAAcoB,MACd3yD,KAAK4wD,YAAcxzD,GAAK,EAAAkzD,kBACxBtwD,KAAK4wD,YAAcxzD,GAAK,EAAAizD,mBAE7BrwD,KAAKuxD,cAAcoB,MACd3yD,KAAK4wD,YAAcxzD,GAAK,EAAAkzD,iBAAmB,GAC3CtwD,KAAK4wD,YAAcxzD,GAAK,EAAAizD,kBAAoB,GAEjDrwD,KAAKuxD,cAAcoB,MACd3yD,KAAK4wD,YAAcxzD,GAAK,EAAAkzD,iBAAmB,GAC3CtwD,KAAK4wD,YAAcxzD,GAAK,EAAAizD,kBAAoB,GAEjDrwD,KAAKuxD,cAAcoB,MACd3yD,KAAK4wD,YAAcxzD,GAAK,EAAAkzD,iBAAmB,GAC3CtwD,KAAK4wD,YAAcxzD,GAAK,EAAAizD,kBAAoB,GAEjDrwD,KAAKuxD,cAAcoB,MACd3yD,KAAK4wD,YAAcxzD,GAAK,EAAAkzD,iBAAmB,GAC3CtwD,KAAK4wD,YAAcxzD,GAAK,EAAAizD,kBAAoB,GAEjDrwD,KAAKuxD,cAAcoB,MACd3yD,KAAK4wD,YAAcxzD,GAAK,EAAAkzD,iBAAmB,GAC3CtwD,KAAK4wD,YAAcxzD,GAAK,EAAAizD,kBAAoB,GAKrD,OADArwD,KAAK4wD,aAAejQ,EAAiB3R,OAAO1tC,QACrC,EAUX,eAAeyyD,EAAkBC,EAAgBllB,GAC7C,QAAI9uC,KAAK8wD,gBAAkB9wD,KAAK2wD,qBAIhC3wD,KAAK2xD,mBAAmB3xD,KAAK8wD,gBAAkB,CAC3C/mB,MAAO1gC,KAAKO,IAAImqD,EAAU/zD,KAAKmnC,UAC/ByN,IAAKvrC,KAAKO,IAAIoqD,EAAQh0D,KAAKmnC,UAC3BG,KAAMwH,KAGR9uC,KAAK8wD,gBACA,GAUX,KAAKriB,EAA+BwlB,GAChC,IAAK,MAAMnlB,KAAe9uC,KAAK2xD,mBAAoB,CAC/C,QAAoB3vD,IAAhB8sC,EACA,OAGJ,IAAK,IAAI1xC,EAAI0xC,EAAY/E,MAAO3sC,EAAI0xC,EAAY8F,MAAOx3C,EAAG,CACtD,MAAM82D,EAAgB92D,EAAI,EAAAizD,kBAEpBvb,EAAOzrC,KAAKO,IACd5J,KAAKmxD,oBAAoBgD,KAAKD,EAAgB,GAC9Cl0D,KAAKmxD,oBAAoBgD,KAAKD,EAAgB,IAElD,GAAIzlB,EAAehpC,EAAIqvC,EACnB,SAGJ,MAAMC,EAAO1rC,KAAKS,IACd9J,KAAKmxD,oBAAoBgD,KAAKD,EAAgB,GAC9Cl0D,KAAKmxD,oBAAoBgD,KAAKD,EAAgB,IAElD,GAAIzlB,EAAehpC,EAAIsvC,EACnB,SAGJ,MAAMC,EAAO3rC,KAAKO,IACd5J,KAAKmxD,oBAAoBiD,KAAKF,EAAgB,GAC9Cl0D,KAAKmxD,oBAAoBiD,KAAKF,EAAgB,IAElD,GAAIzlB,EAAe/oC,EAAIsvC,EACnB,SAGJ,MAAMlZ,EAAOzyB,KAAKS,IACd9J,KAAKmxD,oBAAoBiD,KAAKF,EAAgB,GAC9Cl0D,KAAKmxD,oBAAoBiD,KAAKF,EAAgB,IAElD,KAAIzlB,EAAe/oC,EAAIo2B,GAAvB,CAIAm4B,EAAanlB,EAAYxH,MACzB,SAUZ,kBAAkB+sB,GACd,MAAM7zB,EA3ec,EA4ehBxgC,KAAK+wD,eAAeh3C,MAveJ,EAwehB/Z,KAAKuxD,cAAcx3C,MACvBs6C,EAAK38C,UAAY8oB,EACjB6zB,EAAK18C,SAAW6oB,EAGZ,cAAcpf,GAClBphB,KAAK2wD,kBAAoBvvC,EAEzB,MAAMkzC,EAAkB,IAAI9iC,aAAapQ,EAAO,EAAAmvC,8BAChD+D,EAAgBttD,IAAIhH,KAAK+wD,eAAep3C,OACxC3Z,KAAK+wD,eAAiB,IAAI3xD,EAAM4xD,kBAAkBsD,EAAiB,EAAAnE,sBACnEnwD,KAAK+wD,eAAeE,SAAS7xD,EAAM8xD,kBACnClxD,KAAKmxD,oBAAsB,IAAI/xD,EAAMya,2BAA2B7Z,KAAK+wD,eAAgB,EAAG,GACxF/wD,KAAKoxD,cAAgB,IAAIhyD,EAAMya,2BAA2B7Z,KAAK+wD,eAAgB,EAAG,GAClF/wD,KAAKqxD,iBAAmB,IAAIjyD,EAAMya,2BAA2B7Z,KAAK+wD,eAAgB,EAAG,GACrF/wD,KAAKsxD,mBAAqB,IAAIlyD,EAAMya,2BAA2B7Z,KAAK+wD,eAAgB,EAAG,IAEvF,MAAMwD,EAAiB,IAAIjjC,YAAYlQ,EAAO,EAAAovC,6BAC9C+D,EAAevtD,IAAIhH,KAAKuxD,cAAc53C,OACtC3Z,KAAKuxD,cAAgB,IAAInyD,EAAM0a,gBAAgBy6C,EAAgB,EAAAnE,qBAC/DpwD,KAAKuxD,cAAcN,SAAS7xD,EAAM8xD,kBAElClxD,KAAKwxD,WAAW/rB,UAChBzlC,KAAKwxD,WAAa,IAAIpyD,EAAMob,eAC5Bxa,KAAKwxD,WAAWC,aAAa,WAAYzxD,KAAKmxD,qBAC9CnxD,KAAKwxD,WAAWC,aAAa,KAAMzxD,KAAKoxD,eACxCpxD,KAAKwxD,WAAWC,aAAa,QAASzxD,KAAKqxD,kBAC3CrxD,KAAKwxD,WAAWC,aAAa,UAAWzxD,KAAKsxD,oBAC7CtxD,KAAKwxD,WAAWE,SAAS1xD,KAAKuxD,eAE9BvxD,KAAK2xD,mBAAmBrwD,OAAStB,KAAK2wD,kBAEtC3wD,KAAK24B,MAAM0K,OAAOrjC,KAAK4xD,SAAU5xD,KAAK25B,QACtC35B,KAAK25B,OAAS,IAAIv6B,EAAM40B,KAAKh0B,KAAKwxD,WAAYxxD,KAAK25B,OAAOlvB,UAC1DzK,KAAK4xD,SAAW,IAAIxyD,EAAM40B,KAAKh0B,KAAKwxD,WAAYxxD,KAAK4xD,SAASnnD,UAC9DzK,KAAK25B,OAAOrT,YAAcwB,OAAOC,iBACjC/nB,KAAK4xD,SAAStrC,YAAcwB,OAAOC,iBAAmB,EACtD/nB,KAAK25B,OAAOk4B,eAAgB,EAC5B7xD,KAAK4xD,SAASC,eAAgB,EAC9B7xD,KAAK24B,MAAMx4B,IAAIH,KAAK4xD,SAAU5xD,KAAK25B,W,wGCriB3C,aAGA,QACA,SAKA,SAAiB66B,GAIA,EAAAC,SAAW,GAKX,EAAAC,SAAW,KAKX,EAAAC,cAAgB,QAKhB,EAAAC,eAAiBvrD,KAAKsJ,IAAI,EAAAgiD,eAWvB,EAAAE,aAAhB,SAA6BzzC,EAAc6H,EAAgB6rC,GACvD,IAAI3uD,EAASib,EACb,OAAQ6H,GACJ,KAAK,EAAAjB,SAAS+sC,GACV5uD,GAAU,EAAAsuD,SACV,MACJ,KAAK,EAAAzsC,SAASgtC,MACV7uD,GAAU,EAAAuuD,SACV,MACJ,KAAK,EAAA1sC,SAASitC,QACV9uD,GAAU,IAAc2uD,EAGhC,OAAO3uD,GAYK,EAAA+uD,kBAAhB,SACIlmB,EACAmmB,EACAz6C,EACAqQ,GAIA,OADIoqC,EAAyBz6C,IAAUqQ,IAAgB,EAAA7C,YAAYktC,UAE7DpmB,EAAOt0B,GAAO40C,KAAKU,QAAQqF,QAAUrmB,EAAOt0B,GAAO40C,KAAKU,QAAQsF,UAChE,GAWM,EAAA19B,aAAhB,SAA6BoX,EAAqBnrB,GAC9C,IAAI1d,EAAS,EAAA4wB,aAAaC,UAAUqB,IAChC3d,EAAQmJ,EACZ,KACImrB,EAAOt0B,GAAOq1C,YAAc,EAAAh5B,aAAaC,UAAUqB,KACnD2W,EAAOt0B,GAAOq1C,YAAc,EAAAh5B,aAAaC,UAAUoB,KACnD1d,EAAQs0B,EAAO1tC,OAAS,KAEtBoZ,EAMN,OAH0C,IAAtCrR,KAAK2S,IAAIgzB,EAAOt0B,GAAOq1C,aACvB5pD,EAAS6oC,EAAOt0B,GAAOq1C,WAEpB5pD,GAYK,EAAAovD,sBAAhB,SACItgD,EACAlH,EACA+yC,EACA91B,EACAwqC,GAEA,MAAMC,EAAWpsD,KAAKkH,IAAIya,GACpB0qC,EAAWrsD,KAAKsH,IAAIqa,GACpB2qC,EAAgBtsD,KAAKkH,IAAIilD,GACzBI,EAAgBvsD,KAAKsH,IAAI6kD,GAC/BvgD,EAAUjO,IACN85C,EAAQ6U,EACR7U,GAAS8U,EACTH,EAAW1nD,EAAStI,EAAIiwD,EAAW3nD,EAASrI,EAC5Co7C,EAAQ8U,EACR9U,EAAQ6U,EACRD,EAAW3nD,EAAStI,EAAIgwD,EAAW1nD,EAASrI,EAC5C,EACA,EACA,IAWQ,EAAAmwD,aAAhB,SACI5D,EACA6D,EACAC,GAEA,MAAMjhB,EAAOzrC,KAAKO,IAAIqoD,EAAQ,GAAGxsD,EAAGwsD,EAAQ,GAAGxsD,EAAGwsD,EAAQ,GAAGxsD,EAAGwsD,EAAQ,GAAGxsD,GACrEsvC,EAAO1rC,KAAKS,IAAImoD,EAAQ,GAAGxsD,EAAGwsD,EAAQ,GAAGxsD,EAAGwsD,EAAQ,GAAGxsD,EAAGwsD,EAAQ,GAAGxsD,GACrEuvC,EAAO3rC,KAAKO,IAAIqoD,EAAQ,GAAGvsD,EAAGusD,EAAQ,GAAGvsD,EAAGusD,EAAQ,GAAGvsD,EAAGusD,EAAQ,GAAGvsD,GACrEo2B,EAAOzyB,KAAKS,IAAImoD,EAAQ,GAAGvsD,EAAGusD,EAAQ,GAAGvsD,EAAGusD,EAAQ,GAAGvsD,EAAGusD,EAAQ,GAAGvsD,QAElD1D,IAArB+zD,SACwD/zD,IAApD+zD,EAAiBp8C,MAAMo8C,EAAiBlyC,SACxCkyC,EAAiBp8C,MAAMo8C,EAAiBlyC,QAAQja,IAAI5C,IAAI8tC,EAAME,GAC9D+gB,EAAiBp8C,MAAMo8C,EAAiBlyC,QAAQ/Z,IAAI9C,IAAI+tC,EAAMjZ,IAE9Di6B,EAAiBp8C,MAAMzT,KACnB,IAAI9G,EAAM42D,KAAK,IAAI52D,EAAMoG,QAAQsvC,EAAME,GAAO,IAAI51C,EAAMoG,QAAQuvC,EAAMjZ,OAG5Ei6B,EAAiBlyC,QAGvBiyC,EAAalsD,IAAI5C,IACbqC,KAAKO,IAAIksD,EAAalsD,IAAInE,EAAGqvC,GAC7BzrC,KAAKO,IAAIksD,EAAalsD,IAAIlE,EAAGsvC,IAEjC8gB,EAAahsD,IAAI9C,IACbqC,KAAKS,IAAIgsD,EAAahsD,IAAIrE,EAAGsvC,GAC7B1rC,KAAKS,IAAIgsD,EAAahsD,IAAIpE,EAAGo2B,KAjKzC,CAAiB,EAAA04B,mBAAA,EAAAA,iBAAgB,M,oRCRjC,aACA,OACA,OAEA,QAoDA,wCAUI,YACayB,EAAkB,GAClBC,EAAyB,GACzBC,EAAoB,GACpBC,EAAY,KAHZ,KAAAH,UACA,KAAAC,iBACA,KAAAC,oBACA,KAAAC,YAXH,KAAAC,aAAgC,CACtC,IAAIj3D,EAAMuG,QACV,IAAIvG,EAAMuG,QACV,IAAIvG,EAAMuG,SAEJ,KAAA2wD,gBAAoC,IAAIl3D,EAAMmO,WAQpD,EAAAjB,OAAO2pD,EAAU,GACjB,EAAA3pD,OAAO6pD,GAAqB,GAC5B,EAAA7pD,OAAO8pD,GAAa,GACpBp2D,KAAKu2D,OAASN,EAAUE,EAAoBC,EAIhD,iBAAiBhnD,IAEjB,mBAEI,OAAO,EAIX,iBAAiBA,IAEjB,mBAEI,OAAO,EAGX,mBACIV,EACAS,EACAiM,GAEA,IAAIo7C,EAAoBx2D,KAAKi2D,QACzBQ,EAAmBz2D,KAAKu2D,OAC5B,GAAIpnD,EAAWS,OAAS,EAAAC,eAAee,UAAW,CAG9C,MAAM1S,EAAI,EAAA8O,eAAeC,kBACnBvP,EAAIgR,EAAOX,SAASzM,SACpBgyD,EAAQjqD,KAAK4U,KAAK/f,EAAIR,GAE5BgR,EAAOqD,YAAY2kD,aACf12D,KAAKq2D,aAAa,GAClBr2D,KAAKq2D,aAAa,GAClBr2D,KAAKq2D,aAAa,IAGtBr2D,KAAKs2D,gBAAgBvlD,iBAAiB/Q,KAAKq2D,aAAa,GAAI/C,GAE5D,MAAMqD,EAAM32D,KAAKq2D,aAAa,GAAGtjD,SAE3B6jD,EAAS52D,KAAKq2D,aAAa,GAAG/mD,KAAKqnD,GAAK3lD,gBAAgBhR,KAAKs2D,iBAE7Dp3D,EAAIc,KAAKq2D,aAAa,GAAG/mD,KAAKZ,EAAOX,UAC3C7O,EAAE23D,gBAAgBD,EAAQvtD,KAAK+H,KAAK1T,EAAIA,EAAIQ,EAAIA,IAChDu4D,EAAWv3D,EAAE4T,IAAIpE,EAAOX,UAAU2H,IAAIihD,GAAO32D,KAAKo2D,UAClDI,EAAYntD,KAAKS,IACb9J,KAAKi2D,QACL9mD,EAAWuB,eAAehC,EAAOX,UAAY/N,KAAKk2D,qBAEnD,GAAI/mD,EAAWS,OAAS,EAAAC,eAAeC,OAAQ,CAClD,MAAMY,EAAiBvB,EAAWuB,eAAehC,EAAOX,UACxDyoD,EAAYntD,KAAKS,IAAI9J,KAAKi2D,QAASvlD,EAAiB1Q,KAAKk2D,gBAEzDO,EAAWD,EAAYx2D,KAAKm2D,kBAAoBn2D,KAAKo2D,eAErD,EAAA9pD,QAAO,EAAO,+BASlB,MAN+B,CAC3BoS,KAAM83C,EACN73C,IAAK83C,EACLK,QAAS92D,KAAKi2D,QACdhM,QAASwM,KAarB,MAAsBM,EAIlB,YAAYhjC,EAAsBD,GAC9B,EAAAxnB,OAAOynB,GAAgBD,GACvB9zB,KAAKg3D,eAAiBljC,EACtB9zB,KAAKi3D,eAAiBljC,EAsB1B,iBAAiB3kB,GACbpP,KAAKi3D,eAAiB7nD,EAEtBpP,KAAKg3D,eAAiB3tD,KAAKO,IAAIwF,EAAWpP,KAAKg3D,gBAMnD,mBACI,OAAOh3D,KAAKi3D,eAkBhB,iBAAiB7nD,GACbpP,KAAKg3D,eAAiB5nD,EAEtBpP,KAAKi3D,eAAiB5tD,KAAKS,IAAIsF,EAAWpP,KAAKi3D,gBAMnD,mBACI,OAAOj3D,KAAKg3D,gBAnEpB,sCAmFA,MAAaE,UAAmCH,EA6C5C,YACIhjC,EAAuB,EAAA/mB,eAAe6X,oBACtCiP,EAAuB,EACdmiC,EAAkB,EAClBkB,EAA6B,IAC7BC,EAAc,GAEvBp0D,MAAM+wB,EAAcD,GAJX,KAAAmiC,UACA,KAAAkB,qBACA,KAAAC,cA9CH,KAAAf,aAAgC,CACtC,IAAIj3D,EAAMuG,QACV,IAAIvG,EAAMuG,QACV,IAAIvG,EAAMuG,SAKJ,KAAA2wD,gBAAoC,IAAIl3D,EAAMmO,WAyCpD,EAAAjB,OAAO2pD,EAAU,GACjB,EAAA3pD,OAAO6qD,EA5RC,MA6RR,EAAA7qD,OAAO8qD,EAAc,GACrB,MAAMC,EAAgBF,EAAqBlB,EAC3Cj2D,KAAKs3D,mBAAqB,CACtB54C,KAAMu3C,EACNt3C,IAAKs3C,EAAUoB,EACfP,QAAS92D,KAAKi2D,QACdhM,QAAS5gD,KAAKS,IAAImsD,EAAUmB,EAAanB,EAAUoB,IAK3D,mBACI3oD,EACAS,EACAiM,GAEA,OAAIjM,EAAWS,OAAS,EAAAC,eAAee,UAC5B5Q,KAAKu3D,8BAA8B7oD,EAAQS,EAAYiM,GACvDjM,EAAWS,OAAS,EAAAC,eAAeC,OACnC9P,KAAKw3D,2BAA2B9oD,EAAQS,EAAYiM,IAE/D,EAAA9O,QAAO,EAAO,+BACP,OAAP,UAAYtM,KAAKy3D,mBAOrB,uBACI,OAAOz3D,KAAKs3D,mBAQN,kBAAkB5oD,EAAsBS,GAC9C,OAAOA,EAAWuB,eAAehC,EAAOX,UAGlC,2BACNW,EACAS,EACAiM,GAEA,EAAA9O,OAAO6C,EAAWS,OAAS,EAAAC,eAAee,WAE1C,IAAI4lD,EAAoBx2D,KAAKi2D,QACzBQ,EAAmBz2D,KAAKi2D,QAAUj2D,KAAKo3D,YAG3C,MAAM1mD,EAAiB1Q,KAAK03D,kBAAkBhpD,EAAQS,GAChDwoD,EAASjnD,EAAiB1Q,KAAKo3D,YAIrCZ,EAAY9lD,EAAiB1Q,KAAK+zB,aAClC0iC,EAAW/lD,EAAiB1Q,KAAK8zB,aAGjC0iC,EAAYntD,KAAKS,IAAI0sD,EAAWx2D,KAAKi2D,SACrCQ,EAAWptD,KAAKO,IAAI6sD,EAAUkB,GAE9B,MAAMN,EAAiBr3D,KAAKm3D,oBAAsBX,EAAYC,GAAa,EAU3E,OATAD,EAAYntD,KAAKS,IAAI0sD,EAAYa,EAAgB,EAAGr3D,KAAKi2D,SACzDQ,EAAWptD,KAAKS,IAAI2sD,EAAWY,EAAgB,EAAGb,EAAYa,GAE/B,CAC3B34C,KAAM83C,EACN73C,IAAK83C,EACLK,QAAS92D,KAAKi2D,QACdhM,QAAS5gD,KAAKS,IAAI6tD,EAAQlB,IAKxB,8BACN/nD,EACAS,EACAiM,GAEA,EAAA9O,OAAO6C,EAAWS,OAAS,EAAAC,eAAee,WAE1C,IAAI4lD,EAAoBx2D,KAAKi2D,QACzBQ,EAAmBz2D,KAAKi2D,QAAUj2D,KAAKo3D,YAK3C,MAAMQ,EAAiB53D,KAAK03D,kBAAkBhpD,EAAQS,GACtDqnD,EAAYoB,EAAiB53D,KAAK+zB,aAMlC,MAAM71B,EAAI,EAAA8O,eAAeC,kBACzB,IAAIvP,EAAIgR,EAAOX,SAASzM,SAExB,GADA5D,EAAU,IAANA,EAjYI,KAiYgBA,EACJ,sBAAhBgR,EAAOkB,KAA8B,CAYrC,MAAM0jD,EAAQjqD,KAAK4U,KAAK/f,EAAIR,GAItBm6D,EAAMnpD,EAEN+D,EAASolD,EAAIplD,OAAS,EAAIolD,EAAIplD,OAAS,EAAIolD,EAAIplD,OAC/CqlD,EAAe14D,EAAMkJ,UAAUW,SAAU4uD,EAAItlD,IAAME,EAAU,GAE7DslD,EAAa/3D,KAAKg4D,wBAAwBH,EAAKn6D,EAAGQ,EAAGo1D,GAC3DmD,EACIqB,EAAexE,EACTyE,EACA/3D,KAAKi4D,oBAAoBJ,EAAKn6D,EAAGQ,EAAG,EAAI45D,EAAc3oD,QAIhEsnD,EAAWz2D,KAAKk4D,sBAAsBx6D,EAAGQ,GAK7C,MAAMq4D,EAASqB,EAAiB53D,KAAK8zB,aAC/B6jC,EAASC,EAAiB53D,KAAKo3D,YAErCZ,EAAYntD,KAAKS,IAAI0sD,EAAWx2D,KAAKi2D,SACrCQ,EAAWptD,KAAKS,IAAI2sD,EAAUF,GAE9B,MAAMc,EAAiBr3D,KAAKm3D,oBAAsBX,EAAYC,GAAa,EAU3E,OATAD,EAAYntD,KAAKS,IAAI0sD,EAAYa,EAAgB,EAAGr3D,KAAKi2D,SACzDQ,EAAWptD,KAAKS,IAAI2sD,EAAWY,EAAgB,EAAGb,EAAYa,GAE/B,CAC3B34C,KAAM83C,EACN73C,IAAK83C,EACLK,QAAS92D,KAAKi2D,QACdhM,QAAS0N,GAYP,mBAAmBj6D,EAAWQ,GAGpC,OAAIR,EAAIQ,EAjcA,KAkcG,EAKJmL,KAAK+H,KAAK1T,EAAIA,EAAIQ,EAAIA,GAcvB,wBACNwQ,EACAhR,EACAQ,EACAo1D,GAmBA,MAAMh1D,EAAI0B,KAAKm4D,mBAAmBz6D,EAAGQ,GAK/Bk6D,EAAKp4D,KAAKm4D,mBAAmBj6D,EAAI8B,KAAK+zB,aAAc71B,GAY1D,OAFYmL,KAAKkH,IAAI+iD,IAAUh1D,EAAI85D,GAK7B,oBACN1pD,EACAhR,EACAQ,EACAm6D,EACAlpD,GA0BA,MAAMmpD,EAAO5pD,EAAOX,SAEpBW,EAAOqD,YAAY2kD,aACf12D,KAAKq2D,aAAa,GAClBr2D,KAAKq2D,aAAa,GAClBr2D,KAAKq2D,aAAa,IAGtBr2D,KAAKs2D,gBAAgBvlD,iBAAiB/Q,KAAKq2D,aAAa,GAAIgC,EAAW,GAEvE,MAAME,EAAev4D,KAAKq2D,aAAa,GAGjCmC,EAAOx4D,KAAKq2D,aAAa,GAAG/mD,KAAKipD,GAAcvnD,gBAAgBhR,KAAKs2D,iBAGpEmC,EAAMH,EAAK5iD,IAAI8iD,GAIrB,GAAIC,EAAM,EAAG,CAIT,OAFuBz4D,KAAK03D,kBAAkBhpD,EAAQS,GAE9BnP,KAAKo3D,YAQjC,MAAMsB,EAAKJ,EAAK5iD,IAAI4iD,GAAQG,EAAMA,EAG5BE,EAAKz6D,EAAIA,EAUf,OATA,EAAAoO,OAAOosD,GAAMC,EAAI,6DASVF,EAFMpvD,KAAK+H,KAAKunD,EAAKD,GAKtB,sBAAsBh7D,EAAWQ,GA+BvC,OAbUR,GAONsC,KAAK+zB,aAxmBD,KAymBE,EACA1qB,KAAK+H,KAAKlT,EAAI8B,KAAK+zB,eAAiB71B,EAAI8B,KAAK+zB,cAAgB71B,EAAIA,IApYnF,+BAkZA,MAAa06D,UAAoC1B,EAWnC,iCACNxoD,EACAS,GAEA,EAAA7C,OAAO6C,EAAWS,OAAS,EAAAC,eAAee,WAyC1C,MAAMioD,EAAcxvD,KAAKyF,GAAK,EAhrBtB,KAirBF8oD,EAAiB53D,KAAK03D,kBAAkBhpD,EAAQS,GAEhD2pD,EAAa,EAAA9qD,aAAasH,kBAAkB5G,EAAQS,GAE1D,IAAI4pD,EAEAC,EAEAC,EAEAC,EAEJ,GAAoB,sBAAhBxqD,EAAOkB,KAA8B,CACrC,MAAMioD,EAAOnpD,EAIP+D,EAAS,EAETqlD,EAAe14D,EAAMkJ,UAAUW,SAAU4uD,EAAItlD,IAAME,EAAU,GACnEsmD,EAAc35D,EAAMkJ,UAAU6B,MAC1B2uD,EAAahB,GACZe,EACDA,GAEJG,EAAiB55D,EAAMkJ,UAAU6B,MAC7B2uD,EAAahB,GACZe,EACDA,GAEJI,EAAKC,EAAKtB,MAGT,CACD,MAAMC,EAAOnpD,EAGbqqD,EAAcC,EAAiBF,EAQ/B,MAAMK,EAAU9vD,KAAKsH,IAAImoD,GACzBI,EAAKtB,EAAiBuB,EAAUtB,EAAIj5C,IACpCq6C,EAAKrB,EAAiBuB,EAAUtB,EAAIv4C,OAKxC,MAAM85C,GAAWF,EAAKl5D,KAAK8zB,cAAgBzqB,KAAKkH,IAAIwoD,GAI9CM,GAAcJ,EAAKj5D,KAAK+zB,cAAgB1qB,KAAKkH,IAAIyoD,GAEvD,MAAO,CACHp6C,IAAKvV,KAAKS,IAAIsvD,EAAS,GACvB95C,OAAQjW,KAAKS,IAAIuvD,EAAY,IAK3B,2BACN3qD,EACAS,EACAiM,GAEA,EAAA9O,OAAO6C,EAAWS,OAAS,EAAAC,eAAee,WAC1C,MAAMq7C,EAAa,OAAH,UAAQjsD,KAAKy3D,kBAMvB6B,EAAat5D,KAAKu5D,iCAAiC7qD,EAAQS,GAKjE,GAAoB,sBAAhBT,EAAOkB,KAA8B,CACrC,MAAMioD,EAAMnpD,EAIN+D,EAAS,EAETqlD,EAAe14D,EAAMkJ,UAAUW,SAAU4uD,EAAItlD,IAAME,EAAU,GAC7D+mD,EAAanwD,KAAKkH,IAAIunD,GAG5B7L,EAAWvtC,KAAO46C,EAAWh6C,OAASk6C,EAGtCvN,EAAWttC,IAAM26C,EAAW16C,IAAM46C,OAIlCvN,EAAWvtC,KAAO46C,EAAWh6C,OAC7B2sC,EAAWttC,IAAM26C,EAAW16C,IAKhC,MAAM,SAAE5P,GAAa,EAAAhB,aAAayN,qBAC9BtM,EACAT,EACA0M,GAGEu8C,EAAS3oD,EAAWhP,KAAKo3D,YAC/BnL,EAAWvtC,KAAOrV,KAAKS,IAAImiD,EAAWvtC,KAAM1e,KAAKi2D,SACjDhK,EAAWttC,IAAMtV,KAAKO,IAAIqiD,EAAWttC,IAAKg5C,GAG1C,MAAMN,EAAiBr3D,KAAKm3D,oBAAsBlL,EAAWvtC,KAAOutC,EAAWttC,KAAQ,EASvF,OARAstC,EAAWvtC,KAAOrV,KAAKS,IAAImiD,EAAWvtC,KAAO24C,EAAgB,EAAGr3D,KAAKi2D,SACrEhK,EAAWttC,IAAMtV,KAAKS,IAClBmiD,EAAWttC,IAAM04C,EAAgB,EACjCpL,EAAWvtC,KAAO24C,GAEtBpL,EAAW6K,QAAU92D,KAAKi2D,QAC1BhK,EAAWhC,QAAU0N,EAEd1L,EAID,8BACNv9C,EACAS,EACAiM,GAEA,EAAA9O,OAAO6C,EAAWS,OAAS,EAAAC,eAAee,WAC1C,MAAMq7C,EAAa,OAAH,UAAQjsD,KAAKy3D,kBAGvBG,EAAiB53D,KAAK03D,kBAAkBhpD,EAAQS,GACtD88C,EAAWvtC,KAAOk5C,EAAiB53D,KAAK+zB,aAExC,IAAI+jC,EAAuB,EAC3B,GAAIppD,aAAkBtP,EAAMq6D,kBAAmB,CAE3C,MAAMhnD,EAAS/D,EAAO+D,OAAS,EAAI/D,EAAO+D,OAAS,EAAI/D,EAAO+D,OAC9DqlD,EAAe14D,EAAMkJ,UAAUW,SAAUyF,EAAO6D,IAAME,EAAU,GAMhEw5C,EAAWvtC,MAAQrV,KAAKkH,IAAIunD,GAMhC,MAAM4B,EAAiB15D,KAAKq2D,aAAa,GAAG/mD,KAAKZ,EAAOX,UAAUgF,SAC5D7U,EAAI,EAAA8O,eAAeC,kBACnBvP,EAAIg8D,EAAep4D,SACzB,IAAIm1D,EACJ,GAAI/nD,aAAkBtP,EAAMq6D,kBAAmB,CAI3C,MAAMnG,EAAQjqD,KAAK4U,KAAK/f,EAAIR,GAGtBmZ,EAAc7W,KAAK25D,eAAeD,EAAgBhrD,GAGlDkrD,EAAgBvwD,KAAK2S,IAAIs3C,EAAQz8C,GAGjCkhD,EAAa/3D,KAAKg4D,wBAAwBtpD,EAAQhR,EAAGQ,EAAG07D,GAC9DnD,EACIqB,GAAgB8B,EACV7B,EACA/3D,KAAK65D,0BAA0Bn8D,EAAGQ,EAAG45D,EAAcjhD,QAE7D4/C,EAAWz2D,KAAKk4D,sBAAsBx6D,EAAGQ,GAE7C+tD,EAAWttC,IAAM83C,EAKjB,MAAM,SAAEznD,GAAa,EAAAhB,aAAayN,qBAC9BtM,EACAT,EACA0M,GAGEm7C,EAASqB,EAAiB53D,KAAK8zB,aAC/B6jC,EAAS3oD,EAAWhP,KAAKo3D,YAC/BnL,EAAWvtC,KAAOrV,KAAKS,IAAImiD,EAAWvtC,KAAM1e,KAAKi2D,SACjDhK,EAAWttC,IAAMvf,EAAMkJ,UAAU6B,MAAM8hD,EAAWttC,IAAK43C,EAAQoB,GAG/D,MAAMN,EAAiBr3D,KAAKm3D,oBAAsBlL,EAAWvtC,KAAOutC,EAAWttC,KAAQ,EAWvF,OAVAstC,EAAWvtC,KAAOrV,KAAKS,IAAImiD,EAAWvtC,KAAO24C,EAAgB,EAAGr3D,KAAKi2D,SACrEhK,EAAWttC,IAAMtV,KAAKS,IAClBmiD,EAAWttC,IAAM04C,EAAgB,EACjCpL,EAAWvtC,KAAO24C,GAItBpL,EAAW6K,QAAU92D,KAAKi2D,QAC1BhK,EAAWhC,QAAU0N,EAEd1L,EAGD,0BACNvuD,EACAQ,EACA45D,EACAjhD,GAgCA,MAAMijD,EAAWzwD,KAAKkH,IAAIsG,EAAcihD,GAClCiC,EAAOr8D,EAAIA,EACXY,EAAIZ,EAAIo8D,EAAWzwD,KAAK+H,KAAK2oD,EAAOD,EAAWA,EAAWC,EAAO77D,EAAIA,GAU3E,OARA,EAAAoO,QACKpD,MAAM5K,GACP,iFAIQ+K,KAAKkH,IAAIunD,GAAgBx5D,EAKjC,eAAeo7D,EAA+BhrD,GAClDgrD,EAAe7oD,YACf,MAAM9B,EAASL,EAAOc,kBAAkBxP,KAAKq2D,aAAa,IAAIxlD,YACxDmpD,EAAYN,EAAehkD,IAAI3G,GAGrC,OAFoB1F,KAAKsM,KAAKvW,EAAMkJ,UAAU6B,MAAM6vD,GAAY,EAAK,KAtU7E,gCA+UA,iCAKI,YAAqBC,EAAkB,EAAYC,EAAuB,IAArD,KAAAD,UAA8B,KAAAC,eAC/Cl6D,KAAKm6D,OAASF,EAAUC,EACxBl6D,KAAKo6D,YAAcH,EACnBj6D,KAAKq6D,WAAar6D,KAAKm6D,OAG3B,gBACI,OAAOn6D,KAAKo6D,YAGhB,cAAcE,GACVt6D,KAAKu6D,iBAAiBD,EAAWt6D,KAAKq6D,YAG1C,eACI,OAAOr6D,KAAKq6D,WAGhB,aAAaG,GACTx6D,KAAKu6D,iBAAiBv6D,KAAKo6D,YAAaI,GAI5C,iBAAiBprD,IAEjB,mBAEI,OAAO,EAIX,iBAAiBA,IAEjB,mBAEI,OAAO,EAIX,mBACIV,EACAS,EACAiM,GAUA,MAN+B,CAC3BsD,KAAM1e,KAAKo6D,YACXz7C,IAAK3e,KAAKq6D,WACVvD,QAAS92D,KAAKi6D,QACdhQ,QAASjqD,KAAKq6D,YAKd,iBAAiB37C,EAAcC,GAGnC,MAAM87C,EAAmBpxD,KAAKS,IAAI9J,KAAKi6D,QAASv7C,GAC1Cg8C,EAAkBrxD,KAAKS,IAAI9J,KAAKm6D,OAAQx7C,EAAK87C,EAAWz6D,KAAKk6D,cACnEl6D,KAAKo6D,YAAcK,EACnBz6D,KAAKq6D,WAAaK,IAWb,EAAAC,iCAAmC,IAAM,IAAI/B,G,kGC3hC1D,aAQA,kBAAagC,EAAb,cASY,KAAAC,MAAkC,IAAI14D,IAL9C,sBACI,OAAOnC,KAAKurC,WAahB,SAASuvB,GACoB,iBAAdA,IACPA,EAAY,IAAMA,EAAU39B,SAAS,IAAI49B,SAAS,EAAG,MAGzD,IAAI9vC,EAAQjrB,KAAK66D,MAAM58D,IAAI68D,GAC3B,YAAc94D,IAAVipB,IAGJA,EAAQ,IAAI7rB,EAAMsqB,MAAMoxC,GACxB96D,KAAK66D,MAAM7zD,IAAI8zD,EAAW7vC,IAHfA,EAUf,WACI,OAAOjrB,KAAK66D,MAAMz5C,KAOtB,QACIphB,KAAK66D,MAAM70B,SAEnB,OAtCmB,EAAAuF,WAAyB,IAAIqvB,EAsChD,GA9CA,GAAa,EAAAA,c,+GCPb,cACA,QAQA,kBAAaI,EAmBT,sBACIC,EACAC,EACAC,GAEA,MAAMC,EAAYp7D,KAAKq7D,aAAaH,EAAWC,GAE/C,OAAO,IAAI,EAAAG,mBAAmBF,EAAWH,GAU7C,oBAAoBC,EAAoBC,QAClBn5D,IAAdk5D,IACAA,EAAYl7D,KAAKu7D,kBAGrB,IAAIH,EAAYp7D,KAAKw7D,WAAWN,GAQhC,YAPkBl5D,IAAdo5D,IACAA,EAAY,IAAI,EAAAK,oBAAoB,CAChCP,YACAC,iBAA6Bn5D,IAAhBm5D,EAA4Bn7D,KAAK07D,mBAAqBP,IAEvEn7D,KAAKw7D,WAAWN,GAAaE,GAE1BA,EAQX,wBAAwBF,GACpB,MAAME,EAAYp7D,KAAKw7D,WAAWN,QAChBl5D,IAAdo5D,IACAA,EAAUO,iBACH37D,KAAKw7D,WAAWN,IAO/B,iBACIp9D,OAAO89D,KAAK57D,KAAKw7D,YAAYn7D,QAAQ1C,IACjCqC,KAAKw7D,WAAW79D,GAAMg+D,YAE1B37D,KAAKw7D,WAAa,IAS1B,OA5EW,EAAAD,iBAA2B,sBAK3B,EAAAG,wBAA8B15D,EAoEtB,EAAAw5D,WAEX,GACR,GAjFA,GAAa,EAAAR,2B,2KCXb,aAiBA,OAeA,OAQA,OACA,QACA,QACA,QACA,QACA,QACA,QACA,QAIA,SACA,SACA,SACA,SACA,SACA,QACA,SACA,QACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,QACA,SACA,SACA,SAEA,QAEA,SACA,SAEA,QACA,SAcA,IAAYa,EANR,EAAApvD,cAAcxM,SAAS67D,kBAAkB,EAAAtuB,SAAS/pC,OAMtD,SAAYo4D,GAER,kBAEA,kBAEA,kBAEA,0BAEA,4BAEA,iCAEA,6BAEA,uCAEA,yCAEA,qCAEA,uCAEA,yCAEA,uCAEA,kCAEA,0CAEA,yCAhCJ,CAAYA,EAAA,EAAAA,oBAAA,EAAAA,kBAAiB,KAmC7B,MAAMrvD,EAAS,EAAAC,cAAcxM,SAASvB,OAAO,WAEvCq9D,EAA0C,CAAEnsD,KAAM,UAAW2C,IAAK,IAM3D,EAAAypD,6BAA+B,IAE5C,MAqCMC,EAAsB,CAAErsD,KAAMisD,EAAkBK,QAChDC,EAA4B,CAAEvsD,KAAMisD,EAAkBO,QACtDC,EAAgC,CAAEzsD,KAAMisD,EAAkBS,aAC1DC,EAAiC,CAAE3sD,KAAMisD,EAAkBW,YAC3DC,EAAoC,CAAE7sD,KAAMisD,EAAkBa,eAC9DC,EAAkC,CAAE/sD,KAAMisD,EAAkBe,aAC5DC,EAAuC,CAAEjtD,KAAMisD,EAAkBiB,kBACjEC,EAAwC,CAAEntD,KAAMisD,EAAkBmB,mBAClEC,EAAsC,CAAErtD,KAAMisD,EAAkBqB,iBAChEC,EAAuC,CAAEvtD,KAAMisD,EAAkBuB,kBACjEC,EAAkC,CAAEztD,KAAMisD,EAAkByB,aAC5DC,EAAsC,CAAE3tD,KAAMisD,EAAkB2B,iBAChEC,GAAuC,CAAE7tD,KAAMisD,EAAkB6B,kBAEjEx7D,GAAQ,CACVy7D,QAAS,CAAC,IAAIv+D,EAAMoG,SACpBgI,QAAS,CAAC,IAAIpO,EAAMuG,QAAW,IAAIvG,EAAMuG,QAAW,IAAIvG,EAAMuG,SAC9DuH,UAAW,IAAI9N,EAAM+N,UACrBR,YAAa,IAAIvN,EAAMwN,MACvBE,aAAc,IAAI1N,EAAM2N,YAAO/K,EAAW,EAAAgL,eAAeC,mBACzD2wD,cAAe,CACX,IAAIx+D,EAAMuG,QACV,IAAIvG,EAAMuG,QACV,IAAIvG,EAAMuG,QACV,IAAIvG,EAAMuG,QACV,IAAIvG,EAAMuG,QACV,IAAIvG,EAAMuG,QACV,IAAIvG,EAAMuG,QACV,IAAIvG,EAAMuG,SAEd8H,QAAS,CAAC,IAAIrO,EAAMsO,QAAW,IAAItO,EAAMsO,SACzCuH,UAAW,CACP,CACIlH,SAAU,IAAI3O,EAAMuG,QACpBiI,MAAO,IAAIxO,EAAMuG,QACjBkI,MAAO,IAAIzO,EAAMuG,QACjBmI,MAAO,IAAI1O,EAAMuG,WA4C7B,IAAYk4D,IAAZ,SAAYA,GAER,oBAEA,uBAEA,qCANJ,CAAYA,GAAA,EAAAA,yBAAA,EAAAA,uBAAsB,KAyXlC,MAAMC,GAAkB,CACpB3uD,WAAY,EAAAusB,mBACZqiC,yBAAyB,EAEzBC,0BAA2B,IAC3BC,wBAAwB,EAExBC,cAAe,IACfC,wBAAyB,EAAAC,wBAAwBC,eACjDC,yBAA0B,EAC1BC,2BAA4B,EAE5BC,WACsB,oBAAXvyB,aAAsDjqC,IAA5BiqC,OAAOwyB,iBAClCxyB,OAAOwyB,iBACP,EACVlwD,OAAQ,IAAI,EAAArG,eAAe,GAAI,GAC/B0O,UAAW,EACXjI,KAAM,EACNC,QAAS,EACT8vD,MAAO,IAiFX,MAAaC,WAAgBv/D,EAAMw/D,gBAgK/B,YAAY3oD,G,MACRjT,QA9II,KAAA67D,gBAA0B,EAUjB,KAAAtvB,mBAEa,IAAI,EAAAuvB,iBAO1B,KAAAC,sBAAgC,EAGhC,KAAAC,uBAAiC,EAEjC,KAAAC,YA9nBmB,EA+nBnB,KAAAC,eA/nBmB,EAgoBnB,KAAAC,eA3nBmB,GA4nBnB,KAAAC,kBAvnBsB,GAynBb,KAAAC,eAAiB,IAAIjgE,EAAMq6B,oBAAoB,EAAG,EAAG,GAAI,GAUzD,KAAA6lC,YAAc,IAAIlgE,EAAMq6D,kBAEjC,KAAA8F,MAAQ,EACR,KAAAC,QAAU,EACV,KAAAC,OAAS,EACT,KAAAC,cAAgB,EAChB,KAAAC,iBAAmB,EACnB,KAAAC,eAAiB,EAAA13D,eAAeqU,WAAWuhD,GAAgBvvD,QAE3D,KAAAsxD,iBAAmB,IAAIzgE,EAAMuG,QACpB,KAAAm6D,aAA2B,CACxCphD,KA/pBuB,GAgqBvBC,IA/pBsB,IAgqBtBm4C,QAjqBuB,GAkqBvB7M,QAjqBsB,KAyqBT,KAAA8V,QAAuB,IAAI3gE,EAAMkiB,MAEjC,KAAA0+C,eAA8B,IAAI5gE,EAAMkiB,MACxC,KAAA2+C,MAAoB,IAAI,EAAAC,WAAWlgE,KAAK+/D,SAExC,KAAAI,YAAc,IAAI/gE,EAAMq1B,SAExB,KAAA2rC,mBAAqB,IAAIhhE,EAAMq1B,SAE/B,KAAA4rC,aAA2B,IAAI,EAAAC,WAExC,KAAAC,iBAA2B,EAE3B,KAAAC,WAAqB,EACrB,KAAAC,iBAA2B,EAE3B,KAAAC,cAAgB,EAIhB,KAAAC,yBAA0C3+D,EAKjC,KAAA4+D,kBAAkC,GAClC,KAAAC,uBAAyB,IAAIlhE,IAC7B,KAAAmhE,oBAAsB,IAAInhE,IAGnC,KAAAohE,yBAAmC,EAI1B,KAAAC,QAAU,IAAI5hE,EAAMwN,MAAM,IAAIxN,EAAMuG,QAAQ,EAAG,EAAG,IAClD,KAAAs7D,SAAW,IAAI7hE,EAAM2N,YAAO/K,EAAW,EAAAgL,eAAeC,mBAK/D,KAAA4iC,QAAiB,GAEjB,KAAAqxB,kBAA4B,EAG5B,KAAAC,sBAAuB,EACvB,KAAAC,sBAAuB,EACvB,KAAAC,4BAA6B,EAM7B,KAAAC,aAAkC,IAAI,EAAAC,kBAAkBvhE,MAExD,KAAA0vC,aAA2B,IAAI,EAAA8xB,WAAWxhE,MAE1C,KAAAyhE,kBAAqC,IAAI,EAAAC,gBAAgB1hE,MAQzD,KAAA2hE,cAAwB,GAGxB,KAAAC,gBAAmC,GAGnC,KAAAC,MAAgB,IAAI,EAAAC,OAAO,IA6kG3B,KAAAC,mBAAsBC,IAC1BhiE,KAAKiiE,cAAc5E,GACnB7wD,EAAOuJ,KAAK,qBAAsBisD,IAQ9B,KAAAE,uBAA0BF,IAC9BhiE,KAAKiiE,cAAc1E,QACKv7D,IAApBhC,KAAKmiE,kBACgBngE,IAAjBhC,KAAK6vC,cAAqD7tC,IAA5BhC,KAAK6vC,QAAQuyB,WAC3CpiE,KAAKmiE,WAAWE,cAAc,IAAIjjE,EAAMsqB,MAAM1pB,KAAK6vC,QAAQuyB,aAE3DpiE,KAAKmiE,WAAWE,cAh1HJ,UAk1HhBriE,KAAKqyC,UAET7lC,EAAOuJ,KAAK,yBAA0BisD,IAplGtChiE,KAAK2wC,UAAY,OAAH,UAAQ16B,GAEtBjW,KAAKsiE,cAAgBtiE,KAAK2wC,UAAU4xB,iBAEAvgE,IAAhChC,KAAK2wC,UAAU5wB,eACf/f,KAAKk/D,eAAiBl/D,KAAK2wC,UAAU5wB,mBAGL/d,IAAhChC,KAAK2wC,UAAU3wB,eACfhgB,KAAKm/D,eAAiBn/D,KAAK2wC,UAAU3wB,mBAGFhe,IAAnChC,KAAK2wC,UAAU6xB,kBACfxiE,KAAKo/D,kBAAoBp/D,KAAK2wC,UAAU6xB,sBAGVxgE,IAA9BhC,KAAK2wC,UAAU8xB,aACf,EAAAzH,wBAAwBO,iBAAmBv7D,KAAKsiE,cAC1CtiE,KAAKsiE,cAAcI,WAAW1iE,KAAK2wC,UAAU8xB,YAC7CziE,KAAK2wC,UAAU8xB,iBAGWzgE,IAAhChC,KAAK2wC,UAAUgyB,eACf,EAAA3H,wBAAwBU,mBAAqB17D,KAAK2wC,UAAUgyB,cAGhE3iE,KAAK4iE,wBAA0B,OAAH,wBACrB9E,IAAe,CAClB+E,yBACoC7gE,IAAhCiU,EAAQ4sD,oBACF5sD,EAAQ4sD,oBACR,EAAAlI,0CAGa34D,IAAvBiU,EAAQ9G,aACRnP,KAAK4iE,wBAAwBzzD,WAAa8G,EAAQ9G,iBAGfnN,IAAnCiU,EAAQgoD,yBACRj+D,KAAK4iE,wBAAwB3E,uBAAyBhoD,EAAQgoD,6BAGxBj8D,IAAtCiU,EAAQ+nD,4BACRh+D,KAAK4iE,wBAAwB5E,0BACzB/nD,EAAQ+nD,gCAGch8D,IAA1BiU,EAAQioD,gBACRl+D,KAAK4iE,wBAAwB1E,cAAgBjoD,EAAQioD,oBAGjBl8D,IAApCiU,EAAQkoD,0BACRn+D,KAAK4iE,wBAAwBzE,wBAA0BloD,EAAQkoD,8BAG1Bn8D,IAArCiU,EAAQqoD,2BACRt+D,KAAK4iE,wBAAwBtE,yBACzBroD,EAAQqoD,+BAG2Bt8D,IAAvCiU,EAAQsoD,6BACRv+D,KAAK4iE,wBAAwBrE,2BACzBtoD,EAAQsoD,iCAGsBv8D,IAAlCiU,EAAQ6sD,wBACR9iE,KAAK+gE,wBAA0B9qD,EAAQ6sD,uBAG3C9iE,KAAK+iE,aAAe9sD,EAAQuoD,WAC5Bx+D,KAAKgjE,YAA4BhhE,IAAnBiU,EAAQ+sD,OAAuB,EAAI/sD,EAAQ+sD,OAEzDhjE,KAAK2wC,UAAUsyB,kBAAuD,IAApCjjE,KAAK2wC,UAAUsyB,iBAEjDjjE,KAAKkjE,YAAcljE,KAAK2wC,UAAUrtB,UAClCtjB,KAAKmjE,gBAAkBnjE,KAAK2wC,UAAUyyB,mBAGMphE,IAAxChC,KAAK2wC,UAAU0yB,sBACyB,OAAxCrjE,KAAK2wC,UAAU0yB,uBAEfrjE,KAAKsjE,uBAAyBtjE,KAAK2wC,UAAU0yB,qBAC7CrjE,KAAKuvC,mBAAqB,IAAI,EAAAg0B,sBAAsBvjE,KAAKsjE,yBAG7DtjE,KAAKwjE,4BAA8BxjE,KAAKyjE,WAAW7kE,KAAKoB,MACxDA,KAAK0jE,cAAgB,IAAI,EAAAC,YACrB3jE,KACAA,KAAKs/D,aACkC,IAAvCt/D,KAAK2wC,UAAUizB,0BAGwB5hE,IAAvChC,KAAK2wC,UAAUkzB,sBACf7jE,KAAKg/D,sBAAwBh/D,KAAK2wC,UAAUkzB,qBAIhD7jE,KAAK8jE,WAAW9jE,KAAK2wC,UAAUsyB,kBAE/BjjE,KAAKwuC,OAAOu1B,iBAAiB,mBAAoB/jE,KAAK+hE,oBACtD/hE,KAAKwuC,OAAOu1B,iBAAiB,uBAAwB/jE,KAAKkiE,wBAG1DliE,KAAKmiE,WAAa,IAAkC,QAA5B,EAAA/iE,EAAc4kE,sBAAc,QAAI5kE,EAAM6kE,eAAe,CACzEz1B,OAAQxuC,KAAKwuC,OACbtuC,QAASF,KAAK2wC,UAAUzwC,QACxBgkE,UAAWlkE,KAAKmkE,4BAChB7Q,MAAOtzD,KAAK2wC,UAAU2iB,MACtB8Q,uBAAgE,IAAzCpkE,KAAK2wC,UAAUyzB,sBACtCC,qBACuCriE,IAAnChC,KAAK2wC,UAAU0zB,gBACTxG,GAAuByG,QACvBtkE,KAAK2wC,UAAU0zB,kBAE7BrkE,KAAKmiE,WAAWoC,WAAY,EAC5BvkE,KAAKmiE,WAAWhzB,MAAMq1B,mBAAoB,EAK1CxkE,KAAKmiE,WAAW9N,KAAKoQ,WAAY,EAEjCzkE,KAAK0kE,gBAEL1kE,KAAK2wC,UAAUg0B,oBACuB3iE,IAAlChC,KAAK2wC,UAAUg0B,eACT5I,EACA/7D,KAAK2wC,UAAUg0B,eACzB3kE,KAAK2wC,UAAUg0B,eAAepyD,IAAMnT,EAAMkJ,UAAU6B,MAChDnK,KAAK2wC,UAAUg0B,eAAgBpyD,IA53BjB,GADA,KAk4BlB,MAAM,MAAEkF,EAAK,OAAEvG,GAAWlR,KAAK4kE,sBACzBnyD,EAASgF,EAAQvG,EACvBlR,KAAKw5B,SAAW,IAAIp6B,EAAMq6D,kBACtBz5D,KAAK2wC,UAAUg0B,eAAepyD,IAC9BE,EAx4BmB,GACD,KA24BtBzS,KAAKw5B,SAASqrC,GAAG79D,IAAI,EAAG,EAAG,GAC3BhH,KAAKmP,WAAWsB,aAAazQ,KAAK4/D,eAAgB5/D,KAAK6/D,kBACvD7/D,KAAK+/D,QAAQ5/D,IAAIH,KAAKw5B,UACtBx5B,KAAKwvC,kBAAoB,IAAI,EAAAs1B,gBAAgB9kE,KAAKw5B,UAGlDx5B,KAAK+kE,cAEL/kE,KAAKglE,YAAc,IAAI,EAAAC,iBAAiBxtD,EAAOvG,GAE/ClR,KAAKklE,mBAAqB,IAAI,EAAAC,uBAC1BnlE,KAAK2wC,UAAUy0B,wBACf,IAAMplE,KAAKqlE,kBACX,IAAMrlE,KAAKslE,oBAGf,MAAMC,EAA2BvlE,KAAK2wC,UAAU60B,wBAsBhD,GArBAxlE,KAAKylE,oBAAsB,IAAI,EAAAC,oBAC3BjuD,EACAvG,EACAlR,KAAK2wC,UAAUg1B,kBACfJ,GAGJvlE,KAAK4lE,sBAAwB,IAAI,EAAAC,oBAAoB7lE,WAEtBgC,IAA3BiU,EAAQ6vD,iBACR9lE,KAAK+lE,iBAAmB9vD,EAAQ6vD,gBAEpC9lE,KAAKgmE,eAAiBhmE,KAAKimE,uBAE3BjmE,KAAKkmE,2BAA6B,IAAI,EAAAC,yBAAyBnmE,OAEhB,IAA3CA,KAAK2wC,UAAUotB,0BACf/9D,KAAKomE,uBAAyB,IAAI,EAAAC,qBAClCrmE,KAAKsmE,cAActmE,KAAKomE,yBAGxBpmE,KAAK+gE,wBAAyB,CAC9B,MAAMwF,OAC4BvkE,IAA9BiU,EAAQuwD,kBACFvwD,EAAQuwD,kBA/5BO,QAk6BzBxmE,KAAKymE,kBAAoB,IAAI,EAAAC,oBAAoB,CAC7CH,eACAI,oBAAqB1wD,EAAQ2wD,2BAGjC5mE,KAAK6mE,6BAIqC7kE,IAA1ChC,KAAK2wC,UAAUm2B,6BACiB9kE,IAAhChC,KAAKomE,wBAELpmE,KAAKomE,uBAAuBW,gBAAgB/mE,KAAK2wC,UAAUm2B,wBAG/D9mE,KAAKgnE,YAELhnE,KAAKinE,uBAAyBjnE,KAAKknE,qBAEnClnE,KAAKqyC,SAOT,a,MACI,OAA2B,QAA3B,EAAOryC,KAAKmnE,uBAAe,QAAI,GAMnC,mBACI,OAAOnnE,KAAK6+D,eAOhB,iBAAiBxgE,GACb2B,KAAK6+D,eAAiBxgE,EAM1B,uCACI,OAAO2B,KAAK+iB,qBAAqBmuB,iCAQrC,qCAAqC7yC,GACjC2B,KAAK+iB,qBAAqBmuB,iCAAmC7yC,EAOjE,2BACI,OAAO2B,KAAKinE,uBAQhB,6BACI,OAAOjnE,KAAKklE,mBAOhB,+BACI,OAAOllE,KAAKkmE,2BAOhB,0BACI,OAAOlmE,KAAK4lE,sBAGhB,qBACI,OAAO5lE,KAAK+lE,iBAGhB,mBAAmBD,GAEX9lE,KAAK+lE,mBAAqBD,IAI9B9lE,KAAK+lE,iBAAmBD,EACxB9lE,KAAKgmE,eAAiBhmE,KAAKimE,uBAC3BjmE,KAAKonE,oBACLpnE,KAAKqyC,UAaT,UACQryC,KAAKqnE,kCACLC,aAAatnE,KAAKqnE,iCAClBrnE,KAAKqnE,qCAAkCrlE,QAGPA,IAAhChC,KAAKunE,yBACLC,qBAAqBxnE,KAAKunE,wBAC1BvnE,KAAKunE,4BAAyBvlE,GAGlChC,KAAKwuC,OAAOi5B,oBAAoB,mBAAoBznE,KAAK+hE,oBACzD/hE,KAAKwuC,OAAOi5B,oBAAoB,uBAAwBznE,KAAKkiE,wBAE7D,IAAK,MAAMvhC,KAAc3gC,KAAK4gE,kBAC1BjgC,EAAW8E,UAEfzlC,KAAKgmE,eAAe0B,iBACpB1nE,KAAKinE,uBAAuBU,oBAC5B3nE,KAAKmiE,WAAW18B,UAChBzlC,KAAKshE,aAAat7B,QAElBhmC,KAAKklE,mBAAmBz/B,UAO5B,8BACI,OAAOzlC,KAAKgmE,eAAe7H,wBAG/B,4BAA4B9/D,GACxB2B,KAAKgmE,eAAe7H,wBAA0B9/D,EAMlD,eACI,OAAO2B,KAAKgmE,eAAe4B,yBAS/B,aAAaxmD,EAAcymD,GACvB7nE,KAAKgmE,eAAe8B,uBAAuB1mD,GAC3CymD,OAAsC7lE,IAApB6lE,EAAgCA,EAAkBzmD,EAAO,EAC3EphB,KAAKgmE,eAAe+B,wBAAwB1+D,KAAKmtB,MAAMqxC,IACvD7nE,KAAKgoE,eACLhoE,KAAKioE,iBAELjoE,KAAKinE,uBAAuBz1B,kBAE5BxxC,KAAKkoE,sBACLloE,KAAKqyC,SAMT,6BACI,YAAiDrwC,IAA1ChC,KAAK2wC,UAAUstB,wBAChBj+D,KAAK4iE,wBAAwB3E,uBAOvC,2BAA2B5/D,GACvB2B,KAAK4iE,wBAAwB3E,uBAAyB5/D,EAM1D,yBACI,OAAO2B,KAAK++D,qBAMhB,uBAAuB1gE,GACnB2B,KAAK++D,qBAAuB1gE,EAMhC,kBACI,OAAO2B,KAAKmoE,cAMhB,gBAAgBC,GACZpoE,KAAKmoE,cAAgBC,EACrBpoE,KAAKqyC,SAQT,gBAAgBg2B,GACZC,MAAMD,GACDrjC,KAAKujC,GAAYA,EAAS3mE,QAC1BojC,KAAMwjC,IACHxoE,KAAKyoE,cAAgBD,EACrBxoE,KAAK0oE,mBAOjB,kBACI,OAAO1oE,KAAKyoE,cAGhB,gBAAgBD,GACZxoE,KAAKyoE,cAAgBD,EACrBxoE,KAAK0oE,iBAMT,YACI,OAAO1oE,KAAK6vC,QAMhB,UAAU6uB,GACN,IAAK,EAAAiK,YAAYC,cAAclK,GAY3B,OAXA1+D,KAAKkhE,kBAAmB,OAExB,EAAAyH,YAAYx2C,KAAKusC,EAAO,CAAE6D,YAAaviE,KAAKsiE,gBACvCt9B,KAAK6jC,IACF7oE,KAAKkhE,kBAAmB,EACxBlhE,KAAK0+D,MAAQmK,IAEhB1jC,MAAM5mB,IACHve,KAAKkhE,kBAAmB,EACxB10D,EAAO+R,MAAM,wBAAwBA,IAASA,KAM1Dve,KAAK6vC,QAAQhhB,IAAM6vC,EAAM7vC,IACzB7uB,KAAK6vC,QAAQi5B,IAAMpK,EAAMoK,IACzB9oE,KAAKkoE,sBACLloE,KAAKigE,MAAMz3B,MAAMxoC,KAAK6vC,SAEtB7vC,KAAK6vC,QAAQk5B,OAASrK,EAAMqK,OAC5B/oE,KAAKioE,iBAGLjoE,KAAK6vC,QAAQuyB,WAAa1D,EAAM0D,WAChCpiE,KAAK6vC,QAAQm5B,WAAatK,EAAMsK,WAChChpE,KAAK04B,SAAS2pC,cAAc,IAAIjjE,EAAMsqB,MAAMg1C,EAAM0D,YAAa1D,EAAMsK,YAErEhpE,KAAK6vC,QAAQo5B,OAASvK,EAAMuK,OAC5BjpE,KAAK6vC,QAAQq5B,cAAgBxK,EAAMwK,cACnClpE,KAAKgoE,eAGLhoE,KAAK6vC,QAAQs5B,UAAYzK,EAAMyK,UAC/BnpE,KAAKopE,gBAGLppE,KAAK6vC,QAAQw5B,WAAa3K,EAAM2K,WAChCrpE,KAAK6vC,QAAQy5B,iBAAmB5K,EAAM4K,iBACtCtpE,KAAK6vC,QAAQ05B,aAAe7K,EAAM6K,aAElCvpE,KAAKonE,oBAEDhmE,MAAMC,QAAQq9D,EAAM8K,cACpBxpE,KAAK6vC,QAAQ25B,WAAa9K,EAAM8K,YAGhCpoE,MAAMC,QAAQq9D,EAAM+K,mBACpBzpE,KAAK6vC,QAAQ45B,gBAAkB/K,EAAM+K,sBAGbznE,IAAxBhC,KAAK6vC,QAAQ65B,SACb1pE,KAAK6vC,QAAQ65B,OAAS,IAEtB1pE,KAAKomE,wBACLpmE,KAAKomE,uBAAuBuD,SAAS3pE,KAAK6vC,SAE9C7vC,KAAK6vC,QAAQ65B,OAAShL,EAAMgL,QAAU,GACtC1pE,KAAK6vC,QAAQhuC,YAAc68D,EAAM78D,YAEjC,IAAK,MAAM8+B,KAAc3gC,KAAK4gE,kBAC1BjgC,EAAWgpC,SAAS3pE,KAAK6vC,SAE7B8sB,EAAmBlrB,KAAOm4B,KAAK1hC,MAC/BloC,KAAKiiE,cAActF,GACnB38D,KAAKqyC,SAOT,kBACI,OAAOryC,KAAKsiE,cAShB,wBACI,OAAOtiE,KAAK2gE,oBAMhB,sBAAsBluD,GAClBzS,KAAK2gE,oBAAsBluD,EAM/B,gBACI,OAAOzS,KAAKkjE,YAMhB,cAAc5/C,GACVtjB,KAAKkjE,YAAc5/C,EACnBtjB,KAAK4gE,kBAAkBvgE,QAASsgC,IAC5BA,EAAWkpC,aAAa7pE,KAAKkjE,eAEjCljE,KAAKqyC,SAUT,oBACI,OAAOryC,KAAKmjE,gBAWhB,kBAAkB2G,GACV9pE,KAAKmjE,kBAAoB2G,IAG7B9pE,KAAKmjE,gBAAkB2G,EACvB9pE,KAAK4gE,kBAAkBvgE,QAASsgC,IAC5BA,EAAWopC,iBAAiBD,MAIpC,oBACI,OAAO9pE,KAAK4hE,gBAQhB,kBAAkB5wB,GACdhxC,KAAKinE,uBAAuBh2B,cAAgBD,EAGhD,oBACI,OAAOhxC,KAAKinE,uBAAuBh2B,cAOvC,kBACI,OAAOjxC,KAAK0gE,cAOhB,mBACI1gE,KAAK0gE,cAAgB,EACrB1gE,KAAKgqE,8BAA2BhoE,EAwBpC,iBAAiB4N,EAAcq6D,GAC3BjnE,MAAM+gE,iBAAiBn0D,EAAMq6D,GAqBjC,oBAAoBr6D,EAAcq6D,GAC9BjnE,MAAMykE,oBAAoB73D,EAAMq6D,GAMpC,aACI,OAAOjqE,KAAK2wC,UAAUnC,OAM1B,2BACI,OAAOxuC,KAAKsjE,uBAMhB,YACI,OAAOtjE,KAAK+/D,QAehB,aACI,OAAO//D,KAAKw5B,SAMhB,eACI,OAAOx5B,KAAKmiE,WAMhB,iBACI,MAAM+H,EAAqBlqE,KAAKmiE,WAAWgI,gBAC3C,YAA8BnoE,IAAvBkoE,EAAmCA,EAAmBtzC,SAAW,EAM5E,eAAe3L,GACXjrB,KAAKmiE,WAAWE,cAAcp3C,GAMlC,iBACI,MAAMm/C,EAAqBpqE,KAAKmiE,WAAWkI,gBAC3C,YAA8BroE,IAAvBooE,EAAmCA,EAAqB,EAMnE,eAAe9W,GACXtzD,KAAKmiE,WAAWmI,cAAchX,GAMlC,iBACI,OAAOtzD,KAAK4iE,wBAAwBzzD,WAQxC,eAAeA,GAEX,MAAMR,EAAO3O,KAAK2O,KACZC,EAAU5O,KAAK4O,QAErB5O,KAAK4iE,wBAAwBzzD,WAAaA,EAC1CnP,KAAK6mE,wBACL7mE,KAAK0nE,iBACL1nE,KAAK+iB,qBAAqB4kD,oBAC1B3nE,KAAKgmE,eAAiBhmE,KAAKimE,uBAE3BjmE,KAAKuqE,WAAW,CAAE57D,OAAMC,YAM5B,0BACI,OAAO5O,KAAK4iE,wBAAwBC,oBAMxC,wBAAwBA,GACpB7iE,KAAK4iE,wBAAwBC,oBAAsBA,EAMvD,kBACI,OAAO7iE,KAAK0/D,cAYhB,aACI,OAAO1/D,KAAK4/D,eAYhB,kBACI,OAAO5/D,KAAK6/D,iBAWhB,qBACI,OAAO7/D,KAAK2/D,iBAehB,iBACI,OAAO3/D,KAAK8/D,aAOhB,gBACI,OAAO9/D,KAAKmP,WAAWgH,eAAenW,KAAKw5B,SAASzrB,UAAU2lB,aAOlE,cAActV,GACV,QAA2Bpc,IAAvBoc,EAAU/V,SACVrI,KAAKmP,WAAWsB,aAAa2N,EAAWpe,KAAKw5B,SAASzrB,cACnD,CAEH,MAAM1F,EAAWrI,KAAKoe,UAAU/V,SAEhCrI,KAAKmP,WAAWsB,aACZ,IAAI,EAAAvI,eAAekW,EAAUjW,SAAUiW,EAAUhW,UAAWC,GAC5DrI,KAAKw5B,SAASzrB,UAItB/N,KAAKqyC,SAST,iBACI,OAAOryC,KAAKqgE,aAMhB,kBACI,OAAOrgE,KAAKw5B,SAASzrB,SAMzB,kBACI,OAAO/N,KAAK0jE,cAMhB,iBACI,OAAO1jE,KAAKshE,aAOhB,iBACI,OAAOthE,KAAK0vC,aAOhB,sBACI,OAAO1vC,KAAKyhE,kBAMhB,sBACI,OAAOzhE,KAAKo/D,kBAMhB,mBACI,OAAOp/D,KAAKk/D,eAMhB,iBAAiBtoD,GACb5W,KAAKk/D,eAAiBtoD,EACtB5W,KAAKqyC,SAMT,mBACI,OAAOryC,KAAKm/D,eAMhB,iBAAiBvoD,GACb5W,KAAKm/D,eAAiBvoD,EACtB5W,KAAKqyC,SAMT,gBACI,OAAOryC,KAAKi/D,YAGhB,cAAcroD,GACV5W,KAAKuqE,WAAW,CAAE3zD,cAMtB,WACI,OAAOxX,EAAMkJ,UAAUC,SAASvI,KAAKw/D,SAOzC,SAAS7wD,GACL3O,KAAKuqE,WAAW,CAAE57D,SAMtB,cACI,OAAQvP,EAAMkJ,UAAUC,SAASvI,KAAKu/D,OAO1C,YAAY3wD,GACR5O,KAAKuqE,WAAW,CAAE37D,YAMtB,UACI,OAAO5O,KAAK6hE,MAQhB,mBACI,OAAOziE,EAAMkJ,UAAU6B,MACnBd,KAAKmtB,MAAMx2B,KAAKi/D,aAChBj/D,KAAKk/D,eACLl/D,KAAKm/D,gBAOb,qBACI,OAAOn/D,KAAKwuC,OAAOt9B,OAQvB,kCACI,YAAqDlP,IAA9ChC,KAAK2wC,UAAU65B,2BAChBxqE,KAAKw+D,WAAa,EAClBx+D,KAAK2wC,UAAU65B,2BAMzB,kBACI,OAAOxqE,KAAK4gE,kBAShB,kBAAkB+D,GACd3kE,KAAK2wC,UAAUg0B,eAAiBA,EAChC3kE,KAAKyqE,qBAAqBzqE,KAAKmiE,WAAWuI,QAAQxoE,GAAMy7D,QAAQ,IAAIzsD,QACpElR,KAAK2qE,gBAMT,oBAAoBC,GAChB,OAAO5qE,KAAK4gE,kBAAkB1oC,KAAK2yC,GAAMA,EAAGltE,OAASitE,GAMzD,6BAA6BrE,GACzB,OAAOvmE,KAAK4gE,kBAAkBpuC,OAAOq4C,GAAMA,EAAGtE,eAAiBA,GAMnE,oBAAoB5lC,GAChB,OACIA,EAAW3hB,SACX2hB,EAAWmqC,SACX9qE,KAAK6gE,uBAAuBt6D,IAAIo6B,EAAWhjC,OAC3CgjC,EAAWoqC,UAAU/qE,KAAK4W,WAWlC,cAAc+pB,GAEV,QAAuB3+B,IADAhC,KAAKgrE,oBAAoBrqC,EAAWhjC,MAEvD,MAAM,IAAI8F,MACN,+BAA+Bk9B,EAAWhjC,yCAYlD,OARAgjC,EAAWsqC,OAAOjrE,MAClB2gC,EAAWuqC,+BAAuDlpE,IAA7BhC,KAAKmrE,qBAC1CnrE,KAAK4gE,kBAAkB16D,KAAKy6B,GAExB3gC,KAAKomE,wBACLpmE,KAAKomE,uBAAuBgF,2BAGzBzqC,EACF0qC,UACArmC,KAAK,IACK,IAAIiT,QAAQqzB,IACf,QAAmBtpE,IAAfhC,KAAK0+D,YAA6C18D,IAAtBhC,KAAK0+D,MAAMgL,OAEvC,YADA4B,IAIJ,MAAMC,EAAc,KAChBvrE,KAAKynE,oBAAoB5L,EAAkBe,YAAa2O,GACxDD,KAGJtrE,KAAK+jE,iBAAiBlI,EAAkBe,YAAa2O,MAG5DvmC,KAAK,MACqE,IAAhDhlC,KAAK4gE,kBAAkBjuC,QAAQgO,KAItDA,EAAWojC,iBAAiBlI,EAAkBK,OAAQ,KAClDl8D,KAAKqyC,WAGT1R,EAAWgpC,SAAS3pE,KAAK6vC,SAEzB7vC,KAAK6gE,uBAAuB1gE,IAAIwgC,EAAWhjC,MAE3CqC,KAAKiiE,cAAc,CACfryD,KAAMisD,EAAkB2P,kBACxBZ,eAAgBjqC,EAAWhjC,OAG/BqC,KAAKqyC,YAERlN,MAAM5mB,IACH/R,EAAO+R,MACH,mCAAmCoiB,EAAWhjC,SAAS4gB,EAAMusB,WAGjE9qC,KAAK8gE,oBAAoB3gE,IAAIwgC,EAAWhjC,MACxCqC,KAAKiiE,cAAc,CACfryD,KAAMisD,EAAkB2P,kBACxBZ,eAAgBjqC,EAAWhjC,KAC3B4gB,YAUhB,iBAAiBoiB,GACb,MAAM8qC,EAAUzrE,KAAK4gE,kBAAkBjuC,QAAQgO,IAC9B,IAAb8qC,IAGJ9qC,EAAW+qC,OAAO1rE,MAElBA,KAAKgmE,eAAe2F,iBAAiBhrC,GACrC3gC,KAAK4gE,kBAAkBz6B,OAAOslC,EAAS,GACvCzrE,KAAK6gE,uBAAuB95D,OAAO45B,EAAWhjC,MAC9CqC,KAAK8gE,oBAAoB/5D,OAAO45B,EAAWhjC,MAEvCqC,KAAKomE,wBACLpmE,KAAKomE,uBAAuBgF,2BAGhCprE,KAAKqyC,UAMT,qBACI,OAAOryC,KAAKgmE,eAQhB,eAAerzB,GACX3yC,KAAKinE,uBAAuB2E,eAAej5B,GAC3C3yC,KAAKqyC,SAQT,mBACIryC,KAAKinE,uBAAuB4E,mBAqEhC,OACIC,EACA98D,EACA+8D,EACAC,GAEA,GAAI,EAAAljE,qBAAqBgjE,GAAiB,CACtC,MAKMzuD,EAAgC,CAClC9O,OAAQu9D,EACRl1D,eANa5U,IAAbgN,EACM,EAAAhB,aAAa0R,+BAA+B1f,KAAMgP,QAClDhN,EAKN2M,KAAMo9D,EACNn9D,QAASo9D,GAEbhsE,KAAKuqE,WAAWltD,OACiB,iBAAnByuD,GACd9rE,KAAKuqE,WAAWuB,GAoBxB,4BACIG,EACAr1D,EACAxG,EAAiB,EACjBC,EAAmB,GAEnBrQ,KAAKoe,UAAY6tD,EACjB,IAAIC,EAAe7iE,KAAKO,IAAI,EAAAoE,aAAa8M,aAAczK,GACvD,GAAIrQ,KAAKmP,WAAWS,OAAS,EAAAC,eAAee,UAAW,CACnD,MAAMu7D,EAA2B9iE,KAAK4U,KAClC,EAAAjR,eAAeC,mBACV,EAAAe,aAAa2I,uCAAuC3W,KAAM4W,GACvD,EAAA5J,eAAeC,oBAErBm/D,EAA2BhtE,EAAMkJ,UAAUC,SAAS4jE,GAC1DD,EAAe7iE,KAAKO,IAAIsiE,EAAcE,GAE1C,EAAAp+D,aAAagN,qBAAqBhb,KAAM,EAAG,EAAG4W,GAC9C,EAAA5I,aAAamQ,YAAYne,KAAMoQ,EAAQ87D,GACvClsE,KAAKqyC,SAiBT,mBAAmB10C,EAAcU,GAC7B,GAAIV,EAAKylD,WAAW,KAChB,MAAM,IAAI3/C,MAAM,uDAAuD9F,MAE3EqC,KAAK6hE,MAAMviC,QAAQ3hC,GAAQU,EAC3B2B,KAAKqyC,SAWT,sBAAsB10C,GAClB,GAAIA,EAAKylD,WAAW,KAChB,MAAM,IAAI3/C,MAAM,0CAA0C9F,aAEvDqC,KAAK6hE,MAAMviC,QAAQ3hC,GAC1BqC,KAAKqyC,SAMT,gBACI,OAAOryC,KAAKugE,iBAAmB,EAMnC,iBACoC,GAA5BvgE,KAAKugE,qBACLvgE,KAAKqyC,SACLwqB,EAAwBprB,KAAOm4B,KAAK1hC,MACpCloC,KAAKiiE,cAAcpF,IAO3B,eACQ78D,KAAKugE,iBAAmB,KACtBvgE,KAAKugE,iBAGmB,IAA1BvgE,KAAKugE,mBACLxD,EAAyBtrB,KAAOm4B,KAAK1hC,MACrCloC,KAAKiiE,cAAclF,IAO3B,qBACI,OAAO/8D,KAAKklE,mBAAmB9kB,eAMnC,qBACI,OACIpgD,KAAKogD,gBACLpgD,KAAKqsE,WACLrsE,KAAKygE,iBACLzgE,KAAKkmE,2BAA2BoG,YAQxC,mBACI,QAA4BtqE,IAAxBhC,KAAKusE,eAA8B,CAEnC,EAAAjgE,YAAyCtK,IAAlChC,KAAK2wC,UAAUg0B,gBAQtB,MAAMhnB,EAAiB39C,KAAK2/D,iBAG5B3/D,KAAKusE,eAAiB,EAAAv+D,aAAagT,gCAC/BhhB,KAAK0/D,cACL/hB,EACA,GAGR,OAAO39C,KAAKusE,eAOhB,mBACI,OAAO,EAAMvsE,KAAKwsE,aAGtB,iBACI,YAA0BxqE,IAAtBhC,KAAK+iE,aACE/iE,KAAK+iE,aAES,oBAAX92B,aAAsDjqC,IAA5BiqC,OAAOwyB,iBACzCxyB,OAAOwyB,iBACP,EAgBV,eAAeD,GACXx+D,KAAK+iE,aAAevE,EAChBx+D,KAAK04B,SAAS+zC,kBAAoBzsE,KAAKw+D,YACvCx+D,KAAK04B,SAASg0C,cAAc1sE,KAAKw+D,YAuBzC,sBAAsBmO,GAClB3sE,KAAKylE,oBAAoBmH,iBAAmBD,EAGhD,wBACI,OAAO3sE,KAAKylE,oBAAoBmH,iBAWpC,kBAAkBC,GACV,EAAAC,cAAcD,GACd3qE,GAAMsL,QAAQ,GAAG8B,KAAKu9D,GAEtB7sE,KAAKmP,WAAWsB,aAAa,EAAAvI,eAAeqU,WAAWswD,GAAM3qE,GAAMsL,QAAQ,IAE/E,MAAMtO,EAAIc,KAAKwvC,kBAAkB+R,QAAQr/C,GAAMsL,QAAQ,IACvD,QAAUxL,IAAN9C,EAAiB,CACjB,MAAM,MAAEuY,EAAK,OAAEvG,GAAWlR,KAAK4kE,sBAC/B1lE,EAAEuG,EAAIvG,EAAEuG,EAAIgS,EAAQ,EACpBvY,EAAEwG,EAAIwL,GAAUhS,EAAEwG,EAAIwL,EAAS,GAEnC,OAAOhS,EAcX,yBAAyBuG,EAAWC,GAEhC,OADA1F,KAAKglE,YAAY+H,cAAc/sE,KAAKgtE,+BAA+BvnE,EAAGC,GAAI1F,KAAKs/D,aACxEt/D,KAAKglE,YAWhB,mBAAmBv/D,EAAWC,GAE1B,OADA1F,KAAKglE,YAAY+H,cAAc/sE,KAAKgtE,+BAA+BvnE,EAAGC,GAAI1F,KAAKw5B,UACxEx5B,KAAKmP,WAAWS,OAAS,EAAAC,eAAee,UACzC5Q,KAAKglE,YAAYj1D,IAAIE,gBAAgBjQ,KAAKihE,SAAU/+D,GAAMsL,QAAQ,IAClExN,KAAKglE,YAAYj1D,IAAIC,eAAehQ,KAAKghE,QAAS9+D,GAAMsL,QAAQ,IAa1E,oBAAoB/H,EAAWC,GAC3B,MAAM2O,EAAgBrU,KAAKitE,mBAAmBxnE,EAAGC,GACjD,OAAK2O,EAGErU,KAAKmP,WAAWgH,eAAe9B,GAF3B,KAWf,+BAA+B5O,EAAWC,GAGtC,MAAM,MAAE+R,EAAK,OAAEvG,GAAWlR,KAAK4kE,sBAC/B,OAAO,IAAIxlE,EAAMuG,QAASF,EAAIgS,EAAS,EAAI,GAAM/R,EAAIwL,EAAU,EAAK,EAAG,GAoB3E,oBAAoBzL,EAAWC,GAC3B,OAAO1F,KAAK0jE,cAAcwJ,oBAAoBznE,EAAGC,GASrD,OAAO+R,EAAevG,GAClBlR,KAAKmiE,WAAWgL,QAAQ11D,EAAOvG,GAAQ,GACnClR,KAAKmiE,WAAWsK,kBAAoBzsE,KAAKw+D,YACzCx+D,KAAKmiE,WAAWuK,cAAc1sE,KAAKw+D,iBAGNx8D,IAA7BhC,KAAKylE,qBACLzlE,KAAKylE,oBAAoB0H,QAAQ11D,EAAOvG,QAGVlP,IAA9BhC,KAAKqjE,uBACLrjE,KAAKqjE,qBAAqB5rD,MAAQA,EAClCzX,KAAKqjE,qBAAqBnyD,OAASA,GAGvClR,KAAK2qE,gBACL3qE,KAAKqyC,SAELryC,KAAKiiE,cAAc,CACfryD,KAAMisD,EAAkBuR,OACxBhsD,KAAM,CACF3J,QACAvG,YAcZ,WAAWm8D,QACgBrrE,IAAnBqrE,IACAA,EAAiB,EAAAplC,iBAAiBC,OAEtCloC,KAAKg5B,OAAOq0C,GAMhB,SACIrtE,KAAKiiE,cAAchG,GAGfj8D,KAAKygE,kBAKTzgE,KAAKygE,iBAAkB,EAEvBzgE,KAAKstE,mBAOT,oBACI,OAAOttE,KAAKygE,gBAOhB,wBACIzgE,KAAKqyC,SAYT,eAAeu4B,GACX,QAA4B5oE,IAAxBhC,KAAKgmE,eAAT,CAKA,QAAuBhkE,IAAnB4oE,EAA8B,CAC9B,MAAMjqC,EAAa3gC,KAAKgrE,oBAAoBJ,GACxCjqC,IACA3gC,KAAKgmE,eAAe0B,eAAe/mC,GACnCA,EAAW4sC,mBAGfvtE,KAAKgmE,eAAe0B,iBACpB1nE,KAAK4gE,kBAAkBvgE,QAAQsgC,GAAcA,EAAW4sC,mBAG3BvrE,IAA7BhC,KAAKmrE,qBACLnrE,KAAKmrE,oBAAoBoC,cASjC,mBAAmBC,GACfxtE,KAAKgmE,eAAeyH,mBAAmBD,GAQ3C,kBAAkBvqE,GACdjD,KAAKgmE,eAAe0H,kBAAkBzqE,GAY1C,eAAe09B,GACX3gC,KAAKgmE,eAAe2H,eAAehtC,GAiBvC,yBACIitC,EACAC,EACAzyD,GAGIpb,KAAK8tE,mBAAqB9tE,KAAK8tE,oBAAsBF,GACrD5tE,KAAK2rE,iBAAiB3rE,KAAK8tE,oBAIwC,IAArD9tE,KAAK4gE,kBAAkBjuC,QAAQi7C,UAEvC5tE,KAAKsmE,cAAcsH,GAE7B5tE,KAAK8tE,kBAAoBF,EACzB5tE,KAAK+tE,uBAAyBF,EACzB7tE,KAAK+tE,uBAAuBjD,eACvB9qE,KAAK+tE,uBAAuB1C,UAEtCrrE,KAAKmrE,oBAAsB/vD,EAC3Bpb,KAAKguE,YAAY3tE,QAAQsgC,IACrBA,EAAWuqC,2BAA0B,KAEzClrE,KAAK4lE,sBAAsBqI,sBAAuBxrD,IAC9C,EAAAyrD,mBAAmBzrD,KAEvBziB,KAAK0nE,iBAOT,qBAAqBkG,GACjB5tE,KAAK2rE,iBAAiBiC,GACtB5tE,KAAK8tE,uBAAoB9rE,EACzBhC,KAAK+tE,4BAAyB/rE,EAC9BhC,KAAKmrE,yBAAsBnpE,EAC3BhC,KAAKguE,YAAY3tE,QAAQsgC,IACrBA,EAAWuqC,2BAA0B,KAEzClrE,KAAK4lE,sBAAsBqI,2BAAsBjsE,GACjDhC,KAAK0nE,iBAMT,UACI,OAAO1nE,KAAKigE,MAGR,iBAEJjgE,KAAKylE,oBAAoB0I,MAAMnvD,SAAU,EACzChf,KAAKylE,oBAAoB2I,QAAQpvD,SAAU,EAC3Chf,KAAKylE,oBAAoB4I,SAASrvD,SAAU,EAC5Chf,KAAKylE,oBAAoB6I,MAAMtvD,SAAU,OAEdhd,IAAvBhC,KAAKyoE,qBAC4BzmE,IAA7BhC,KAAKyoE,cAAc0F,QACnBnuE,KAAKylE,oBAAoB0I,MAAQnuE,KAAKyoE,cAAc0F,YAErBnsE,IAA/BhC,KAAKyoE,cAAc2F,UACnBpuE,KAAKylE,oBAAoB2I,QAAQpvD,QAAUhf,KAAKyoE,cAAc2F,QAAQpvD,QACtEhf,KAAKylE,oBAAoB8I,cAAcvuE,KAAKyoE,cAAc2F,eAE1BpsE,IAAhChC,KAAKyoE,cAAc4F,WACnBruE,KAAKylE,oBAAoB4I,SAAWruE,KAAKyoE,cAAc4F,eAE1BrsE,IAA7BhC,KAAKyoE,cAAc6F,QACnBtuE,KAAKylE,oBAAoB6I,MAAQtuE,KAAKyoE,cAAc6F,QAQhE,wBACI,OAAOtuE,KAAKmrE,oBAGhB,qBACI,OAAwC,IAAjCnrE,KAAK2wC,UAAU69B,cAG1B,mBAAmBxvD,QAGmBhd,IAA9BhC,KAAKmiE,WAAWsM,WAChBzvD,IAAYhf,KAAKmiE,WAAWsM,UAAUzvD,UAI1Chf,KAAK2wC,UAAU69B,cAAgBxvD,EAE/Bhf,KAAKmiE,WAAWsM,UAAUzvD,QAAUA,EAGpChf,KAAKmiE,WAAWsM,UAAU7+D,KAAOxQ,EAAMsvE,iBACvC1uE,KAAK0nE,kBAGD,kBACJ,MAAMh5D,EAAS1O,KAAKw5B,SACdrqB,EAAanP,KAAKmP,WAElBE,EAAYnN,GAAMsL,QAAQ,GAC1ByH,EAAY/S,GAAM+S,UAAU,GAC5B05D,EAAqBzsE,GAAMuL,QAAQ,GAEzC4B,EAAU6G,sBAAsBxH,EAAOqD,aACvC5C,EAAW+F,kBAAkBlV,KAAK4/D,eAAgB3qD,GAClD05D,EAAmBx5D,UAAUF,EAAUrH,MAAOqH,EAAUpH,MAAOoH,EAAUnH,OAGzE5L,GAAMuL,QAAQ,GAAGyG,WAAWy6D,GAAoBt5D,SAAS3G,EAAOqD,aAChEkD,EAAUrH,MAAMwI,oBAAoBlU,GAAMuL,QAAQ,GAAI,GACtDwH,EAAUpH,MAAMuI,oBAAoBlU,GAAMuL,QAAQ,GAAI,GACtDwH,EAAUnH,MAAMsI,oBAAoBlU,GAAMuL,QAAQ,GAAI,GAGtD,IAAI4I,EAAM,EACNC,EAAQ,EACRC,EAAO,EAGX,MACM7Y,EAAIuX,EAAUnH,MAAM4H,IAAIrG,EAAUrI,IAAI,EAAG,EAAG,IAmBlD,OAlBItJ,EAAI,EAFQ,MAGRA,EAHQ,MAGH,GACL2Y,EAAMhN,KAAKmN,MAAMvB,EAAUnH,MAAMrI,GAAIwP,EAAUnH,MAAMpI,GACrD4Q,EAAQjN,KAAKsM,KAAKV,EAAUnH,MAAMlI,GAClC2Q,EAAOlN,KAAKmN,MAAMvB,EAAUrH,MAAMnI,EAAGwP,EAAUpH,MAAMjI,KAGrDyQ,GAAOhN,KAAKmN,OAAOvB,EAAUpH,MAAMpI,EAAGwP,EAAUrH,MAAMnI,GACtD6Q,EAAQ,IACRC,EAAO,IAIXF,EAAMhN,KAAKmN,OAAOvB,EAAUpH,MAAMpI,EAAGwP,EAAUrH,MAAMnI,GACrD6Q,EAAQ,EACRC,EAAO,GAGJ,CACHF,MACAC,QACAC,QAIA,WAAW8G,GACf,MAAM1O,EAAOtF,KAAKO,IAAI,EAAAglE,eAAevxD,EAAO1O,KAAM3O,KAAK2O,MAAO,EAAAX,aAAa8M,cACrElM,EAAU,EAAAggE,eAAevxD,EAAOzO,QAAS5O,KAAK4O,SAEpD,IAAIL,EACJ,QAAsBvM,IAAlBqb,EAAO86B,OAAsB,CAC7B,IAAI02B,EAEJ,GAAIxxD,EAAO86B,kBAAkB,EAAAtjB,OACzBtmB,EAAS8O,EAAO9O,OACV,EAAArG,eAAeqU,WAAWc,EAAO9O,QACjC8O,EAAO86B,OAAOl7B,OACpB4xD,EAAY,EAAA7gE,aAAa+O,kBAAkBM,EAAO86B,aAC/C,GAAI,EAAA22B,mBAAmBzxD,EAAO86B,QAAS,CAC1C5pC,EAAS8O,EAAO9O,OAAS,EAAArG,eAAeqU,WAAWc,EAAO9O,QAAUvO,KAAKuO,OACzE,MAAMyO,EAAM,EAAA6X,OAAOk6C,qBAAqBxgE,EAAQ8O,EAAO86B,QACvD02B,EAAY,EAAA7gE,aAAa+O,kBAAkBC,OACxC,KAAI5b,MAAMC,QAAQgc,EAAO86B,QAM5B,MAAM10C,MAAM,mCALZorE,EAAYxxD,EAAO86B,YACGn2C,IAAlBqb,EAAO9O,SACPA,EAAS,EAAArG,eAAeqU,WAAWc,EAAO9O,SAK9CvO,KAAKg/D,uBAAyBh/D,KAAKmP,WAAWS,OAAS,EAAAC,eAAeC,SAKtE++D,EAAY,EAAA7gE,aAAaoO,sBAAsByyD,EAAWtgE,IAE9D,MAAM6O,EAAcyxD,EAAU9oE,IAAIyL,GAC9BxR,KAAKmP,WAAWsB,aAAa,EAAAvI,eAAeqU,WAAW/K,GAAQ,IAAIpS,EAAMuG,UAEvEiM,EAAc,IAAIxS,EAAMuG,QAC9B,QAAgB3D,IAAZuM,EAAuB,EACX,IAAInP,EAAMm7B,MAAOy0C,cAAc5xD,GACvC6xD,UAAUr9D,GACd5R,KAAKmP,WAAW+/D,oBAAoBt9D,GACpCrD,EAASvO,KAAKmP,WAAWgH,eAAevE,QAExC5R,KAAKmP,WAAWsB,aAAalC,EAAQqD,GAEzC,OAAO5R,KAAKuqE,WACR,EAAAv8D,aAAakP,yBAAyB3O,EAAQqD,EAAawL,EAAa,CACpEzO,OACAC,UACA2O,YAAa,EAAAvP,aAAayR,+BACtBzf,KACAA,KAAKggB,cAET7Q,WAAYnP,KAAKmP,WACjBT,OAAQ1O,KAAK0O,UAIzBH,OACsBvM,IAAlBqb,EAAO9O,OAAuB,EAAArG,eAAeqU,WAAWc,EAAO9O,QAAUvO,KAAKuO,OAElF,MAAMS,OACmBhN,IAArBqb,EAAOzG,UACD,EAAA5I,aAAayR,+BACTzf,KACAZ,EAAMkJ,UAAU6B,MACZkT,EAAOzG,UACP5W,KAAKk/D,eACLl/D,KAAKm/D,sBAGOn9D,IAApBqb,EAAOrO,SACPqO,EAAOrO,SACPhP,KAAK2/D,iBAKf,EAAA3xD,aAAagH,0BACThV,KAAKmP,WACLZ,GACCK,EACDD,EACA3O,KAAK0O,OAAO+O,YAEhB,EAAAzP,aAAakC,uCACT3B,EACAS,GACCJ,EACDD,EACA3O,KAAKmP,WACLnP,KAAK0O,OAAOX,UAEhB/N,KAAK0O,OAAOqG,mBAAkB,GAI9B/U,KAAKmvE,uBACLnvE,KAAKqyC,SAMD,wBACJ,MAAM1R,EAAa3gC,KAAKymE,kBACxB,IAAqC,IAAjCzmE,KAAK+gE,8BAAmD/+D,IAAf2+B,EAA0B,CACnE,MAAMyuC,EAAiBpvE,KAAKgrE,oBAAoBrqC,EAAWhjC,MAEvDqC,KAAKmP,WAAWS,OAAS,EAAAC,eAAee,eACjB5O,IAAnBotE,GACApvE,KAAKsmE,cAAc3lC,QAGA3+B,IAAnBotE,GACApvE,KAAK2rE,iBAAiBhrC,IAa9B,cAAcsrB,GAGlBjsD,KAAKw5B,SAASzkB,mBAAkB,GAChC/U,KAAKmvE,uBAEL,MAAM,MAAE13D,EAAK,OAAEvG,GAAWlR,KAAKmiE,WAAWuI,QAAQxoE,GAAMy7D,QAAQ,IAChE39D,KAAKw5B,SAAS/mB,YACmBzQ,IAA7BhC,KAAK2gE,oBAAoC3gE,KAAK2gE,oBAAsBlpD,EAAQvG,EAChFlR,KAAKqvE,eAAervE,KAAK2wC,UAAUg0B,eAAiBzzD,GAMpD,MACMo+D,EADkBtvE,KAAKmP,WAAWogE,eAAevvE,KAAK0O,OAAOX,UAG/D/N,KAAK4gE,kBAAkBpiC,OAAO,CAACtgC,EAAG2sE,IAAOxhE,KAAKS,IAAI5L,EAAG2sE,EAAG5mC,mBAAoB,GAKhFnmC,OAAOysD,OACHvqD,KAAK8/D,kBACU99D,IAAfiqD,EACMjsD,KAAKgmE,eAAewJ,iBAAiBF,GACrCrjB,GAEVjsD,KAAKw5B,SAAS9a,KAAO1e,KAAK8/D,aAAaphD,KACvC1e,KAAKw5B,SAAS7a,IAAM3e,KAAK8/D,aAAanhD,IAEtC3e,KAAKw5B,SAASi2C,yBAIdzvE,KAAKs/D,YAAYhwD,KAAKtP,KAAKw5B,UAC3Bx5B,KAAKs/D,YAAYvxD,SAAS2hE,UAAU,GACpC1vE,KAAKs/D,YAAYvqD,mBAAkB,GAEnC/U,KAAKq/D,eAAevgD,KAAOrH,GAAS,EACpCzX,KAAKq/D,eAAehgD,MAAQ5H,EAAQ,EACpCzX,KAAKq/D,eAAe//C,OAASpO,GAAU,EACvClR,KAAKq/D,eAAezgD,IAAM1N,EAAS,EACnClR,KAAKq/D,eAAeoQ,yBACpBzvE,KAAKq/D,eAAetqD,mBAAkB,GAEtC/U,KAAKwvC,kBAAkB6C,OAAOryC,KAAK0O,OAAQ+I,EAAOvG,GAClDlR,KAAKuvC,mBAAmB8C,OAAO56B,EAAOvG,GAEtClR,KAAKusE,oBAAiBvqE,EACtBhC,KAAKigE,MAAM5tB,OAAOryC,KAAMA,KAAK8/D,aAAa7V,SAMtC,uBAEJ,MAAM,OAAE17C,EAAM,SAAES,GAAa,EAAAhB,aAAayN,qBACtCzb,KAAKmP,WACLnP,KAAK0O,OACL1O,KAAKob,mBAGTpb,KAAK6/D,iBAAiBvwD,KAAKf,GAC3BvO,KAAK4/D,eAAiB5/D,KAAKmP,WAAWgH,eAAenW,KAAK6/D,kBAC1D7/D,KAAK2/D,iBAAmB3wD,EACxBhP,KAAKi/D,YAAc,EAAAjxD,aAAa0R,+BAA+B1f,KAAMA,KAAK2/D,kBAE1E,MAAM,IAAEtpD,EAAG,MAAEC,EAAK,KAAEC,GAASvW,KAAKgW,kBAClChW,KAAKu/D,MAAQlpD,EACbrW,KAAKw/D,QAAUlpD,EACftW,KAAKy/D,OAASlpD,EAMV,YACJvW,KAAK6hE,MAAMviC,QAAQqwC,MAAQ3vE,KAAKi/D,YAIhCj/D,KAAK6hE,MAAMviC,QAAQswC,eAAiB5vE,KAAKwsE,aAEzCxsE,KAAK6hE,MAAMviC,QAAQuwC,aAAe7vE,KAAK0gE,cAQnC,UAAUoP,EAAqB3pE,GAMnC,OALAA,EACKa,IAAI8oE,EAAOrqE,EAAGqqE,EAAOpqE,EAAGoqE,EAAOlqE,GAC/BqM,aAAajS,KAAK0O,OAAOqhE,yBAEzB99D,aAAajS,KAAKs/D,YAAYvtD,aAC5B5L,EAOH,iBAAiB6pE,EAAwBthE,GAC7C,OAAOshE,EAAQ/9D,aAAavD,EAAOuhE,oBAM/B,eAEJ,IACKjwE,KAAKusB,gBACNvsB,KAAKmP,WAAWS,OAAS,EAAAC,eAAee,gBACf5O,IAAzBhC,KAAKmnE,iBAC2B,IAAhCnnE,KAAKmnE,gBAAgB7lE,OAErB,OAGJ,MAaM4uE,EAbwB,CAE1B,CAAEzqE,GAAI,EAAGC,GAAI,EAAGE,GAAI,GACpB,CAAEH,EAAG,EAAGC,GAAI,EAAGE,GAAI,GACnB,CAAEH,GAAI,EAAGC,EAAG,EAAGE,GAAI,GACnB,CAAEH,EAAG,EAAGC,EAAG,EAAGE,GAAI,GAGlB,CAAEH,GAAI,EAAGC,GAAI,EAAGE,EAAG,GACnB,CAAEH,EAAG,EAAGC,GAAI,EAAGE,EAAG,GAClB,CAAEH,GAAI,EAAGC,EAAG,EAAGE,EAAG,GAClB,CAAEH,EAAG,EAAGC,EAAG,EAAGE,EAAG,IAEYG,IAAI,CAAC7G,EAAG9B,IAAM4C,KAAKmwE,UAAUjxE,EAAGgD,GAAM07D,cAAcxgE,KAErF4C,KAAKmnE,gBAAgB9mE,QAAQ83B,IACzB,MAAMi4C,EAAmBj4C,EACzB,IAA4C,IAAxCi4C,EAAiBC,mBAA6B,CAC9C,MAAMC,EAAiBpuE,GAAMsL,QAAQ,GACrC8iE,EAAehhE,KAAK8gE,EAAiB7hE,OAAOR,UAC5CuiE,EAAex9D,IAAIs9D,EAAiBriE,UACpCuiE,EAAez/D,YAEf,MAAM0E,EAASrT,GAAMsL,QAAQ,GACzBxN,KAAKmP,WAAWS,OAAS,EAAAC,eAAeC,QAGxCyF,EAAOvO,IAAI,EAAG,GAAI,GAUtB,MAAM2H,EAAO3O,KAAKw/D,QAEZ+Q,EADevwE,KAAKiP,eAAiB5F,KAAKkH,IAAI5B,GACjB4G,EAAOG,IAAI46D,GAE9CF,EAAiB7hE,OAAOR,SAASuB,KAAKtP,KAAK4R,aAAakB,IAAI9S,KAAK0O,OAAOX,UACxEqiE,EAAiBriE,SAASuB,KAAKtP,KAAK4R,aACpCw+D,EAAiBriE,SAAS8oD,gBAAgByZ,GAAiBC,GAC3DH,EAAiBriE,SAAS+E,IAAI9S,KAAK0O,OAAOX,UAC1CqiE,EAAiBr7D,oBACjBq7D,EAAiBI,OAAOC,eAAeL,GAEvC,MAAM1hE,EAAS0hE,EAAiBI,OAAO9hE,OACjCgiE,EAAqBR,EAAkBnqE,IAAI7G,GAC7Cc,KAAK2wE,iBAAiBzxE,EAAE2N,QAAS6B,IAG/BsO,EAAM,IAAI5d,EAAMm7B,KACtBm2C,EAAmBrwE,QAAQmR,IACvBwL,EAAI4zD,cAAcp/D,KAEtB9C,EAAOoQ,KAAO9B,EAAIpT,IAAInE,EACtBiJ,EAAO2Q,MAAQrC,EAAIlT,IAAIrE,EACvBiJ,EAAOkQ,IAAM5B,EAAIlT,IAAIpE,EACrBgJ,EAAO4Q,OAAStC,EAAIpT,IAAIlE,EAGxBgJ,EAAOgQ,KAAoB,KAAZ1B,EAAIlT,IAAIlE,EACvB8I,EAAOiQ,KAAO3B,EAAIpT,IAAIhE,EACtB8I,EAAO+gE,4BAUX,WAAWpC,GAEf,IAAIrtE,KAAK2wC,UAAUkgC,qBAAnB,CAIA,GAAoB,IAAhB7wE,KAAKgjE,OAELhjE,KAAKg5B,OAAOq0C,OACT,CAIH,MAAMyD,EAAgB,EAChBC,EAAgB,IAAO/wE,KAAKgjE,OAK9BqK,SAHkCrrE,IAAlChC,KAAKgqE,yBAAyC,EAAIhqE,KAAKgqE,0BACpB+G,EAAgBD,GAGnD9wE,KAAKg5B,OAAOq0C,GAMhBrtE,KAAKygE,iBAAmBzgE,KAAKqsE,UAC7BrsE,KAAKunE,uBAAyByJ,sBAAsBhxE,KAAKwjE,6BAGzDxjE,KAAKunE,4BAAyBvlE,GAO9B,uBACgCA,IAAhChC,KAAKunE,wBAAwCvnE,KAAK2wC,UAAUkgC,uBAIhE7wE,KAAKunE,uBAAyByJ,sBAAsBhxE,KAAKwjE,8BAMrD,4BAGJ,MAAMyN,EAAmC,GAEzC,IAAK,MAAMtwC,KAAc3gC,KAAK4gE,kBACtB5gE,KAAKkxE,oBAAoBvwC,IACzBswC,EAAmB/qE,KAAKy6B,GAIhC,OAAOswC,EAMH,OAAO5D,GACX,GAAIrtE,KAAKwgE,UACL,OAQJ,IAAI2Q,EALJhV,EAAa1qB,KAAO47B,EACpBrtE,KAAKiiE,cAAc9F,KAEjBn8D,KAAK0gE,cAGP,MAAMx8B,EAAQ,EAAAC,sBAAsBlkC,SAC9BmxE,EAA4BltC,EAAMllB,QACxC,GAAIoyD,EAAkB,CAGlB,GAFAD,EAAoBjtC,EAAMG,kBAEYriC,IAAlChC,KAAKgqE,yBAAwC,CAG7C,MAAMqH,EAAyBhE,EAAiBrtE,KAAKgqE,yBACrDmH,EAAkBhpC,SAAS,aAAc,IAAOkpC,GAMpDntC,EAAMotC,yBAENH,EAAoBA,EACpBA,EAAkBhpC,SAAS,0BAA2BnoC,KAAK0gE,eAK/D,IAAI6Q,EACAC,EACAC,EACAC,EACAC,EACAC,EA4BJ,GAnCA5xE,KAAKgqE,yBAA2BqD,EAShCrtE,KAAKmiE,WAAW9N,KAAK7rB,QAErBxoC,KAAKygE,iBAAkB,EACvBzgE,KAAK6xE,6BAA0B7vE,EAE/BhC,KAAKwgE,WAAY,EAEbxgE,KAAKmiE,WAAWsK,kBAAoBzsE,KAAKw+D,YACzCx+D,KAAKmiE,WAAWuK,cAAc1sE,KAAKw+D,YAGvCx+D,KAAK2qE,gBACL3qE,KAAK8xE,YACL9xE,KAAK+xE,eAEL/xE,KAAKmiE,WAAWn8B,QAGhBhmC,KAAKmgE,YAAYj+C,SAAS5gB,OAAS,EACnCtB,KAAKogE,mBAAmBl+C,SAAS5gB,OAAS,EAEtC8vE,IACAG,EAAY,EAAAtpC,iBAAiBC,QAI5BloC,KAAKgyE,mBAAoB,CAC1B,MAAMC,EAAmBjyE,KAAKgmE,eAAekM,iBACzClyE,KAAKo6C,aACL/wC,KAAKmtB,MAAMx2B,KAAK4W,WAChB5W,KAAKmyE,4BACLnyE,KAAK+tE,wBAILkE,EAAiBG,mBACjBpyE,KAAK2qE,cAAcsH,EAAiBhmB,YAIxCmlB,IACAI,EAAW,EAAAvpC,iBAAiBC,OAGhC,MAAMmqC,EAAaryE,KAAKgmE,eAAexjD,mBAyDvC,GAtDA6vD,EAAWhyE,QAAQ,EAAGuW,YAAW+6B,oBAC7BA,EAActxC,QAAQoiB,IAClBziB,KAAKsyE,kBAAkB7vD,EAAM7L,GAO7B6L,EAAKse,oBAAsB/gC,KAAK0gE,kBAOnC1gE,KAAKqhE,4BACLrhE,KAAKohE,sBACLphE,KAAKuyE,gBACLvyE,KAAKkhE,mBACNlhE,KAAKyhE,kBAAkBv+C,kBACvBljB,KAAKgmE,eAAe7iD,uBACpBnjB,KAAK6gE,uBAAuBz/C,KAAOphB,KAAK8gE,oBAAoB1/C,OACxDphB,KAAK4gE,kBAAkBt/D,QAC1BtB,KAAKinE,uBAAuBlzB,cAC5B/zC,KAAKinE,uBAAuBjkD,UAE7BhjB,KAAKqhE,4BAA6B,GAGtCrhE,KAAKqgE,aAAahuB,OACdryC,KAAKmP,WACLnP,KAAK0O,OAAOX,SACZ/N,KAAKmgE,YACLngE,KAAKogE,mBACLpgE,KAAK6vC,QAAQ25B,YAGjBxpE,KAAKkmE,2BAA2B7zB,OAAOryC,KAAK4W,gBAElB5U,IAAtBmvE,IAEAA,EAAkB7sC,SAAS,+BAAgC,GAC3D6sC,EAAkB7sC,SAAS,8BAA+B,GAC1D6sC,EAAkB7sC,SAAS,8BAA+B,GAG1D+tC,EAAWhyE,QAAQ,EAAGuW,YAAW+6B,gBAAejvB,eAAcL,sBAC1D8uD,EAAmB7sC,SAAS,+BAAgCqN,EAAcvwB,MAC1E+vD,EAAmB7sC,SAAS,8BAA+B5hB,EAAaphB,QACxE6vE,EAAmB7sC,SAAS,8BAA+BjiB,MAI/DriB,KAAKklE,mBAAmBsN,iBAAiBxyE,KAAMqtE,GAAiB,CAEhE,MAAM,SAAEllE,EAAQ,UAAEC,EAAS,SAAEC,GAAarI,KAAKoe,UAC/Cpe,KAAKiiE,cAAc,CACfryD,KAAMisD,EAAkB4W,sBACxBtqE,WACAC,YACAC,WAEAgO,IAAKrW,KAAKu/D,MACVjpD,MAAOtW,KAAKw/D,QACZjpD,KAAMvW,KAAKy/D,OACX9wD,KAAM3O,KAAK2O,KACXC,QAAS5O,KAAK4O,QACdiQ,KAAM7e,KAAK4W,YAKnB,MAAMlI,OAAgC1M,IAAvBhC,KAAKmoE,cAA8BnoE,KAAKmoE,cAAgBnoE,KAAKs/D,YAqD5E,GAnDIt/D,KAAK0yE,cACL1yE,KAAK2yE,0BAA0BtF,GAG/B+D,IACAK,EAAoB,EAAAxpC,iBAAiBC,YAEZlmC,IAAzBhC,KAAK4yE,iBAAiC5yE,KAAKmP,WAAWS,OAAS,EAAAC,eAAeC,QAC9E9P,KAAK4yE,gBAAgBC,aAAa7yE,KAAKw5B,UAG3Cx5B,KAAKylE,oBAAoBzsC,OACrBh5B,KAAKmiE,WACLniE,KAAK+/D,QACLrxD,GACC1O,KAAKuyE,gBAGNnB,IACAM,EAAW,EAAAzpC,iBAAiBC,OAG5BloC,KAAK0yE,cACL1yE,KAAK8yE,2BAGL9yE,KAAKogE,mBAAmBl+C,SAAS5gB,OAAS,GAC1CtB,KAAKmiE,WAAWnpC,OAAOh5B,KAAKggE,eAAgBtxD,GAG5C0iE,IACAO,EAAe,EAAA1pC,iBAAiBC,OAG/BloC,KAAKmhE,uBACNnhE,KAAKmhE,sBAAuB,EAExBiQ,GACAltC,EAAMmH,WAAWrkC,IAAI,aAAcqmE,GAGvC9Q,EAAkB9qB,KAAO47B,EACzBrtE,KAAKiiE,cAAc1F,IAGvBv8D,KAAKgmE,eAAe+M,sBAEpB/yE,KAAKwgE,WAAY,EAEjBxgE,KAAKgzE,6BAEqBhxE,IAAtBmvE,EAAiC,CACjCS,EAAU,EAAA3pC,iBAAiBC,MAE3B,MAAM+qC,EAAkBrB,EAAUvE,EAElC8D,EAAkBhpC,SAAS,mBAAoBopC,EAAalE,GAC5D8D,EAAkBhpC,SAAS,kBAAmBqpC,EAAYD,GAC1DJ,EAAkBhpC,SAAS,2BAA4BspC,EAAqBD,GAC5EL,EAAkBhpC,SAAS,kBAAmBupC,EAAYD,GAC1DN,EAAkBhpC,SAAS,sBAAuBwpC,EAAgBD,GAClEP,EAAkBhpC,SAAS,qBAAsBypC,EAAUD,GAC3DR,EAAkBhpC,SAAS,yBAA0B8qC,GAIrD9B,EAAkBhpC,SAAS,uBAAwB8qC,GACnD9B,EAAkBhpC,SAAS,8BAA+B,GAG1DjE,EAAMgvC,aAAalzE,KAAKmiE,WAAW9N,MAOnCnwB,EAAMivC,gBAGV9W,EAAiB5qB,KAAO47B,EACxBrtE,KAAKiiE,cAAc5F,GAOdr8D,KAAKohE,uBACNphE,KAAKqhE,4BACJrhE,KAAKuyE,gBACLvyE,KAAK+iB,qBAAqBC,UAE3BhjB,KAAKohE,sBAAuB,EAExBgQ,GACAltC,EAAMmH,WAAWrkC,IAAI,qBAAsBqmE,GAG/C5Q,EAAqBhrB,KAAO47B,EAC5BrtE,KAAKiiE,cAAcxF,IAInB,kBAAkBh6C,EAAY7L,G,MAClC,MAAMw8D,EAAe3wD,EAAK4wD,sBAC1B,GAAI5wD,EAAK6wD,WAAW18D,GAAY,CAC5B,IAAK,MAAM9X,KAAU2jB,EAAKme,QAAS,CAC/B,MAAM2yC,EAAmB,EAAA3mC,iBAAiB3uC,IAAIa,GAC9C,IAAKkB,KAAKwzE,kBAAkB/wD,EAAM3jB,EAAQy0E,GACtC,SAEJz0E,EAAOiP,SAASuB,KAAKmT,EAAKxF,aACEjb,IAAxBlD,EAAO20E,cACP30E,EAAOiP,SAAS5N,IAAIrB,EAAO20E,cAE/B30E,EAAOiP,SAAStI,GAAK2tE,EACrBt0E,EAAOiP,SAAS+E,IAAI9S,KAAKw5B,SAASzrB,UAC9B0U,EAAKvN,mBACLpW,EAAO40E,sBAAsBjxD,EAAK0f,YAAYwxC,qBAElD70E,EAAO+yD,eAAgB,OACW7vD,IAA9BlD,EAAO80E,qBACP90E,EAAO80E,mBAAqB90E,EAAOwnB,aAGvC,MAAMutD,EAAmC,QAAzB,EAAGN,aAAgB,EAAhBA,EAAkBxmC,YAAI,eAAE+mC,SAAS,EAAAC,aAAaC,UAajEl1E,EAAOwnB,YACHxnB,EAAO80E,qBACLC,GAAcpxD,EAAKye,YAAc,EAC7B,EAAA86B,6BAA+Bv5C,EAAKye,YACpC,GAEVlhC,KAAKmgE,YAAYhgE,IAAIrB,GAEzB2jB,EAAKwxD,aASL,kBAAkBxxD,EAAY3jB,EAAoBy0E,GACtD,QAAKz0E,EAAOsnB,YAGPpmB,KAAKk0E,0BAA0BzxD,EAAM3jB,MAItCy0E,IACAA,EAAiBnmC,cAAcptC,OAC1BuzE,EAAiBxI,eActB,0BAA0BtoD,EAAY3jB,GAC1C,MAAMwtB,EAA8BxtB,EAAOgjB,SAASwK,UAEpD,IAAKA,QAAmCtqB,IAAtBsqB,EAAUtN,QAExB,OAAO,EAGX,MAAM+C,EAA2BjjB,EAAOgjB,SAASC,QAEjD,IAAKA,IAAY,EAAAvgB,KAAKuG,OAAOukB,EAAUtN,SACnC,OAAOm1D,QAAQ,EAAAjnD,iBAAiBZ,EAAUtN,QAAShf,KAAK6hE,QAG5D,MAAM,OAAEphC,EAAM,SAAEC,GAAa3e,EAE7B,IAAK3gB,MAAMC,QAAQq/B,KAAct/B,MAAMC,QAAQo/B,GAG3C,OAAO,EAGX,MAAMvmB,EAA8Cpb,EAAeob,SAEnE,IAAKA,IAAaA,EAASk6D,iBAGvB,OAAO,EAGX,MAAM15D,EAAQR,EAASm6D,WAOvB,IAAIC,EA6CJ,OAjDAp6D,EAASq6D,cAMT7zC,EAASrgC,QAAQ,CAACX,EAAY80E,K,MAE1B,MAAM1uD,EAAY,EAAA2uD,aAAa/0E,GAE/B,IAAIsf,GAAU,EAEd,GAAI,EAAAxd,KAAKuG,OAAOukB,EAAUtN,SAAU,CAEhC,MAAMve,EAAegiB,EAAKke,WAAW+zC,gBAAgB5uD,GAI/C6uD,EAASl0E,EAAe,IAAI,EAAAqhE,OAAOrhE,GAAgB,KAEnDm0E,EACoB,iBAAfl1E,EACD,IAAI,EAAAoiE,OAAOpiE,EAAYM,KAAK6hE,OAC5B7hE,KAAK6hE,MAETz/D,EAAM,IAAI,EAAA0/D,OAAO,CAAE6S,UAAUC,GAEnC51D,EAAUm1D,QAAQ,EAAAjnD,iBAAiBZ,EAAUtN,QAAS5c,IAG1D,IAAK4c,EAED,OAGJ,MAAM+qB,EAAQtJ,EAAO+zC,GAEfz6D,GAD8B,QAA3B,EAAG0mB,EAAO+zC,EAAe,UAAE,QAAI95D,EAAMX,OAC1BgwB,EAEhBA,IAAUuqC,EAEVp6D,EAAS0oB,OAAO1oB,EAAS0oB,OAAOthC,OAAS,GAAGyY,OAASA,EAErDG,EAAS26D,SAAS9qC,EAAOhwB,GAG7Bu6D,EAAiBvqC,EAAQhwB,IAGtBG,EAAS0oB,OAAOthC,OAAS,EAG5B,0BAA0BmwC,QAImBzvC,IAAvBhC,KAAKmoE,eAM/BnoE,KAAKinE,uBAAuB6N,UAAU90E,KAAKgmE,eAAexjD,mBAAoBivB,GAG1E,gCACiDzvC,IAAvBhC,KAAKmoE,gBAI/BnoE,KAAKq/D,eAAe1gD,IAAM3e,KAAK8/D,aAAa7V,QAC5CjqD,KAAKinE,uBAAuB8N,WAAW/0E,KAAKq/D,iBAI5C,YACJ,MAAMX,EAAQ,EAAAkQ,eAAe5uE,KAAK2wC,UAAU+tB,MAAOZ,GAAgBY,OAEnE1+D,KAAKkhE,kBAAmB,EACxBjpB,QAAQqzB,QAAwB5M,GAE3B15B,KAAK05B,GAAS,EAAAiK,YAAYx2C,KAAKusC,EAAO,CAAE6D,YAAaviE,KAAKsiE,iBAE1Dt9B,KAAK05B,IACF1+D,KAAKkhE,kBAAmB,EACxBlhE,KAAK0+D,MAAQA,IAEhBv5B,MAAM5mB,IACHve,KAAKkhE,kBAAmB,EACxB,MAAM8T,EAC8B,iBAAzBh1E,KAAK2wC,UAAU+tB,MAAqB,SAAS1+D,KAAK2wC,UAAU+tB,QAAU,GACjFlyD,EAAO+R,MAAM,uBAAuBy2D,MAAcz2D,IAASA,KAI/D,cACJ,MAAM,MAAE9G,EAAK,OAAEvG,GAAWlR,KAAK4kE,sBAE/B5kE,KAAKyqE,qBAAqBv5D,GAC1BlR,KAAKgmE,eAAiBhmE,KAAKimE,uBAE3BjmE,KAAK2wC,UAAUpiC,OAAS,EAAArG,eAAeqU,WACnC,EAAAqyD,eAAe5uE,KAAK2wC,UAAUpiC,OAAQuvD,GAAgBvvD,SAGzDvO,KAAK2wC,UAAUpiC,OAA0BlG,SAAW,EACrDrI,KAAK2wC,UAAUhiC,KAAO,EAAAigE,eAAe5uE,KAAK2wC,UAAUhiC,KAAMmvD,GAAgBnvD,MAE1E3O,KAAK2wC,UAAU/hC,QAAU,EAAAggE,eAAe5uE,KAAK2wC,UAAU/hC,QAASkvD,GAAgBlvD,SAEhF5O,KAAK2wC,UAAU/5B,UAAY,EAAAg4D,eACvB5uE,KAAK2wC,UAAU/5B,UACfknD,GAAgBlnD,WAGpB5W,KAAKuqE,WAAWvqE,KAAK2wC,WAGrB3wC,KAAKi1E,OAAOx9D,EAAOvG,GAEnBlR,KAAKq/D,eAAetxD,SAASnI,EAAI,EACjC5F,KAAKq/D,eAAe3gD,KAAO,EAGvB,uBACJ,MAAMonD,OACwB9jE,IAA1BhC,KAAK+lE,iBACC/lE,KAAKmP,WAAWS,OAAS,EAAAC,eAAee,UACxC5Q,KAAK+lE,iBAEf,OAAO,IAAI,EAAAmP,eACP,IAAI,EAAAC,oBACAn1E,KAAKw5B,SACLx5B,KACAA,KAAK4iE,wBAAwB3E,uBAC7Bj+D,KAAKg/D,sBACL8G,GAEJ9lE,KAAK4lE,sBACL5lE,KAAK4iE,yBAIL,sBACJ,QAAqB5gE,IAAjBhC,KAAK6vC,QACL,OAEJ,MAAM6uB,EAAQ1+D,KAAK6vC,QACnB,GAAI7vC,KAAK4yE,2BAA2B,EAAAwC,oBAA+BpzE,IAAd08D,EAAMoK,IAEvD9oE,KAAKq1E,0BAA0B3W,EAAMoK,IAAKpK,EAAM0D,gBAC7C,SAA6BpgE,IAAzBhC,KAAK4yE,sBAA+C5wE,IAAd08D,EAAMoK,IAGnD,YADA9oE,KAAKs1E,oBAAoB5W,EAAMoK,IAAKpK,EAAM0D,YAEnCpiE,KAAK4yE,2BAA2B,EAAAwC,oBAA+BpzE,IAAd08D,EAAMoK,KAE9D9oE,KAAKu1E,uBAIL,oBAAoBzM,EAAU1G,GACjB,aAAb0G,EAAIl5D,WAA4D5N,IAApC8mE,EAAoB0M,cAChD1M,EAAI0M,YAAc,EAAA5G,eAAexM,EAAY,YAEjDpiE,KAAK4yE,gBAAkB,IAAI,EAAAwC,cAActM,EAAK9oE,KAAKmP,WAAWS,KAAM5P,KAAKw5B,UACzEx5B,KAAK+/D,QAAQ0V,WAAaz1E,KAAK4yE,gBAAgBz7D,QAG3C,sBACJnX,KAAK+/D,QAAQ0V,WAAa,UACGzzE,IAAzBhC,KAAK4yE,kBACL5yE,KAAK4yE,gBAAgBntC,UACrBzlC,KAAK4yE,qBAAkB5wE,GAIvB,0BAA0B8mE,EAAU1G,GACvB,aAAb0G,EAAIl5D,WAA4D5N,IAApC8mE,EAAoB0M,cAChD1M,EAAI0M,YAAc,EAAA5G,eAAexM,EAAY,iBAEpBpgE,IAAzBhC,KAAK4yE,iBACL5yE,KAAK4yE,gBAAgB8C,cAAc5M,EAAK9oE,KAAKmP,WAAWS,MAIxD,iB,MACJ,IAAK5P,KAAK6vC,QACN,OAGJ,MAAM6uB,EAAQ1+D,KAAK6vC,aACM7tC,IAArB08D,EAAM0D,YACNpiE,KAAKmiE,WAAWE,cAAc,IAAIjjE,EAAMsqB,MAAMg1C,EAAM0D,aAGpDpiE,KAAKmnE,iBACLnnE,KAAKmnE,gBAAgB9mE,QAASs1E,IAC1B31E,KAAK+/D,QAAQ18B,OAAOsyC,KAID,QAA3B,EAAA31E,KAAK41E,8BAAsB,SAAEv1E,QAAQs1E,IACjC31E,KAAKggE,eAAe38B,OAAOsyC,GACvBA,aAAiBv2E,EAAMy2E,kBACvB71E,KAAKggE,eAAe38B,OAAOsyC,EAAMpnE,eAIpBvM,IAAjB08D,EAAMqK,SACN/oE,KAAKmnE,gBAAkB,GACvBnnE,KAAK41E,uBAAyB,GAE9BlX,EAAMqK,OAAO1oE,QAASy1E,IAClB,MAAMH,EAAQ,EAAAI,YAAYD,GAC1B,IAAKH,EAKD,YAJAnpE,EAAOuJ,KAEH,mCAAmC+/D,EAAiBn4E,gBAAgBm4E,EAAiBlmE,QAM7F,GAFA5P,KAAK+/D,QAAQ5/D,IAAIw1E,GAEZA,EAActF,mBAAoB,CACnC,MAAMD,EAAmBuF,EAGzB31E,KAAK+/D,QAAQ5/D,IAAIiwE,EAAiB7hE,QAEtCvO,KAAKmnE,gBAAiBjhE,KAAKyvE,GAE3B,MAAMK,EAA2BL,EAAM9oE,QACvC7M,KAAKggE,eAAe7/D,IAAI61E,GACpBA,aAAuB52E,EAAMy2E,kBAC7B71E,KAAKggE,eAAe7/D,IAAI61E,EAAYznE,OAAO1B,YAMnD,kBACJ7M,KAAKinE,uBAAuB5B,kBAE5BpI,EAAuBxrB,KAAOm4B,KAAK1hC,MACnCloC,KAAKiiE,cAAchF,GAGf,mBACJj9D,KAAKinE,uBAAuB3B,mBAE5BnI,EAAwB1rB,KAAOm4B,KAAK1hC,MACpCloC,KAAKiiE,cAAc9E,GAGdn9D,KAAKqsE,iBACuCrqE,IAAzChC,KAAKqnE,iCACLC,aAAatnE,KAAKqnE,iCAEtBrnE,KAAKqnE,gCAAkC4O,WAAW,KAC9Cj2E,KAAKqnE,qCAAkCrlE,EACvChC,KAAKqyC,UACN,IAWH,sBACJ,QAAqCrwC,IAAjChC,KAAK6xE,wBACL,OAAO7xE,KAAK6xE,wBAEhB,MAAMQ,EAAaryE,KAAKgmE,eAAexjD,mBAEjC0zD,EAAuB,GAE7BA,EAAW50E,OAAS,EAEpB+wE,EAAWhyE,QAAQ,EAAGsgC,aAAYgR,oBAC9BA,EAActxC,QAAQoiB,IAClByzD,EAAWhwE,KAAKy6B,EAAWhjC,KAAO,IAAM8kB,EAAKmB,QAAQO,kBAI7D+xD,EAAWttC,OAEX,MAAMutC,EAAaD,EAAWE,KAAK,KASnC,OAPID,IAAen2E,KAAK2hE,eACpB3hE,KAAK2hE,cAAgBwU,EACrBn2E,KAAK6xE,yBAA0B,GAE/B7xE,KAAK6xE,yBAA0B,EAG5B7xE,KAAK6xE,wBAGR,wBACJ,IAAK7xE,KAAKq2E,sBACN,OAGJ,MAAMC,EAAmBt2E,KAAKu2E,gCAC9B,GAAID,IAAqBt2E,KAAK4hE,gBAA9B,CAGA,GAAI0U,EAAiBh1E,SAAWtB,KAAK4hE,gBAAgBtgE,OAAQ,CACzD,IAAIk1E,GAAW,EACf,IAAK,IAAIp5E,EAAI,EAAGA,EAAIk5E,EAAiBh1E,OAAQlE,IAAK,CAC9C,MAAMoM,EAAI8sE,EAAiBl5E,GACrBsM,EAAI1J,KAAK4hE,gBAAgBxkE,GAC/B,GAAIoM,EAAExD,QAAU0D,EAAE1D,MAAO,CACrBwwE,GAAW,EACX,OAGR,GAAIA,EACA,OAGRx2E,KAAK4hE,gBAAkB0U,EACvBt2E,KAAKiiE,cAAcxE,KAGf,gCACJ,IAAIt3D,EAA0B,GAC9B,IAAK,MAAMmc,KAAYtiB,KAAKgmE,eAAexjD,mBACvC,IAAK,MAAMC,KAAQH,EAASqvB,cAAchS,SAAU,CAChD,MAAM82C,EAAoBh0D,EAAK+hB,mBACLxiC,IAAtBy0E,GAAgE,IAA7BA,EAAkBn1E,SAGzD6E,EAAS,EAAAuwE,cAAcC,YAAYxwE,EAAQswE,IAGnD,OAAOtwE,EAGH,eACJ,IAAKnG,KAAK6vC,QACN,OAGJ,MAAM6uB,EAAQ1+D,KAAK6vC,QAKnB,GAHA7vC,KAAKshE,aAAat7B,QAClBhmC,KAAK42E,WAAW5wC,aAEKhkC,IAAjB08D,EAAMuK,OACN,IAAK,MAAMtrE,KAAQG,OAAO89D,KAAK8C,EAAMuK,QAAS,CAC1C,MAAM3xD,EAAQonD,EAAMuK,OAAOtrE,GAC3BqC,KAAKshE,aAAauV,SAASl5E,EAAM2Z,EAAMmsC,KAAuB,IAAlBnsC,EAAMw/D,SACvB,iBAAhBx/D,EAAMy/D,OACb/2E,KAAK42E,WAAWI,gBAAgBr5E,EAAM2Z,EAAMy/D,YAK5B/0E,IAAxB08D,EAAMwK,eACNxK,EAAMwK,cAAc7oE,QAAS8lD,IACzBnmD,KAAK42E,WAAWK,gBAAgB9wB,KAKpC,qBACiBnkD,IAAjBhC,KAAK6vC,UAIT7vC,KAAKijB,gBAAgB+iB,QAGrBhmC,KAAKijB,gBACAmmD,cAAcppE,KAAK6vC,SACnB7K,KAAK,IAAMhlC,KAAKqyC,UAChBlN,MAAM,IAAMnlC,KAAKqyC,WAGlB,WAAW6kC,GAEf,IAAI,EAAA/yC,sBAAsB+yC,EAAQ,KAG9B,gB,MACJl3E,KAAKmiE,WAAWE,cAvxHI,UAyxHpBriE,KAAK+/D,QAAQ5/D,IAAIH,KAAKmgE,aACtBngE,KAAKggE,eAAe7/D,IAAIH,KAAKogE,oBAE7BpgE,KAAKusB,eAA6C,QAA/B,EAAGvsB,KAAK2wC,UAAU69B,qBAAa,SAG9C,qBAKJ,OAAO,IAAI,EAAA2I,qBACP,IAAI,EAAAC,aAAap3E,KAAMA,KAAKq2E,oBAAoBz3E,KAAKoB,OACrDA,KAAKw5B,SANkC,KACvCx5B,KAAKqyC,UAOLryC,KAAKuvC,mBACLvvC,KAAKwvC,kBACL,IAAI,EAAA6nC,kBAAkBr3E,KAAKmiE,YAC3BniE,KAAK0vC,aACL,IAAI,EAAA4nC,mBAAmBt3E,MACvB,IAAI,EAAAu3E,kBAAkBv3E,KAAK6vC,SAC3B7vC,KAAK6vC,QACL7vC,KAAK2wC,WAIL,oBACJ,MAAM6mC,EAAcx3E,KAAKinE,uBAAuBuQ,YAChDx3E,KAAKinE,uBAAyBjnE,KAAKknE,0BACfllE,IAAhBw1E,GACAx3E,KAAKinE,uBAAuB2E,eAAe4L,GAgC3C,SAASjlE,EAAaE,GAC1BF,EAAMnT,EAAMkJ,UAAU6B,MAAMoI,EAn1HV,GADA,KAs1HlB,IAAIiO,EAAOphB,EAAMkJ,UAAUC,SACvB,EAAAyF,aAAa0S,oCAAoCthB,EAAMkJ,UAAUW,SAASsJ,GAAME,IAYpF,OATI+N,EA11Hc,KA01HcA,EAz1Hd,MA01HdA,EAAOphB,EAAMkJ,UAAU6B,MAAMqW,EA11Hf,GADA,KA41HdjO,EAAMnT,EAAMkJ,UAAUC,SAClB,EAAAyF,aAAauS,oCACTnhB,EAAMkJ,UAAUW,SAASuX,GACzB/N,KAILF,EAQH,eAAeoyD,EAAgCzzD,GACnD,IAAIqB,EAAM,EACkB,UAAxBoyD,EAAe/0D,MACf5P,KAAKyqE,qBAAqBv5D,GAC1BqB,EAAMoyD,EAAepyD,MAErB,EAAAjG,OAA8B,IAAvBtM,KAAK0/D,eACZntD,EAAM,EAAAvE,aAAa6S,0BAA0B7gB,KAAK0/D,cAAexuD,IAErElR,KAAKw5B,SAASjnB,IAAMvS,KAAKy3E,SAASllE,EAAKvS,KAAKw5B,SAAS/mB,QAWjD,qBAAqBvB,GACzB,EAAA5E,YAAyCtK,IAAlChC,KAAK2wC,UAAUg0B,gBACtB3kE,KAAK0/D,cAAgB,EAAA1xD,aAAa4S,kCAC9BxhB,EAAMkJ,UAAUW,SAASjJ,KAAK2wC,UAAUg0B,eAAgBpyD,KACxDrB,GAUA,sBACJ,MAAM,YAAEwmE,EAAW,aAAEC,GAAiB33E,KAAKwuC,OAC3C,GACoB,IAAhBkpC,GACiB,IAAjBC,GACuB,iBAAhBD,GACiB,iBAAjBC,EACT,CACE,MAAMnZ,EAAax+D,KAAKmiE,WAAWsK,gBACnC,MAAO,CACHh1D,MAAOpO,KAAKggC,MAAMrpC,KAAKwuC,OAAO/2B,MAAQ+mD,GACtCttD,OAAQ7H,KAAKggC,MAAMrpC,KAAKwuC,OAAOt9B,OAASstD,IAG5C,MAAO,CAAE/mD,MAAOigE,EAAaxmE,OAAQymE,IAn0GjD,c,kGC3tBA,cAEA,OACA,OAIMnrE,EAAS,EAAAC,cAAcxM,SAASvB,OAAO,cACvCk5E,EAAe,CAAEhoE,KAAM,UA8D7B,kBAAsBioE,UAAmBz4E,EAAMw/D,gBAyF3C,YAAY3oD,EAA6B,IACrCjT,QAhFJ,KAAAgc,SAAmB,EAKnB,KAAA84D,WAAqB,EAKrB,KAAAC,mBAA6B,EAa7B,KAAAC,gBAA0B,EAK1B,KAAAC,aAAuB,EAKvB,KAAAC,aAAuB,GAKvB,KAAAC,gBAA0B,EAK1B,KAAAC,gBAA0B,GAE1B,KAAAC,uBAAiC,EAKxB,KAAAC,SAAW,IAAI,EAAAC,SAehB,KAAA30C,oBAAsB,EAKtB,KAAA40C,qBAA+B,EAEtB,KAAAC,kBAAoB,IAAIt2E,IASrC,IAAI,KAAExE,GAASsY,EACf,MAAM,aACFswD,EAAY,aAEZxmD,EAAY,aAEZC,EAAY,aACZi4D,EAAY,aACZC,EAAY,gBACZC,EAAe,gBACfC,EAAe,mBACfM,EAAkB,sBAClBL,GACApiE,OACSjU,IAATrE,GAAsC,IAAhBA,EAAK2D,SAC3B3D,EAAO,0BAA0Bk6E,EAAWc,qBAEhD34E,KAAKrC,KAAOA,EAEZqC,KAAKumE,aAAeA,OAECvkE,IAAjBi2E,IACAj4E,KAAKi4E,aAAeA,QAEHj2E,IAAjBk2E,IACAl4E,KAAKk4E,aAAeA,QAEHl2E,IAAjB+d,IAEA/f,KAAK+f,aAAeA,QAEH/d,IAAjBge,IAEAhgB,KAAKggB,aAAeA,QAEAhe,IAApBm2E,IACAn4E,KAAKm4E,gBAAkBA,QAEHn2E,IAApBo2E,IACAp4E,KAAKo4E,gBAAkBA,QAEAp2E,IAAvB02E,IACA14E,KAAKw4E,qBAAuBE,QAEF12E,IAA1Bq2E,IACAr4E,KAAKq4E,sBAAwBA,GASrC,gBAAgBvyD,GACZ,OAAO9lB,KAAKy4E,kBAAkBx6E,IAAI6nB,GAMtC,oBACI9lB,KAAKy4E,kBAAkBzyC,QAa3B,gBAAgBlgB,EAAmBi4B,GAC/B/9C,KAAKy4E,kBAAkBzxE,IAAI8e,EAAWi4B,GAQ1C,mBAAmBj4B,GACf9lB,KAAKy4E,kBAAkB1xE,OAAO+e,GAMlC,mBACI,OAAO9lB,KAAK44E,eAUhB,iBAAiBrS,GACbvmE,KAAK44E,eAAiBrS,OACCvkE,IAAnBhC,KAAK64E,gBAA4C72E,IAAjBukE,GAChCvmE,KAAK2pE,SAAS3pE,KAAK64E,UAAUna,OAOrC,WAOA,cAYA,kBACI,OAAO1+D,KAAKg4E,eAQhB,QACI,OAAO,EAMX,cACI,QAAuBh2E,IAAnBhC,KAAK64E,UACL,MAAM,IAAIp1E,MAAM,4CAGpB,OAAOzD,KAAK64E,UAWhB,iBACI,OAAO74E,KAAKkO,QAAQiB,WAQxB,iBAgBA,OAAOjB,GACHlO,KAAK64E,UAAY3qE,EAUrB,OAAOA,GACH,EAAA5B,OAAOtM,KAAK64E,YAAc3qE,GAC1BlO,KAAK64E,eAAY72E,EAgBrB,YAAY82E,EAAqBj3E,EAA2ByhB,IAY5D,SAASo7C,EAAcp7C,IAUvB,aAAaA,IAWb,iBAAiBwmD,IAoBjB,WAAWrnD,IAWX,qBACI,OAAO,EAQX,mBAII,OAHAjW,EAAOuJ,KACH,qFAEG/V,KAAKi4E,aAGhB,iBAAiBr8D,GACbpP,EAAOuJ,KACH,wFAEJ/V,KAAKi4E,aAAer8D,EAQxB,mBAII,OAHApP,EAAOuJ,KACH,wFAEG/V,KAAKk4E,aAGhB,iBAAiBt8D,GACbpP,EAAOuJ,KACH,wFAEJ/V,KAAKk4E,aAAet8D,EAWxB,wBACI,OAAO5b,KAAK4jC,oBAEhB,sBAAsBvlC,GAClB2B,KAAK4jC,oBAAsBvlC,EAW/B,yBACI,OAAO2B,KAAKw4E,qBAQhB,uBAAuBt3C,GACnBlhC,KAAKw4E,qBAAuBt3C,EAShC,0BAA0Bg2C,IAU1B,iBAAiBtgE,GACb,OAAOxX,EAAMkJ,UAAU6B,MACnByM,EAAY5W,KAAKw4E,qBACjBx4E,KAAKi4E,aACLj4E,KAAKk4E,cAQb,UAAUthE,GACN,OAAOA,GAAa5W,KAAKm4E,iBAAmBvhE,GAAa5W,KAAKo4E,gBAWlE,WAAWxhE,EAAmBgN,GAC1B,OAAOA,EAAQhI,OAAShF,EAa5B,gBAAgBA,EAAmBgN,GAC/B,OAAOA,EAAQhI,OAAShF,EAkB5B,iBAAiBA,EAAmBgN,GAChC,OAAO,EAMX,gBACI5jB,KAAKiiE,cAAc2V,IAE3B,OAhhBmB,EAAAe,kBAA4B,EAghB/C,GArhBA,GAAsB,EAAAd,c,2GCvEtB,aA+CA,SAIA,SACA,OACA,OAaA,OACA,OACA,OACA,QAQA,SAMA,QACA,QACA,QAEA,SACA,QACA,QAEA,QAEMrrE,EAAS,EAAAC,cAAcxM,SAASvB,OAAO,uBAEvCq6E,EAAa,IAAI35E,EAAMuG,QACvBqzE,EAAa,IAAI55E,EAAMoG,QAE7B,MAAMyzE,EAAN,cACa,KAAAC,iBAAmB,IAAI/2E,IAEvB,KAAAg3E,sBAAwB,IAAIh3E,KAMzC,MAAMi3E,UAAqB,EAAAh1E,SAKvB,YAAYvE,GACRmD,MAAM,OAAQ,CAACnD,IAJF,KAAAw5E,mBAA+C,GAK5Dr5E,KAAKs5E,OAASl4E,MAAM6I,KAAKpK,EAAKC,eAAeJ,YAC7CM,KAAKsE,WAAatE,KAGtB,KAAKE,GACD,IAAIojC,GAAU,EAgBd,OAdAtjC,KAAKs5E,OAAOj5E,QAAQ,CAAC3C,EAAGN,KACpB,MAAMm8E,EAAWr5E,EAAQkC,IAAI6qB,OAAOvvB,GAC/B4lC,GAAWi2C,IAAav5E,KAAKq5E,mBAAmBj8E,KACjDkmC,GAAU,GAEVA,IACAtjC,KAAKq5E,mBAAmBj8E,GAAKm8E,MAIjCj2C,QAAkCthC,IAAvBhC,KAAKw5E,iBAChBx5E,KAAKw5E,cAAgBt5E,EAAQu5E,SAASz5E,KAAKI,KAAK,KAG7CJ,KAAKw5E,eAIpB,MAAME,EACF,YACax/D,EACAm6C,EACAnyD,GAFA,KAAAgY,WACA,KAAAm6C,OACA,KAAAnyD,QAGb,mBAAmBy3E,GACf,GAAI35E,KAAKkC,MAAMg3E,iBAAiB3yE,IAAIozE,GAChC,OAAO35E,KAAKkC,MAAMg3E,iBAAiBj7E,IAAI07E,GAE3C,MAAMrgE,EAAY,EAAAsgE,mBAAmBD,GAErC,OADA35E,KAAKkC,MAAMg3E,iBAAiBlyE,IAAI2yE,EAAargE,GACtCA,EAGX,+BAA+BqgE,GAC3B,MAAMR,EAAwBn5E,KAAKkC,MAAMi3E,sBAAsBl7E,IAAI07E,GAEnE,GAAIR,EACA,OAAOA,EAGX,MACMzoD,EAAS,IADG,EAAAmpD,oBAAoBF,EAAY/pE,MACnC,CAAc+pE,EAAYjpD,QACnCopD,EAAoB,IAAI16E,EAAM4xD,kBAAkBtgC,EAAQipD,EAAYI,QAEpEC,EAAQL,EAAYl/D,WAAW1U,IAAIk0E,IACrC,MAAM3gE,EAAY,IAAIla,EAAMya,2BACxBigE,EACAG,EAAgBjgE,SAChBigE,EAAgBp2D,QAChB,GAGJ,MAAO,CAAElmB,KADIs8E,EAAgBt8E,KACd2b,eAInB,OADAtZ,KAAKkC,MAAMi3E,sBAAsBnyE,IAAI2yE,EAAaK,GAC3CA,GAIf,SAASE,EACLzvE,EACA0vE,GAEA,GAAI/4E,MAAMC,QAAQoJ,GAAW,CACzB,MAAMkX,EAAYlX,EAClB0vE,EAAkBj0E,QAAQyb,QAE1Bw4D,EAAkBj0E,KAAKuE,GAyB/B,MAAa2vE,EAeT,eAPA,sBACI,OAAOp6E,KAAKurC,aAAevrC,KAAKurC,WAAa,IAAI6uC,GAoBrD,gBACIv2C,EACAw2C,EACAC,GAEA,IAAK,MAAMhuD,KAAauX,EAAY02C,WAAY,CAE5C,MAAMxtC,EAAOzgB,EAAUygB,UAGV/qC,IAAT+qC,GAAuBA,aAAgBptC,KAAqB,IAAdotC,EAAK3rB,KACnDkL,EAAUkuD,YAAa,EAM3BluD,EAAUkuD,kBACcx4E,IAAlBs4E,GAA+BA,EAAc/jC,gBAAgBxJ,UAC7C/qC,IAAjBq4E,GAA8BA,EAAa9jC,gBAAgBxJ,GAGpE,IAAK,MAAM0tC,KAAe52C,EAAYjiB,WAClC,IAAK,MAAM+gB,KAAS83C,EAAY73C,OAC5BD,EAAM+3C,eAAiB,GAcnC,oBAAoBj4D,EAAYohB,GAC5B,MAAMrR,EAAUlG,IACoB,IAAzBA,EAAUkuD,WAGrBx6E,KAAK26E,cAAcl4D,EAAMohB,EAAarR,GAEtCxyB,KAAK46E,YAAYn4D,EAAMohB,GAcvB7jC,KAAK66E,mBAAmBp4D,EAAMohB,EAVVvX,MAEX,EAAAwuD,eAAexuD,IACf,EAAAyuD,sBAAsBzuD,IACtB,EAAA0uD,gBAAgB1uD,KAIdkG,EAAOlG,IAIlBtsB,KAAKi7E,6BAA6Bx4D,EAAMohB,GAGpCphB,EAAKke,WAAWq3C,gBAAkBv1D,EAAKtT,WAAWS,OAAS,EAAAC,eAAeC,QAS1EsqE,EAAoBn6E,SAAS+3E,eAAev1D,GAAO,EAAAu5C,6BAA+B,GAI1F,6BAA6Bv5C,EAAYohB,GACrC,QAAmC7hC,IAA/B6hC,EAAYq3C,eAGhB,IAAK,MAAMh0D,KAAQ2c,EAAYq3C,eAC3Bz4D,EAAK04D,mBAAmB,IAAI,EAAAC,oBAAoBl0D,EAAKA,OAY7D,kBACIzE,EACA43D,EACAC,GAEA,MAAMz2C,EAAcphB,EAAKohB,YAEzB,QAAoB7hC,IAAhB6hC,EACA,OAGJ7jC,KAAKq7E,kBAAkB54D,GAKvBziB,KAAKs7E,gBAAgBz3C,EAAaw2C,EAAcC,GAGhD,MAAMhC,EAAW71D,EAAKke,WAAW23C,SACjCz0C,EAAY02C,WAAWl6E,QAASisB,IAC5B,IAAK,MAAMmG,KAAgBnG,EAAW,CAClC,IAAKA,EAAUrtB,eAAewzB,GAC1B,SAEJ,MAAMp0B,EAAQiuB,EAAUmG,GACxB,GAAI,EAAAvxB,WAAW7C,IAA2B,SAAjBo0B,EAErB,IACI,IAAI5yB,EAAO,EAAA2B,KAAKmF,SAAStI,IACY,IAAjCwB,EAAKC,eAAeU,WACpBX,EAAO,IAAIu5E,EAAa,EAAA53E,KAAKmF,SAAStI,KAE1CiuB,EAAUmG,GAAgB5yB,EAAK07E,OAAOjD,GACxC,MAAO/5D,GACL/R,EAAO+R,MAAM,gCAAiCA,OAkBlE,mBACIkE,EACA3jB,EACA08E,EACAC,GAEA,MAAM1uC,EACFyuC,aAAwB77E,IAClByB,MAAM6I,KAAMuxE,EAAiC77C,UAC7Cv+B,MAAMC,QAAQm6E,GACdA,EACA,CAACA,GAEX,EAAA5uC,iBAAiBluC,OAAOI,EAAQ,OAAF,QAC1BiuC,QACG0uC,SAIiBz5E,IAApBlD,EAAOgjB,WACPhjB,EAAOgjB,SAAW,IAGtB,MAAMA,EAAWhjB,EAAOgjB,SACxBA,EAAS8B,QAAUnB,EAAKmB,QACxB9B,EAAS6e,WAAale,EAAKke,WAAWhjC,KAEtCmkB,EAASirB,KAAOA,EAGhBtqB,EAAKi5D,yBAWT,iBACIC,EACA93C,EACA+3C,GAEA,MAAMC,EAAiB,IAAIz6E,MACrB06E,EAAWH,EAAmBr1E,QAEpC,KAAOw1E,EAASx6E,OAAS,GAAG,CACxB,MAAM87C,EAAW0+B,EAASC,MAE1B,QAAiB/5E,IAAbo7C,EACA,MAGJ,MAAM9wB,EAAYuX,EAAY02C,WAAWn9B,EAAS9wB,WAE7C,EAAA0uD,gBAAgB1uD,UACDtqB,IAAf45E,GAA6BA,EAAWtvD,KAK7CuvD,EAAe31E,KAAKk3C,GAExB,OAAOy+B,EAYX,mBACIp5D,EACAohB,EACA+3C,GAEA,MAAM1tE,EAAUuU,EAAKvU,QACf8tE,EAAiBv5D,EAAKu5D,eACtB5I,EAAe3wD,EAAK4wD,sBAEpB4I,EAAoB5yE,KAAKmtB,MAAMtoB,EAAQ0I,WACvCslE,EAAkB,IAAI,EAAApa,OAAO,CAAE6N,MAAOsM,GAAqB/tE,EAAQ9L,KAEzE,QAAuCJ,IAAnC6hC,EAAY83C,mBAAkC,CAC9C,MAAMA,EAAqB37E,KAAKm8E,iBAC5Bt4C,EAAY83C,mBACZ93C,EACA+3C,GAGJ,IAAK,MAAMx+B,KAAYu+B,EAAoB,CACvC,MAAMrvD,EAAYuX,EAAY02C,WAAWn9B,EAAS9wB,WAElD,IAC6B,IAAzBA,EAAUkuD,aACT,EAAAQ,gBAAgB1uD,SACDtqB,IAAf45E,IAA6BA,EAAWtvD,GAEzC,SAGJ,MAAMpF,EAAwB,GAC9B,IAAK,IAAI9pB,EAAI,EAAGA,EAAIggD,EAASl2B,KAAK5lB,OAAQlE,GAAK,EAC3C8pB,EAAKhhB,KACD,IAAI9G,EAAMuG,QACNy3C,EAASl2B,KAAK9pB,GAAKg2E,EACnBh2B,EAASl2B,KAAK9pB,EAAI,GAClBggD,EAASl2B,KAAK9pB,EAAI,KAM9B,MAAMuoB,OACqB3jB,IAAvBsqB,EAAU3G,SACJ,EAAAuH,iBAAiBZ,EAAU3G,SAAUu2D,GACrC,EACJl2D,OACqBhkB,IAAvBsqB,EAAUtG,SACJ,EAAAkH,iBAAiBZ,EAAUtG,SAAUk2D,GACrC5vD,EAAUtG,SACdC,OACoBjkB,IAAtBsqB,EAAUrG,QACJ,EAAAiH,iBAAiBZ,EAAUrG,QAASi2D,GACpC5vD,EAAUrG,QACdnE,EAAWs7B,EAAS1c,SACpB5a,EAAY,EAAA2uD,aAAa3yD,GACzBghB,EAAc,IAAI,EAAAvd,YACpB,EAAA62D,0BAA0Bn8E,SAASo8E,QAAQj/B,EAAS53B,MACpD0B,EACA80D,EAAeM,eAAehwD,GAC9B0vD,EAAeO,eAAejwD,GAC9B3G,OACsB3jB,IAAtBsqB,EAAU1G,QAAwB0G,EAAU1G,QAAU,OAChC5jB,IAAtBsqB,EAAUzG,QAAwByG,EAAUzG,QAAU,EACtDC,EACAwG,EAAUvG,MACVC,EACAC,EACAxD,EAAKoB,QAETif,EAAY05C,cAAgBp/B,EAASo/B,cACrC15C,EAAY/iB,kBACmB/d,IAA3BsqB,EAAUvM,aACJuM,EAAUvM,aACV7R,EAAQ6R,aAClB+iB,EAAY9iB,kBACmBhe,IAA3BsqB,EAAUtM,aACJsM,EAAUtM,aACV9R,EAAQ8R,aAClB8iB,EAAYzc,mBACoBrkB,IAA5BsqB,EAAUjG,cACJiG,EAAUjG,cACV,EAAAknB,4BACVzK,EAAY/b,YAAsC,IAAzBuF,EAAUvF,WACnC+b,EAAY9b,cAA0C,IAA3BsF,EAAUtF,aAErC8b,EAAYiK,KAAOzgB,EAAUygB,KAE7BjK,EAAYhhB,SAAWs7B,EAAS1c,SAChCoC,EAAY4iB,aAAep5B,EAAUo5B,aAErCjjC,EAAKsgB,eAAeD,IAI5B,QAAmC9gC,IAA/B6hC,EAAY44C,eACZ,IAAK,MAAMj3D,KAAQqe,EAAY44C,eAAgB,CAC3C,QAAuBz6E,IAAnBwjB,EAAK8G,gBAAkDtqB,IAAvBwjB,EAAKk3D,cACrC,SAGJ,MAAMpwD,EAAYuX,EAAY02C,WAAW/0D,EAAK8G,WAE9C,IAC6B,IAAzBA,EAAUkuD,aACT,EAAAQ,gBAAgB1uD,SACDtqB,IAAf45E,IAA6BA,EAAWtvD,GAEzC,SAGJ,MAAMijC,EAAY,IAAInwD,EAAM0a,gBACxB,IAAI0X,aAAahM,EAAK+pC,UAAU7+B,QAChClL,EAAK+pC,UAAU97B,WAGbkpD,EAAeptB,EAAUx1C,MAC/B,GAAI4iE,EAAe,EACf,SAGJ,MAAMh3D,OACqB3jB,IAAvBsqB,EAAU3G,SACJ,EAAAuH,iBAAiBZ,EAAU3G,SAAUu2D,GACrC,EACJl2D,OACqBhkB,IAAvBsqB,EAAUtG,SACJ,EAAAkH,iBAAiBZ,EAAUtG,SAAUk2D,GACrC5vD,EAAUtG,SACdC,OACoBjkB,IAAtBsqB,EAAUrG,QACJ,EAAAiH,iBAAiBZ,EAAUrG,QAASi2D,GACpC5vD,EAAUrG,QAEpB,IAAK,IAAI7oB,EAAI,EAAGA,EAAIu/E,IAAgBv/E,EAAG,CACnC,MAAMqI,EAAI8pD,EAAU4E,KAAK/2D,GAAKg2E,EACxB1tE,EAAI6pD,EAAU6E,KAAKh3D,GACnBwI,EAAI2pD,EAAUqtB,KAAKx/E,GACnB4I,EAAQwf,EAAKk3D,cAAcl3D,EAAKq3D,MAAMz/E,IAC5C,QAAc4E,IAAVgE,EAEA,SAGJ,MAAM8b,OAA6B9f,IAAlBwjB,EAAKkb,SAAyBlb,EAAKkb,SAAStjC,QAAK4E,EAC5D8jB,EAAY,EAAA2uD,aAAa3yD,GAEzBghB,EAAc,IAAI,EAAAvd,YACpB,EAAA62D,0BAA0Bn8E,SAASo8E,QAAQr2E,GAC3C,IAAI5G,EAAMuG,QAAQF,EAAGC,EAAGE,GACxBo2E,EAAeM,eAAehwD,GAC9B0vD,EAAeO,eAAejwD,GAC9B3G,EACA2G,EAAU1G,SAAW,EACrB0G,EAAUzG,SAAW,EACrBC,EACAwG,EAAUvG,WACV/jB,OACAA,EACAygB,EAAKoB,QAGTif,EAAY/iB,kBACmB/d,IAA3BsqB,EAAUvM,aACJuM,EAAUvM,aACV7R,EAAQ6R,aAClB+iB,EAAY9iB,kBACmBhe,IAA3BsqB,EAAUtM,aACJsM,EAAUtM,aACV9R,EAAQ8R,aAClB8iB,EAAY/b,YAAsC,IAAzBuF,EAAUvF,WACnC+b,EAAY9b,cAA0C,IAA3BsF,EAAUtF,aAErC8b,EAAYiK,KAAOzgB,EAAUygB,KAE7BjK,EAAY9c,SAAWA,EACvB8c,EAAY7c,QAAUA,EACtB6c,EAAY4iB,aAAep5B,EAAUo5B,aAGrC5iB,EAAYhhB,SAAWA,EACvBW,EAAKsgB,eAAeD,KAcpC,cACIrgB,EACAohB,EACAi5C,G,gBAEA,MAAM5uE,EAAUuU,EAAKvU,QACfyT,EAA8B,GAC9Bw4D,EAAsC,GACtC4C,EAA2B7uE,EAAQ6uE,yBACnCp8C,EAAale,EAAKke,WAClBs7C,EAAoB5yE,KAAKmtB,MAAMtoB,EAAQ0I,WACvCslE,EAAkB,IAAI,EAAApa,OAAO,CAAE6N,MAAOsM,GAAqB/tE,EAAQ9L,KACnEw+B,EAAUne,EAAKme,QACfqrB,EAAa/9C,EAAQ+9C,WACrBt4B,OAAiD3xB,IAA9BkM,EAAQkN,kBAEjC,IAAK,MAAM4hE,KAAch9E,KAAKi9E,eAAep5C,GAAc,CACvD,MAAM42C,EAAcuC,EAAW9iE,SACzB0oB,EAASo6C,EAAW3oB,KAAKzxB,OACzBs6C,EAAat6C,EAAOthC,OAE1B,IAAK,IAAI67E,EAAa,EAAGA,EAAaD,GAAc,CAChD,MAAMv6C,EAAQC,EAAOu6C,KACfpzC,EAAQpH,EAAMoH,MACdqzC,EAAiBz6C,EAAMrW,UACvBA,EAAYuX,EAAY02C,WAAW6C,GAMzC,QAJ6Bp7E,IAAzB2gC,EAAM+3C,iBACN/3C,EAAM+3C,eAAiB,KAIyB,IAAhD/3C,EAAM+3C,eAAgB/nD,QAAQlQ,EAAKoB,UACV,IAAzByI,EAAUkuD,iBACWx4E,IAApB86E,IAAkCA,EAAgBxwD,GAEnD,SAGJ,IAAIvS,EAAQ4oB,EAAM5oB,MAIlB,IAHA4oB,EAAM+3C,eAAgBx0E,KAAKuc,EAAKoB,QAK5Bs5D,EAAaD,GAAct6C,EAAOu6C,GAAY7wD,YAAc8wD,GAGxDrzC,EAAQhwB,IAAU6oB,EAAOu6C,GAAYpzC,QAFvCozC,EAMFpjE,GAAS6oB,EAAOu6C,GAAYpjE,MAG5B6oB,EAAOu6C,GAAYzC,eAAgBx0E,KAAKuc,EAAKoB,QAGjD,IAAK,EAAAw5D,aAAa/wD,GACd,SAEJ,MAAMgxD,EACyE,QADhD,EAC3BP,aAAwB,EAAxBA,EAA0BQ,uBAAuBjxD,EAAW4vD,UAAe,SAG/E,IAAIzxE,EAAuCkX,EAAUy7D,GAErD,QAAiBp7E,IAAbyI,EAAwB,CACxB,MAAM+yE,EAAqBrmE,IACvBwpB,EAAW8D,qBACKziC,IAAZmV,GACAsL,EAAKg7D,gBAAgBtmE,IAY7B,GATA1M,EAAW,EAAAizE,eACP,CACIpxD,YACAlqB,IAAK8L,EAAQ9L,IACbysB,IAA2B,OAAtB3gB,EAAQyqB,MAAM9J,IACnBtC,eAAgBre,EAAQqe,gBAE5BixD,QAEax7E,IAAbyI,EACA,SAEA6yE,GAA6B,EAAAK,oBAAoBlzE,IACjDyvE,EAAuBzvE,EAAU0vE,GAErCx4D,EAAUy7D,GAAkB3yE,EAIhC,MAAMmzE,EAAgBtxD,EAAUygB,KAG5B,EAAA3d,mBAAmB9C,IACnBtsB,KAAK69E,qBAAqBvxD,EAAW7hB,EAAUgY,EAAKvU,QAAQk0D,YAGhE,MAAMjoD,EAAiB,IAAI/a,EAAMob,eAEL,QAA5B,EAAAigE,EAAYqD,wBAAgB,SAAEz9E,QAAQ09E,IAClC,MAAMrtD,EAASssD,EAAWpD,mBAAmBmE,GAC7C5jE,EAAes3C,aAAassB,EAAgBpgF,KAAM+yB,KAGf,QAAvC,EAAA+pD,EAAYuD,mCAA2B,SAAE39E,QAAQ49E,IAC7CjB,EACKkB,+BAA+BD,GAC/B59E,QAAQ,EAAG1C,OAAM2b,eACda,EAAes3C,aAAa9zD,EAAM2b,MAI9C,MAAMoB,EAA6B,QAAxB,EAAGsiE,EAAW3oB,KAAK35C,aAAK,QAAI+/D,EAAY//D,MAC/CA,GACAP,EAAeu3C,SAASsrB,EAAWpD,mBAAmBl/D,IAK1D,MAAMm5D,EACF,EAAA7kD,2BAA2B1C,SACGtqB,IAA9Bg7E,EAAW3oB,KAAK8pB,UAWpB,GARKhkE,EAAeikE,aAAa,YAC5BvK,IAAc,EAAAwK,mBAAmB/xD,IAElCnS,EAAemkE,uBAGnBnkE,EAAe06D,SAAS9qC,EAAOhwB,GAE3B,EAAAwkE,qBAAqBjyD,GAAY,CAEjC,EAAAhgB,QAAQ,EAAAkyE,4BAA4B/zE,IACpC,MAAMg0E,EAAeh0E,GAEM,IAAvB6hB,EAAU26B,UACVxkC,EAAKtT,WAAWS,OAAS,EAAAC,eAAeC,SAExC2S,EAAK0f,YAAYuoC,QAAQqO,GACzBC,EAAWhyE,IAAI+xE,EAAWtzE,EAAGszE,EAAWrzE,GACxC+4E,EAAaC,aAAe1F,GAG5B7+D,EAAeikE,aAAa,UAC5B,EAAAO,wBAAwBF,EAAc,aAAa,GAK3D,MAAMG,EACF,EAAAL,qBAAqBjyD,SAA2CtqB,IAA7BsqB,EAAU66B,eAI3C03B,EACF,EAAAr9E,KAAKuG,OAAOukB,EAAUtN,UACtBy7D,EAAYqE,eACZrE,EAAYqE,cAAcx9E,OAAS,EAEjCxC,EAAS,EAAAigF,YACXzyD,EACAnS,EACA0kE,EAAmB,CAACp0E,GAAYA,EAChCgY,EACAkR,GAkBJ,GAfA70B,EAAOwnB,YAAc,EAAA4G,iBAAiBZ,EAAUhG,YAAapY,EAAQ9L,UAExCJ,IAAzBg7E,EAAW3oB,KAAK98C,OAChBzY,EAAOyY,KAAOylE,EAAW3oB,KAAK98C,KAC9BzY,EAAOgjB,SAASk9D,WAAahC,EAAW3oB,KAAK98C,OAI5C,EAAA0nE,mBAAmB3yD,IAAc,EAAA4yD,mBAAmB5yD,UACzBtqB,IAA5BsqB,EAAUo4B,gBAGT5lD,EAAyBqgF,iBAAmB7yD,EAAUo4B,eAGvD,EAAA06B,gBAAgB9yD,IAAc,EAAA+yD,oBAAoB/yD,GAAY,CAC9D,MAAMgzD,EAAet/E,KAAKu/E,gBAAgBrD,EAAiB5vD,GAC3D,EAAAm+B,cAAcuB,gBACVltD,EACAmtD,EACAqzB,EAAat5D,SACbs5D,EAAar5D,SACb,GAIR,GAAI,EAAAs4D,qBAAqBjyD,GAAY,CACjC,MAAMgzD,EAAet/E,KAAKu/E,gBAAgBrD,EAAiB5vD,GAE3D,EAAAm+B,cAAcuB,gBACVltD,EACAmtD,EACAqzB,EAAat5D,SACbs5D,EAAar5D,SACb,GAIR,GAAI,EAAAuG,wBAAwBF,SAGEtqB,IAAtBsqB,EAAUrG,QAAuB,CACjC,MAAMq5D,EAAet/E,KAAKu/E,gBACtBrxE,EAAQ9L,IACRkqB,GAGJ,EAAAm+B,cAAcuB,gBACVltD,EACAmtD,EACAqzB,EAAat5D,SACbs5D,EAAar5D,SACb,GAcZ,GATAjmB,KAAKw/E,YAAY/8D,EAAMg4D,EAAanuD,EAAWxtB,GAE3C,EAAAkwB,2BAA2B1C,IAC3BxtB,EAAO2gF,WAAavxE,EAAQqe,eAC5BztB,EAAO4gF,cAAgBxxE,EAAQqe,iBACxB,EAAA4C,oBAAoB7C,IAAc,EAAAi9B,gBAAgBj9B,MACzDxtB,EAAO4gF,cAAgBxxE,EAAQqe,iBAI/B,EAAAyC,2BAA2B1C,IAC3B,EAAA6C,oBAAoB7C,IACpB,EAAAi9B,gBAAgBj9B,UAKUtqB,IAAtBsqB,EAAUrG,QAAuB,CACjC,MAAMq5D,EAAet/E,KAAKu/E,gBAAgBrD,EAAiB5vD,GAC3D,EAAAm+B,cAAcuB,gBACVltD,EACAmtD,EACAqzB,EAAat5D,SACbs5D,EAAar5D,SACb,GASZ,GAHI,EAAA+I,2BAA2B1C,IAC3B,EAAAqzD,4BAA4BrzD,EAAW4vD,GAEnB,CACpB,MAAM0D,EAAgB,EAAAC,uBAAuB/gF,GAG7CkB,KAAK8/E,mBAAmBr9D,EAAMm9D,EAAehC,EAAe,CACxDtxD,cAEJsU,EAAQ16B,KAAK05E,GAETtC,GACApD,EAAuB0F,EAAcn1E,SAAU0vE,GAGnD,EAAA4F,uBAAuBH,EAAe9gF,GAS1C,GANAkB,KAAK8/E,mBAAmBr9D,EAAM3jB,EAAQ8+E,EAAe,CACjDtxD,cAEJsU,EAAQ16B,KAAKpH,GAGT+0E,EAAY,CACZ,MAAMmM,EAAoB1zD,EACpB2zD,EAAe,IAAI7gF,EAAMob,eAC/BylE,EAAaxuB,aAAa,WAAYt3C,EAAeikE,aAAa,aAElE,MAAM8B,EAAiB/lE,EAAeikE,aAAa,cAC5Bp8E,IAAnBk+E,GACAD,EAAaxuB,aAAa,QAASyuB,GAGvC,MAAMC,EAAqBhmE,EAAeikE,aAAa,sBAC5Bp8E,IAAvBm+E,GACAF,EAAaxuB,aAAa,gBAAiB0uB,GAG/C,MAAMC,EAAkBjmE,EAAeikE,aAAa,eAC5Bp8E,IAApBo+E,GACAH,EAAaxuB,aAAa,SAAU2uB,GAGxC,MAAMC,EAAclmE,EAAeikE,aAAa,WAC5Bp8E,IAAhBq+E,GACAJ,EAAaxuB,aAAa,KAAM4uB,GAGpCJ,EAAavuB,SACTsrB,EAAWpD,mBAAmBoD,EAAW3oB,KAAK8pB,YAIlD,MAAMmC,EAA2Bh0D,EAE3BgzD,EAAet/E,KAAKugF,uBACtBrE,EACAoE,GAIEE,EAAyC,CAC3Cv1D,MAAOq0D,EAAar0D,MACpBw1D,SAAUnB,EAAamB,SACvBz6D,SAAUs5D,EAAav4B,aACvB9gC,QAASq5D,EAAax4B,YACtB+F,eAAgBywB,EAA4B,OAAIt7E,GAE9C0+E,EAAe,IAAI,EAAAC,aAAaH,GAChCI,EAAU,IAAIxhF,EAAMi1B,aAAa4rD,EAAcS,GAGrDE,EAAQt6D,YAAcxnB,EAAOwnB,YAAc,GAE3C,EAAAmkC,cAAcuB,gBACV40B,EACA30B,EACAqzB,EAAav4B,aACbu4B,EAAax4B,aACb,GAGAw2B,GACApD,EAAuB0G,EAAQn2E,SAAU0vE,GAG7Cn6E,KAAK8/E,mBAAmBr9D,EAAMm+D,EAAShD,EAAe,CAClDtxD,cAEJ,EAAA2G,mBAAmBv0B,OAAOgiF,EAAc,CACpCz1D,MAAO+0D,EAAkBn5B,UACzB37B,QAAS80D,EAAkB90D,UAE/B0V,EAAQ16B,KAAK06E,GAajB,GATI,EAAA5xD,2BAA2B1C,IAAcgxD,IACzCx+E,EAAO+hF,oBAAsB,IAAI,EAAA7yB,qBAAqB,CAClD8yB,aAAc1hF,EAAM2hF,mBAExB7G,EAAuBp7E,EAAO+hF,oBAAqB1G,IAKnD,EAAA5wB,gBAAgBj9B,IAAc0wD,EAAW3oB,KAAK8pB,UAAW,CACzD,MAAM6C,EAAkB,IAAI5hF,EAAMob,eAClCwmE,EAAgBvvB,aACZ,WACAt3C,EAAeikE,aAAa,aAEhC4C,EAAgBtvB,SACZsrB,EAAWpD,mBAAmBoD,EAAW3oB,KAAK8pB,YAGlD,MAAM8C,EAAgB30D,EAEhBgzD,EAAet/E,KAAKugF,uBAAuBryE,EAAQ9L,IAAK6+E,GAGxDT,EAAyC,CAC3Cv1D,MAAOq0D,EAAar0D,MACpBw1D,SAAUnB,EAAamB,SACvBz6D,SAAUs5D,EAAav4B,aACvB9gC,QAASq5D,EAAax4B,aAEpBo6B,EAAkB,IAAI,EAAAP,aAAaH,GACnCW,EAAa,IAAI/hF,EAAMi1B,aAAa2sD,EAAiBE,GAC3DC,EAAW76D,YAAcxnB,EAAOwnB,YAAc,GAE9C,EAAAmkC,cAAcuB,gBACVm1B,EACAl1B,EACAqzB,EAAav4B,aACbu4B,EAAax4B,aACb,GAGJ9mD,KAAK8/E,mBAAmBr9D,EAAM0+D,EAAYvD,EAAe,CACrDtxD,cAEJ,EAAA2G,mBAAmBv0B,OAAOwiF,EAAiB,CACvCj2D,MAAOg2D,EAAcp6B,UACrB37B,QAAS+1D,EAAc/1D,UAE3B0V,EAAQ16B,KAAKi7E,GAIjB,GAAIvC,EAAuB,CACvB,MAAMwC,EAAmB90D,EACnB40D,EAAkBz2E,EAASoC,QACjC,EAAA8gB,yBACIuzD,EACAA,EAAgBj2D,MAChBm2D,EAC+B,QADf,EAChBA,EAAiBh6B,sBAAc,QAAI,EACnC80B,QAGmCl6E,IAAnCo/E,EAAiBC,gBACjBH,EAAgBI,KAAO,EAAAp0D,iBACnBk0D,EAAiBC,cACjBnzE,EAAQ9L,MAGhB,MAAM++E,EAAa,EAAApC,YACfzyD,EACAnS,EACA+mE,EACAz+D,EACAkR,GAGJwtD,EAAW76D,aAC8D,QAArE,EAAC,EAAA4G,iBAAiBk0D,EAAiBl6B,qBAAsBh5C,EAAQ9L,YAAI,QACjE,GAAK,KAEbpC,KAAKw/E,YAAY/8D,EAAMg4D,EAAanuD,EAAW60D,GAE/C,MAAM7B,EAAet/E,KAAKu/E,gBAAgBrD,EAAiB5vD,GAC3D,EAAAm+B,cAAcuB,gBACVm1B,EACAl1B,EACAqzB,EAAat5D,SACbs5D,EAAar5D,SACb,GAGJ,MAAMkhC,EAAiB,EAAAt6B,0BACnBu0D,EAAiBj6B,eAEjBi6B,EAAiBt0D,YAErB9sB,KAAK8/E,mBAAmBr9D,EAAM0+D,EAAYvD,EAAe,CAAEtxD,cAC3D,MAAMi1D,EAAsB,EAAAtuD,mBAAmBh1B,IAAIwM,GAE7C+2E,EAAyB,EAAAvuD,mBAAmBv0B,OAAOwiF,EAAiB,CACtEj2D,MAAOm2D,EAAiBh6B,eACxBl8B,QAASk2D,EAAiBl2D,QAC1Bo2D,KAAMF,EAAiBC,cAEvBx1D,UAAY41D,IACR,IAAKF,EACD,OAEJA,EAAoBn0C,cAAcq0C,GAClC,MAAMC,EACFH,EAAoBI,wBAAwB91D,UAE1C+1D,EAAqB,EAAA10D,iBACvBi6B,EACAj5C,EAAQ9L,KAEN8oB,EAAUs2D,EAAuBG,wBAClCz2D,QACL,MAC6B,iBAAlBw2D,GACuB,iBAAvBE,EAGHA,GAAsBF,IACrBx2D,SAAyD,IAAZA,GAIvC,EAEA02D,EAGJ,KAInBhhD,EAAQ16B,KAAKi7E,KAIrBhH,EAAkB74E,OAAS,GAC3B4M,EAAQ6uE,yBAAyB58E,IAAIsiB,EAAM03D,GAOnD,YAAY13D,EAAYohB,QACc7hC,IAA9B6hC,EAAYg+C,eACZp/D,EAAKvU,QAAQ0oE,WAAWkL,QAAQr/D,EAAMohB,GAU9C,kBACIphB,EACAhY,EACAs3E,EACAx1D,GAEA,MAAM,WAAEoU,EAAU,WAAExxB,EAAU,QAAEjB,GAAYuU,EACtCyC,EAAmByb,EAAWsB,kBAAkB9yB,WAChD6yE,EAAkB7yE,EAAWS,OAAS,EAAAC,eAAee,UACrDqxE,EAAO,IAAI7iF,EAAMuG,QAEvB,SAASu8E,EAAeC,GACpB,MAAMlE,EAAOkE,EAAK/D,aAAa,YACzBgE,EAAWnE,EAAKtkE,MACtB,IAAK,IAAIvc,EAAI,EAAGA,EAAIglF,EAAS9gF,OAAQlE,GAAK,EACtC6kF,EAAKj7E,IAAIo7E,EAAShlF,GAAIglF,EAAShlF,EAAI,GAAIglF,EAAShlF,EAAI,IACpD+R,EAAWwsB,eAAezW,EAAkB+8D,EAAMA,GAClDA,EAAKnvE,IAAI2P,EAAKxF,QACdmlE,EAAShlF,GAAK6kF,EAAKx8E,EACnB28E,EAAShlF,EAAI,GAAK6kF,EAAKv8E,EACvB08E,EAAShlF,EAAI,GAAK6kF,EAAKr8E,EAE3Bq4E,EAAK1xE,aAAc,EAIvB,MAAM,KAAEqQ,EAAI,KAAEC,EAAI,MAAEL,EAAK,MAAEC,GAAUgG,EAAKyT,OACpChc,EAAW,IAAI9a,EAAMob,eACrB6nE,EAAKn9D,EAAiBzU,aACxB,IAAI,EAAAvI,eAAeuU,EAAOI,GAC1B,IAAIzd,EAAMuG,SAER28E,EAAKp9D,EAAiBzU,aACxB,IAAI,EAAAvI,eAAeuU,EAAOG,GAC1B,IAAIxd,EAAMuG,SAER48E,EAAKr9D,EAAiBzU,aACxB,IAAI,EAAAvI,eAAesU,EAAOK,GAC1B,IAAIzd,EAAMuG,SAER68E,EAAKt9D,EAAiBzU,aACxB,IAAI,EAAAvI,eAAesU,EAAOI,GAC1B,IAAIxd,EAAMuG,SAER88E,EAAU,IAAIrjF,EAAM0a,gBACtB,IAAI0X,aAAa,IAAI6wD,EAAGK,aAAcJ,EAAGI,aAAcH,EAAGG,aAAcF,EAAGE,YAC3E,GAGJ,GADAxoE,EAASu3C,aAAa,WAAYgxB,IACX,IAAnBl2D,EAAyB,CACzBrH,EAAiB1P,cAAc6sE,EAAIJ,GAEnCA,EAAKlvE,SACL,MAAM4vE,EAAW,IAAIvjF,EAAM0a,gBACvB,IAAI0X,aAAa,IACVywD,EAAKS,aACLT,EAAKS,aACLT,EAAKS,aACLT,EAAKS,YAEZ,GAEJxoE,EAASu3C,aAAa,SAAUkxB,GAIpC,GAFAzoE,EAASw3C,SAAS,IAAItyD,EAAM0a,gBAAgB,IAAIoX,YAAY,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,IAAK,IAE7E6wD,EAAiB,CACjB,MAAMa,EAAS,IAAIxjF,EAAM0a,gBAAgB,IAAI0X,aAAa,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAAK,GACrFtX,EAASu3C,aAAa,KAAMmxB,GAGhC,GAAIZ,EAAiB,CACjB,MAAMpgE,EAAqC,GACrCihE,EAAoB,IAAI,EAAAC,qCAC1B1jF,EAAMkJ,UAAUW,SAAS,IACzBic,GAIJ,GAFuBhX,EAAQ43D,qBAA6C9jE,IAA3BkM,EAAQ43D,eAErC,CAEhB,IAAK,IAAIid,EAAkB,EAAGA,EAAkB,IAAKA,EAAiB,CAClE,MAAMC,EAAc35E,KAAK2N,IAAI,EAAG+rE,GAC1BE,EAAoB/oE,EAASrN,QACnC,GAAIm2E,EAAc,EAAG,CACI,IAAI,EAAAE,sCACrBF,EACAvgE,EAAKyT,OACL,EAAAitD,gBAAgBC,IAChBl+D,GAESm+D,OAAOJ,GAExBJ,EAAkBQ,OAAOJ,GACzBf,EAAee,GACfrhE,EAAW1b,KAAK+8E,GAEpB,OAAO,IAAI,EAAAx8C,QAAQ7kB,EAAYnX,GAM/B,OAHAo4E,EAAkBQ,OAAOnpE,GACzBgoE,EAAehoE,GAER,IAAI9a,EAAM40B,KAAK9Z,EAAUzP,GAKpC,OADAy3E,EAAehoE,GACR,IAAI9a,EAAM40B,KAAK9Z,EAAUzP,GASxC,eAAegY,EAAY6D,GACvB,MAAMiG,EAAiB9J,EAAKvU,QAAQqe,eAC9B9hB,EAAWzK,KAAKsjF,0BAClB,IAAIlkF,EAAMsqB,MAAMjH,EAAKvU,QAAQk0D,YAC7B3/C,EAAKvU,QAAQqe,eACb9J,EAAKvU,QAAQiB,WAAWS,OAAS,EAAAC,eAAee,WAE9C8Q,EAAO1hB,KAAKujF,kBAAkB9gE,EAAMhY,GAAU,EAAO8hB,GAC3D7K,EAAKg+D,cAAgBnzD,EACrB7K,EAAK4E,YAAcA,EACnBtmB,KAAK8/E,mBAAmBr9D,EAAMf,EAAM,EAAAqyD,aAAayP,YACjD/gE,EAAKme,QAAQ16B,KAAKwb,GAGd,0BACJuJ,EACAsB,EACAotB,GAEA,OAAIptB,EACO,IAAI,EAAA7T,wBAAwB,CAC/BuS,QACA7E,SAAS,EACTuzB,aACA7qB,oBAAoB,IAGjB,IAAI,EAAA1W,qBAAqB,CAC5B6S,QACA7E,SAAS,EACTuzB,eAUJ,gBAAgB9V,GACpB,MAAM3hC,EAAQ,IAAI+2E,EAElB,IAAK,MAAM/+D,KAAY2pB,EAAYjiB,WAAY,CAG3C,MAAM6hE,EAA6B,CAC/B/oE,MAAOR,EAASQ,MAChByjE,UAAWjkE,EAASikE,UACpB5mE,KAAM2C,EAAS3C,KACfqrB,OAAQ1oB,EAAS0oB,QAKrB,SAFM,IAAI82C,EAAex/D,EAAUupE,EAAgBvhF,GAE/CgY,EAASwpE,YAET,IAAK,MAAMrvB,KAAQn6C,EAASwpE,kBAClB,IAAIhK,EAAex/D,EAAUm6C,EAAMnyD,IAYjD,kBAAkBugB,GACtB,MAAMohB,EAAcphB,EAAKohB,YAEzB,QAAoB7hC,IAAhB6hC,EACA,OAKJ,IAFcphB,EAAKvU,QAGf,OAGJ,MAAM,WAAEs7D,EAAU,gBAAEC,GAAoBhnD,EAAKvU,QAAQwwD,MAErD76B,EAAY02C,WAAWl6E,QAAQisB,IAC3B,GACI,EAAA0uD,gBAAgB1uD,IAChB,EAAAwuD,eAAexuD,IACf,EAAAyuD,sBAAsBzuD,IAItB,GAAIm9C,GAAkD,iBAAxBn9C,EAAUq3D,UAAwB,CAE5D,MAAMh+D,EAAW8jD,EAAgB92C,QAAQrG,EAAUq3D,YACjC,IAAdh+D,IACA2G,EAAU3G,SAAW8jD,EAAgBnoE,OAASqkB,SAGnD,GAAI6jD,QAAsCxnE,IAAxBsqB,EAAUs3D,UAAyB,CAExD,MAAMC,EAAsBC,IACxB,MAAMn+D,EAAW6jD,aAAU,EAAVA,EAAYua,UACzBC,GAASA,EAAMrhD,QAAUrW,EAAUs3D,WAAaI,EAAMF,WAAaA,GAGvE,YAAoB9hF,IAAb2jB,IAAwC,IAAdA,EACV,IAAhBA,EAAW,QACZ3jB,GAGV,GAAmC,iBAAxBsqB,EAAUq3D,UAAwB,CAEzC,MAAMr9D,EAAcu9D,EAAmBv3D,EAAUq3D,gBAE7B3hF,IAAhBskB,IACAgG,EAAUhG,YAAcA,GAIhC,GAA4C,iBAAjCgG,EAAU23D,mBAAiC,CAElD,MAAM/8B,EAAuB28B,EAAmBv3D,EAAU23D,yBAE7BjiF,IAAzBklD,IACC56B,EAAkB46B,qBAAuBA,OAOtD,qBACJ56B,EACA7hB,EACAy5E,GAEA,QAAkCliF,IAA9BsqB,EAAUtT,gBAQbvO,EAAiBsgD,gBAAmB9xB,IACjCA,EAAOI,eAAiBJ,EAAOI,eAAejtB,QAC1C,+BACA,mJAKJ6sB,EAAOI,eAAiBJ,EAAOI,eAAejtB,QAC1C,0BACA,4CACW,EAAAY,eAAe2X,cAAc8lB,QAAQ,iCACrC,EAAAz9B,eAAe4X,cAAc6lB,QAAQ,uVAYpDxR,EAAOG,aAAeH,EAAOG,aAAahtB,QACtC,oCACA,KAGP3B,EAAqCuO,gBAAiBzM,aAAc,MArCrE,CAEwB9B,EACRwgB,MAAMjkB,IAAIk9E,IAqCtB,YACJzhE,EACAg4D,EACAnuD,EACAxtB,GAEA,GAAI,EAAAswB,mBAAmB9C,GAAY,CAC/B,EAAAhgB,OAC4C,IAAxCxO,OAAO89D,KAAK98D,EAAOgjB,UAAUxgB,OAC7B,0CAGJ,EAAAgL,OACwC,iBAA7BmuE,EAAY/5C,SAAU,GAC7B,iDAGJ,MAAM1nB,EAAmByhE,EAAY/5C,SAA+B,GAC9DyjD,EAA2C,CAC7CvgE,QAASnB,EAAKmB,QACdzM,QAAS,IAAI/X,EAAMuyB,YACf3Y,EAAgB0X,OAChB1X,EAAgBorE,eAChBprE,EAAgBqrE,eAChBjlF,EAAMklF,gBACNllF,EAAMmyB,WAEVvY,kBACAkd,OAAQzT,EAAKyT,QAEjBp3B,EAAOgjB,SAAWqiE,MACf,CAGH,MAAMtiE,EAA+B,CACjC0iE,aAAc9J,EAAY7qE,KAC1B6wB,OAAQg6C,EAAYqE,cACpBp+C,SAAU+5C,EAAY/5C,UAE1B5hC,EAAOgjB,SAASC,QAAUF,EAC1B/iB,EAAOgjB,SAASwK,UAAYA,GAO5B,gBACJlqB,EACAkqB,GAUA,MAAO,CACHtG,cARuBhkB,IAAvBsqB,EAAUtG,SACJ,EAAAkH,iBAAiBZ,EAAUtG,SAAU5jB,GACrC,EAAAqoD,cAAce,kBAOpBvlC,aALsBjkB,IAAtBsqB,EAAUrG,QACJ,EAAAiH,iBAAiBZ,EAAUrG,QAAS7jB,GACpC,EAAAqoD,cAAcgB,kBAUpB,uBACJrpD,EACAkqB,GAEA,IAAIrB,EACAw1D,EAAW,EAAAE,aAAa6D,kBAE5B,QAA4BxiF,IAAxBsqB,EAAUu6B,YACV57B,EAAQ,EAAAiC,iBAAiBZ,EAAUu6B,UAAWzkD,GAC1C,EAAA4sB,2BAA2B1C,IAAY,CACvC,MAAMg0D,EAA2Bh0D,EACjCm0D,OAC8Cz+E,IAA1Cs+E,EAAyBn3B,aACnBm3B,EAAyBn3B,aACzB,EAAAw3B,aAAa6D,kBAI/B,MAAMx+D,OACqBhkB,IAAvBsqB,EAAUtG,SACJ,EAAAkH,iBAAiBZ,EAAUtG,SAAU5jB,GACrC,EAAAqoD,cAAce,kBAClBvlC,OACoBjkB,IAAtBsqB,EAAUrG,QACJ,EAAAiH,iBAAiBZ,EAAUrG,QAAS7jB,GACpC,EAAAqoD,cAAcgB,iBAElB1E,OACyB/kD,IAA3BsqB,EAAUy6B,aACJ,EAAA75B,iBAAiBZ,EAAUy6B,aAAc3kD,GACzC4jB,EACJ8gC,OACwB9kD,IAA1BsqB,EAAUw6B,YACJ,EAAA55B,iBAAiBZ,EAAUw6B,YAAa1kD,GACxC6jB,EAMV,YAJcjkB,IAAVipB,IACAA,EAAQ,EAAA01D,aAAal3D,eAGlB,CACHwB,QACAw1D,WACAz6D,WACAC,UACA8gC,eACAD,gBAn2CZ,yB,0GCtNA,aAEA,OACA,OACA,QAkCA,MAAa7zB,EA0DT,YAAYxoB,EAA0Bg6E,GAH9B,KAAA53C,yBAA2B,EAI/B7sC,KAAKyK,SAAWA,EAChBzK,KAAKykF,iBAAmBA,EAExBzkF,KAAK2hF,wBAA0B,GAC/B3hF,KAAK0kF,oBAAsB,GAC3B,IAAK,MAAMC,KAAYF,EAAkB,CACrC,IAAKA,EAAiBxlF,eAAe0lF,GACjC,SAEJ,MAAMC,EAAiBH,EAAkBE,GACrC,EAAAnjF,KAAKuG,OAAO68E,IAA6C,mBAAnBA,EACtC5kF,KAAK0kF,oBAAoBx+E,KAAK,CAACy+E,EAAUC,IAEzC5kF,KAAK2hF,wBAAwBgD,GAAYC,EAGjD5kF,KAAK6kF,wBAvET,WAAWp6E,G,MACP,MAAMwiC,EAA8B,QAApB,EAAGxiC,EAASqX,gBAAQ,eAAEmrB,WACtC,OAAIA,aAAsBha,EACfga,OACJ,EASX,eAAeC,GAIX,OAHKA,EAAQziC,SAASqX,WAClBorB,EAAQziC,SAASqX,SAAW,IAExBorB,EAAQziC,SAASqX,SAASmrB,WAAaC,EAGnD,cACIziC,EACAg6E,GAEA,OAAOxxD,EAAmBka,QAAQ,IAAIla,EAAmBxoB,EAAUg6E,IAGvE,qBAAqBh6E,EAA0BvK,G,QAC3C,OAA8D,QAA9D,EAAuC,QAAvC,EAAO+yB,EAAmBh1B,IAAIwM,UAAS,eAAE2iC,cAAcltC,UAAO,SAoDlE,SACI,MAAO,CAAEukF,iBAAkBzkF,KAAKykF,kBAYpC,cAAcvkF,GACV,OAAIF,KAAK6sC,0BAA4B3sC,EAAQsiC,cAG7CxiC,KAAK6sC,wBAA0B3sC,EAAQsiC,YAEhCxiC,KAAK8kF,wBAAwB5kF,IAMhC,wB,QACJ,IAAI6kF,GAAkB,EACtB,IAAK,MAAMJ,KAAY3kF,KAAKykF,iBAAkB,CAC1C,IAAKzkF,KAAKykF,iBAAiBxlF,eAAe0lF,GACtC,SAEJ,MAAM94E,EAAe7L,KAAK2hF,wBAAwBgD,GAC9C94E,UAGa,UAAb84E,GAAqC,YAAbA,EACxBI,GAAkB,EAElB/kF,KAAKglF,yBAAyBL,EAAU94E,IAGhD,GAAIk5E,EAAiB,CACjB,MAAM95D,EAAsD,QAA7C,EAAAjrB,KAAK2hF,wBAAwB12D,aAAgB,QAAI,SAC1DC,EAA0D,QAA/C,EAAAlrB,KAAK2hF,wBAAwBz2D,eAAkB,QAAI,EACpElrB,KAAKilF,uBAAuBh6D,EAAOC,IAOnC,wBAAwBhrB,G,QAC5B,IAAIotC,GAAmB,EACvB,GAAIttC,KAAK0kF,oBAAoBpjF,OAAS,EAAG,CACrC,IAAIyjF,GAAkB,EAEtB,IAAK,MAAOJ,EAAUC,KAAmB5kF,KAAK0kF,oBAAqB,CAC/D,MAAMnL,EAAW,EAAA/3E,KAAKuG,OAAO68E,GACvB,EAAA13D,iBAAiB03D,EAAgB1kF,EAAQkC,KACzCwiF,EAAe1kF,GACjBq5E,IAAav5E,KAAK2hF,wBAAwBgD,KAG9C3kF,KAAK2hF,wBAAwBgD,GAAYpL,EAGxB,UAAboL,GAAqC,YAAbA,EACxBI,GAAkB,GAElB/kF,KAAKglF,yBAAyBL,EAAUpL,GACxCjsC,GAAmB,IAI3B,GAAIy3C,EAAiB,CACjB,MAAM95D,EAA0C,QAArC,EAAGjrB,KAAK2hF,wBAAwB12D,aAAK,QAAI,SAC9CC,EAA0D,QAA/C,EAAAlrB,KAAK2hF,wBAAwBz2D,eAAkB,QAAI,EACpElrB,KAAKilF,uBAAuBh6D,EAAOC,GACnCoiB,GAAmB,GAG3B,OAAOA,EAGH,yBAAyBq3C,EAAkBtmF,GAC/C,MAAMb,EAAIwC,KAAKyK,SACf,GAAIjN,EAAEmnF,aAAqBvlF,EAAMsqB,MAAO,CACpC,IAAIkE,EAAavvB,EACjB,GAA0B,iBAAfuvB,EAAyB,CAChC,MAAMO,EAAS,EAAAb,sBAAsBM,GACrC,QAAe5rB,IAAXmsB,EACA,OAEJP,EAAaO,EAEjB,MAAM+2D,EAAW,EAAA33D,WAAWE,mBAAmBG,GAC/CpwB,EAAEmnF,GAAU39E,IAAIk+E,QAEhB1nF,EAAEmnF,GAAYtmF,EAId,uBAAuB4sB,EAAcC,GACzC,GAAqB,iBAAVD,EAAoB,CAC3B,MAAMkD,EAAS,EAAAb,sBAAsBrC,GACrC,QAAejpB,IAAXmsB,EACA,OAEJlD,EAAQkD,EAEZ,MAAM,EAAEjwB,EAAC,EAAE2vB,EAAC,EAAEnkB,EAAC,EAAEF,GAAM,EAAA+jB,WAAWO,eAAe7C,UAAS,UACpDk6D,EAAgB37E,EAAIpK,EAAMkJ,UAAU6B,MAAM+gB,UAAW,EAAG,EAAG,GACjElrB,KAAKyK,SAASygB,QAAUi6D,EACvBnlF,KAAKyK,SAAiBwgB,MAAMgD,OAAO/vB,EAAG2vB,EAAGnkB,GAE3By7E,GAAiB,EAI5B,EAAAj3D,gBAAgBluB,KAAKyK,UAFrB,EAAAD,eAAexK,KAAKyK,WAzMhC,wB,yHCtCA,aAgBA,MAAsB26E,UAAsBhmF,EAAMo1B,OAAlD,c,oBAII,KAAA2qD,kBAA4B,EAgC5B,QAAQkG,EAA6BC,GACjC,IAAKtlF,KAAKm/E,iBACN,OAGJ,MAAMjlE,EAAWla,KAAKka,SAChBnI,EAAc/R,KAAK+R,YACnBwzE,EAAeF,EAAUt1E,IAAIy1E,OAC9B34E,QACA1M,IAAIklF,EAAUt1E,IAAIggD,WAClBxO,QAAQ8jC,EAAU32E,QACjB+2E,EAAc,IAAIrmF,EAAMoG,QAC1B6D,KAAKuW,MAAO2lE,EAAa9/E,EAAI,GAAK,EAAK4/E,EAAU5tE,OACjDpO,KAAKuW,MAAO,EAAI2lE,EAAa7/E,GAAK,EAAK2/E,EAAUn0E,SAGrD,GAAIgJ,aAAoB9a,EAAMob,eAAgB,CAC1C,MAAMhJ,EAAQ,IAAIpS,EAAMuG,QAClB+U,EAAQR,EAASQ,MAEjB60C,EADar1C,EAASO,WACC1M,SAAS4L,MACtC,GAAc,OAAVe,EAAgB,CAChB,MAAMgrE,EAAUhrE,EAAMf,MACtB,IAAK,IAAIvc,EAAI,EAAGuoF,EAAKD,EAAQpkF,OAAQlE,EAAIuoF,EAAIvoF,IAAK,CAC9C,MAAMoM,EAAIk8E,EAAQtoF,GAClBoU,EAAMo0E,UAAUr2B,EAA2B,EAAJ/lD,GACvC,MAAMq8E,EAAYC,EAAat0E,EAAOO,EAAaszE,GAC/CQ,EAAUE,iBACV/lF,KAAKgmF,UACDx0E,EACAq0E,EAAUI,uBACVR,EACAroF,EACAyoF,EAAU72E,SACVs2E,SAKZ,IAAK,IAAIloF,EAAI,EAAGC,EAAIkyD,EAAUjuD,OAAS,EAAGlE,EAAIC,EAAGD,IAAK,CAClDoU,EAAMo0E,UAAUr2B,EAA2B,EAAJnyD,GACvC,MAAMyoF,EAAYC,EAAat0E,EAAOO,EAAaszE,GAC/CQ,EAAUE,iBACV/lF,KAAKgmF,UACDx0E,EACAq0E,EAAUI,uBACVR,EACAroF,EACAyoF,EAAU72E,SACVs2E,QAKb,CACH,MAAMjrE,EAAWH,EAASG,SAC1B,IAAK,IAAIK,EAAQ,EAAGA,EAAQL,EAAS/Y,OAAQoZ,IAAS,CAClD,MAAMlJ,EAAQ6I,EAASK,GACjBmrE,EAAYC,EAAat0E,EAAOO,EAAaszE,GAC/CQ,EAAUE,iBACV/lF,KAAKgmF,UACDx0E,EACAq0E,EAAUI,uBACVR,EACA/qE,EACAmrE,EAAU72E,SACVs2E,MAQxB,SAASQ,EACLt0E,EACAO,EACAszE,GAMA,MAAMhxE,EAAgB7C,EAAM3E,QAC5BwH,EAAcpC,aAAaF,GAC3B,MAAM/C,EAAWqF,EAAcqH,WAAW2pE,EAAUt1E,IAAIy1E,QACxDnxE,EAAcktC,QAAQ8jC,EAAU32E,QAChC,MAAMw3E,EAAyB,IAAI9mF,EAAMoG,QAAQ6O,EAAc5O,EAAG4O,EAAc3O,GAC1EqgF,EACFG,EAAuBzgF,EAAI,GAC3BygF,EAAuBzgF,GAAK,GAC5BygF,EAAuBxgF,EAAI,GAC3BwgF,EAAuBxgF,GAAK,EAChC,GAAIqgF,EAAiB,CAIjB,OAHA1xE,EAAc5O,GAAM4O,EAAc5O,EAAI,GAAK,EAAK4/E,EAAU5tE,MAC1DpD,EAAc3O,GAAM,EAAI2O,EAAc3O,GAAK,EAAK2/E,EAAUn0E,OAEnD,CACH+0E,uBAF2B,IAAI7mF,EAAMoG,QAAQ6O,EAAc5O,EAAG4O,EAAc3O,GAG5EqgF,kBACA/2E,YAGR,MAAO,CACH+2E,mBA5IR,kBAmJA,wBAA6BX,EAEzB,UACI5zE,EACAi9B,EACA03C,EACAzrE,EACA1L,EACAs2E,GAEA,MAAMc,EAAK33C,EAAehpC,EAAI0gF,EAAgB1gF,EACxC4gF,EAAK53C,EAAe/oC,EAAIygF,EAAgBzgF,EACjC2D,KAAK+H,KAAKg1E,EAAKA,EAAKC,EAAKA,IACtBrmF,KAAKyK,SAAkC2W,KAAO,GAG1DkkE,EAAWp/E,KAAK,CACZsL,QACAxC,WACA0L,QACA5b,OAAQkB,SASxB,wBAA6BolF,EAEzB,UACI5zE,EACAi9B,EACA03C,EACAzrE,EACA1L,EACAs2E,GAEA,MAAMc,EAAK33C,EAAehpC,EAAI0gF,EAAgB1gF,EACxC4gF,EAAK53C,EAAe/oC,EAAIygF,EAAgBzgF,EACxC4gF,EAAYtmF,KAAKyK,SAAkC2W,KAAO,EAE5D/X,KAAK2S,IAAIoqE,IAAOE,GAAYj9E,KAAK2S,IAAIqqE,IAAOC,GAC5ChB,EAAWp/E,KAAK,CACZsL,QACAxC,WACA0L,QACA5b,OAAQkB,U,mHCnNxB,aAgCMumF,EAA2B,oBAAXt6C,OAMtB,kBAAMu6C,UAAoBpnF,EAAMw/D,gBAQ5B,YAAmBvgE,GACf2E,QADe,KAAA3E,QAUnB,IAAIA,EAAYV,GACZqC,KAAK3B,MAAQA,EACb2B,KAAKiiE,cAAc,CAAEryD,KAAM42E,EAAYC,eAAgB9oF,OAAMU,WAErE,OArBW,EAAAooF,eAAyB,MAqBpC,GAtBA,GA4BA,MAAaC,EAMT,cAKI,GAJA1mF,KAAK2mF,aAAe,IAAIxkF,KAInBokF,GAA4B,oBAAXt6C,QAA0BA,OAAQ,CAClCA,OACR26C,eAAiB5mF,MAYnC,SAASrC,EAAcU,GACnB,IAAIwoF,EAAM7mF,KAAK2mF,aAAa1oF,IAAIN,GAC3BkpF,EAIDA,EAAI7/E,IAAI3I,EAAOV,IAHfkpF,EAAM,IAAIL,EAAYnoF,GACtB2B,KAAK2mF,aAAa3/E,IAAIrJ,EAAMkpF,IAWpC,SAASlpF,GACL,MAAMkpF,EAAM7mF,KAAK2mF,aAAa1oF,IAAIN,GAClC,OAAOkpF,EAAMA,EAAIxoF,WAAQ2D,EAQ7B,UAAUrE,GACN,YAAuCqE,IAAhChC,KAAK2mF,aAAa1oF,IAAIN,GASjC,iBAAiBA,EAAcssE,GAC3B,MAAM4c,EAAM7mF,KAAK2mF,aAAa1oF,IAAIN,GAClC,IAAIkpF,EAGA,MAAMpjF,MAAM,mBAAqB9F,GAFjCkpF,EAAI9iB,iBAAiByiB,EAAYC,eAAgBxc,GAYzD,iBAAiBtsE,EAAcssE,GAC3B,MAAM4c,EAAM7mF,KAAK2mF,aAAa1oF,IAAIN,GAClC,GAAIkpF,EACA,OAAOA,EAAIC,iBAAiBN,EAAYC,eAAgBxc,GAExD,MAAMxmE,MAAM,mBAAqB9F,GAUzC,oBAAoBA,EAAcssE,GAC9B,MAAM4c,EAAM7mF,KAAK2mF,aAAa1oF,IAAIN,GAClC,IAAIkpF,EAGA,MAAMpjF,MAAM,mBAAqB9F,GAFjCkpF,EAAIpf,oBAAoB+e,EAAYC,eAAgBxc,GAU5D,cACI,OAAOjqE,KAAK2mF,aAOhB,QACI3mF,KAAK2mF,aAAatmF,QAAQ0mF,IACtBA,EAAO//E,SAAIhF,EAAW,OAjHlC,iBAsHa,EAAAg3C,aAAe,IAAI0tC,G,oHCxLhC,aACA,OAEA,OAEA,QAMA,IAAYrzC,GAAZ,SAAYA,GAIR,iCAKA,qBAKA,mBAKA,mBAKA,mBAKA,mBAKA,2BAlCJ,CAAYA,EAAA,EAAAA,iBAAA,EAAAA,eAAc,KAsF1B,MAAM2zC,EAAS,IAAI,EAAA3lD,aAMnB,oBACI,YACanzB,EACAQ,EACFk1D,GAAsB,GAFpB,KAAA11D,UACA,KAAAQ,SACF,KAAAk1D,sBAYX,oBAAoBn+D,EAAWC,GAC3B,MAAMyf,EAAWnlB,KAAKkO,QAAQ8+D,+BAA+BvnE,EAAGC,GAC1DwH,EAAYlN,KAAKkO,QAAQ+4E,yBAAyBxhF,EAAGC,GACrDotC,EAA4B,GAElC,QAA0C9wC,IAAtChC,KAAKkO,QAAQ6U,qBAAoC,CACjD,MAAM,YAAE20D,EAAW,aAAEC,GAAiB33E,KAAKkO,QAAQsgC,OAC7C04C,EAAU/hE,EAAS1f,EAAIiyE,EAAc,GACrCyP,EAAUhiE,EAASzf,EAAIiyE,EAAe,GACtCyP,EAAgB,IAAIhoF,EAAMoG,QAAQ0hF,EAASC,GACjDnnF,KAAKkO,QAAQ6U,qBAAqBywB,iBAAiB4zC,EAAet0C,GAGtE,MAAMwyC,EAAmC,GACxBtlF,KAAKkO,QAAQqU,eAAeC,mBACpCniB,QAAQmiB,IACbA,EAAmBmvB,cAActxC,QAAQoiB,IACrCukE,EAAO13E,KAAKmT,EAAK0f,aACjB6kD,EAAOj5E,SAAS+E,IAAI9S,KAAKkO,QAAQ2sB,aAGjC,MAAMu4C,EAAe3wD,EAAK4wD,sBAC1B2T,EAAOj5E,SAAStI,GAAK2tE,OAEuBpxE,IAAxCglF,EAAOK,cAAcn6E,EAAU6C,MAC/B7C,EAAUo6E,iBAAiB7kE,EAAKme,SAAS,EAAM0kD,OAK3D,IAAK,MAAMiC,KAAajC,EAAY,CAChC,MAAMnyC,EAAyB,CAC3BvjC,KAAMyjC,EAAem0C,YACrBh2E,MAAO+1E,EAAU/1E,MACjBxC,SAAUu4E,EAAUv4E,SACpBy4E,aAAcF,GAGlB,QACkCvlF,IAA9BulF,EAAUzoF,OAAOgjB,eACqB9f,IAAtCulF,EAAUzoF,OAAOgjB,SAASC,QAC5B,CACE+wB,EAAY5sC,KAAKitC,GACjB,SAGJ,MAAMtxB,EAA+B0lE,EAAUzoF,OAAOgjB,SAASC,QAO/D,GANI/hB,KAAK4jE,sBACLzwB,EAAW7mB,UAAYi7D,EAAUzoF,OAAOgjB,SAASwK,WAGrDtsB,KAAK0nF,WAAW7lE,EAAa0lE,EAAWp0C,QAEXnxC,IAAzB6f,EAAY6e,SAAwB,CACpC,MAAM5a,EAC8B,IAAhCjE,EAAY6e,SAASp/B,OACf,EAAAmzE,aAAa5yD,EAAY6e,SAAS,SAClC1+B,EACVmxC,EAAWrtB,UAAYA,EAG3B,IAAImtB,EAEJ,OAAQpxB,EAAY0iE,cAChB,KAAK,EAAAoD,aAAa3yB,MAClB,KAAK,EAAA2yB,aAAar0C,KACdL,EAAiBI,EAAe2hB,MAChC,MACJ,KAAK,EAAA2yB,aAAapzD,KAClB,KAAK,EAAAozD,aAAaC,aAClB,KAAK,EAAAD,aAAaE,UAClB,KAAK,EAAAF,aAAaG,SACd70C,EAAiBI,EAAe9e,KAChC,MACJ,KAAK,EAAAozD,aAAaI,QAClB,KAAK,EAAAJ,aAAaK,gBACd/0C,EAAiBI,EAAe40C,KAChC,MACJ,KAAK,EAAAN,aAAalzD,SACdwe,EAAiBI,EAAe5e,SAChC,MACJ,QACIwe,EAAiBI,EAAem0C,YAGxCr0C,EAAWvjC,KAAOqjC,EAClBH,EAAY5sC,KAAKitC,GAOrB,OAJAL,EAAYlK,KAAK,CAACp/B,EAAeE,IACtBF,EAAEwF,SAAWtF,EAAEsF,UAGnB8jC,EAGH,WACJjxB,EACA0lE,EACAp0C,GAEA,QAA6BnxC,IAAzB6f,EAAY6e,SACZ,OAGJ,GAAIyS,EAAWs0C,aAAc3oF,kBAAkB,EAAAsmF,cAE3C,YADAjyC,EAAWrxB,SAAWD,EAAY6e,SAAS6mD,EAAU7sE,QAIzD,QAC2B1Y,IAAvB6f,EAAY4e,QACkB,IAA9B5e,EAAY4e,OAAOn/B,aACMU,IAAxBulF,EAAUW,gBAA+ClmF,IAApBulF,EAAU7sE,MAEhD,OAGJ,GAAkC,IAA9BmH,EAAY4e,OAAOn/B,OAEnB,YADA6xC,EAAWrxB,SAAWD,EAAY6e,SAAS,IAI/C,MAAMynD,OACsBnmF,IAAxBulF,EAAUW,UAAgD,EAAtBX,EAAUW,UAAgBX,EAAU7sE,MAG5E,IAAI0tE,EAAgB,EACpB,IAAK,MAAMC,KAAqBxmE,EAAY4e,OAAQ,CAChD,GAAI4nD,EAAoBF,EACpB,MAEJC,IAEJj1C,EAAWrxB,SAAWD,EAAY6e,SAAS0nD,EAAgB,M,qGC7PnE,cAmDA,SAAiB1R,GASG,EAAAC,YAAhB,SAA4BntE,EAAoBE,GAC5C,MAAMvD,EAA0B,GAChC,IAAK,MAAMklB,IAAU,CAAC7hB,EAAGE,GACrB,QAAe1H,IAAXqpB,EAIJ,IAAK,MAAMi9D,KAAcj9D,EAAQ,CAC7B,MAAMk9D,EAAepiF,EAAO+xB,KACxBswD,GACIA,EAASz5D,KAAOu5D,EAAWv5D,SACP/sB,IAAnBwmF,EAASxiF,OAAuBwiF,EAASxiF,QAAUsiF,EAAWtiF,YAGlDhE,IAAjBumF,EACApiF,EAAOD,KAAK,OAAD,UAAMoiF,KAEjBC,EAAaE,KAAO,EAAAngF,UAAUof,KAAK4gE,EAAWG,KAAMF,EAAaE,MACjEF,EAAaviF,MAAQ,EAAA4oE,eAAe0Z,EAAWtiF,MAAOuiF,EAAaviF,OACnEuiF,EAAaG,KAAO,EAAA9Z,eAAe0Z,EAAWI,KAAMH,EAAaG,OAI7E,OAAOviF,GAWK,EAAAwiF,aAAhB,SAA6BnkD,GACzB,GAA6B,IAAzBA,EAAcljC,OACd,MAAO,GAGX,MAAMsnF,EAAWpkD,EAAchS,OAAOwxD,GAAyB,KAAhBA,EAAMh+E,OACrD,OAAwB,IAApB4iF,EAAStnF,OACF,GAIP,KACAsnF,EACK7iF,IAAIi+E,I,MACD,MAAMh+E,EAAmB,QAAd,EAAGg+E,EAAMh+E,aAAK,QAAIg+E,EAAMj1D,GAC7BvJ,OAAsBxjB,IAAfgiF,EAAMyE,KAAqB,GAAGzE,EAAMyE,QAAQziF,IAAUA,EAC7D0iF,EAAO1E,EAAM0E,KACnB,OAAOA,EACD,YAAYA,gDAAmDljE,QAC/D,GAAGA,MAEZ4wD,KAAK,OAhEtB,CAAiB,EAAAM,gBAAA,EAAAA,cAAa,M,0GCnD9B,aAKA,OAeA,SACA,SACA,UAEA,SAAiBmS,GAOb,SAAgBC,EAAiB3nF,GAC7B,OAAO,IAAI,EAAAwE,QAAQ0D,KAAK0/E,OAAO5nF,EAAEsE,GAAI4D,KAAK0/E,OAAO5nF,EAAEuE,GAAI2D,KAAK0/E,OAAO5nF,EAAEyE,IAkFzE,SAAgBojF,EACZt6E,EACAu6E,GAEA,MACMC,GADoB,IAAI,EAAAx7E,SAAU4B,KAAKZ,EAAOyF,kBACtBkB,SAAS3G,EAAOuhE,oBACxCkZ,EAAS,IAAI,EAAAxjF,QAAQ,EAAG,EAAG,GAAGsM,aAAag3E,GAG3CG,EAAcN,EAAiBK,GAIrC,MAAO,CACHE,eAAgBH,EAChBI,SAAUF,EACVG,SALaT,EAAiBK,EAAOr2E,IAAIs2E,KAuDjD,SAAgBI,EACZj6B,GAKA,GAAIA,EAAUjuD,OAAS,EAAG,CACtB,MAAMH,EAAIouD,EAAU,GAEpB,GAAIpuD,QACA,MAAMsC,MAAM,8BAGhB,MAAMgmF,EAAc,IAAIroF,MAClBsoF,EAAiB,IAAItoF,MAErBuoF,EAAa,IAAIhqD,KACnB,IAAK,MAAMthC,KAASshC,EAAQ,CACxB,MAAMiqD,EAAQvgF,KAAK0/E,OAAO1qF,GAC1BqrF,EAAexjF,KAAK7H,EAAQurF,GAC5BH,EAAYvjF,KAAK0jF,KAInBC,EAAeC,IACjBH,EAAWG,EAAIrkF,EAAGqkF,EAAIpkF,EAAGokF,EAAIlkF,IAIjC,QAAe5D,IADFb,EACJyE,EACJ2pD,EAAwBlvD,QAAQypF,IAC7BD,EAAYC,SAEb,CACH,GAAIL,EAAYnoF,OAAS,GAAM,EAC3B,MAAMmC,MAAM,gCAEf8rD,EAAuBlvD,QAASxB,IAC7B8qF,EAAW9qF,KAInB,MAAO,CACHkrF,aAAc,IAAI,EAAAC,uBAAuBP,EAAa,GACtDQ,YAAa,IAAI,EAAAD,uBAAuBN,EAAgB,IAG5D,MAAO,CACHK,aAAc,IAAI,EAAAC,uBAAuB,GAAI,GAC7CC,YAAa,IAAI,EAAAD,uBAAuB,GAAI,IAaxD,SAAgBE,EACZ36B,EACAwqB,EACAoQ,EAAiB,GAEjB,MAAMC,EAAe,IAAIhpF,MAEnBwzC,EAAM2a,EAAUjuD,OAEtB,IAAK,IAAIlE,EAAI,EAAGA,EAAIw3C,EAAKx3C,GAAK28E,EAAQ,CAClC,IAAK,IAAI/3B,EAAI,EAAGA,EAAImoC,EAAgBnoC,IAChCooC,EAAalkF,KAAKqpD,EAAUnyD,EAAI4kD,IAGpC,MAAMv8C,EAAI8pD,EAAUnyD,EAAI+sF,GAClBzkF,EAAI6pD,EAAUnyD,EAAI+sF,EAAiB,GACnCvkF,EAAI2pD,EAAUnyD,EAAI+sF,EAAiB,GACnCE,EAAShhF,KAAK0/E,OAAOtjF,GACrB6kF,EAAS7kF,EAAI4kF,EACbE,EAASlhF,KAAK0/E,OAAOrjF,GACrB8kF,EAAS9kF,EAAI6kF,EACbE,EAASphF,KAAK0/E,OAAOnjF,GACrB8kF,EAAS9kF,EAAI6kF,EAGnBL,EAAalkF,KAAKmkF,EAAQE,EAAQE,EAAQH,EAAQE,EAAQE,GAE1D,IAAK,IAAI1oC,EAAImoC,EAAiB,EAAGnoC,EAAI+3B,EAAQ/3B,IACzCooC,EAAalkF,KAAKqpD,EAAUnyD,EAAI4kD,IAIxC,OAAOooC,EASX,SAAgBO,EACZ7rF,EACAywD,GAEA,MAAM90C,EAAa+uE,EAAiBj6B,GAKpC,OAHAzwD,EAAOqb,eAAes3C,aAAa,WAAYh3C,EAAWsvE,cAC1DjrF,EAAOqb,eAAes3C,aAAa,cAAeh3C,EAAWwvE,aAEtDxvE,EAAWsvE,aAAa/vE,SArQnB,EAAA8uE,iBAAgB,EAUhB,EAAA8B,aAAhB,SAA6BzpF,GACzB,MAAMkpF,EAAShhF,KAAK0/E,OAAO5nF,EAAEsE,GACvB8kF,EAASlhF,KAAK0/E,OAAO5nF,EAAEuE,GACvB+kF,EAASphF,KAAK0/E,OAAO5nF,EAAEyE,GAEvBilF,EAAW,IAAI,EAAAllF,QAAQxE,EAAEsE,EAAI4kF,EAAQlpF,EAAEuE,EAAI6kF,EAAQppF,EAAEyE,EAAI6kF,GAM/D,OAJAtpF,EAAEsE,EAAI4D,KAAK0/E,OAAOsB,GAClBlpF,EAAEuE,EAAI2D,KAAK0/E,OAAOwB,GAClBppF,EAAEyE,EAAIyD,KAAK0/E,OAAO0B,GAEXI,GA8DK,EAAA7B,6BAA4B,EA4B5B,EAAA8B,iBAAhB,SACIhsF,EACA4P,EACAq8E,GAEA,MAAMC,EAA0BhC,EAC5Bt6E,EACA5P,EAAOmxE,oBAELiZ,EAAM8B,EAAwB3B,eAEpC,QAAuBrnF,IAAnB+oF,IAAgCA,EAAeE,WAkB/C,MAAMxnF,MAAM,qDAjBZ,KACIsnF,EAAe/yE,UACf+yE,EAAe/yE,SAASkzE,OACxBH,EAAe/yE,SAASmzE,UACxBJ,EAAe/yE,SAASozE,kBAUxB,MAAM3nF,MAAM,+CARZsnF,EAAe/yE,SAASkzE,MAAM7sF,MAAQ,IAAImzB,aAAa03D,EAAIniD,UAC3DgkD,EAAe/yE,SAASmzE,SAAS9sF,MAAQ,IAAImzB,aACzCw5D,EAAwB1B,SAAS5G,WAErCqI,EAAe/yE,SAASozE,iBAAiB/sF,MAAQ,IAAImzB,aACjDw5D,EAAwBzB,SAAS7G,YAejC,EAAA8G,iBAAgB,EA8DhB,EAAAU,0BAAyB,EAyCzB,EAAAS,aAAY,EAiBZ,EAAAU,iBAAhB,SACI97B,GAEA,GAAIA,EAAUjuD,QAAU,EACpB,MAAO,CAAEiuD,UAAW,IAGxB,MAAMpuD,EAAIouD,EAAU,GAEpB,GAAIpuD,QACA,MAAMsC,MAAM,8BAGhB,MAAM6nF,EAAOnqF,EACb,QAAea,IAAXspF,EAAK5lF,QAA8B1D,IAAXspF,EAAK1lF,EAC7B,MAAO,CAAE2pD,UAAWA,GAGxB,MAAMg8B,EAAkB,IAAInqF,MAK5B,OAJCmuD,EAAwBlvD,QAAQypF,IAC7ByB,EAAgBrlF,KAAK4jF,EAAIrkF,EAAGqkF,EAAIpkF,EAAGokF,EAAIlkF,KAGpC,CAAE2pD,UAAWg8B,IASR,EAAAC,WAAhB,SACIC,EACApuE,GAEA,MAAMwO,OAAiC7pB,IAArBqb,EAAOwO,UAA0BxO,EAAOwO,UAAY,EAChE6/D,OAAmC1pF,IAAtBqb,EAAOquE,YAA2BruE,EAAOquE,WACtDC,OAAiC3pF,IAArBqb,EAAOsuE,WAA0BtuE,EAAOsuE,UAEpDp8B,EAAsB,GACtBm2B,EAAoB,GAE1B,EAAAkG,gBAAgBH,EAAe5/D,EAAW0jC,EAAWm2B,EAASgG,GAE9D,MAAMG,EAAiB,IAAI,EAAArxE,eACrBsxE,EAAc5B,EAA0B36B,EAAW,GACnD7+B,EAAS,IAAI,EAAAsgC,kBAAkB,IAAIx/B,aAAas6D,GAAc,GAE9DC,EAAoB,IAAI,EAAAlyE,2BAA2B6W,EAAQ,EAAG,GAAG,GACjEs7D,EAAuB,IAAI,EAAAnyE,2BAA2B6W,EAAQ,EAAG,GAAG,GAE1Em7D,EAAep6B,aAAa,WAAYs6B,GACxCF,EAAep6B,aAAa,cAAeu6B,GAC3CH,EAAen6B,SAAS,IAAI,EAAA53C,gBAAgB,IAAIwX,YAAYo0D,GAAU,IAEtE,MAAMuG,EAAkB,IAAI,EAAAr9D,0BAA0BvR,GAEhD6uE,EAAaP,EACb,IAAIQ,EAAIC,2BAA2BP,EAAgBI,GACnD,IAAIE,EAAIE,kBAAkBR,EAAgBI,GAIhD,OAFAC,EAAWI,oBAEJJ,GAUK,EAAAK,aAAhB,SACIC,EACAC,GAEA,MAAM/G,EAAoB,GAG1B,IAAK,IAAItoF,EAAI,EAAGA,EAAIovF,EAAelrF,OAAQlE,IACvCsoF,EAAQx/E,KAAKw/E,EAAQpkF,OAAS,GAGlC,MAAMorF,EAAmB,IAAI,EAAAlyE,eAEvBmyE,EAAmB,EAAAC,6BAA6BH,GAChDA,EACA,IAAI,EAAAI,2BAA2BJ,GAE/BK,EAAe,IAAIC,EAAIC,oBAAoBN,EAAkBC,GAMnE,OAJAhC,EAAamC,EAAcN,GAE3BM,EAAaR,oBAENQ,GArXf,CAAiB,EAAAjE,qBAAA,EAAAA,mBAAkB,M,sMCpBnC,SAAYoE,GAOR,yBAIA,uBAXJ,CAAY,EAAAA,oBAAA,EAAAA,kBAAiB,KA2B7B,SAAiBC,GAIb,IAAYC,GAAZ,SAAYA,GAER,iBAEA,qBAEA,+BAEA,2BAEA,2BAVJ,CAAYA,EAAA,EAAAA,cAAA,EAAAA,YAAW,KAoBP,EAAAC,YAAhB,SAA4BC,EAAaC,GACrC,OAAQA,EAAarvD,OACjB,KAAKivD,EAAgBC,YAAYI,IAC7B,OAAO,EACX,KAAKL,EAAgBC,YAAYK,MAC7B,OAAOH,IAAQC,EAAajvF,MAChC,KAAK6uF,EAAgBC,YAAYM,WAC7B,OAAOH,EAAajvF,MAAM+kD,WAAWiqC,GACzC,KAAKH,EAAgBC,YAAYO,SAC7B,OAAOJ,EAAajvF,MAAM0uB,SAASsgE,GACvC,QACI,OAAOA,EAAI16D,QAAQ26D,EAAajvF,QAAU,IAnC1D,CAAiB,EAAA6uF,kBAAA,EAAAA,gBAAe,KAgDhC,SAAYS,GACR,yBACA,qBACA,+BACA,yBAJJ,CAAY,EAAAA,kBAAA,EAAAA,gBAAe,KAoId,EAAAC,8BAAgC,mBAOhC,EAAAC,uBAAyB,a,+FCzNtC,cAEA,MAAaC,UAAgB,EAAAC,KACzB,YAAYptD,EAAwB/c,GAChC5gB,MAAM29B,EAAY/c,IAF1B,a,sGCKA,0BAA+Bjb,GAC3B,GAAIvH,MAAMC,QAAQsH,GAAW,CACzB,MAAOP,EAAWD,EAAUE,GAAYM,EACxC,MACyB,iBAAdP,GACa,iBAAbD,SACOnG,IAAbqG,GAA8C,iBAAbA,GAG1C,OAAO,I,oGCHX,wBAA6BvJ,GACzB,OAAOA,GAAgC,iBAAfA,EAAO2J,KAA0C,iBAAf3J,EAAO4J,M,uJCfrE,cACA,OAEA,QACA,OACA,QAEA,QACA,QAEA,OAEA,kBAAMslF,UAAkC,EAAAn0D,WAAxC,c,oBAKa,KAAAjqB,KAAuB,EAAAC,eAAeC,OAG/C,eAAe0rB,GACX,OAAO,EAIX,YACIrG,EACAE,EACAlvB,GAWA,OATKA,IACDA,EAAU,IAAI/G,EAAMm7B,MAExBp0B,EAAOyD,IAAInE,EAAI,EACfU,EAAOyD,IAAIlE,EAAI,EACfS,EAAOyD,IAAIhE,EAAIuvB,EACfhvB,EAAO2D,IAAIrE,EAAIzF,KAAKilB,UACpB9e,EAAO2D,IAAIpE,EAAI1F,KAAKilB,UAAY,EAChC9e,EAAO2D,IAAIlE,EAAIyvB,EACRlvB,EAIX,aACIwC,EACAxC,GAyBA,YAvBenE,IAAXmE,IAYAA,EAAS,CAAEV,EAAG,EAAGC,EAAG,EAAGE,EAAG,IAE9BO,EAAOV,GACFrG,EAAMkJ,UAAUW,SAASN,EAASP,WAAaiB,KAAKyF,IACrDk/E,EAA0BC,gBAC1BjuF,KAAKilB,UACT9e,EAAOT,GACFtG,EAAMkJ,UAAUW,SAASN,EAASR,UAAsB,GAAVkB,KAAKyF,IACpDk/E,EAA0BC,gBAC1BjuF,KAAKilB,UACT9e,EAAOP,EAAI+C,EAASN,UAAY,EACzBlC,EAIX,eAAek0B,GAOX,OANiB,EAAAnyB,eAAeyyB,YAC3BN,EAAW30B,EAAIsoF,EAA0BE,gBAAmBluF,KAAKilB,UACpD,GAAV5b,KAAKyF,GACRurB,EAAW50B,EAAIuoF,EAA0BE,gBAAmBluF,KAAKilB,UAAY5b,KAAKyF,GACnFurB,EAAWz0B,GAMnB,kBAAkBy0B,GACd,OAAOA,EAAWz0B,EAItB,WACIswB,EACA/vB,GAEA,MAAM00B,EAAc76B,KAAKyQ,aACrB,IAAI,EAAAvI,eAAeguB,EAAOjZ,OAAO9U,SAAU+tB,EAAOjZ,OAAO7U,UAAW,KAElE,sBAAE+lF,EAAqB,uBAAEC,EAAsB,aAAEh5D,GAAiBc,EAClEm4D,EAAQD,EAAyBJ,EAA0BC,gBAC3DK,EAAQH,EAAwBH,EAA0BC,gBA2BhE,OA1BK9nF,IACDA,EAAU,IAAI/G,EAAMm7B,MAEpB,EAAAU,WAAW90B,IACXA,EAAOyD,IAAInE,EAAIo1B,EAAYp1B,EAAY,GAAR4oF,EAAcruF,KAAKilB,UAClD9e,EAAOyD,IAAIlE,EAAIm1B,EAAYn1B,EAAY,GAAR4oF,EAActuF,KAAKilB,UAClD9e,EAAO2D,IAAIrE,EAAIo1B,EAAYp1B,EAAY,GAAR4oF,EAAcruF,KAAKilB,UAClD9e,EAAO2D,IAAIpE,EAAIm1B,EAAYn1B,EAAY,GAAR4oF,EAActuF,KAAKilB,eAC7BjjB,IAAjBozB,GACAjvB,EAAOyD,IAAIhE,EAAIi1B,EAAYj1B,EAAmB,GAAfwvB,EAC/BjvB,EAAO2D,IAAIlE,EAAIi1B,EAAYj1B,EAAmB,GAAfwvB,IAE/BjvB,EAAOyD,IAAIhE,EAAI,EACfO,EAAO2D,IAAIlE,EAAI,IAEZ,EAAAs1B,mBAAmB/0B,KAC1B,EAAAmC,UAAUyB,WAAW,EAAG,EAAG,EAAG5D,EAAOyH,OACrC,EAAAtF,UAAUyB,WAAW,EAAG,EAAG,EAAG5D,EAAO0H,OACrC,EAAAvF,UAAUyB,WAAW,EAAG,EAAG,EAAG5D,EAAO2H,OACrC3H,EAAO4H,SAAStI,EAAIo1B,EAAYp1B,EAChCU,EAAO4H,SAASrI,EAAIm1B,EAAYn1B,EAChCS,EAAO4H,SAASnI,EAAIi1B,EAAYj1B,EAChCO,EAAO6e,QAAQvf,EAAY,GAAR4oF,EAAcruF,KAAKilB,UACtC9e,EAAO6e,QAAQtf,EAAY,GAAR4oF,EAActuF,KAAKilB,UACtC9e,EAAO6e,QAAQpf,EAAIyD,KAAKS,IAAIge,OAAOqT,QAA+B,IAArB/F,GAAgB,KAE1DjvB,EAIX,aAAai1B,GACT,MAAMC,EAASr7B,KAAKmW,eAAeilB,EAASxxB,KACtC0xB,EAASt7B,KAAKmW,eAAeilB,EAAStxB,KAC5C,OAAO,EAAA+qB,OAAO0G,gBAAgBF,EAAQC,GAI1C,eAAejB,GACX,OAAOA,EAAWz0B,EAItB,oBAAoBy0B,GAEhB,OADAA,EAAWz0B,EAAI,EACRy0B,EAIX,cAAcmB,EAA0BjmB,GAQpC,YAPevT,IAAXuT,EACAA,EAAS,CAAE9P,EAAG,EAAGC,EAAG,EAAGE,EAAG,IAE1B2P,EAAO9P,EAAI,EACX8P,EAAO7P,EAAI,EACX6P,EAAO3P,EAAI,GAER2P,GAEf,OAjJW,EAAA04E,gBAA0B,GAAO,EAAM5kF,KAAKyF,IAC5C,EAAAo/E,gBAA2B,EAAM7kF,KAAKyF,GAAM,EAgJvD,GAlJA,GAwJa,EAAAy/E,oCAAkD,IAAIP,EAA0B,GAMhF,EAAAQ,0BAAwC,IAAIR,EACrD,EAAAhhF,eAAe+J,2B,8IC3KnB,cACA,OAEA,QACA,OACA,QAEA,QACA,QAEA,OAQA,MAAM03E,UAAqC,EAAA50D,WAiDvC,YAAqB5U,GACjBjiB,MAAMiiB,GADW,KAAAA,YALZ,KAAArV,KAAuB,EAAAC,eAAeC,OAEvC,KAAA4+E,OAAiB,EACjB,KAAAC,UAAoB,EAhC5B,qBAAqBhmF,EAA8BimF,GAC/C,MAAMnmF,EAAME,EAASR,SACf0mF,EAAMlmF,EAASP,UAEflK,EAAI4wF,EAAwBC,YAC5BC,EAAMF,EAAwBG,eAE9BC,EAAiB7lF,KAAKggC,MAAMwlD,EAAM,IAClCM,EAA4B,GAAjBD,EAAsBL,EACvC,GAAIK,EAAiB,GAAM,GAAK7lF,KAAK2S,IAAImzE,GAAYjxF,EACjD,OAAOyK,EAGX,MAAMymF,EAAW3mF,EAAM,EACjB4mF,EAAmBF,EAAWA,EAAWC,EAAWA,EAC1D,GAAIC,EAAmBL,EAAK,CACxB,MAAMM,EAAiBjmF,KAAK+H,KAAKi+E,GAC3BvuC,GAAS5iD,EAAIoxF,GAAkBA,EAG/BC,EAAM,EACNC,EAAyB,IAAbL,GAA+B,IAAbC,EAAiBlxF,EAAIqxF,EAAMJ,EAC/D,OAAO,IAAI,EAAAjnF,eAAeO,EAAM2mF,EAAWtuC,EAAO+tC,EAAMW,EAAY1uC,GAGxE,OAAOn4C,EAcX,eAAe0xB,GACX,OAAOhxB,KAAKixB,KAA6C,GAAvCD,EAAW50B,EAAIzF,KAAKilB,UAAY,IAAW5b,KAAKyF,IAItE,YACIqmB,EACAE,EACAlvB,GAWA,OATKA,IACDA,EAAU,IAAI/G,EAAMm7B,MAExBp0B,EAAOyD,IAAInE,EAAI,EACfU,EAAOyD,IAAIlE,EAAI,EACfS,EAAOyD,IAAIhE,EAAIuvB,EACfhvB,EAAO2D,IAAIrE,EAAIzF,KAAKilB,UACpB9e,EAAO2D,IAAIpE,EAAI1F,KAAKilB,UACpB9e,EAAO2D,IAAIlE,EAAIyvB,EACRlvB,EAIX,aACIwC,EACAxC,GAEKA,IAEDA,EAAS,CAAEV,EAAG,EAAGC,EAAG,EAAGE,EAAG,IAG9B,MAAM6pF,EAAUhB,EAA6BiB,cAAc/mF,EAAU3I,KAAKilB,WACpE0qE,EAAYF,EAAQrnF,UAAY,IAAM,GACtCyb,EAAuB,IAAd8rE,EAAkB,EAAItmF,KAAKmtB,MAAMm5D,GAC1CC,EAAMxwF,EAAMkJ,UAAUW,SAASwmF,EAAQtnF,UACvC0nF,EAASzwF,EAAMkJ,UAAUW,SAASwmF,EAAQrnF,UAAqB,IAATyb,GAAgB7jB,KAAK2uF,UAE3EmB,EAAIzmF,KAAKkH,IAAIq/E,GAAOvmF,KAAKsH,IAAIk/E,GAEnC1pF,EAAOV,EAAI4D,KAAK0mF,MAAMD,GACtB3pF,EAAOT,EAAI2D,KAAKmN,MAAMnN,KAAKsJ,IAAIi9E,GAAMvmF,KAAKkH,IAAIs/E,IAAW7vF,KAAK0uF,OAE9D,MAAMsB,EAAW,GAAM3mF,KAAKyF,GAM5B,OALA3I,EAAOV,EACHzF,KAAKilB,WAAa7lB,EAAMkJ,UAAU6B,MAAMhE,EAAOV,EAAIuqF,EAAW,GAAK,EAAG,GAAKnsE,GAC/E1d,EAAOT,EAAI1F,KAAKilB,UAAY7lB,EAAMkJ,UAAU6B,MAAMhE,EAAOT,EAAIsqF,EAAW,GAAK,EAAG,GAEhF7pF,EAAOP,EAAI+C,EAASN,UAAY,EACzBlC,EAIX,eAAek0B,GACX,MAAM41D,EAAgB,EAAV5mF,KAAKyF,GACXohF,EAAK71D,EAAW50B,EAAIzF,KAAKilB,UACzBkrE,EAAK91D,EAAW30B,EAAI1F,KAAKilB,UACzBpB,EAAgB,IAAPqsE,EAAW,EAAI7mF,KAAKmtB,MAAM05D,GACnCzqF,EAAIwqF,GAAOC,EAAK,GAAMrsE,GACtBne,EAAIuqF,GAAOE,EAAK,IAChBvqF,EAAIy0B,EAAWz0B,GAAK,EAEpBwqF,EAAI1qF,EAAI1F,KAAK0uF,OAEbkB,EAAMvmF,KAAK4U,KAAK5U,KAAKsH,IAAIy/E,GAAK/mF,KAAKixB,KAAK70B,IACxCoqF,EAAS7vF,KAAK2uF,UAAYtlF,KAAKmN,MAAMnN,KAAKgnF,KAAK5qF,GAAI4D,KAAKkH,IAAI6/E,IAAMvsE,EAASosE,EAGjF,OADiB,EAAA/nF,eAAeyyB,YAAYi1D,EAAKC,EAAQjqF,GAK7D,WACIswB,EACA/vB,GAEA,MAAM,MAAEqW,EAAK,MAAEC,EAAK,KAAEG,EAAI,KAAEC,GAASqZ,EAE/Bo6D,EAAgB,CAClBp6D,EAAOjZ,OACPiZ,EAAOnB,UACPmB,EAAOpB,UACP,IAAI,EAAA5sB,eAAeuU,EAAOG,GAC1B,IAAI,EAAA1U,eAAesU,EAAOK,IAGxB0zE,EAAIzB,EAAwB0B,cAG5BC,EAAkB5zE,EAAO,IAAMD,EAAO,GACtC8zE,EAAkB7zE,EAAO,GAAKD,EAAO,EACrC+zE,EAAkB9zE,EAAO0zE,GAAK3zE,GAAQ2zE,GAAK/zE,EAAQ,GAAKC,EAAQ,EAH9CI,GAAQ,IAAMD,GAAQ,KAM1C0zE,EAAcpqF,KAAK,IAAI,EAAAgC,eAAesU,GAAQ,KAC9C8zE,EAAcpqF,KAAK,IAAI,EAAAgC,eAAeuU,GAAQ,MAG9Cg0E,IACAH,EAAcpqF,KAAK,IAAI,EAAAgC,eAAesU,EAAO,KAC7C8zE,EAAcpqF,KAAK,IAAI,EAAAgC,eAAeuU,EAAO,MAG7Ci0E,IACAJ,EAAcpqF,KAAK,IAAI,EAAAgC,eAAesU,EAAO,IAC7C8zE,EAAcpqF,KAAK,IAAI,EAAAgC,eAAeuU,EAAO,KAG7Ck0E,IACAL,EAAcpqF,KAAK,IAAI,EAAAgC,eAAe,EAAG2U,IACzCyzE,EAAcpqF,KAAK,IAAI,EAAAgC,eAAe,EAAG0U,KAG7CkyE,EAAwB8B,cAAcN,EAAeA,EAAc,IAEnE,MAAMO,EAAYP,EAAcvqF,IAAI7G,GAAKc,KAAKyQ,aAAavR,IACrD4xF,EAAKD,EAAU9qF,IAAI7G,GAAKA,EAAEuG,GAC1BsrF,EAAKF,EAAU9qF,IAAI7G,GAAKA,EAAEwG,GAC1BsrF,EAAKH,EAAU9qF,IAAI7G,GAAKA,EAAE0G,GAE1BkvC,EAAOzrC,KAAKO,OAAOknF,GACnB97C,EAAO3rC,KAAKO,OAAOmnF,GACnBE,EAAO5nF,KAAKO,OAAOonF,GACnBj8C,EAAO1rC,KAAKS,OAAOgnF,GACnBh1D,EAAOzyB,KAAKS,OAAOinF,GACnBG,EAAO7nF,KAAKS,OAAOknF,GAKzB,GAHK7qF,IACDA,EAAU,IAAI/G,EAAMm7B,MAEpB,EAAAU,WAAW90B,GACXA,EAAOyD,IAAInE,EAAIqvC,EACf3uC,EAAOyD,IAAIlE,EAAIsvC,EACf7uC,EAAOyD,IAAIhE,EAAIqrF,EACf9qF,EAAO2D,IAAIrE,EAAIsvC,EACf5uC,EAAO2D,IAAIpE,EAAIo2B,EACf31B,EAAO2D,IAAIlE,EAAIsrF,MACZ,KAAI,EAAAh2D,mBAAmB/0B,GAW1B,MAAM,IAAI1C,MAAM,wBAVhB,EAAA6E,UAAUyB,WAAW,EAAG,EAAG,EAAG5D,EAAOyH,OACrC,EAAAtF,UAAUyB,WAAW,EAAG,EAAG,EAAG5D,EAAO0H,OACrC,EAAAvF,UAAUyB,WAAW,EAAG,EAAG,EAAG5D,EAAO2H,OACrC3H,EAAO4H,SAAStI,GAAKqvC,EAAOC,GAAQ,EACpC5uC,EAAO4H,SAASrI,GAAKsvC,EAAOlZ,GAAQ,EACpC31B,EAAO4H,SAASnI,GAAKqrF,EAAOC,GAAQ,EACpC/qF,EAAO6e,QAAQvf,GAAKsvC,EAAOD,GAAQ,EACnC3uC,EAAO6e,QAAQtf,GAAKo2B,EAAOkZ,GAAQ,EACnC7uC,EAAO6e,QAAQpf,GAAKsrF,EAAOD,GAAQ,EAIvC,OAAO9qF,EAuBX,aAAai1B,GACT,MAAMj8B,EAAIa,KAAKilB,UAETrb,EAAMwxB,EAASxxB,IACfE,EAAMsxB,EAAStxB,IACfwmF,EAAgB,CAClB,CAAE7qF,GAAImE,EAAInE,EAAIqE,EAAIrE,GAAK,EAAGC,GAAIkE,EAAIlE,EAAIoE,EAAIpE,GAAK,EAAGE,EAAG,GACrDgE,EACAE,EACA,CAAErE,EAAGmE,EAAInE,EAAGC,EAAGoE,EAAIpE,EAAGE,EAAG,GACzB,CAAEH,EAAGqE,EAAIrE,EAAGC,EAAGkE,EAAIlE,EAAGE,EAAG,IAGvBqX,EAAS,GAAM9d,EACfgyF,EAAS,IAAOhyF,EAChBiyF,EAAS,IAAOjyF,EAEhBuxF,EAAkB9mF,EAAInE,EAAIwX,GAAUnT,EAAIrE,EAAIwX,EAC5C0zE,EAAkB/mF,EAAIlE,EAAIuX,GAAUnT,EAAIpE,EAAIuX,EAC5Co0E,EAAkBznF,EAAIlE,EAAIyrF,GAAUrnF,EAAIpE,EAAIyrF,EAC5CG,EAAkB1nF,EAAIlE,EAAI0rF,GAAUtnF,EAAIpE,EAAI0rF,EAE9CT,IACAL,EAAcpqF,KAAK,CAAET,EAAGmE,EAAInE,EAAGC,EAAGuX,EAAQrX,EAAG,IAC7C0qF,EAAcpqF,KAAK,CAAET,EAAGqE,EAAIrE,EAAGC,EAAGuX,EAAQrX,EAAG,IAEzC8qF,GACAJ,EAAcpqF,KAAK,CAAET,EAAGwX,EAAQvX,EAAGuX,EAAQrX,EAAG,KAGlDyrF,IACAf,EAAcpqF,KAAK,CAAET,EAAGmE,EAAInE,EAAGC,EAAGyrF,EAAQvrF,EAAG,IAC7C0qF,EAAcpqF,KAAK,CAAET,EAAGqE,EAAIrE,EAAGC,EAAGyrF,EAAQvrF,EAAG,IAEzC8qF,GACAJ,EAAcpqF,KAAK,CAAET,EAAGwX,EAAQvX,EAAGyrF,EAAQvrF,EAAG,KAGlD0rF,IACAhB,EAAcpqF,KAAK,CAAET,EAAGmE,EAAInE,EAAGC,EAAG0rF,EAAQxrF,EAAG,IAC7C0qF,EAAcpqF,KAAK,CAAET,EAAGqE,EAAIrE,EAAGC,EAAG0rF,EAAQxrF,EAAG,IAEzC8qF,GACAJ,EAAcpqF,KAAK,CAAET,EAAGwX,EAAQvX,EAAG0rF,EAAQxrF,EAAG,KAItD,MAAMipE,EAAYyhB,EAAcvqF,IAAI7G,GAAKc,KAAKmW,eAAejX,IAC7D4vF,EAAwByC,eAAe1iB,EAAWA,EAAU,IAE5D,MAAM2iB,EAAY3iB,EAAU9oE,IAAI8nB,GAAKA,EAAE1lB,UACjCspF,EAAa5iB,EAAUr8C,OAAO3E,GAAKxkB,KAAK2S,IAAI6R,EAAE1lB,UAAY,IAAIpC,IAAI8nB,GAAKA,EAAEzlB,WACzEspF,EAAY7iB,EAAU9oE,IAAI8nB,GAAKA,EAAExlB,UAAY,GAE7CgzB,EAAS,IAAI,EAAAnzB,eACfmB,KAAKO,OAAO4nF,GACZnoF,KAAKO,OAAO6nF,GACZpoF,KAAKO,OAAO8nF,IAGVp2D,EAAS,IAAI,EAAApzB,eACfmB,KAAKS,OAAO0nF,GACZnoF,KAAKS,OAAO2nF,GACZpoF,KAAKS,OAAO4nF,IAIhB,OADe,EAAA78D,OAAO0G,gBAAgBF,EAAQC,GAKlD,kBAAkBjB,GACd,OAAOA,EAAWz0B,EAItB,eAAey0B,GACX,OAAOA,EAAWz0B,EAItB,oBAAoBy0B,GAEhB,OADAA,EAAWz0B,EAAI,EACRy0B,EAIX,cAAcmB,EAA0BjmB,GAQpC,YAPevT,IAAXuT,EACAA,EAAS,CAAE9P,EAAG,EAAGC,EAAG,EAAGE,GAAI,IAE3B2P,EAAO9P,EAAI,EACX8P,EAAO7P,EAAI,EACX6P,EAAO3P,GAAK,GAET2P,GAIf,kBAAau5E,EAaT,qBAAqBx9E,EAA8BqgF,GAG/C,IAAK,MAAMngF,KAASF,EACO,IAAnBE,EAAMrJ,WACNqJ,EAAMrJ,SAJE,KAISwpF,EAAexpF,UAW5C,sBAAsBmJ,EAA8BqgF,GAChD,MAAMC,EAAMD,EAAevpF,UAAY,EAAI,KAAO,IAC5CypF,EAAOF,EAAevpF,UAAY,GAAK,IAAM,IAEnD,IAAK,MAAMoJ,KAASF,EACZE,EAAMpJ,YAAcwpF,IACpBpgF,EAAMpJ,UAAYypF,IAIlC,OAtCW,EAAAC,UAAoB,mBACpB,EAAAtB,cAAwBpxF,EAAMkJ,UAAUC,SAASumF,EAAwBgD,WACzE,EAAA/C,YAAsB,GAAKD,EAAwB0B,cACnD,EAAAvB,eAAyB5lF,KAAK2N,IAAI83E,EAAwBC,YAAa,GAmClF,GAvCA,GAAa,EAAAD,0BA6CA,EAAAiD,6BAA2C,IAAItD,EACxD,EAAAzhF,eAAe+J,2B,oHC9XnB,aAMA,qCAYI,YACai7E,EACAl+D,EAAuB,EACvBC,EAAuB,GAFvB,KAAAi+D,eACA,KAAAl+D,eACA,KAAAC,eAET/zB,KAAKiyF,eAAiBD,EACtBhyF,KAAKkyF,WAAaF,EAAa7iF,WAAWq3B,YAAY1S,EAAcC,GACpE,MAAM,IAAEnqB,EAAG,IAAEE,GAAQ9J,KAAKkyF,WAC1BlyF,KAAKmyF,kBAAoB,CAAE1sF,EAAGqE,EAAIrE,EAAImE,EAAInE,EAAGC,EAAGoE,EAAIpE,EAAIkE,EAAIlE,EAAGE,EAAGkE,EAAIlE,EAAIgE,EAAIhE,GAMlF,iBACI,OAAO5F,KAAKiyF,eAAe9iF,WAM/B,wBACI,OAAOnP,KAAKiyF,eAAev8D,kBAiB/B,YAAY9R,EAAkBzd,GAC1B,MAAMyV,EAAQgI,EAAQhI,MAChBw2E,EAAkBpyF,KAAK01B,kBAAkB28D,mBAAmBz2E,GAC5D02E,EAAkBtyF,KAAK01B,kBAAkB68D,mBAAmB32E,GAC5DyyE,EAAQruF,KAAKmyF,kBAAkB1sF,EAAI2sF,EACnC9D,EAAQtuF,KAAKmyF,kBAAkBzsF,EAAI4sF,EACnCE,EAAUxyF,KAAKkyF,WAAWtoF,IAAInE,EAAI4oF,EAAQzqE,EAAQqY,OAClDw2D,EAAUzyF,KAAKkyF,WAAWtoF,IAAIlE,EAAI4oF,EAAQ1qE,EAAQoY,IAYxD,OAVK71B,IACDA,EAAS,IAAI/G,EAAMm7B,MAGvBp0B,EAAOyD,IAAInE,EAAI+sF,EACfrsF,EAAOyD,IAAIlE,EAAI+sF,EACftsF,EAAOyD,IAAIhE,EAAI5F,KAAKkyF,WAAWtoF,IAAIhE,EACnCO,EAAO2D,IAAIrE,EAAI+sF,EAAUnE,EACzBloF,EAAO2D,IAAIpE,EAAI+sF,EAAUnE,EACzBnoF,EAAO2D,IAAIlE,EAAI5F,KAAKkyF,WAAWpoF,IAAIlE,EAC5BO,EAcX,UAAUyd,GACN,MAAMwX,EAAWp7B,KAAKq2B,YAAYzS,GAClC,OAAO5jB,KAAKmP,WAAWujF,aAAat3D,M,qHC5E/B,EAAAu3D,8BAAmD,IAtBhE,MACI,kBACI,OAAO,EAEX,gBAAgB/2E,GACZ,OAAiB,IAAVA,EAAc,EAAI,EAE7B,mBAAmBA,GAEf,OAAO,GAAKA,EAEhB,mBAAmBA,GAEf,OAAiB,IAAVA,EAAc,GAAMA,EAAQ,EAAK,K,gGCfhD,cAEA,MAAag3E,EACT,YAAmBhvE,EAAyByqE,EAAsBC,GAA/C,KAAA1qE,UAAyB,KAAAyqE,QAAsB,KAAAC,QAElE,CAACnwF,OAAO00F,YACJ,OAAsB,IAAf7yF,KAAKquF,OAA8B,IAAfruF,KAAKsuF,MAC1BsE,EAASE,eAAe9yF,KAAK4jB,SAC7BgvE,EAASG,kBAAkB/yF,KAAK4jB,QAAS5jB,KAAKquF,MAAOruF,KAAKsuF,QANxE,aAUA,SAAiBsE,GACI,EAAAG,kBAAjB,UACIC,EACA3E,EACAC,GAEA,IAAK,IAAI5oF,EAAI,EAAGA,EAAI4oF,EAAO5oF,IACvB,IAAK,IAAID,EAAI,EAAGA,EAAI4oF,EAAO5oF,UACjB,EAAA+e,QAAQ8X,mBACV02D,EAAUh3D,IAAMsyD,EAAQ5oF,EACxBstF,EAAU/2D,OAASoyD,EAAQ5oF,EAC3ButF,EAAUp3E,MAAQ,IAMjB,EAAAk3E,eAAjB,UAAgCE,GAE5B,IAAK,IAAI51F,EAAI,EAAGA,EAAI,EAAGA,UACb,EAAAonB,QAAQ8X,mBACT02D,EAAUh3D,KAAO,EAAM5+B,GAAK,EAC5B41F,EAAU/2D,QAAU,EAAU,EAAJ7+B,EAC3B41F,EAAUp3E,MAAQ,IAvBlC,CAAiBg3E,EAAA,EAAAA,WAAA,EAAAA,SAAQ,M,oGCXzB,aAGA,QAGA,MAAa58D,EACT,+BACIg8D,EACArpF,EACAiT,GAEA,MACMye,EADa23D,EAAa7iF,WACFsB,aAAa9H,GAE3C,OAAO3I,KAAKizF,0BAA0BjB,EAAc33D,EAAYze,GAGpE,iCACIo2E,EACA33D,EACAze,GAEA,MAAMzM,EAAa6iF,EAAa7iF,WAC1BumB,EAAoBs8D,EAAat8D,kBAEjCw9D,EAAKx9D,EAAkB28D,mBAAmBz2E,GAC1Cu3E,EAAKz9D,EAAkB68D,mBAAmB32E,IAE1C,IAAEhS,EAAG,IAAEE,GAAQqF,EAAWq3B,YAAY,EAAG,GACzC4sD,EAAatpF,EAAIrE,EAAImE,EAAInE,EACzB4tF,EAAavpF,EAAIpE,EAAIkE,EAAIlE,EAE/B,GAAI20B,EAAW50B,EAAImE,EAAInE,GAAK40B,EAAW50B,EAAIqE,EAAIrE,EAC3C,OAAO,KAGX,GAAI40B,EAAW30B,EAAIkE,EAAIlE,GAAK20B,EAAW30B,EAAIoE,EAAIpE,EAC3C,OAAO,KAGX,MAAMu2B,EAAS5yB,KAAKO,IAAIspF,EAAK,EAAG7pF,KAAKmtB,MAAO08D,GAAM74D,EAAW50B,EAAImE,EAAInE,GAAM2tF,IACrEp3D,EAAM3yB,KAAKO,IAAIupF,EAAK,EAAG9pF,KAAKmtB,MAAO28D,GAAM94D,EAAW30B,EAAIkE,EAAIlE,GAAM2tF,IAExE,OAAO,EAAA7uE,QAAQ8X,mBAAmBN,EAAKC,EAAQrgB,GAGnD,8BACIo2E,EACA97D,EACAta,GAEA,MAAM03E,EAAO,CAACj1F,EAAek1F,EAAeC,IACpCn1F,EAAQk1F,EACDC,GAAUD,EAAQl1F,IAAUm1F,EAAQD,GAGxCA,GAAUl1F,EAAQk1F,IAAUC,EAAQD,GAGzCppF,EAAQ,CAAC1E,EAAWguF,EAAgBC,IAC/BrqF,KAAKO,IAAIP,KAAKS,IAAIrE,EAAGguF,GAASC,GAInCC,EAAqBL,EAAKp9D,EAAOpB,UAAU8+D,oBAAqBvqF,KAAKyF,GAAIzF,KAAKyF,IAC9E+kF,EAAoB1pF,EACtB+rB,EAAOpB,UAAU4F,mBACL,GAAVrxB,KAAKyF,GACG,GAAVzF,KAAKyF,IAEHglF,EAAqBR,EAAKp9D,EAAOnB,UAAU6+D,oBAAqBvqF,KAAKyF,GAAIzF,KAAKyF,IAC9EilF,EAAoB5pF,EACtB+rB,EAAOnB,UAAU2F,mBACL,GAAVrxB,KAAKyF,GACG,GAAVzF,KAAKyF,IAEHklF,EAAah+D,EAAaC,wBAC5B+7D,EACA,EAAA9pF,eAAeyyB,YAAYk5D,EAAmBF,GAC9C/3E,GAEEq4E,EAAaj+D,EAAaC,wBAC5B+7D,EACA,EAAA9pF,eAAeyyB,YAAYo5D,EAAmBD,GAC9Cl4E,GAEEs4E,EAAclC,EAAat8D,kBAAkB28D,mBAAmBz2E,GAEtE,IAAKo4E,IAAeC,EAChB,MAAM,IAAIxwF,MAAM,uBAGpB,MAAM0wF,EAAYH,EAAW/3D,OAC7B,IAAIm4D,EAAYH,EAAWh4D,OAGvB03D,EAAqBG,IAEjBM,GADAA,IAAcD,EACDD,EAGAA,EAAc,GAInC,MAAMG,EAAShrF,KAAKO,IAAIoqF,EAAWh4D,IAAKi4D,EAAWj4D,KAC7Cs4D,EAASjrF,KAAKS,IAAIkqF,EAAWh4D,IAAKi4D,EAAWj4D,KAE7C4/B,EAAO,IAAIx6D,MAEjB,IAAK,IAAI46B,EAAMq4D,EAAQr4D,GAAOs4D,IAAUt4D,EACpC,IAAK,IAAIC,EAASk4D,EAAWl4D,GAAUm4D,IAAan4D,EAChD2/B,EAAK11D,KAAK,EAAAse,QAAQ8X,mBAAmBN,EAAKC,EAASi4D,EAAat4E,IAIxE,OAAOggD,GA/Gf,kB,wGCNA,cAGA,yBAGI,YAAYlmC,GACR11B,KAAKu0F,oBAAsB7+D,EAG/B,SAAS9R,GACL,MAAM4wE,EAAOx0F,KAAKu0F,oBAAoBE,gBAAgB7wE,EAAQhI,OACxD84E,EAAO10F,KAAKu0F,oBAAoBI,gBAAgB/wE,EAAQhI,OAE9D,OAAO,IAAI,EAAAg3E,SAAShvE,EAAS4wE,EAAME,M,yICf3C,aAOA,OACA,OAOA,IAAYE,GAAZ,SAAYA,GACR,mBACA,yBACA,2BAHJ,CAAYA,EAAA,EAAAA,yBAAA,EAAAA,uBAAsB,KAiBlC,iCAuBI,YAAoB/b,GAAA,KAAAA,YAnBpB,KAAA75D,SAAmB,EAInB,KAAA61E,SAnB+B,IAqBvB,KAAA31B,eApBmB,GAqBnB,KAAA41B,gBAA0B,EAG1B,KAAAC,UAA6C,IAAI5yF,IACjD,KAAA6yF,QAAkCJ,EAAuBK,KACzD,KAAAC,aAAuB,EAY/B,mBACI,OAAOl1F,KAAK80F,eAQhB,iBAAiBK,GACbn1F,KAAK80F,eAAiBK,EACtBn1F,KAAK60F,SAlDsB,IAwD/B,mBACI,OAAO70F,KAAKk/D,eAWhB,uBAAuB5yC,EAAsBlqB,GACzC,IAAK,EAAA4sB,2BAA2B1C,GAC5B,OAAO,EAOX,GAJI,iBAAkBA,IAClBtsB,KAAKk/D,eAAkB5yC,EAAkBvM,cAGzC/f,KAAKo1F,aACL,OAAOp1F,KAAKgf,aAG2Bhd,IAAvCsqB,EAAU28B,2BACVjpD,KAAK60F,SAAWvoE,EAAU28B,0BAG9B,MAAMosC,EAAwB,EAAAnoE,iBAAiBZ,EAAU48B,iBAAkB9mD,GAE3E,OAA8B,OAA1BizF,EACOr1F,KAAKgf,QAGwB,kBAA1Bq2E,EACRA,EACiC,iBAA1BA,GACmB,IAA1BA,EAQV,OAAOz+E,GACH,MAAM0+E,EAAmBt1F,KAAK+0F,UAAU3zE,KAAO,GAAKxK,GAAa5W,KAAKk/D,eAElEl/D,KAAKg1F,UAAYJ,EAAuBK,MAAQK,EAChDt1F,KAAKg1F,QAAUJ,EAAuBW,QAC/Bv1F,KAAKg1F,UAAYJ,EAAuBK,MAASK,GACxDt1F,KAAKw1F,gBAAe,GAGxBx1F,KAAKkpD,mBAST,IAAIzmC,EAAYd,GACZc,EAAKgzE,mBAAmBz1F,KAAK01F,WAAW92F,KAAKoB,OAC7C,IAAI21F,GAAW,EAEX31F,KAAKg1F,UAAYJ,EAAuBK,OACxCU,EAAW31F,KAAK41F,cAAcnzE,GAC1BkzE,EAEA31F,KAAK61F,sBAAsBl0E,EAAW,GAC/B3hB,KAAKg1F,UAAYJ,EAAuBkB,UAG/C91F,KAAKw1F,gBAAe,IAG5Bx1F,KAAK+0F,UAAU/tF,IAAIyb,EAAKmB,QAAQO,aAAc,CAAExC,YAAWg0E,aAM/D,kBACI,OACI31F,KAAKg1F,UAAYJ,EAAuBkB,UACxC91F,KAAKg1F,UAAYJ,EAAuBK,KAIxC,cAAcxyE,GAClB,OAAOziB,KAAK+1F,uBAAuBtzE,IAASziB,KAAKg2F,yBAAyBvzE,GAGtE,uBAAuBA,G,QAC3B,MAAMwzE,EAAWxzE,EAAKke,WAAWu1D,iBAAiBl2F,KAAKk/D,gBACjDi3B,EAAqB9sF,KAAKS,IAAI,EAAG2Y,EAAKmB,QAAQhI,MAAQq6E,GACtDG,EAAW/sF,KAAKO,IAClBusF,EACAn2F,KAAK64E,UAAUt2D,eAAetM,QAAQqoD,0BAG1C,IAAI+3B,EAAc5zE,EAAKmB,QACvB,IAAK,IAAI0yE,EAAU,EAAGA,GAAWF,IAAYE,EAEzC,GADAD,EAAcA,EAAY92D,SACgC,QAA1D,EAAgD,QAAhD,EAAIv/B,KAAK+0F,UAAU92F,IAAIo4F,EAAYlyE,qBAAa,eAAEwxE,gBAAQ,SACtD,OAAO,EAGf,OAAO,EAGH,yBAAyBlzE,G,QAC7B,MAAM8zE,EAAqB9zE,EAAKke,WAAWu3C,aAAez1D,EAAKmB,QAAQhI,MACjE46E,EAAantF,KAAKO,IACpB2sF,EACAv2F,KAAK64E,UAAUt2D,eAAetM,QAAQsoD,4BAGpCyzB,EAAevvE,EAAKke,WAAWsB,kBACrC,IAAIw0D,EAAe,CAACh0E,EAAKmB,SACrB8yE,EAA2B,GAC/B,IAAK,IAAIC,EAAY,EAAGA,GAAaH,IAAcG,EAAW,CAC1DD,EAAcp1F,OAAS,EACvB,IAAK,MAAMsiB,KAAW6yE,EAClB,IAAK,MAAMG,KAAgB5E,EAAa6E,eAAejzE,GAAU,CAC7D,GAA2D,QAA3D,EAAiD,QAAjD,EAAI5jB,KAAK+0F,UAAU92F,IAAI24F,EAAazyE,qBAAa,eAAEwxE,gBAAQ,SACvD,OAAO,EAEXe,EAAcxwF,KAAK0wF,IAI1BH,EAAcC,GAAiB,CAACA,EAAeD,GAGpD,OAAO,EAGH,WAAWh0E,GACfziB,KAAK+0F,UAAUhuF,OAAO0b,EAAKmB,QAAQO,cAG/B,mBACJ,GAAInkB,KAAKg1F,UAAYJ,EAAuBW,QACxC,OAGJ,MAAMuB,EAAcltB,KAAK1hC,MACrBloC,KAAKk1F,YAAc,IACnBl1F,KAAKk1F,YAAc4B,GAGvB,MAAMjC,EAAW70F,KAAK60F,SAChBkC,EAAe1tF,KAAKO,IAAIktF,EAAc92F,KAAKk1F,YAAaL,GAExDhoC,EAAiB,EAAAvkD,UAAU0uF,eAC7B,EAAA72D,qBAAqBC,kBACrB,EAAAD,qBAAqBE,kBACrB02D,EAAelC,GAEnB70F,KAAKotD,kBAAkBP,GAEnBkqC,GAAgBlC,IAChB70F,KAAKg1F,QAAUJ,EAAuBkB,UAG1C91F,KAAK64E,UAAUxmC,SAGX,eAAe4kD,GACnBj3F,KAAKg1F,QAAUJ,EAAuBK,KACtCj1F,KAAKk1F,aAAe,EAChB+B,GACAj3F,KAAK+0F,UAAU10F,QAAQ09C,IACnBA,EAAM43C,UAAW,IAIrB,kBAAkBt3F,GACtB2B,KAAK+0F,UAAU10F,QAAQ09C,IACdA,EAAM43C,WACP31F,KAAK61F,sBAAsB93C,EAAMp8B,UAAWtjB,GACxCA,GAAS,IACT0/C,EAAM43C,UAAW,MAMzB,sBAAsBh0E,EAA+BtjB,GACzDsjB,EAAUthB,QAAQoK,IACdA,EAASoiD,eAAiBxuD,O,sGCzQtC,uBACI,MAAMysC,KAAkBosD,GAEpBC,QAAQ54E,MAAMusB,KAAYosD,GAG9B,MAAMpsD,KAAkBosD,GAEpBC,QAAQhoD,MAAMrE,KAAYosD,GAG9B,KAAKpsD,KAAkBosD,GAEnBC,QAAQ9iC,KAAKvpB,KAAYosD,GAG7B,IAAIpsD,KAAkBosD,GAElBC,QAAQl9D,IAAI6Q,KAAYosD,GAG5B,MAAMpsD,KAAkBosD,GAEpBC,QAAQC,MAAMtsD,KAAYosD,GAG9B,KAAKpsD,KAAkBosD,GAEnBC,QAAQphF,KAAK+0B,KAAYosD,M,8FCjCjC,cAKA,eAII,YAAqBv5F,EAAsB05F,EAAqBphF,GAA3C,KAAAtY,OAAsB,KAAA05F,YAH3C,KAAAr4E,SAAmB,EACnB,KAAApD,MAAkB,EAAA4xB,SAAS8pD,WAGPt1F,IAAZiU,GACAjW,KAAKqyC,OAAOp8B,GAIpB,MAAM60B,KAAkBosD,GAChBl3F,KAAKgf,SAAWhf,KAAK4b,OAAS,EAAA4xB,SAAS/pC,OACvCzD,KAAKq3F,UAAU94E,MAAMve,KAAKu3F,OAAQzsD,KAAYosD,GAItD,MAAMpsD,KAAkBosD,GAChBl3F,KAAKgf,SAAWhf,KAAK4b,OAAS,EAAA4xB,SAASgqD,OACvCx3F,KAAKq3F,UAAUloD,MAAMnvC,KAAKu3F,OAAQzsD,KAAYosD,GAItD,KAAKpsD,KAAkBosD,GACfl3F,KAAKgf,SAAWhf,KAAK4b,OAAS,EAAA4xB,SAASiqD,MACvCz3F,KAAKq3F,UAAUhjC,KAAKr0D,KAAKu3F,OAAQzsD,KAAYosD,GAIrD,IAAIpsD,KAAkBosD,GACdl3F,KAAKgf,SAAWhf,KAAK4b,OAAS,EAAA4xB,SAASC,KACvCztC,KAAKq3F,UAAUp9D,IAAIj6B,KAAKu3F,OAAQzsD,KAAYosD,GAIpD,MAAMpsD,KAAkBosD,GAChBl3F,KAAKgf,SAAWhf,KAAK4b,OAAS,EAAA4xB,SAAS8pD,OACvCt3F,KAAKq3F,UAAUD,MAAMp3F,KAAKu3F,OAAQzsD,KAAYosD,GAItD,KAAKpsD,KAAkBosD,GACfl3F,KAAKgf,SAAWhf,KAAK4b,OAAS,EAAA4xB,SAASkqD,MACvC13F,KAAKq3F,UAAUthF,KAAK/V,KAAKu3F,OAAQzsD,KAAYosD,GAIrD,OAAOjhF,GACHjW,KAAKgf,aAA8Bhd,IAApBiU,EAAQ+I,QAAwBhf,KAAKgf,QAAU/I,EAAQ+I,QACtEhf,KAAK4b,WAA0B5Z,IAAlBiU,EAAQ2F,MAAsB5b,KAAK4b,MAAQ3F,EAAQ2F,MAGpE,aACI,OAAO5b,KAAKrC,KAAO,O,8HCzD3B,cAIa,EAAAg6F,uBAAyB,yBActC,sBACI,MAAM7sD,KAAkBosD,GACpB,MAAMU,EAAuC,CACzC9sD,QAAS,CAACA,KAAYosD,GACtBtnF,KAAM,EAAA+nF,uBACN/7E,MAAO,EAAA4xB,SAAS/pC,OAEpBo0F,KAAKC,YAAYF,GAGrB,MAAM9sD,KAAkBosD,GACpB,MAAMU,EAAuC,CACzC9sD,QAAS,CAACA,KAAYosD,GACtBtnF,KAAM,EAAA+nF,uBACN/7E,MAAO,EAAA4xB,SAASgqD,OAEpBK,KAAKC,YAAYF,GAGrB,KAAK9sD,KAAkBosD,GACnB,MAAMU,EAAuC,CACzC9sD,QAAS,CAACA,KAAYosD,GACtBtnF,KAAM,EAAA+nF,uBACN/7E,MAAO,EAAA4xB,SAASiqD,MAEpBI,KAAKC,YAAYF,GAGrB,IAAI9sD,KAAkBosD,GAClB,MAAMU,EAAuC,CACzC9sD,QAAS,CAACA,KAAYosD,GACtBtnF,KAAM,EAAA+nF,uBACN/7E,MAAO,EAAA4xB,SAASC,KAEpBoqD,KAAKC,YAAYF,GAGrB,MAAM9sD,KAAkBosD,GACpB,MAAMU,EAAuC,CACzC9sD,QAAS,CAACA,KAAYosD,GACtBtnF,KAAM,EAAA+nF,uBACN/7E,MAAO,EAAA4xB,SAAS8pD,OAEpBO,KAAKC,YAAYF,GAGrB,KAAK9sD,KAAkBosD,GACnB,MAAMU,EAAuC,CACzC9sD,QAAS,CAACA,KAAYosD,GACtBtnF,KAAM,EAAA+nF,uBACN/7E,MAAO,EAAA4xB,SAASkqD,MAEpBG,KAAKC,YAAYF,M,6BCrDzB,IAAYG,E,0LAAZ,SAAYA,GAIR,cAKA,0BAKA,oBAKA,cAKA,cAKA,gBAKA,kBAKA,cAKA,sBAKA,gBAKA,kBAtDJ,CAAYA,EAAA,EAAAA,uBAAA,EAAAA,qBAAoB,KA+EnB,EAAAhkB,aAAegkB,EA4B5B,MAAaC,UAAwBr4F,IAIjC,WAAWs4F,GACP,IAAK,MAAMC,KAAQD,EACf,IAAKj4F,KAAKuG,IAAI2xF,GACV,OAAO,EAGf,OAAO,EAMX,gBAAgBlxF,GACZ,IAAK,MAAMkxF,KAAQlxF,EACf,GAAIhH,KAAKuG,IAAI2xF,GACT,OAAO,EAGf,OAAO,EAOX,gBAAgBlxF,GACZ,OAAIA,aAAerH,IACRK,KAAKm4F,gBAAgBnxF,GAEzBhH,KAAKuG,IAAIS,GAMpB,qBAAqBixF,GACjB,IAAK,MAAMC,KAAQD,EACf,GAAIj4F,KAAKuG,IAAI2xF,GACT,OAAO,EAGf,OAAO,GA7Cf,oBA6GA,SAAYE,GAKR,yBAMA,+CASA,+BApBJ,CAAY,EAAAA,wBAAA,EAAAA,sBAAqB,KA4MjC,SAAYC,GAIR,uBAIA,uBAIA,2BAZJ,CAAY,EAAAA,eAAA,EAAAA,aAAY,KA2BxB,SAAYC,GACR,eACA,UACA,gBACA,YACA,mBACA,aACA,kBACA,WACA,aACA,iBACA,YACA,iBACA,WACA,iBACA,YACA,iBACA,WAjBJ,CAAY,EAAAA,iBAAA,EAAAA,eAAc,KA+9B1B,2BAAgCx5F,GAC5B,OAAOA,GAAUA,EAAO4xB,QAAiC,iBAAhB5xB,EAAO8Q,O,4HC/6CpD,SAAYu0C,GAUR,yCAWA,6CASA,+CA9BJ,CAAY,EAAAA,YAAA,EAAAA,UAAS,KA0DrB,uCACOo0C,GAEH,MAAMpyF,EAAiC,CACnC+9C,WAAY,IAEhB,IAAK,MAAM5/C,KAAci0F,OACoBv2F,IAArCsC,EAAWkqB,wBACXroB,EAAOqoB,sBAAwBlqB,EAAWkqB,4BAEhBxsB,IAA1BsC,EAAW4/C,aACX/9C,EAAO+9C,WAAa,OAAH,wBAAQ/9C,EAAO+9C,YAAe5/C,EAAW4/C,aAGlE,OAAO/9C,I,wGC1EX,aAEA,OACA,QACA,QACA,QAEMqG,EAAS,EAAAC,cAAcxM,SAASvB,OAAO,iBAS7C,4BACIK,EACAqD,EACAF,G,UAEA,GAAI,EAAAV,KAAKuG,OAAOhJ,GACZ,IACI,IAAIb,EAAIa,EAAS06E,SAASr3E,EAAK,EAAAb,UAAUi3F,QAASt2F,GAMlD,MAJiB,iBAANhE,IACPA,EAAoC,QAAnC,EAAgB,QAAhB,EAAG,EAAA4F,KAAKnC,MAAMzD,UAAE,QAAI,EAAA6F,OAAOpC,MAAMzD,UAAE,QAAIA,GAGxCA,aAAa,EAAA4F,KACN5F,EAAE04B,SACF14B,aAAa,EAAA6F,OACb7F,EAAEG,OAA6C,QAArC,EAACypB,OAAO1lB,EAAI6qB,OAAO,0BAAkB,QAAI,GAEvD/uB,EACT,MAAOqgB,GAOL,OANA/R,EAAO+R,MACH,gCACA9W,KAAKC,UAAU3I,GACf,QACA8wD,OAAOtxC,IAEJ,KAIf,GAAIxf,QACA,OAAO,KACJ,GAAwB,iBAAbA,EAEd,OAAOA,EACJ,CAEH,MAAMigC,EAAiB58B,EAAI6qB,OAAO,mBAAgC,EAC5D5uB,EAAQ,EAAAo6F,0BAA0B15F,EAAUigC,GAClD,YAAiBh9B,IAAV3D,EAAsBA,EAAQU,K,+MCvD7C,aAUA,OACA,SACA,QA2UA,SAAgB25F,EACZt2F,EACAu2F,EACA3zC,EACAC,EACA3hC,GAEA,IAAI3lB,EAIJ,QAHqBqE,IAAjB22F,IACAA,EAAe,QAEf3zC,EAAiB,CACjB,MAAM4zC,EAAex2F,EAAI6qB,OAAO,GAAG0rE,WACnC,GAA4B,iBAAjBC,GAA6BA,EAAat3F,OAAS,EAC1D,OAAOs3F,EAGf,GAAI3zC,EAAY,CACZ,MAAM4zC,EAAUz2F,EAAI6qB,OAAO,YAC3B,GAAuB,iBAAZ4rE,GAAwBA,EAAQv3F,OAAS,EAChD,OAAOu3F,EAGf,QAAkB72F,IAAdshB,EACA,IAAK,MAAME,KAAQF,EAEf,GADA3lB,EAAOyE,EAAI6qB,OAAO,GAAG0rE,KAAgBn1E,MAAWphB,EAAI6qB,OAAO,GAAG0rE,KAAgBn1E,KAC1D,iBAAT7lB,GAAqBA,EAAK2D,OAAS,EAC1C,OAAO3D,EAKnB,GADAA,EAAOyE,EAAI6qB,OAAO0rE,GACE,iBAATh7F,EACP,OAAOA,EA9Rf,+BAAoCsgF,GAChC,OAAQA,GACJ,IAAK,QACD,OAAOzsD,aACX,IAAK,QACD,OAAOb,WACX,IAAK,SACD,OAAOO,YACX,IAAK,SACD,OAAOI,YACX,IAAK,OACD,OAAOR,UACX,IAAK,QACD,OAAOE,WACX,IAAK,QACD,OAAOI,aAqBnB,SAAYu2D,GACR,iCACA,qBACA,mBACA,6BACA,mBACA,2BACA,mCACA,yBACA,yCACA,2BACA,uBAXJ,CAAY,EAAAA,eAAA,EAAAA,aAAY,KAuJxB,yBAA8BmR,GAC1B,OAAQA,GACJ,IAAK,WACD,OAAO,EAAAp9D,mBACX,IAAK,cACD,OAAO,EAAAD,sBACX,IAAK,SACD,OAAO,EAAAs9D,iBACX,IAAK,4BACD,OAAO,EAAAxK,oCACX,IAAK,kBACD,OAAO,EAAAC,0BACX,QACI,MAAM,IAAI/qF,MAAM,sBAAsBq1F,OASlD,6BAAkC3pF,GAC9B,GAAIA,IAAe,EAAAusB,mBACf,MAAO,WACJ,GAAIvsB,IAAe,EAAAssB,sBACtB,MAAO,cACJ,GAAItsB,IAAe,EAAA4pF,iBACtB,MAAO,SACJ,GAAI5pF,IAAe,EAAAo/E,oCACtB,MAAO,4BACJ,GAAIp/E,IAAe,EAAAq/E,0BACtB,MAAO,kBAEX,MAAM,IAAI/qF,MAAM,uBAMpB,wBAA6Bu1F,GACzB,YAAqBh3F,IAAjBg3F,EACO,EAGiB,iBAAjBA,EACAA,EAGPA,EAAa/5F,eAAe,OACpB+5F,EAAqBC,IAG1B,GAaX,mBA+CA,0BACI/4F,EACAosB,EACAhJ,GAEA,IAAI0hC,EACAC,EACJ,MAAM7iD,EAAMlC,aAAmB,EAAAm/B,IAAMn/B,EAAUA,EAAQkC,IACvD,IAAIuiF,EAAmB,OACvB,GACI,EAAA3J,gBAAgB1uD,IAChB,EAAAwuD,eAAexuD,IACf,EAAAyuD,sBAAsBzuD,GACxB,CACE,QAAuBtqB,IAAnBsqB,EAAU9G,KACV,OAAO,EAAA0zE,sBAAsBh5F,EAASosB,EAAU9G,MAGpD,QAAwBxjB,IAApBsqB,EAAUtmB,QAEV2+E,EAAW,EAAAuU,sBAAsBh5F,EAASosB,EAAUtmB,OAC5B,iBAAb2+E,GACP,OAIR3/B,EAAkB14B,EAAU04B,gBAE5BC,EAAa34B,EAAU24B,WAG3B,OAAOyzC,EAAet2F,EAAKuiF,EAAU3/B,EAAiBC,EAAY3hC,K,gMCtatE,aAMa,EAAA61E,WAA2B,CACpCnhF,SAAU,CACNohF,SAAU,CAAE/6F,MAAO,MACnB6sB,QAAS,CAAE7sB,MAAO,IAEtB+6B,aAAc,0JAMdC,eAAgB,6MAapB,MAAaggE,UAAqBj6F,EAAM0Y,eAMpC,YAAYE,GACRhV,MAAM,CACFrF,KAAM,eACNqa,WACAohB,aAAc,EAAA+/D,WAAW//D,aACzBC,eAAgB,EAAA8/D,WAAW9/D,eAC3BvuB,oBAAoB,EACpBJ,aAAa,EACbE,SAAUxL,EAAMk6F,WAChBpqE,WAAW,EACXyqB,YAAY,KAhBxB,kB,8EC7BA,UAAe,CACX4/C,wBAAyB,qeAczBC,wBAAyB,q1DAiDzBC,0BAA2B,u9D,8GChE/B,aAGA,QAaA,+BAiBI,YACYC,EACAC,EACAC,GAFA,KAAAF,sBACA,KAAAC,wBACA,KAAAC,yBAlBJ,KAAAC,gBAAkB,IAAI,EAAAl0F,QACtB,KAAAm0F,eAAiB,IAAI,EAAAn0F,QAErB,KAAAo0F,yBAA+B/3F,EAC/B,KAAAg4F,2BAAqC,EA8HrC,KAAAC,gBAAkB,KACtBj6F,KAAK+5F,yBAAsB/3F,EAC3B,MAAMkmC,EAAMgE,YAAYhE,MACpBA,GAAOloC,KAAKg6F,2BACZh6F,KAAKslE,mBAELtlE,KAAKk6F,2BAA2BhyD,SApHHlmC,IAA7BhC,KAAK05F,sBACL15F,KAAK05F,oBA/BkB,KA0C/B,iBAAiBxrF,EAAkBg6B,GAC/B,MAAMiyD,EAAc,EAAAnsF,aAAagI,gBAAgB9H,EAASA,EAAQQ,QAC5D0rF,EAAelsF,EAAQQ,OAAO4yC,iBAAiBthD,KAAK85F,gBAE1D,QAA4B93F,IAAxBhC,KAAKq6F,eAGL,OAFAr6F,KAAK65F,gBAAgBvqF,KAAK8qF,GAC1Bp6F,KAAKq6F,eAAiBF,GACf,EAEX,MAAMG,GACDt6F,KAAK65F,gBAAgBU,OAAOH,IAC7BD,EAAY9jF,MAAQrW,KAAKq6F,eAAehkF,KACxC8jF,EAAY7jF,QAAUtW,KAAKq6F,eAAe/jF,OAC1C6jF,EAAY5jF,OAASvW,KAAKq6F,eAAe9jF,KAmB7C,OAjBI+jF,IACAt6F,KAAK65F,gBAAgBvqF,KAAK8qF,GAC1Bp6F,KAAKq6F,eAAiBF,GAGtBG,IAAgBt6F,KAAKw6F,yBACjBF,GACAt6F,KAAKqlE,kBAETrlE,KAAKw6F,uBAAyBF,GAE9BA,IAEAt6F,KAAKg6F,2BAA6B9xD,EAAMloC,KAAK05F,oBAC7C15F,KAAKk6F,2BAA2BhyD,IAG7BloC,KAAKw6F,uBAOhB,MAAMtsF,GACF,MAAMksF,EAAelsF,EAAQQ,OAAO4yC,iBAAiBthD,KAAK85F,gBAC1D95F,KAAK65F,gBAAgB7yF,IAAIozF,EAAa30F,EAAG20F,EAAa10F,EAAG00F,EAAax0F,GAEtE,MAAMu0F,EAAc,EAAAnsF,aAAagI,gBAAgB9H,EAASA,EAAQQ,QAClE1O,KAAKq6F,eAAiBF,EAM1B,aACIn6F,KAAK65F,gBAAgB7yF,IAAI8gB,OAAO2yE,IAAK3yE,OAAO2yE,IAAK3yE,OAAO2yE,KAO5D,qBACI,YAAoCz4F,IAA7BhC,KAAK+5F,oBAMhB,UACI/5F,KAAK06F,8BACL16F,KAAK25F,2BAAwB33F,EAC7BhC,KAAK45F,4BAAyB53F,EAMlC,2BACI,OAAuC,IAAhChC,KAAKw6F,uBAGR,uBAC+Bx4F,IAA/BhC,KAAK25F,uBACL35F,KAAK25F,wBAIL,mBACJ35F,KAAK06F,mCAC+B14F,IAAhChC,KAAK45F,wBACL55F,KAAK45F,yBAIL,2BAA2B1xD,GAC/B,QAAiClmC,IAA7BhC,KAAK+5F,oBAAmC,CACxC,MAAMY,EAAgBtxF,KAAKS,IAAI,EAAG9J,KAAKg6F,2BAA6B9xD,GACpEloC,KAAK+5F,oBAAsB9jB,WAAWj2E,KAAKi6F,gBAAiBU,IAc5D,mCAC6B34F,IAA7BhC,KAAK+5F,sBACLzyB,aAAatnE,KAAK+5F,qBAClB/5F,KAAK+5F,yBAAsB/3F,M,+FCjKvC,aAQA,MAAaykC,UAAgBrnC,EAAM40B,KAQ/B,YACIpS,EACAnX,GAEAzH,WAAMhB,EAAWyI,GAEjBzK,KAAK4hB,WAAaA,EAMtB,eAAeA,GAEP5hB,KAAK46F,eAAiBh5E,GACtB5hB,KAAK66F,oBAGT76F,KAAK46F,aAAeh5E,EAChB5hB,KAAK4hB,YAAc5hB,KAAK46F,aAAct5F,OAAS,IAC/CtB,KAAKka,SAAWla,KAAK46F,aAAc,IAO3C,iBACI,OAAO56F,KAAK46F,aAOhB,iBAAiBh/E,GACR5b,KAAK46F,cAA6C,IAA7B56F,KAAK46F,aAAat5F,SAG5Csa,EAAQxc,EAAMkJ,UAAU6B,MAAMyR,EAAO,EAAG5b,KAAK46F,aAAat5F,OAAS,GAEnEtB,KAAKka,SAAWla,KAAK46F,aAAah/E,IAM9B,oBACJ,GAAI5b,KAAK46F,aACL,IAAK,MAAM1gF,KAAYla,KAAK46F,aACxB1gF,EAASurB,UAGjBzlC,KAAKka,SAASurB,WA7DtB,a,iYCAA,a,gJCRA,aAEMq1D,EAAkB,CACpBC,eAAgB,2IAMhBC,YAAa,wIAMbC,wBAAyB,oOAWzBC,kBAAmB,qFAInBC,uBAAwB,khCA6B5Br9F,OAAOysD,OAAOnrD,EAAMwsD,YAAakvC,GAkGjC,MAAaM,UAA2Bh8F,EAAMyY,kBAM1C,cASI7U,MARqD,CACjDrF,KAAM,qBACNy7B,aAzGsB,+NA0GtBC,eAhGwB,uIAiGxBrhB,SAAU,GACVkX,WAAW,EACXyqB,YAAY,KAbxB,uBAuBA,MAAa0hD,UAA0Bj8F,EAAMyY,kBAMzC,cAmBI7U,MAlBqD,CACjDrF,KAAM,oBACNy7B,aA9GqB,wTA+GrBC,eAjGuB,qmCAkGvBrhB,SAAU,CACNsjF,WAAY,IAAIl8F,EAAMgsD,QAAQ,GAC9BmwC,MAAO,IAAIn8F,EAAMgsD,QAAQhsD,EAAM8Y,QAAQsjF,eACvCC,MAAO,IAAIr8F,EAAMgsD,QAAQhsD,EAAM8Y,QAAQsjF,eACvCE,MAAO,IAAIt8F,EAAMgsD,QAAQhsD,EAAM8Y,QAAQsjF,eACvCG,MAAO,IAAIv8F,EAAMgsD,QAAQhsD,EAAM8Y,QAAQsjF,eACvCI,MAAO,IAAIx8F,EAAMgsD,QAAQhsD,EAAM8Y,QAAQsjF,eACvCK,MAAO,IAAIz8F,EAAMgsD,QAAQhsD,EAAM8Y,QAAQsjF,eACvCM,MAAO,IAAI18F,EAAMgsD,QAAQhsD,EAAM8Y,QAAQsjF,eACvCO,MAAO,IAAI38F,EAAMgsD,QAAQhsD,EAAM8Y,QAAQsjF,gBAE3CtsE,WAAW,EACXyqB,YAAY,KAvBxB,sBA+CA,MAAaqiD,UAAwB58F,EAAMyY,kBAQvC,YAAYwF,GA2BRra,MA1BqD,CACjDrF,KAAM,kBACNy7B,kBAC4Bp3B,IAAxBqb,EAAO4+E,aAA6B5+E,EAAO4+E,aAnHvB,oSAoHxB5iE,oBAC8Br3B,IAA1Bqb,EAAO6+E,eAA+B7+E,EAAO6+E,eAzGvB,6WA0G1BlkF,SAAU,CACNmkF,WAAY,IAAI/8F,EAAMgsD,QAAQ/tC,EAAOlG,SACrCilF,UAAW,IAAIh9F,EAAMgsD,QACjB,IAAIhsD,EAAMyG,QACNwX,EAAOm8B,YAAY/zC,EACnB4X,EAAOm8B,YAAY9zC,EACnB2X,EAAO+D,KACP/D,EAAOg/E,iBAInB7wF,QAAS,CACL8wF,KAAMj/E,EAAOk/E,OAAS,EAAM,EAC5BC,QAASn/E,EAAOo/E,aAAe,EAAM,GAEzCvtE,WAAW,EACXyqB,YAAY,EACZ+iD,KAAMt9F,EAAMu9F,WACZjyF,aAAa,IAGjB1K,KAAK48F,WAAWC,aAAc,GApCtC,qB,wGC5NA,yBAaI,YACa7tD,EACAte,EACAynB,EACA2kD,EACAzlD,EACAC,GALA,KAAAtI,SACA,KAAAte,SACA,KAAAynB,SACA,KAAA2kD,kBACA,KAAAzlD,kBACA,KAAAC,qB,6GCzBjB,cAqBA,iCAAsCj6B,GAClC,OAAO,IAAI,EAAA2+E,gBAAgB,CACvB7kF,QAASkG,EAAO06B,YAAY5gC,QAC5BqiC,YAAan8B,EAAO06B,YAAYyB,YAChCp4B,KAAM/D,EAAO06B,YAAY32B,KACzBi7E,cAAeh/E,EAAO06B,YAAYskD,cAClCE,OAAoC,SAA5Bl/E,EAAO06B,YAAYnoC,KAC3B6sF,cAAsC,IAAxBp/E,EAAOo/E,aACrBR,aAAc5+E,EAAO4+E,aACrBC,eAAgB7+E,EAAO6+E,mB,8EC9B/B,aAGI,qFAAAx2B,uBAEJ,YAAgB,sEAAAltC,QAChB,YAAS,gFAAAukE,kBAAgB,8EAAAC,iB,qHCRzB,aACA,OAEA,QAQA,IAAYA,GAAZ,SAAYA,GACR,yBACA,yBACA,yBACA,yBACA,yBACA,yBANJ,CAAYA,EAAA,EAAAA,eAAA,EAAAA,aAAY,KAwBxB,kBAAaD,UAAuB,EAAAvkE,KAmChC,cACIx1B,QA5BJ,KAAAi6F,cAA8BD,EAAaE,QAEnC,KAAAC,eAAiD,KACxC,KAAAC,cAA0C,IAAIh+F,EAAMq6B,oBAChE,EACD,EACA,GACC,EACD,EACA,GAEa,KAAA4jE,YAA2B,IAAIj+F,EAAMkiB,MACrC,KAAAg8E,eACb,EAAAnE,WAAWnhF,SACE,KAAAulF,eAAuC,IAAI,EAAAC,aAAax9F,KAAKs9F,gBAC7D,KAAAG,OAAqB,IAAIr+F,EAAM40B,KAC5C,IAAI50B,EAAMs6B,oBAAoB,EAAG,GACjC15B,KAAKu9F,gBAYLv9F,KAAKy9F,OAAO5rC,eAAgB,EAC5B7xD,KAAKq9F,YAAYl9F,IAAIH,KAAKy9F,QAM9B,UACgC,OAAxBz9F,KAAKm9F,iBACLn9F,KAAKm9F,eAAe13D,UACpBzlC,KAAKm9F,eAAiB,MA4B9B,OACIzkE,EACAC,EACAjqB,EACAkqB,EACAC,GAEA,IAAK74B,KAAKgf,QACN,OAIwB,OAAxBhf,KAAKm9F,iBACLn9F,KAAKm9F,eAAiB,IAAI/9F,EAAMs+F,kBAAkB7kE,EAAWphB,MAAOohB,EAAW3nB,OAAQ,CACnF4e,UAAW1wB,EAAMu+F,aACjB/tE,UAAWxwB,EAAMu+F,aACjB/rE,OAAQxyB,EAAMw+F,aAElB59F,KAAKm9F,eAAehmF,QAAQxZ,KAAO,yBAEvCqC,KAAKs9F,eAAelE,SAAS/6F,MAAQ2B,KAAKm9F,eAAehmF,QAEzD,MAAM0mF,EAAUd,EAAee,cAAc99F,KAAKi9F,eAE5C/yB,EAAqBxxC,EAASyxC,gBAC9B4zB,OAAuC/7F,IAAvBkoE,EAAmCA,EAAmBtzC,SAAW,EAOjFonE,EAAU,CACZh/E,QAAyB,OAAhBtQ,EAAOqQ,MAAiBrQ,EAAOqQ,KAAKC,QAC7CC,UAAW4Z,EAAWphB,MACtByH,WAAY2Z,EAAW3nB,OACvBzL,EAAG,EACHC,EAAG,EACH+R,MAAOohB,EAAWphB,MAClBvG,OAAQ2nB,EAAW3nB,QAMnB8sF,EAAQh/E,SAA2B,OAAhBtQ,EAAOqQ,OAC1Bi/E,EAAQ/+E,UAAYvQ,EAAOqQ,KAAKE,UAChC++E,EAAQ9+E,WAAaxQ,EAAOqQ,KAAKG,WACjC8+E,EAAQv4F,EAAIiJ,EAAOqQ,KAAKxK,QACxBypF,EAAQt4F,EAAIgJ,EAAOqQ,KAAKvK,QACxBwpF,EAAQvmF,MAAQ/I,EAAOqQ,KAAKtH,MAC5BumF,EAAQ9sF,OAASxC,EAAOqQ,KAAK7N,QAGjC,MAAM+sF,EAAkBvlE,EAASwlE,kBACjC,IAAK,IAAI9gG,EAAI,EAAGA,EAAIygG,EAAQv8F,OAAQlE,IAAK,CAGrC,MAAMymB,EAASg6E,EAAQzgG,GACvBsR,EAAOyvF,cACHH,EAAQ/+E,UACR++E,EAAQ9+E,WACR8+E,EAAQv4F,EAAIoe,EAAO,GAAK,GACxBm6E,EAAQt4F,EAAIme,EAAO,GAAK,GACxBm6E,EAAQvmF,MACRumF,EAAQ9sF,QAMZ,MAAMktF,GAAsChhG,EAAI,IAAOygG,EAAQv8F,OAA1B,GAC/B+8F,EAAe,EAAMR,EAAQv8F,OAAS88F,EAA8B,GAE1Ep+F,KAAKs9F,eAAepyE,QAAQ7sB,MAAQggG,EAEpC3lE,EAASK,gBAAgB/4B,KAAKm9F,gBAC9BzkE,EAASsN,QACTtN,EAASM,OAAOL,EAAOjqB,GAKvBgqB,EAASK,gBAAgB/4B,KAAKy4B,eAAiB,KAAOG,GAC5C,IAANx7B,IACAs7B,EAAS2pC,cAAc,GACvB3pC,EAASsN,SAEbtN,EAASM,OAAOh5B,KAAKq9F,YAAar9F,KAAKo9F,eAC7B,IAANhgG,QAAkC4E,IAAvBkoE,GACXxxC,EAAS2pC,cAAc07B,GAG/BrlE,EAASK,gBAAgBklE,GAGL,OAAhBvvF,EAAOqQ,OACPrQ,EAAOqQ,KAAKC,QAAUg/E,EAAQh/E,QAC9BtQ,EAAOqQ,KAAKxK,QAAUypF,EAAQv4F,EAC9BiJ,EAAOqQ,KAAKvK,QAAUwpF,EAAQt4F,GAWtC,QAAQ+R,EAAevG,GACflR,KAAKm9F,gBACLn9F,KAAKm9F,eAAehwB,QAAQ11D,EAAOvG,IAuF/C,OA3EoB,EAAA4sF,cAA8B,CAC1C,CAAC,CAAC,EAAG,IACL,CACI,CAAC,EAAG,GACJ,EAAE,GAAI,IAEV,CACI,EAAE,GAAI,GACN,CAAC,GAAI,GACL,EAAE,EAAG,GACL,CAAC,EAAG,IAER,CACI,CAAC,GAAI,GACL,EAAE,EAAG,GACL,CAAC,EAAG,GACJ,EAAE,GAAI,GACN,EAAE,EAAG,GACL,EAAE,GAAI,GACN,CAAC,EAAG,GACJ,CAAC,GAAI,IAET,CACI,CAAC,EAAG,GACJ,EAAE,GAAI,GACN,EAAE,EAAG,GACL,CAAC,GAAI,GACL,EAAE,GAAI,GACN,CAAC,EAAG,GACJ,CAAC,EAAG,GACJ,CAAC,GAAI,GACL,EAAE,EAAG,GACL,CAAC,GAAI,GACL,EAAE,GAAI,GACN,EAAE,EAAG,GACL,EAAE,EAAG,GACL,CAAC,GAAI,GACL,CAAC,EAAG,GACJ,EAAE,GAAI,IAEV,CACI,EAAE,GAAI,GACN,EAAE,GAAI,GACN,EAAE,GAAI,GACN,EAAE,GAAI,GACN,EAAE,GAAI,GACN,EAAE,GAAI,GACN,EAAE,GAAI,GACN,EAAE,EAAG,GACL,EAAE,EAAG,GACL,EAAE,EAAG,GACL,EAAE,EAAG,GACL,EAAE,EAAG,GACL,EAAE,EAAG,GACL,EAAE,EAAG,GACL,EAAE,EAAG,GACL,EAAE,EAAG,GACL,CAAC,GAAI,GACL,CAAC,GAAI,GACL,CAAC,GAAI,GACL,CAAC,GAAI,GACL,CAAC,GAAI,GACL,CAAC,GAAI,GACL,CAAC,GAAI,GACL,CAAC,GAAI,GACL,CAAC,EAAG,GACJ,CAAC,EAAG,GACJ,CAAC,EAAG,GACJ,CAAC,EAAG,GACJ,CAAC,EAAG,GACJ,CAAC,EAAG,GACJ,CAAC,EAAG,GACJ,CAAC,EAAG,KAGhB,GAlRA,GAAa,EAAAf,kB,sKCnCb,aACA,OAQA,QAEA,OAEMvwF,EAAS,EAAAC,cAAcxM,SAASvB,OAAO,uBAE7C,SAAgB4/F,EAAiBxzD,GAC7B,OAAOA,GAAoC,iBAAlBA,EAAQlvB,OAAsBkvB,EAAQl7B,OAAS,EAAA+nF,uBAD5E,qBAkEa,EAAA4G,sCAAwC,IAkBrD,4BA6BI,YAAoB5tD,GAAA,KAAAA,YA5BZ,KAAA6tD,sBAAwB,EAAA/xF,cAAcxM,SAASvB,OAAO,iBAC7C,KAAA+/F,iBAAmB,IAAIt8F,IAChC,KAAAu8F,UAAY,IAAIt9F,MAIhB,KAAAu9F,mBAAqB,IAAIv9F,MACzB,KAAAw9F,iBAAmB,IAAIx9F,MAGd,KAAAy9F,gBAAkB,IAAI18F,IACtB,KAAA28F,WAAwC,IAAI38F,IACrD,KAAA48F,qBAA6C,GAE7C,KAAAC,gBAA0B,EAC1B,KAAAC,WAAqB,EAErB,KAAAC,iBAA2B,EA+V3B,KAAAC,gBAAkB,CAACC,EAAkBp9B,KACzC,GAAI,EAAAq9B,sBAAsBC,kBAAkBt9B,EAAM16B,MAAO,CACrD,MAAMihC,EAAWvG,EAAM16B,KACvB,GAA2B,OAAvBihC,EAASg3B,UAET,YADA/yF,EAAO+R,MAAM,IAAIve,KAAK2wC,UAAUuqB,iDAGpC,MAAM8oB,EAAQhkF,KAAK8+F,WAAW7gG,IAAIsqE,EAASg3B,WAC3C,QAAcv9F,IAAVgiF,EAIA,YAHAx3E,EAAO+R,MACH,IAAIve,KAAK2wC,UAAUuqB,sDAK3B,GAAIkkC,GAAY,GAAKA,EAAWp/F,KAAK0+F,UAAUp9F,OAAQ,CACnD,MAAMk+F,EAASx/F,KAAK0+F,UAAUU,GAC9Bp/F,KAAK2+F,mBAAmBz4F,KAAKs5F,GAE7Bx/F,KAAKy/F,+BAELjzF,EAAO+R,MAAM,IAAIve,KAAK2wC,UAAUuqB,iDAEpC,QAA8Bl5D,IAA1BumE,EAASm3B,aAA4B,CACrC,MAAMnhF,EAAQ,IAAI9a,MAAM8kE,EAASm3B,mBACL19F,IAAxBumE,EAASo3B,aACTphF,EAAMqhF,MAAQr3B,EAASo3B,YAE3B3b,EAAM6b,SAASthF,QAEfylE,EAAM6b,cAAS79F,EAAWumE,EAASA,eAEpC,GAAI,EAAA82B,sBAAsBS,qBAAqB99B,EAAM16B,MAAO,CAC/D,MAAMy4D,EAAe//F,KAAKggG,gBAAgBh+B,EAAM16B,KAAK24D,WAC/CF,EAAahmF,QAAU/Z,KAAK4+F,iBAAiBt9F,QAC/Cy+F,EAAaz0B,eAEd,GAAIgzB,EAAiBt8B,EAAM16B,MAC9B,OAAQ06B,EAAM16B,KAAK1rB,OACf,KAAK,EAAA4xB,SAAS8pD,MACVt3F,KAAKw+F,sBAAsBpH,SAASp1B,EAAM16B,KAAKwD,SAC/C,MACJ,KAAK,EAAA0C,SAASgqD,MACVx3F,KAAKw+F,sBAAsBrvD,SAAS6yB,EAAM16B,KAAKwD,SAC/C,MACJ,KAAK,EAAA0C,SAASC,IACVztC,KAAKw+F,sBAAsBvkE,OAAO+nC,EAAM16B,KAAKwD,SAC7C,MACJ,KAAK,EAAA0C,SAASiqD,KACVz3F,KAAKw+F,sBAAsBnqC,QAAQ2N,EAAM16B,KAAKwD,SAC9C,MACJ,KAAK,EAAA0C,SAASkqD,KACV13F,KAAKw+F,sBAAsBzoF,QAAQisD,EAAM16B,KAAKwD,SAC9C,MACJ,KAAK,EAAA0C,SAAS/pC,MACVzD,KAAKw+F,sBAAsBjgF,SAASyjD,EAAM16B,KAAKwD,cAIvD9qC,KAAKkgG,aAAal+B,IA9YtBhiE,KAAK+pC,QAST,eACI/pC,KAAKk/F,kBAAoB,EACK,IAA1Bl/F,KAAKk/F,kBAA0Bl/F,KAAKi/F,WACpCj/F,KAAK+pC,QAYb,kBACI/pC,KAAKk/F,kBAAoB,EACK,IAA1Bl/F,KAAKk/F,kBACLl/F,KAAK27D,UAcb,MAAM1lD,GAIF,QAHgBjU,IAAZiU,IACAjW,KAAK2wC,UAAY16B,IAEhBjW,KAAKi/F,UACN,MAAM,IAAIx7F,MAAM,wCAGpBzD,KAAKmgG,cAAgB,EAAAvxB,eACjB5uE,KAAK2wC,UAAUwqB,YACM,oBAAd93C,gBAA+DrhB,IAAlCqhB,UAAU+8E,oBAExChhG,EAAMkJ,UAAU6B,MAAMkZ,UAAU+8E,oBAAsB,EAAG,EAAG,QAC5Dp+F,EA7GW,GAmHrB,MAAMq+F,EAAU,EAAAzxB,eACZ5uE,KAAK2wC,UAAU2vD,wBACf,EAAA/B,uCAEJ,IAAK,IAAIa,EAAW,EAAGA,EAAWp/F,KAAKmgG,gBAAiBf,EAAU,CAC9D,MAAMmB,EAAgB,EAAAC,aAAaC,YAAYzgG,KAAK2wC,UAAUuqB,UAAWmlC,GAASr7D,KAC9Ew6D,IACI,MAAMv1B,EAAYy2B,IACd1gG,KAAKm/F,gBAAgBC,EAAUsB,IAMnC,OAHAlB,EAAOz7B,iBAAiB,UAAWkG,GACnCjqE,KAAK0+F,UAAUx4F,KAAKs5F,GACpBx/F,KAAK2+F,mBAAmBz4F,KAAKs5F,GACtB,CACHA,SACAv1B,cAIZjqE,KAAK4+F,iBAAiB14F,KAAKq6F,GAE/BvgG,KAAKi/F,WAAY,EAOrB,kBACI,OAAOj/F,KAAKmgG,cAYhB,aACIngG,KAAKi/F,WAAY,QAEXj/F,KAAK2gG,sBAAsB37D,KAAK,KAClChlC,KAAK4gG,qBAWb,UACI5gG,KAAKi/F,WAAY,EAGjBj/F,KAAK8+F,WAAWz+F,QAAQ2jF,IACpBA,EAAM6b,SAAS,IAAIp8F,MAAM,uBAE7BzD,KAAK8+F,WAAW94D,QAChBhmC,KAAK++F,qBAAuB,GAE5B/+F,KAAK4gG,mBAGL5gG,KAAKy+F,iBAAiBz4D,QAc1B,cAAc66D,GAGV,OAFA7gG,KAAK8gG,sBACC7oD,QAAQC,IAAIl4C,KAAK4+F,kBAChB5+F,KAAKggG,gBAAgBa,GAAWE,QAU3C,iBAAiBF,EAAmBz6D,GAChCpmC,KAAKy+F,iBAAiBz3F,IAAI65F,EAAWz6D,GAQzC,oBAAoBy6D,GAChB7gG,KAAKy+F,iBAAiB13F,OAAO85F,GAgBjC,cACIA,EACAG,EACAt3C,EACAu3C,GAEAjhG,KAAK8gG,gBAEL,MAAMvB,EAAYv/F,KAAKg/F,kBACvB,IAAIa,EAEJ,MAAMkB,EAAU,IAAI9oD,QAAa,CAACqzB,EAAS41B,KACvCrB,EAAW,CAACthF,EAAegqD,KACvBvoE,KAAK8+F,WAAW/3F,OAAOw4F,QAETv9F,IAAVuc,EACA2iF,EAAO3iF,GAEP+sD,EAAQ/C,MAIpBvoE,KAAK8+F,WAAW93F,IAAIu4F,EAAW,CAC3BwB,UACAlB,SAAUA,IAGd,MAAM/0D,EAAgD,CAClDm1D,QAASY,EACTjxF,KAAM,EAAAyvF,sBAAsB8B,mBAAmBC,QAC/C7B,YACAyB,WAGJ,OADAhhG,KAAKqhG,mBAAmBv2D,EAAS4e,EAAcu3C,GACxCF,EAiBX,iBACIF,EACAG,EAGAt3C,GAEA1pD,KAAK8gG,gBAEL,MAAMQ,EAAW,GACjB,IAAK,MAAM9B,KAAUx/F,KAAK0+F,UAAW,CACjC,MAAMa,EAAYv/F,KAAKg/F,kBAEvB,IAAIa,EACJ,MAAMkB,EAAU,IAAI9oD,QAAa,CAACqzB,EAAS41B,KACvCrB,EAAW,CAACthF,EAAcgqD,KACtBvoE,KAAK8+F,WAAW/3F,OAAOw4F,QAETv9F,IAAVuc,EACA2iF,EAAO3iF,GAEP+sD,EAAQ/C,MAIpB+4B,EAASp7F,KAAK66F,GAEd/gG,KAAK8+F,WAAW93F,IAAIu4F,EAAW,CAC3BwB,UACAlB,SAAUA,IAGd,MAAM/0D,EAAgD,CAClDm1D,QAASY,EACTjxF,KAAM,EAAAyvF,sBAAsB8B,mBAAmBC,QAC/C7B,YACAyB,gBAEiBh/F,IAAjB0nD,EACA81C,EAAO1H,YAAYhtD,EAAS4e,GAE5B81C,EAAO1H,YAAYhtD,GAI3B,OAAOmN,QAAQC,IAAIopD,GASvB,iBAAiBx2D,EAAcy2D,GAC3BvhG,KAAK8gG,qBAEW9+F,IAAZu/F,EACAvhG,KAAK0+F,UAAUr+F,QAAQm/F,GAAUA,EAAO1H,YAAYhtD,EAASy2D,IAE7DvhG,KAAK0+F,UAAUr+F,QAAQm/F,GAAUA,EAAO1H,YAAYhtD,IAO5D,uBACI,OAAO9qC,KAAK++F,qBAAqBz9F,OAMrC,iBACI,OAAOtB,KAAK0+F,UAAUp9F,OAM1B,qBACI,OAAOtB,KAAK2+F,mBAAmBr9F,OAQzB,aAAa0gE,GACY,iBAApBA,EAAM16B,KAAK13B,MAItB5P,KAAKiiE,cAAcD,EAAM16B,KAAK13B,KAAMoyD,GAiFhC,mBACJl3B,EACAy2D,EACAN,GAGA,GADAjhG,KAAK8gG,gBACyB,IAA1B9gG,KAAK0+F,UAAUp9F,OACf,MAAM,IAAImC,MAAM,uDAKpB,QAA0BzB,IAAtBi/F,GAAmCA,EAAkBO,OAAOC,QAAS,CACrE,MAAMzd,EAAQhkF,KAAK8+F,WAAW7gG,IAAI6sC,EAAQy0D,WAC1C,QAAcv9F,IAAVgiF,EAIA,YAHAx3E,EAAO+R,MACH,IAAIve,KAAK2wC,UAAUuqB,qDAK3B,MAAMwmC,EAAM,IAAIj+F,MAAM,WAItB,OAHAi+F,EAAI/jG,KAAO,kBAEXqmF,EAAM6b,SAAS6B,OAAK1/F,GAIxB,GAAIhC,KAAK2+F,mBAAmBr9F,OAAS,EAAG,CACpC,MAAMk+F,EAASx/F,KAAK2+F,mBAAmB5iB,WAEvB/5E,IAAZu/F,EACA/B,EAAO1H,YAAYhtD,EAASy2D,GAE5B/B,EAAO1H,YAAYhtD,aAIG9oC,IAAtBi/F,IACAA,EAAoB,IAAI,EAAAU,kBAAkB,IAEX,IAA/BV,EAAkBt7E,WAElBs7E,EAAkBt7E,UAAY3lB,KAAKg/F,iBAEvCh/F,KAAK++F,qBAAqB6C,QAAQ,CAC9B92D,UACAy2D,UACAN,sBAKJ,gBACJ,GAAIjhG,KAAKi/F,UACL,MAAM,IAAIx7F,MAAM,+BAIhB,4BACJ,MAAM69F,EAAW,IAAIlgG,MACrBpB,KAAK8+F,WAAWz+F,QAAQ2jF,IACpBsd,EAASp7F,KAAK89E,EAAM+c,iBAElB9oD,QAAQC,IAAIopD,GAGd,cAAcvyE,EAAY+b,GAC9B,MAAM1E,EAAWpmC,KAAKy+F,iBAAiBxgG,IAAI8wB,QAC1B/sB,IAAbokC,GAGJA,EAAS0E,GAGL,mBAEJ9qC,KAAK4+F,iBAAiBv+F,QAAQkgG,IAC1BA,EAAcv7D,KAAK68D,SACK7/F,IAAhB6/F,IAGJA,EAAYrC,OAAO/3B,oBAAoB,UAAWo6B,EAAY53B,UAC9D43B,EAAYrC,OAAOsC,iBAG3B9hG,KAAK0+F,UAAY,GACjB1+F,KAAK4+F,iBAAmB,GACxB5+F,KAAK2+F,mBAAqB,GAC1B3+F,KAAK6+F,gBAAgB74D,QAGjB,gBAAgBjX,GACpB,MAAMgxE,EAAe//F,KAAK6+F,gBAAgB5gG,IAAI8wB,GAC9C,QAAqB/sB,IAAjB+9F,EACA,OAAOA,EAGX,MAAMgC,EAA2B,CAC7BhoF,MAAO,EACPgnF,aAAS/+F,EACTspE,QAAS,OAGT41B,OAAS3iF,IACLwjF,EAAWxjF,MAAQA,GAEvBA,WAAOvc,GAiBX,OAdA+/F,EAAWhB,QAAU,IAAI9oD,QAAc,CAACqzB,EAAS41B,KAC7C,MAAMc,EAAOD,OAEM//F,IAAfggG,EAAKzjF,MACL2iF,EAAOc,EAAKzjF,OACLyjF,EAAKjoF,QAAU/Z,KAAK4+F,iBAAiBt9F,QAC5CgqE,IAGJ02B,EAAK12B,QAAUA,EACf02B,EAAKd,OAASA,IAGlBlhG,KAAK6+F,gBAAgB73F,IAAI+nB,EAAIgzE,GACtBA,EAQH,0BACJ,GAAyC,IAArC/hG,KAAK++F,qBAAqBz9F,QAAmD,IAAnCtB,KAAK2+F,mBAAmBr9F,OAQtE,IALAtB,KAAK++F,qBAAqBn2D,KAAK,CAACp/B,EAAuBE,IAC5CF,EAAEy3F,kBAAmBt7E,SAAWjc,EAAEu3F,kBAAmBt7E,UAIzD3lB,KAAK2+F,mBAAmBr9F,OAAS,GAAKtB,KAAK++F,qBAAqBz9F,OAAS,GAAG,CAC/E,MAAM0/F,EAAUhhG,KAAK++F,qBAAqBhjB,MAC1C/7E,KAAKqhG,mBAAmBL,EAAQl2D,QAASk2D,EAAQO,QAASP,EAAQC,uB,oGCzqB9E,MAEA,aACA,SAEMz0F,EAAS,EAAAC,cAAcxM,SAASvB,OAAO,gBAO7C,kBAAa8hG,EA0DT,mBAAmBtlC,EAAmBmlC,EAAkB,KACpD,OAAInlC,EAAU9X,WAAW,SACdpjD,KAAKiiG,uBAAuB/mC,EAAWmlC,GAG9CrgG,KAAKkiG,mCACEliG,KAAKmiG,gBAAgBjnC,EAAWmlC,GAEpCrgG,KAAKiiG,uBAAuB/mC,EAAWmlC,GAASl7D,MAAM5mB,IACzD,GAAsB,oBAAX0tB,OAAwB,CAC/B,MAAMm2D,EAAUn2D,OAAOx1B,SAAS4rF,KAC1BC,EAAgB,IAAItwE,IAAIkpC,EAAWknC,GAASC,KAClD,GAAI,EAAAh/C,aAAai/C,KAAmB,EAAAj/C,aAAa++C,GAC7C,MAAM7jF,EAMV,OAJA/R,EAAOytB,IACH,gFAEJj6B,KAAKkiG,oCAAqC,EACnC1B,EAAa2B,gBAAgBjnC,EAAWmlC,GAE/C,MAAM9hF,IAWlB,8BAA8B28C,EAAmBmlC,GAC7C,IACI,MAAMb,EAAS,IAAI+C,OAAOrnC,GAC1B,OAAOl7D,KAAKwiG,sBAAsBhD,EAAQa,GAC5C,MAAO9hF,GACL,OAAO05B,QAAQipD,OAAO3iF,IAW9B,uBAAuB28C,EAAmBmlC,GACtC,OAAOrgG,KAAKyiG,2BAA2BvnC,GAAWl2B,KAAK09D,GAC5C1iG,KAAKiiG,uBAAuBS,EAASrC,IAYpD,kCAAkCnlC,GAC9B,IAAIynC,EAAiB3iG,KAAK4iG,kBAAkB3kG,IAAIi9D,GAChD,YAAuBl5D,IAAnB2gG,IAGJA,EAAiBr6B,MAAMpN,GAClBl2B,KAAKujC,GAAYA,EAAS/iD,QAC1B2f,MAAM5mB,IACH,MAAM,IAAI9a,MACN,uEAAuE8a,OAG9EymB,KAAK69D,IACF7iG,KAAK4iG,kBAAkB77F,OAAOm0D,GAC9B,MAAM4nC,EAAO,IAAI/wE,KAAK,CAAC8wE,GAAe,CAAEjzF,KAAM,2BAC9C,OAAOoiB,IAAIC,gBAAgB6wE,KAEnC9iG,KAAK4iG,kBAAkB57F,IAAIk0D,EAAWynC,IAd3BA,EAwCf,6BAA6BnD,EAAgBa,GACzC,OAAO,IAAIpoD,QAAgB,CAACqzB,EAAS41B,KACjC,MAAM6B,EAAwB/gC,IAC1B,MAAMl3B,EAAUk3B,EAAM16B,KACtB,GAAI,EAAA07D,yBAAyBl4D,GAA7B,CACI,MAAMhrC,EAAegrC,EAAQhrC,aACvBmjG,EAAiC,GACvC,IAAK,MAAMC,KAAcpjG,EAAc,CACnC,MAAMqjG,EAAWnjG,KAAKojG,qBAAqBF,GAC3C,IAAKC,EAQD,OAPAE,SACAnC,EACI,IAAIz9F,MACA,8CAA8Cy/F,KAC1C,iCAKhBD,EAAqB/8F,KAAKi9F,GAE9B,MAAM56B,EAAoC,CACtC34D,KAAM,4BACNqzF,wBAEJzD,EAAO1H,YAAYvvB,QAIvB86B,IACA/3B,EAAQk0B,GAKRvpB,WAAW,KACPupB,EAAOv9B,cAAcD,IACtB,IAEDshC,EAAiB/kF,IACnB8kF,IAGA,IAAIv4D,EAAU,qCACVvsB,EAAMusB,UACNA,GAAoB,KAAKvsB,EAAMusB,WAEL,iBAAnBvsB,EAAMglF,UAAiD,iBAAjBhlF,EAAMilF,SACnD14D,GAAoB,OAAOvsB,EAAMglF,YAAYhlF,EAAMilF,UAEvDtC,EAAO,IAAIz9F,MAAMqnC,KAEfu4D,EAAU,KACZ/7B,aAAam8B,GACbjE,EAAO/3B,oBAAoB,UAAWs7B,GACtCvD,EAAO/3B,oBAAoB,QAAS67B,IAGxC9D,EAAOz7B,iBAAiB,QAASu/B,GACjC9D,EAAOz7B,iBAAiB,UAAWg/B,GACnC,MAAMU,EAAUxtB,WAAW,KACvBotB,IACAnC,EAAO,IAAIz9F,MAAM,kEAClB48F,MAGf,OApOW,EAAA6B,oCAA8C,EAC9C,EAAAU,kBAAoB,IAAIzgG,IACxB,EAAAihG,qBAAmD,GAkO9D,GArOA,GAAa,EAAA5C,gB,0GCbb,aAoBA,IAAIkD,EAAsB,EAU1B,2BAUI,YACqBtoC,EACAH,GADA,KAAAG,YACA,KAAAH,qBAVb,KAAA0oC,kBAA4B,EAYhC3jG,KAAKo7D,UAAUwoC,eACf5jG,KAAK6gG,UAAY,GAAG7gG,KAAKi7D,sBAAsByoC,MAOnD,UACQ1jG,KAAK2jG,kBACL3jG,KAAKo7D,UACAyoC,iBAAiB,EAAAxE,sBAAsByE,kCAAmC,CACvEl0F,KAAM,EAAAyvF,sBAAsB0E,SAASC,eACrCC,gBAAiBjkG,KAAK6gG,YAEzB17D,MAAM,QAKfnlC,KAAKo7D,UAAU8oC,kBAOnB,sBACUlkG,KAAKo7D,UAAUiQ,QAAQ,EAAAg0B,sBAAsByE,mCAC9C9jG,KAAK2jG,yBACA3jG,KAAKo7D,UAAUyoC,iBACjB,EAAAxE,sBAAsByE,kCACtB,CACIl0F,KAAM,EAAAyvF,sBAAsB0E,SAASI,cACrCC,kBAAmBpkG,KAAKi7D,mBACxBgpC,gBAAiBjkG,KAAK6gG,YAG9B7gG,KAAK2jG,kBAAmB,GAWhC,WACIr8D,EACA1jB,EACAzU,EACA8xF,GAEA,MAAMoD,EAAczgF,EAAQO,aAEtB2mB,EAAmD,CACrDl7B,KAAM,EAAA00F,sBAAsBP,SAASQ,kBACrC3gF,QAASygF,EACT/8D,OACAn4B,WAAY,EAAAq1F,kBAAkBr1F,IAG5Bu6C,EAAepiB,aAAgBsiB,YAAc,CAACtiB,QAAQtlC,EAE5D,OAAOhC,KAAKo7D,UAAUqpC,cAClBzkG,KAAK6gG,UACL/1D,EACA4e,EACAu3C,GAWR,YACI35D,EACA1jB,EACAzU,EACA8xF,GAEA,MAAMoD,EAAczgF,EAAQO,aAEtB2mB,EAAiD,CACnDl7B,KAAM,EAAA00F,sBAAsBP,SAASW,gBACrC9gF,QAASygF,EACT/8D,OACAn4B,WAAY,EAAAq1F,kBAAkBr1F,IAG5Bu6C,EAAepiB,aAAgBsiB,YAAc,CAACtiB,QAAQtlC,EAC5D,OAAOhC,KAAKo7D,UAAUqpC,cAClBzkG,KAAK6gG,UACL/1D,EACA4e,EACAu3C,GAeR,UACInoB,EACAj3E,EACAyhB,EACArN,GAEA,MAAM60B,EAAsD,CACxDm1D,QAASjgG,KAAK6gG,UACdjxF,KAAM,EAAA00F,sBAAsBK,mBAAmBC,cAC/C9rB,WACAj3E,cACAoU,UACAqN,aAGJtjB,KAAKo7D,UAAUypC,iBAAiB/5D,GAOpC,kBACI,OAAO9qC,KAAKo7D,UAAUD,e,6GCrL9B,cACA,QAQA,kBAAa2pC,EAmBT,gBAAgBC,EAA0B7pC,EAAoBC,GAC1D,MAAMC,EAAYp7D,KAAKq7D,aAAaH,EAAWC,GAE/C,OAAO,IAAI,EAAA6pC,iBAAiB5pC,EAAW2pC,GAU3C,oBAAoB7pC,EAAoBC,QAClBn5D,IAAdk5D,IACAA,EAAYl7D,KAAKu7D,kBAGrB,IAAIH,EAAYp7D,KAAKw7D,WAAWN,GAQhC,YAPkBl5D,IAAdo5D,IACAA,EAAY,IAAI,EAAAK,oBAAoB,CAChCP,YACAC,iBAA6Bn5D,IAAhBm5D,EAA4Bn7D,KAAK07D,mBAAqBP,IAEvEn7D,KAAKw7D,WAAWN,GAAaE,GAE1BA,EAQX,wBAAwBF,GACpB,MAAME,EAAYp7D,KAAKw7D,WAAWN,QAChBl5D,IAAdo5D,IACAA,EAAUO,iBACH37D,KAAKw7D,WAAWN,IAO/B,iBACIp9D,OAAO89D,KAAK57D,KAAKw7D,YAAYn7D,QAAQ1C,IACjCqC,KAAKw7D,WAAW79D,GAAMg+D,YAE1B37D,KAAKw7D,WAAa,IAS1B,OAxEW,EAAAD,iBAA2B,sBAK3B,EAAAG,mBAA6B,EAgErB,EAAAF,WAEX,GACR,GA7EA,GAAa,EAAAspC,yB,wGCVb,aAaA,IAAIpB,EAAsB,EAU1B,yBAUI,YACqBtoC,EACA2pC,GADA,KAAA3pC,YACA,KAAA2pC,mBAVb,KAAApB,kBAA4B,EAYhC3jG,KAAKo7D,UAAUwoC,eACf5jG,KAAK6gG,UAAY,GAAG7gG,KAAK+kG,oBAAoBrB,MAOjD,UACQ1jG,KAAK2jG,kBACL3jG,KAAKo7D,UACAyoC,iBAAiB,EAAAxE,sBAAsByE,kCAAmC,CACvEl0F,KAAM,EAAAyvF,sBAAsB0E,SAASC,eACrCC,gBAAiBjkG,KAAK6gG,YAEzB17D,MAAM,QAKfnlC,KAAKo7D,UAAU8oC,kBAOnB,sBACUlkG,KAAKo7D,UAAUiQ,QAAQ,EAAAg0B,sBAAsByE,mCAC9C9jG,KAAK2jG,yBACA3jG,KAAKo7D,UAAUyoC,iBACjB,EAAAxE,sBAAsByE,kCACtB,CACIl0F,KAAM,EAAAyvF,sBAAsB0E,SAASI,cACrCC,kBAAmBpkG,KAAK+kG,iBACxBd,gBAAiBjkG,KAAK6gG,YAI9B7gG,KAAK2jG,kBAAmB,GAWhC,cAAcsB,EAAiBlkG,GAC3B,MAAM+pC,EAAoD,CACtDl7B,KAAM,EAAAs1F,oBAAoBnB,SAASoB,cACnCp2E,GAAIk2E,EACJlkG,MAAOA,aAAiBixB,IAAMjxB,EAAMshG,KAAQthG,GAEhD,OAAOf,KAAKo7D,UAAUqpC,cAAczkG,KAAK6gG,UAAW/1D,GAUxD,YAAYm6D,EAAiBlkG,GACzB,MAAM+pC,EAAkD,CACpDl7B,KAAM,EAAAs1F,oBAAoBnB,SAASqB,YACnCr2E,GAAIk2E,EACJlkG,MAAOA,aAAiBixB,IAAMjxB,EAAMshG,KAAQthG,GAEhD,OAAOf,KAAKo7D,UAAUqpC,cAAczkG,KAAK6gG,UAAW/1D,GASxD,QAAQm6D,EAAiBrhF,GACrB,MAAMygF,EAAczgF,EAAQO,aACtB2mB,EAA2C,CAC7Cl7B,KAAM,EAAAs1F,oBAAoBnB,SAASsB,YACnC3qF,MAAOuqF,EACPrhF,QAASygF,GAEb,OAAOrkG,KAAKo7D,UAAUqpC,cAAczkG,KAAK6gG,UAAW/1D,M,4GC5H5D,aACA,QACA,QACA,QAKA,kBAAau7B,UAA6B,EAAAwR,WAItC,cACI70E,MAAM,CAAErF,KAAM,eAHV,KAAAs0F,eAA+B5rB,EAAqBi/B,sBAIxDtlG,KAAK83E,WAAY,EACjB93E,KAAKg4E,gBAAiB,EAG1B,2BACI,IAAIU,EAEJ14E,KAAKkO,QAAQ8/D,YAAY3tE,QAAQwqE,IAC7B,GAAIA,IAAO7qE,KACP,OAEiB6qE,EAAG5oC,oBACHjiC,KAAKiyF,iBACtBvZ,OAC2B12E,IAAvB02E,EACM7N,EAAG6N,mBACHrvE,KAAKS,IAAI4uE,EAAoB7N,EAAG6N,4BAIvB12E,IAAvB02E,IACAA,EAAqB,GAGrBA,IAAuB14E,KAAK04E,qBAC5B14E,KAAK04E,mBAAqBA,EAC1B14E,KAAKkO,QAAQw5D,eAAe1nE,KAAKrC,OAKzC,SAAS+gE,EAAcp7C,GACnBtjB,KAAKkO,QAAQw5D,eAAe1nE,KAAKrC,MAGrC,gBAAgBq0F,GACZ,MAAMuT,EAAYvT,GAAgB3rB,EAAqBi/B,sBACnDC,IAAcvlG,KAAKiyF,iBAIvBjyF,KAAKiyF,eAAiBsT,EACtBvlG,KAAKorE,2BACLprE,KAAKkO,QAAQw5D,eAAe1nE,KAAKrC,OAIrC,kBACI,OAAOqC,KAAKiyF,eAIhB,QAAQruE,GACJ,MAAMnB,EAAO,IAAI,EAAAsrE,KAAK/tF,KAAM4jB,GAK5B,OAJAnB,EAAKuhB,kBAAiB,GACtBvhB,EAAK+iF,oBACL,EAAAprB,oBAAoBn6E,SAAS+3E,eAAev1D,EAAMqF,OAAO29E,kBAElDhjF,GAEf,OAjE4B,EAAA6iF,sBAAwB,EAAAI,wBAiEpD,GAlEA,GAAa,EAAAr/B,wB,gGCTb,aAwBA,+BACqB,KAAAs/B,kBAAoB,IAAIxjG,IACxB,KAAAyjG,iBAAmB,IAAIzjG,IACvB,KAAA0jG,iBAAmB,IAAI1jG,IACvB,KAAA2jG,iBAAmB,IAAI3jG,IACvB,KAAA4jG,gBAAuC,GACvC,KAAAC,WAAa,IAAI7jG,IACjB,KAAA8jG,oBAAsB,IAAI9jG,IAC1B,KAAA+jG,aAA4B,GAC5B,KAAAC,YAA0B,GAC1B,KAAAC,mBAAwC,GACxC,KAAAC,YAA0B,GAC1B,KAAAC,YAAc,IAAInkG,IASnC,IAAItC,GACA,OAAOA,EAAKE,OAAOC,UAAMgC,GAG7B,qBAAqBnC,EAAuBK,GACxC,OAAO,EAAAqD,gBAAgBtD,SAG3B,wBAAwBJ,EAA0BK,GAC9C,MAAMwE,EAAI1E,KAAK2lG,kBAAkB1nG,IAAI4B,EAAKxB,OAC1C,OAAIqG,IAGJ1E,KAAK2lG,kBAAkB3+F,IAAInH,EAAKxB,MAAOwB,GAChCA,GAGX,uBAAuBA,EAAyBK,GAC5C,MAAMwE,EAAI1E,KAAK4lG,iBAAiB3nG,IAAI4B,EAAKxB,OACzC,OAAIqG,IAGJ1E,KAAK4lG,iBAAiB5+F,IAAInH,EAAKxB,MAAOwB,GAC/BA,GAGX,uBAAuBA,EAAyBK,GAC5C,MAAMwE,EAAI1E,KAAK6lG,iBAAiB5nG,IAAI4B,EAAKxB,OACzC,OAAIqG,IAGJ1E,KAAK6lG,iBAAiB7+F,IAAInH,EAAKxB,MAAOwB,GAC/BA,GAGX,uBAAuBA,EAAyBK,GAC5C,MAAMwE,EAAI1E,KAAK8lG,iBAAiB7nG,IAAI4B,EAAKxB,OACzC,GAAIqG,EACA,OAAOA,EAGX,GAAItD,MAAMC,QAAQxB,EAAKxB,OAAQ,CAC3B,MAAMsb,EAAQ9Z,EAAKxB,MAEbH,EAAI8B,KAAK+lG,gBAAgB7tE,KAAKquE,IAChC,MAAMx/D,EAAWw/D,EAAQloG,MACzB,OAAI0oC,EAASzlC,SAAWqY,EAAMrY,QAGvBqY,EAAM5U,MAAM,CAACU,EAAGrI,IAAMqI,IAAMshC,EAAS3pC,MAGhD,QAAU4E,IAAN9D,EACA,OAAOA,EAGX8B,KAAK+lG,gBAAgB7/F,KAAKrG,GAK9B,OAFAG,KAAK8lG,iBAAiB9+F,IAAInH,EAAKxB,MAAOwB,GAE/BA,EAGX,aAAaA,EAAeK,GACxB,MAAMwE,EAAI1E,KAAKgmG,WAAW/nG,IAAI4B,EAAKlC,MACnC,OAAI+G,IAGJ1E,KAAKgmG,WAAWh/F,IAAInH,EAAKlC,KAAMkC,GACxBA,GAGX,sBAAsBA,EAAwBK,GAC1C,MAAMwE,EAAI1E,KAAKimG,oBAAoBhoG,IAAI4B,EAAKlC,MAC5C,OAAI+G,IAGJ1E,KAAKimG,oBAAoBj/F,IAAInH,EAAKlC,KAAMkC,GACjCA,GAGX,eAAeA,EAAiBK,GAC5B,MAAM7B,EAAQwB,EAAKxB,MAAM0B,OAAOC,KAAME,GAChCQ,EAAiCb,EAAKa,SAASqF,IAAI,EAAEC,EAAOC,KAAU,CACxED,EACAC,EAAKlG,OAAOC,KAAME,KAEhBW,EAAWhB,EAAKgB,SAASd,OAAOC,KAAME,GAC5C,IAAK,MAAMsmG,KAAaxmG,KAAKkmG,aAAc,CACvC,GAAIM,EAAUnoG,QAAUA,EACpB,SAEJ,GAAImoG,EAAU3lG,WAAaA,EACvB,SAEJ,GAAI2lG,EAAU9lG,SAASY,SAAWZ,EAASY,OACvC,SAEJ,IAAImlG,GAAmB,EACvB,IAAK,IAAIrpG,EAAI,EAAGA,EAAIsD,EAASY,OAAQlE,IACjC,GACIsD,EAAStD,GAAG,KAAOopG,EAAU9lG,SAAStD,GAAG,IACzCsD,EAAStD,GAAG,KAAOopG,EAAU9lG,SAAStD,GAAG,GAC3C,CACEqpG,GAAmB,EACnB,MAGR,GAAIA,EACA,OAAOD,EAGf,MAAMtoG,EAAI,IAAI,EAAA0G,UAAUvG,EAAOqC,EAAUG,GAEzC,OADAb,KAAKkmG,aAAahgG,KAAKhI,GAChBA,EAGX,cAAc2B,EAAgBK,GAC1B,MAAMQ,EAAiCb,EAAKa,SAASqF,IAAI,EAAEjF,EAAWmF,KAAU,CAC5EnF,EAAUf,OAAOC,KAAME,GACvB+F,EAAKlG,OAAOC,KAAME,KAEhBW,EAAWhB,EAAKgB,SAASd,OAAOC,KAAME,GAE5C,IAAK,MAAMsmG,KAAaxmG,KAAKmmG,YAAa,CACtC,GAAIK,EAAU3lG,WAAaA,EACvB,SAEJ,GAAI2lG,EAAU9lG,SAASY,SAAWZ,EAASY,OACvC,SAEJ,IAAImlG,GAAmB,EACvB,IAAK,IAAIrpG,EAAI,EAAGA,EAAIsD,EAASY,OAAQlE,IACjC,GACIsD,EAAStD,GAAG,KAAOopG,EAAU9lG,SAAStD,GAAG,IACzCsD,EAAStD,GAAG,KAAOopG,EAAU9lG,SAAStD,GAAG,GAC3C,CACEqpG,GAAmB,EACnB,MAGR,GAAIA,EACA,OAAOD,EAIf,MAAMtoG,EAAI,IAAI,EAAA+G,SAASvE,EAAUG,GAEjC,OADAb,KAAKmmG,YAAYjgG,KAAKhI,GACfA,EAGX,cAAc2B,EAAgBK,GAE1B,MAAMwmG,EAAc7mG,EAAKO,KAAK2F,IAAIzF,GAAaA,EAAUP,OAAOC,KAAME,IAEjEF,KAAKsmG,YAAY//F,IAAI1G,EAAKU,KAC3BP,KAAKsmG,YAAYt/F,IAAInH,EAAKU,GAAI,IAGlC,MAAMorC,EAAQ3rC,KAAKsmG,YAAYroG,IAAI4B,EAAKU,IACxC,IAAK,MAAMhD,KAAQouC,EAAO,CAEtB,GAAIpuC,EAAK6C,KAAKkB,SAAWolG,EAAYplG,OACjC,SAGJ,IAAIoZ,EAAQ,EACZ,KAAOA,EAAQnd,EAAK6C,KAAKkB,QACjB/D,EAAK6C,KAAKsa,KAAWgsF,EAAYhsF,KADNA,GAKnC,GAAIA,IAAUnd,EAAK6C,KAAKkB,OAEpB,OAAO/D,EAGf,MAAMmH,EAAI,IAAI,EAAAN,SAASvE,EAAKU,GAAImmG,GAGhC,OAFAhiG,EAAEJ,WAAazE,EAAKyE,WACpBqnC,EAAMzlC,KAAKxB,GACJA,EAGX,cAAc7E,EAAgBK,GAC1B,GAAIF,KAAKqmG,YAAYvyB,SAASj0E,GAC1B,OAAOA,EAEX,MAAMkB,EAAQlB,EAAKkB,MAAMhB,OAAOC,KAAME,GAChCc,EAAenB,EAAKmB,aAAajB,OAAOC,KAAME,GAC9Ce,EAA+BpB,EAAKoB,MAAM8E,IAAI+jC,IAChD,MAAMnrC,EAAMmrC,EAAK,GACXzrC,EAAQyrC,EAAK,GAAG/pC,OAAOC,KAAME,GACnC,OAAO7B,IAAUyrC,EAAK,GAAKA,EAAO,CAACnrC,EAAKN,KAE5C,IAAK,MAAMyhC,KAAQ9/B,KAAKqmG,YACpB,GACIvmE,EAAK/+B,QAAUA,GACf++B,EAAK9+B,eAAiBA,GACtBC,EAAMK,SAAWw+B,EAAK7+B,MAAMK,QAC5BL,EAAM8D,MACF,EAAEpG,EAAKN,GAAQjB,IAAMuB,IAAQmhC,EAAK7+B,MAAM7D,GAAG,IAAMiB,IAAUyhC,EAAK7+B,MAAM7D,GAAG,IAG7E,OAAO0iC,EAGf,MAAMp7B,EAAI,IAAI,EAAAU,SAASrE,EAAOC,EAAcC,GAE5C,OADAjB,KAAKqmG,YAAYngG,KAAKxB,GACfA,EAGX,qBAAqB7E,EAAuBK,GACxC,GAAIF,KAAKomG,mBAAmBtyB,SAASj0E,GACjC,OAAOA,EAEX,MAAMkB,EAAQlB,EAAKkB,MAAMhB,OAAOC,KAAME,GAChCe,EAA+BpB,EAAKoB,MAAM8E,IAAI+jC,IAChD,MAAMnrC,EAAMmrC,EAAK,GACXzrC,EAAQyrC,EAAK,GAAG/pC,OAAOC,KAAME,GACnC,OAAO7B,IAAUyrC,EAAK,GAAKA,EAAO,CAACnrC,EAAKN,KAE5C,IAAK,MAAMsoG,KAAU3mG,KAAKomG,mBACtB,GACIO,EAAO5lG,QAAUA,GACjB4lG,EAAOpoG,KAAK,KAAOsB,EAAKtB,KAAK,IAC7BooG,EAAOpoG,KAAK,KAAOsB,EAAKtB,KAAK,IAC7B0C,EAAMK,SAAWqlG,EAAO1lG,MAAMK,QAC9BL,EAAM8D,MACF,EAAEpG,EAAKN,GAAQjB,IAAMuB,IAAQgoG,EAAO1lG,MAAM7D,GAAG,IAAMiB,IAAUsoG,EAAO1lG,MAAM7D,GAAG,IAGjF,OAAOupG,EAGf,MAAMjiG,EAAI,IAAI,EAAAY,gBAAgBzF,EAAKtB,KAAMwC,EAAOE,GAEhD,OADAjB,KAAKomG,mBAAmBlgG,KAAKxB,GACtBA,K,2GC1Rf,aAEMkiG,EAAa,IAAI,EAAAjhG,QACjBkhG,EAAa,IAAI,EAAAlhG,QACjBmhG,EAAa,IAAI,EAAAnhG,QAKvB,4BAII,eAaA,OAAOuU,GACH,MAAM6sF,EAAe7sF,EAASkkE,aAAa,YACrCrwE,EAAW3M,MAAM6I,KAAK88F,EAAaptF,OAEnCipE,EAAS1oE,EAASkkE,aAAa,MAC/B4oB,OAAgBhlG,IAAX4gF,EAAuBxhF,MAAM6I,KAAK24E,EAAOjpE,YAAS3X,EAEvDilG,EAAW/sF,EAASkkE,aAAa,QACjC8oB,OAAoBllG,IAAbilG,EAAyB7lG,MAAM6I,KAAKg9F,EAASttF,YAAS3X,EAE7DmlG,EAAWjtF,EAASkkE,aAAa,QACjCgpB,OAAoBplG,IAAbmlG,EAAyB/lG,MAAM6I,KAAKk9F,EAASxtF,YAAS3X,EAE7DqlG,EAAYntF,EAASm6D,WACrBqR,EAAUtkF,MAAM6I,KAAKo9F,EAAU1tF,OAI/BzX,EAAQ,IAAIC,IAKlB,SAASmlG,EAAalqG,EAAW4kD,GAE7B,MAAMrjD,EAAM,GAAG0K,KAAKO,IAAIxM,EAAG4kD,MAAM34C,KAAKS,IAAI1M,EAAG4kD,KAEvC51B,EAAIlqB,EAAMjE,IAAIU,GAEpB,QAAUqD,IAANoqB,EAEA,OAAOA,EAIXw6E,EAAW5/F,IAAI+G,EAAa,EAAJ3Q,GAAQ2Q,EAAa,EAAJ3Q,EAAQ,GAAI2Q,EAAa,EAAJ3Q,EAAQ,IACtEypG,EAAW7/F,IAAI+G,EAAa,EAAJi0C,GAAQj0C,EAAa,EAAJi0C,EAAQ,GAAIj0C,EAAa,EAAJi0C,EAAQ,IACtE8kD,EAAWS,YAAYX,EAAYC,EAAY,IAG/C,MAAMnsF,EAAQ3M,EAASzM,OAAS,EAuChC,OAtCAyM,EAAS7H,QAAQ4gG,EAAWpkB,WAE5BxgF,EAAM8E,IAAIrI,EAAK+b,QAGJ1Y,IAAPglG,IACAJ,EAAW5/F,IAAIggG,EAAO,EAAJ5pG,GAAQ4pG,EAAO,EAAJ5pG,EAAQ,GAAI,GACzCypG,EAAW7/F,IAAIggG,EAAO,EAAJhlD,GAAQglD,EAAO,EAAJhlD,EAAQ,GAAI,GACzC8kD,EAAWS,YAAYX,EAAYC,EAAY,IAC/CG,EAAG9gG,KAAK4gG,EAAWrhG,EAAGqhG,EAAWphG,SAMxB1D,IAATklG,IACIA,EAAK9pG,KAAO4kD,GACZklD,EAAKhhG,KAAK87C,GACVklD,EAAK9pG,GAAKsd,GACHwsF,EAAKllD,KAAO5kD,GACnB8pG,EAAKhhG,KAAK9I,GACV8pG,EAAKllD,GAAKtnC,GAEVwsF,EAAKhhG,MAAM,SAGNlE,IAATolG,IACIA,EAAKhqG,KAAO4kD,GACZolD,EAAKlhG,KAAK87C,GACVolD,EAAKhqG,GAAKsd,GACH0sF,EAAKplD,KAAO5kD,GACnBgqG,EAAKlhG,KAAK9I,GACVgqG,EAAKplD,GAAKtnC,GAEV0sF,EAAKlhG,MAAM,IAIZwU,EAGX,MAAM8sF,EAAa,GACnB,KAAO9hB,EAAQpkF,QAAU,GAAG,CACxB,MAAM6tD,EAAKu2B,EAAQ+hB,QACbp4C,EAAKq2B,EAAQ+hB,QACbC,EAAKhiB,EAAQ+hB,QAQnB,OANAb,EAAW5/F,IAAI+G,EAAc,EAALohD,GAASphD,EAAc,EAALohD,EAAS,GAAIphD,EAAc,EAALohD,EAAS,IACzE03C,EAAW7/F,IAAI+G,EAAc,EAALshD,GAASthD,EAAc,EAALshD,EAAS,GAAIthD,EAAc,EAALshD,EAAS,IACzEy3C,EAAW9/F,IAAI+G,EAAc,EAAL25F,GAAS35F,EAAc,EAAL25F,EAAS,GAAI35F,EAAc,EAAL25F,EAAS,IAErD1nG,KAAK2nG,oBAAoBf,EAAYC,EAAYC,IAGjE,KAAK,EAAG,CACJ,MAAMc,EAAKN,EAAan4C,EAAIE,GAC5Bq2B,EAAQx/E,KAAKipD,EAAIy4C,EAAIF,EAAIE,EAAIv4C,EAAIq4C,GACjC,MAGJ,KAAK,EAAG,CACJ,MAAME,EAAKN,EAAaj4C,EAAIq4C,GAC5BhiB,EAAQx/E,KAAKipD,EAAIE,EAAIu4C,EAAIz4C,EAAIy4C,EAAIF,GACjC,MAGJ,KAAK,EAAG,CACJ,MAAME,EAAKN,EAAaI,EAAIv4C,GAC5Bu2B,EAAQx/E,KAAKipD,EAAIE,EAAIu4C,EAAIA,EAAIv4C,EAAIq4C,GACjC,MAGJ,UAAK1lG,EACDwlG,EAAWthG,KAAKipD,EAAIE,EAAIq4C,GACxB,MAGJ,QACI,MAAM,IAAIjkG,MAAM,2CAsB5B,OAlBAsjG,EAAaptF,MAAQ,IAAI6X,aAAazjB,GACtCg5F,EAAahtF,MAAQhM,EAASzM,OAASylG,EAAa/sF,SACpD+sF,EAAax6F,aAAc,EAE3B2N,EAASw3C,SAAS81C,QAEPxlG,IAAPglG,IACApkB,EAAOjpE,MAAQ,IAAI6X,aAAaw1E,GAChCpkB,EAAO7oE,MAAQitF,EAAG1lG,OAASshF,EAAO5oE,SAClC4oE,EAAOr2E,aAAc,QAGZvK,IAATklG,IACAD,EAASttF,MAAQ,IAAI6X,aAAa01E,GAClCD,EAASltF,MAAQmtF,EAAK5lG,OAAS2lG,EAASjtF,SACxCitF,EAAS16F,aAAc,GAGpB2N,K,gHCtKf,aACA,OACA,SAOA,kBAAa2tF,UAAiCzoG,EAAM0a,gBAkBhD,YACWguF,EACCC,EACAC,EACRhvF,GAEAhW,MAAM8kG,EAAkBnuF,MAAOmuF,EAAkB9tF,SAAU8tF,EAAkBp0E,YALtE,KAAAo0E,oBACC,KAAAC,YACA,KAAAC,QAlBJ,KAAAC,eAAyB,EACzB,KAAAC,gBAA0B,EAC1B,KAAAC,QAAU,IAAI,EAAAC,YAAYP,EAAyBQ,gBAEnD,KAAAC,UAAY,IAAIlpG,EAAMuG,QACtB,KAAA4iG,YAAc,IAAInpG,EAAMuG,QAiB5B3F,KAAKwoG,aAAaxvF,GAWtB,MACI8uF,EACAW,EACAC,EACA1vF,GAEAhZ,KAAK2Z,MAAQmuF,EAAkBnuF,MAC/B3Z,KAAKga,SAAW8tF,EAAkB9tF,SAClCha,KAAK+Z,MAAQ/Z,KAAK2Z,MAAMrY,OAAStB,KAAKga,SACtCha,KAAK0zB,WAAao0E,EAAkBp0E,WACpC1zB,KAAK8nG,kBAAoBA,EACzB9nG,KAAK+nG,UAAYU,EACjBzoG,KAAKgoG,MAAQU,EACb1oG,KAAKmoG,QAAQniE,QACbhmC,KAAK2oG,uBAAoB3mG,EACzBhC,KAAKwoG,aAAaxvF,GAKtB,KAAK0B,GACD,OAAO1a,KAAK4oG,uBAAuBluF,GAAOjV,EAE9C,KAAKiV,GACD,OAAO1a,KAAK4oG,uBAAuBluF,GAAOhV,EAE9C,KAAKgV,GACD,OAAO1a,KAAK4oG,uBAAuBluF,GAAO9U,EAGtC,aAAaoT,GACjBhZ,KAAK6oG,UAAY,IAAIr3E,aAAaxY,EAAgB1B,MAAMgwB,KAAK5W,QAC7D1wB,KAAKioG,eAAiBjvF,EAAgB1B,MAAMG,MAC5CzX,KAAKkoG,gBAAkBlvF,EAAgB1B,MAAMpG,OAEzC,uBAAuB43F,GAC3B,OAAIA,IAAgB9oG,KAAK2oG,kBACd3oG,KAAKsoG,WAEhBtoG,KAAK2oG,kBAAoBG,EACrB9oG,KAAKmoG,QAAQlqG,IAAI6qG,EAAa9oG,KAAKsoG,aAGvCtoG,KAAK+oG,iBAAiBD,GACtB9oG,KAAKmoG,QAAQnhG,IAAI8hG,EAAa9oG,KAAKsoG,YAHxBtoG,KAAKsoG,WAMZ,iBAAiBQ,GACrB9oG,KAAKsoG,UAAUU,oBACXhpG,KAAK8nG,kBACLgB,GAEJ,MAAML,EAAUzoG,KAAK+nG,UACrB/nG,KAAKuoG,YAAYS,oBAAoBP,EAASK,GAC9C,MAAMJ,EAAM1oG,KAAKgoG,MACXiB,EAAI7pG,EAAMkJ,UAAU6B,MAAMu+F,EAAIv0C,KAAK20C,GAAc,EAAG,GACpD3nG,EAAI/B,EAAMkJ,UAAU6B,MAAMu+F,EAAIt0C,KAAK00C,GAAc,EAAG,GACpDr1B,EAAe,EAAAy1B,eACjBlpG,KAAK6oG,UACL7oG,KAAKioG,eACLjoG,KAAKkoG,gBACLe,EACA9nG,GAEJnB,KAAKsoG,UAAUnoG,IAAIH,KAAKuoG,YAAY30F,eAAe6/D,KAE3D,OArGmB,EAAA40B,eAAiB,EAqGpC,GAtGA,GAAa,EAAAR,4B,6HCVb,aACA,QAEMsB,EAAQ,IAAI/pG,EAAMuG,QAClByjG,EAAQ,IAAIhqG,EAAMuG,QAClB0jG,EAAS,IAAIjqG,EAAMm7B,KAoBzB,SAAgB+uE,EACZtsF,EACAusF,EACAC,GAEAH,EAAO/5F,KAAK0N,GACZ,MAAMysF,EAAeN,EAAM75F,KAAKk6F,GAC1BE,EAAeN,EAAM95F,KAAKm6F,GAIhC,OAHAzsF,EAAI2sF,UAAUF,EAAa71F,eAAe21F,EAAkB3/F,MAAMggG,MAC9DP,EAAOM,UAAUD,EAAa91F,eAAe21F,EAAkBz/F,OAE5DkT,EAXX,gBAmBA,MAAa6sF,UAAgCzqG,EAAMob,eAY/C,YACWsvF,EACP9wF,EACOuwF,EACPQ,GAEA/mG,QALO,KAAA8mG,mBAEA,KAAAP,oBAbH,KAAAS,sBAAwB,IAAI5qG,EAAMm7B,KAyBlCv6B,KAAKiqG,qBARJF,GAC2B,IAAI,EAAAlC,yBAC5BiC,EAAiBrvF,WAAW1M,SAC5B+7F,EAAiBrvF,WAAWlF,OAC5Bu0F,EAAiBrvF,WAAWusF,GAC5BhuF,GAKRhZ,KAAKkqG,kBAST,MACIhwF,EACAlB,EACAuwF,GAEAvpG,KAAK8pG,iBAAmB5vF,EACxB,MAAMq1C,EAAYr1C,EAASO,WAAW1M,SAChC06F,EAAUvuF,EAASO,WAAWlF,OAC9BmzF,EAAMxuF,EAASO,WAAWusF,GAChChnG,KAAKiqG,qBAAqBzhE,MAAM+mB,EAAWk5C,EAASC,EAAK1vF,GACzD,MAAMmxF,EACFnqG,KAAKupG,kBAAkB3/F,MAAQ2/F,EAAkB3/F,KACjD5J,KAAKupG,kBAAkBz/F,MAAQy/F,EAAkBz/F,IACrD9J,KAAKupG,kBAAoBA,EACzBvpG,KAAKkqG,kBACLlqG,KAAKoqG,qBAAqBD,GAK9B,qBAK8C,OAAtCnqG,KAAK8pG,iBAAiB3nE,aACtBniC,KAAK8pG,iBAAiBO,qBAE1B,MAAMC,EAAWtqG,KAAKgqG,sBAAsB16F,KAAKtP,KAAK8pG,iBAAiB3nE,aAC9C,OAArBniC,KAAKmiC,YACLniC,KAAKmiC,YAAcmoE,EAASz9F,QAE5B7M,KAAKmiC,YAAY7yB,KAAKg7F,GAE1BhB,EACItpG,KAAKmiC,YACLniC,KAAKupG,kBACLJ,EAAMH,oBAAoBhpG,KAAKya,WAAWlF,OAAiC,IAMnF,wBAE6B,OAArBvV,KAAKmiC,aACLniC,KAAKqqG,qBAEmB,OAAxBrqG,KAAKuqG,iBACLvqG,KAAKuqG,eAAiB,IAAInrG,EAAM2N,QAEpC/M,KAAKmiC,YAAaqoE,kBAAkBxqG,KAAKuqG,gBAGrC,uBAAuBJ,GAC3B,OACIA,GACsB,OAArBnqG,KAAKmiC,eACAniC,KAAK8pG,iBAAiB3nE,cACnBniC,KAAKgqG,sBAAsBzP,OAAOv6F,KAAK8pG,iBAAiB3nE,cAIjE,qBAAqBgoE,GACrBnqG,KAAKyqG,uBAAuBN,KAC5BnqG,KAAKqqG,qBACDrqG,KAAKuqG,gBACLvqG,KAAK0qG,yBAKT,kBACJ1qG,KAAK0a,MAAQ1a,KAAK8pG,iBAAiBpvF,MACnC1a,KAAK4iC,OAAS5iC,KAAK8pG,iBAAiBlnE,OACpC5iC,KAAK2qG,UAAY3qG,KAAK8pG,iBAAiBa,UACvC3qG,KAAKya,WAAa,OAAH,UAAQza,KAAK8pG,iBAAiBrvF,YAC7Cza,KAAKya,WAAW1M,SAAW/N,KAAKiqG,sBAnHxC,6B,0KC5CA,aAcA,yBAA8Br4E,GAC1B,OAAQA,GACJ,IAAK,QACD,OAAOxyB,EAAMwrG,YACjB,IAAK,MACD,OAAOxrG,EAAMyrG,UACjB,IAAK,OACD,OAAOzrG,EAAMw+F,WACjB,IAAK,YACD,OAAOx+F,EAAMklF,gBACjB,IAAK,iBACD,OAAOllF,EAAM0rG,qBACjB,IAAK,OACD,OAAO1rG,EAAM2rG,WACjB,IAAK,QACD,OAAO3rG,EAAM4rG,YACjB,IAAK,eACD,OAAO5rG,EAAM6rG,mBACjB,IAAK,MACD,OAAO7rG,EAAM8rG,UACjB,QACI,MAAM,IAAIznG,MAAM,yBAAyBmuB,OAOrD,6BAAkCu5E,GAC9B,OAAQA,GACJ,IAAK,eACD,OAAO/rG,EAAMwxB,iBACjB,IAAK,OACD,OAAOxxB,EAAMyxB,SACjB,IAAK,QACD,OAAOzxB,EAAM2xB,UACjB,IAAK,gBACD,OAAO3xB,EAAM6xB,kBACjB,IAAK,MACD,OAAO7xB,EAAM+xB,QACjB,IAAK,cACD,OAAO/xB,EAAMiyB,gBACjB,IAAK,QACD,OAAOjyB,EAAMmyB,UACjB,IAAK,YACD,OAAOnyB,EAAMqyB,cACjB,QACI,MAAM,IAAIhuB,MAAM,8BAA8B0nG,OAO1D,0BAA+B5sG,GAC3B,OAAQA,GACJ,IAAK,QACD,OAAOa,EAAMgsG,oBACjB,IAAK,SACD,OAAOhsG,EAAMisG,eACjB,IAAK,SACD,OAAOjsG,EAAMksG,uBACjB,QACI,MAAM,IAAI7nG,MAAM,0BAA0BlF,OAOtD,2BAAgCi0B,GAC5B,OAAQA,GACJ,IAAK,UACD,OAAOpzB,EAAMmsG,cACjB,IAAK,uBACD,OAAOnsG,EAAMosG,2BACjB,IAAK,sBACD,OAAOpsG,EAAMqsG,0BACjB,IAAK,SACD,OAAOrsG,EAAMu+F,aACjB,IAAK,sBACD,OAAOv+F,EAAMssG,0BACjB,IAAK,qBACD,OAAOtsG,EAAMusG,yBACjB,QACI,MAAM,IAAIloG,MAAM,2BAA2B+uB,OAOvD,uBAA4BsjD,GACxB,OAAQA,EAAiBlmE,MACrB,IAAK,UAAW,CACZ,MAAM+lE,EAAQ,IAAIv2E,EAAMwsG,aACpB91B,EAAiB7qD,MACjB6qD,EAAiB+1B,WAGrB,OADAl2B,EAAMh4E,KAAOm4E,EAAiBn4E,KACvBg4E,EAEX,IAAK,cAAe,CAChB,MAAMA,EAAQ,IAAIv2E,EAAMy2E,iBACpBC,EAAiB7qD,MACjB6qD,EAAiB+1B,WAiBrB,OAfAl2B,EAAMh4E,KAAOm4E,EAAiBn4E,UACMqE,IAAhC8zE,EAAiB2J,aACjB9J,EAAM8J,WAAa3J,EAAiB2J,YAEpC9J,EAAM8J,aACN9J,EAAMnF,OAAOs7B,KAAO,KACpBn2B,EAAMnF,OAAOu7B,QAAQt0F,MAAQ,KAC7Bk+D,EAAMnF,OAAOu7B,QAAQ76F,OAAS,MAElCykE,EAAM5nE,SAAS/G,IACX8uE,EAAiB/lB,UAAUtqD,EAC3BqwE,EAAiB/lB,UAAUrqD,EAC3BowE,EAAiB/lB,UAAUnqD,GAE/B+vE,EAAM5nE,SAAS8C,YACR8kE,M,gOCxInB,aAGA,QACA,OACA,QAMa,EAAAq2B,4BAA8B,EA4D3C,SAAgBC,EAA2BC,GACvCA,EAAavyD,YAAa,EAC1BuyD,EAAaC,UAAY/sG,EAAMgtG,WAC/BF,EAAaG,YAAa,EAC1B,EAAAC,gBAAgBJ,GAEhB,MAAMK,EAA6DL,EAAar/F,QAQhF,OAPA0/F,EAAkBC,wBAAyB,EAC3CD,EAAkB5yD,YAAa,EAC/B4yD,EAAkBr9E,WAAY,EAC9Bq9E,EAAkBJ,UAAY/sG,EAAMqtG,UACpCF,EAAkBF,YAAa,EAC/BE,EAAkBrhF,QAAU,EAC5BqhF,EAAkB3hG,SAAWxL,EAAMk6F,WAC5BiT,EAxDX,uCAA4CjgF,EAAqClqB,GAE7E,IAAqC,IAAjCkqB,EAAU08B,mBACV,OAAO,EAEX,IAAIt+C,OACsB1I,IAAtBsqB,EAAUpB,SAAyBoB,EAAUpB,QAAU,GAAOoB,EAAUpB,QAAU,EAItF,IAAKxgB,EAAa,CAGd,MAAMugB,EAAQ,EAAAyhF,0BAA0BpgF,EAAWlqB,GACnD,QAAcJ,IAAVipB,EAAqB,CACrB,MAAMqoC,EAAQ,EAAA/lC,WAAWuJ,gBAAgB7L,GACzCvgB,EAAc4oD,EAAQ,GAAOA,EAAQ,GAG7C,OAAO5oD,GAuBX,+BAgCA,kCAAuCgX,GACnC,MAAMooF,EAAmBpoF,EAAKxH,SAE9B,KAAM4vF,aAA4B1qG,EAAMob,gBACpC,MAAM,IAAI/W,MAAM,yDAEpB,MAAMsoF,EAAoB+d,EAAiB1rB,aAAa,YACxD,IAAK2N,EACD,MAAM,IAAItoF,MAAM,qDAGpB,MAAMkpG,EAAoB,IAAIvtG,EAAMob,eACpCmyF,EAAkBl7C,aAAa,WAAYs6B,GAC3C,MAAM1L,EAAcypB,EAAiB1rB,aAAa,MAC9CiC,GACAssB,EAAkBl7C,aAAa,KAAM4uB,GAEzC,MAAMD,EAAkB0pB,EAAiB1rB,aAAa,UAClDgC,GACAusB,EAAkBl7C,aAAa,SAAU2uB,GAE7C,MAAMwsB,EAAyB9C,EAAiB1rB,aAAa,iBACzDwuB,GACAD,EAAkBl7C,aAAa,gBAAiBm7C,GAGhD9C,EAAiBpvF,OACjBiyF,EAAkBj7C,SAASo4C,EAAiBpvF,OAGhD,IAAK,MAAMioB,KAASmnE,EAAiBlnE,OAAQ,CACzC,MAAM,MAAEmH,EAAK,MAAEhwB,EAAK,cAAE8yF,GAAkBlqE,EACxCgqE,EAAkB93B,SAAS9qC,EAAOhwB,EAAO8yF,GAG7C,MAAMN,EACF7qF,EAAKjX,oBAAoBrJ,MACnBsgB,EAAKjX,SAAS1E,IAAIkmG,GAClBA,EAA2BvqF,EAAKjX,UAEpCm1E,EAAgB,IAAIxgF,EAAM40B,KAAK24E,EAAmBJ,GAGxD,OAFA3sB,EAAct5D,YAAc5E,EAAK4E,YAhIM,KAkIhCs5D,GAYX,kCAAuCktB,EAAuBC,GAK1D,MAAMC,EAAgBF,EAAUriG,SAChCuiG,EAAcC,cAAe,EAC7BD,EAAcE,YAAc9tG,EAAM+tG,cAClCH,EAAcI,aAAehuG,EAAM+tG,cACnCH,EAAcK,aAAejuG,EAAMkuG,iBACnCN,EAAcO,YAAcnuG,EAAMouG,kBAClCR,EAAcS,WAAa,IAC1BT,EAAsBU,gBAAkB,EAAA1B,4BAMzC,MAAM2B,EAAgBZ,EAAUtiG,SAChCkjG,EAAcV,cAAe,EAC7BU,EAAcT,YAAc9tG,EAAM+tG,cAClCQ,EAAcP,aAAehuG,EAAM+tG,cACnCQ,EAAcN,aAAejuG,EAAMwuG,cACnCD,EAAcJ,YAAcnuG,EAAMyuG,iBAClCF,EAAcF,WAAa,IAC1BE,EAAsBD,gBAAkB,EAAA1B,8B,+HCvL7C,aAEA,OACA,OAcA,SAAS8B,EAAchvG,EAAoBka,GACvC,KAAM,aAAcla,GAChB,OAGJ,MAAM2L,EAAY3L,EAAe2L,SAE7BrJ,MAAMC,QAAQoJ,GACdA,EAASpK,QAAQ0tG,IACT,EAAAC,uBAAuBD,KACvBA,EAAI/0F,gBAAkBA,KAGvBvO,GAAY,EAAAujG,uBAAuBvjG,KAC1CA,EAASuO,gBAAkBA,GAcnC,SAASi1F,EACLC,EACA9yF,EACApC,EACA7J,GAGA,MAAMg/F,EAAYh/F,EAAWgH,eAAe+3F,GAE5C,GAAIl1F,EAAgBkd,OAAOk4E,SAASD,GAChCA,EAAU9lG,SAAW+S,EAAkBizF,aAAaF,EAAWn1F,QAG/D,GADAm1F,EAAU9lG,SAAW+S,EAAkBC,UAAU8yF,EAAWn1F,EAAgB4K,QAAQhI,YACzD5Z,IAAvBmsG,EAAU9lG,SACV,OAAO,EAIf,OADA8G,EAAWsB,aAAa09F,EAAWD,IAC5B,EAmCX,8BACIprE,EACA1nB,EACApC,EACA7J,GAEA,EAAA7C,QAAQw2B,EAAYvc,UACfvN,IAIL8pB,EAAYvc,SAAWuc,EAAY5b,KAjCvC,SACIA,EACA9L,EACApC,EACA7J,GAEA,IAAK,MAAMpB,KAAYmZ,EACnB,IAAK+mF,EAAgBlgG,EAAUqN,EAAmBpC,EAAiB7J,GAC/D,OAAO,EAGf,OAAO,EAuBDm/F,CAAYxrE,EAAY5b,KAAM9L,EAAmBpC,EAAiB7J,GAClE8+F,EAAgBnrE,EAAY/0B,SAAUqN,EAAmBpC,EAAiB7J,KASpF,8BAAmCsT,GAC/B,MAAMrH,EAAoBqH,EAAKvU,QAAQkN,kBAEvC,QAA0BpZ,IAAtBoZ,GAA2D,IAAxBqH,EAAKme,QAAQt/B,OAChD,OAEJ,MAAMitG,EAAc9rF,EAAKme,QAAQ,GACjC,IACK2tE,EAAYzsF,WACZysF,EAAYzsF,SAASirB,OACrBwhE,EAAYzsF,SAASirB,KAAK7U,KAAM6U,GACtBA,IAAS,EAAAgnC,aAAaqP,KAAOr2C,IAAS,EAAAgnC,aAAay6B,SAG9D,OAGJ,MAAMx1F,EAAkBoC,EAAkBs6B,mBAAmBjzB,EAAKmB,SAClE,QAAwB5hB,IAApBgX,EAKJ,IAAK,MAAMla,KAAU2jB,EAAKme,QACtBktE,EAAchvG,EAAQka,EAAgB7B,W,iXChJ9C,aACA,OACA,OAWA,OACA,OAEA,SACA,SAGA,QAEA,QAaMs3F,EAAc,IAAIrvG,EAAMuG,QAAQ,EAAG,EAAG,GACtC+oG,EAAe,IAAItvG,EAAMuG,QAAQ,EAAG,EAAG,GACvCgpG,EAAc,IAAIvvG,EAAMuG,QAAQ,EAAG,EAAG,GA2D5C,SAAgB68C,EACZ1f,EACA8rE,EACAC,GAEA,IAAI54D,EAGJ,MAAM/uB,EAAO4b,EAAY5b,KACzB,GAAIA,GAAQA,EAAK5lB,OAAS,EAAG,CACzB,MAAMwtG,EAAgBrwD,EAAqBv3B,EAAK,GAAI0nF,EAAaC,GAC3DE,EAAgBtwD,EAAqBv3B,EAAKA,EAAK5lB,OAAS,GAAIstG,EAAaC,GAE/E54D,EAAe5sC,KAAKO,IAAIklG,EAAeC,QAEvC94D,EAAewI,EAAqB3b,EAAY/0B,SAAU6gG,EAAaC,GAG3E,OAAO54D,EAYX,SAAgBwI,EACZuwD,EACAC,EACAC,GAGA,OADoBP,EAAYr/F,KAAK0/F,GAAUl8F,IAAIm8F,GAChCv5F,IAAIw5F,GAiB3B,IAAYh0D,EArDZ,wBA8BA,yBAgBA,8BAAmCuE,EAAsB3D,GACrD,OAAO2D,EAAUzB,kBAAoBlC,GAMzC,SAAYZ,GACR,eACA,2BACA,6BACA,uBACA,6BACA,qBANJ,CAAYA,EAAA,EAAAA,qBAAA,EAAAA,mBAAkB,KAS9B,MAAMi0D,EAAuB,IAAI/vG,EAAMuG,QACjCypG,EAAqB,IAAIhwG,EAAM42D,KAcrC,kCACIlzB,EACA2c,EACA4vD,EACAz4B,EACA97B,GAEA,IAAI7E,EAEJ,OAAKnT,EAAY1c,QAMZwwD,EAAW04B,sBAAsBxsE,GASjCA,EAAY1c,SACZ,EAAA9d,UAAUu2C,UACPY,EAAU7oC,UACVksB,EAAY/iB,aACZ+iB,EAAY9iB,eAMpBi2B,OACwBj0C,IAApB84C,EACM0H,EAAoB1f,EAAa2c,EAAU5kB,YAAa4kB,EAAUvL,cA7JhF,SACIpR,EACAqmD,EACA0lB,EACAU,EACAz0D,GAEA,MAAMoD,EAAesE,EAAoB1f,EAAaqmD,EAAQ0lB,GAE9D,OAAIU,IAAmB,EAAA1/F,eAAee,UAC3BstC,GAAgBpD,EAAkBoD,OAAel8C,GAI5DysG,EAAYn/F,KAAKwzB,EAAY/0B,UAAU8C,YACvC69F,EAAap/F,KAAK65E,GAAQt4E,YACT49F,EAAY/4F,IAAIg5F,GA9BE,mBAgCcxwD,GAAgBpD,EACvDoD,OACAl8C,GA0IAwtG,CACI1sE,EACA2c,EAAU5kB,YACV4kB,EAAUvL,aACVuL,EAAUtwC,WAAWS,KACrBkrC,QAGO94C,IAAjBi0C,EACO,CAAE9vC,OAAQ+0C,EAAmBu0D,OAAQx5D,gBAGzC,CAAE9vC,OAAQ+0C,EAAmBC,GAAIlF,iBAlB7B,CAAE9vC,OAAQ+0C,EAAmBmE,UAAWpJ,gBAbxC,CAAE9vC,OAAQ+0C,EAAmBw0D,SAAUz5D,gBARvC,CAAE9vC,OAAQ+0C,EAAmBmE,UAAWpJ,iBAoJvD,MAAMozD,EAAS,IAAIjqG,EAAM42D,KACnB25C,EAAyB,GACzBC,EAA8C,GAC9CC,EAAoC,GACpCC,EAAkB,IAAI,EAAAC,aACtBC,EAAoB,IAAI5wG,EAAMoG,QAC9ByqG,EAAgB,IAAI7wG,EAAMoG,QAC1B0qG,EAAW,IAAI,EAAAjuD,OAAOkuD,IACtBC,EAAY,IAAIhxG,EAAMoG,QACtB6qG,EAAU,IAAIjxG,EAAMoG,QAgB1B,IAAY45C,EAuSZ,SAASkxD,EACLnyD,EACA1P,EACA8hE,EACAzvD,EACAvP,EACAnvC,EACAouG,EACAC,EACAC,EACAC,GAEA,MAAM3qG,EAAQm4C,EAAWhmB,QACzB,EAAA7rB,YAAwBtK,IAAjBgE,EAAMgpC,QACb,EAAA1iC,YAA6BtK,IAAtBgE,EAAM2gB,aAEb,MAAMiqF,OAA+B5uG,IAAjBgE,EAAMmyC,QAAwBu4D,OAC7B1uG,IAAjBgE,EAAMmyC,SACNnyC,EAAMmyC,OAAS,IAAI/4C,EAAM42D,MAI7B66C,EAAmBt/D,EAAYg/D,GAE3BK,IAEAhB,EAAqBkB,2BAAwB9uG,EAC7C4tG,EAAqB1oF,UAAOllB,EAC5B4tG,EAAqBlhE,cAAe,EACpCkhE,EAAqBhhE,gBAAkB5oC,EAAM6oC,eAE7C0C,EAAWq/D,YAAY5qG,EAAMgpC,OAAShpC,EAAMmyC,OAAQy3D,GAIpD5pG,EAAMmyC,OAAO44D,eAAe,EAAAC,iCAIhC,MAAMC,EAvcV,SACInuE,EACAytE,EACAzvD,EACA1+C,EACAyhB,EAAwB,IAAIzkB,EAAMoG,SASlC,OAPA,EAAA8G,OAAOw2B,EAAYlzB,OAAS,EAAAgX,gBAAgBC,UAC5C,EAAAva,YAAmCtK,IAA5B8gC,EAAYnc,aACnB,EAAAra,YAA8BtK,IAAvB8gC,EAAYqV,QAEnBt0B,EAAOpe,EAAIq9B,EAAYld,QACvB/B,EAAOne,EAAIo9B,EAAYjd,QAEf0qF,EAAUnkF,GACd,KAAK,EAAAxD,oBAAoB6B,KAErB5G,EAAOpe,GAAKq9B,EAAYqV,OAAQruC,IAAIrE,EACpC,MACJ,KAAK,EAAAmjB,oBAAoBsoF,MAErBrtF,EAAOpe,GAAKq9B,EAAYqV,OAAQvuC,IAAInE,EAG5C,OAAQ8qG,EAAUpvG,GACd,KAAK,EAAAwnB,kBAAkBwoF,IACnBttF,EAAOne,GAAKo9B,EAAYqV,OAAQvuC,IAAIlE,EACpC,MACJ,KAAK,EAAAijB,kBAAkByoF,OACnBvtF,EAAOne,GAAK,IAAOo9B,EAAYqV,OAAQruC,IAAIpE,EAAIo9B,EAAYqV,OAAQvuC,IAAIlE,GACvE,MACJ,KAAK,EAAAijB,kBAAkB0oF,OAEnBxtF,EAAOne,GAAKo9B,EAAYqV,OAAQruC,IAAIpE,EAI5C,QAA4B1D,IAAxB8gC,EAAY1d,SAAyB,EAAAksF,gBAAgBxuE,EAAY1d,SAAU,CAC3E,EAAA9Y,YAA6CtK,IAAtC8gC,EAAY1d,QAAQmsF,eAC3B,EAAAjlG,YAA8CtK,IAAvC8gC,EAAY1d,QAAQosF,gBAG3B3tF,EAAOpe,GAAKq9B,EAAY1d,QAAQmsF,eAAkB,GAAMhB,EAAUnkF,GAClEvI,EAAOne,GAAKo9B,EAAY1d,QAAQosF,gBAAmB,GAAMjB,EAAUpvG,GAInE,MAAMswG,EAAS,EAAAC,wBAAwB5uE,EAAYnc,YAAa2E,qBAC1DqmF,EAAS,EAAAC,wBAAwB9uE,EAAYnc,YAAa4E,mBAChE,GAAIkmF,IAAWlB,EAAUnkF,GAAKulF,IAAWpB,EAAUpvG,EAAG,CAElD,MAAMmrB,EAAYwW,EAAY1d,QAAQkH,UACtC,IAAIq5B,EAAc,EAAAz4B,iBAAiBZ,EAAUq5B,YAAavjD,GACtDwjD,EAAc,EAAA14B,iBAAiBZ,EAAUs5B,YAAaxjD,GAC1DujD,EAAqC,iBAAhBA,EAA2BA,EAAc,EAC9DC,EAAqC,iBAAhBA,EAA2BA,EAAc,EAK9D,MAAMisD,EAAaJ,EAASlB,EAAUnkF,EAChC0lF,EAAaH,EAASpB,EAAUpvG,EAChC4wG,EAAapsD,EAAc7iB,EAAYld,QACvCosF,EAAapsD,EAAc9iB,EAAYjd,QAEzC4rF,IAAW,EAAA7oF,oBAAoBwoF,QAAUO,IAAW,EAAAhpF,kBAAkByoF,QAGtEvtF,EAAOpe,GAAK,EAAI4D,KAAK2S,IAAI61F,GAAcE,EACvCluF,EAAOne,GAAK,EAAIosG,EAAazoG,KAAK2S,IAAI+1F,GAEtCluF,EAAOne,GAAK,EAAI2D,KAAK2S,IAAI81F,GAAcE,EACvCnuF,EAAOpe,GAAK,EAAIosG,EAAaxoG,KAAK2S,IAAIg2F,KAGtCnuF,EAAOpe,GAAK,EAAI4D,KAAKO,IAAIP,KAAK2S,IAAI61F,GAAa,IAAOE,EACtDluF,EAAOne,GACH,EACA2D,KAAKD,KAAK0oG,GACVzoG,KAAKO,IAAIP,KAAK2S,IAAI81F,GAAa,IAC/BzoG,KAAK2S,IAAI+1F,GAEbluF,EAAOne,GAAK,EAAI2D,KAAKO,IAAIP,KAAK2S,IAAI81F,GAAa,IAAOE,EACtDnuF,EAAOpe,GACH,EACA4D,KAAKD,KAAKyoG,GACVxoG,KAAKO,IAAIP,KAAK2S,IAAI61F,GAAa,IAC/BxoG,KAAK2S,IAAIg2F,KAMzB,OADAnuF,EAAOjQ,eAAektC,GACfj9B,EA0WYouF,CAAuBjsG,EAAOuqG,EAAWzvD,EAAO1+C,EAAK6tG,GAgBxE,GAfAgB,EAAW9wG,IAAIsuC,GACf46D,EAAO/5F,KAAKtJ,EAAMmyC,QAClBkxD,EAAOM,UAAUsH,GAEjB5H,EAAOp6B,UAAUmhC,GACjB/G,EAAO3+B,QAAQ2lC,GAEfA,EAAQz8F,eAAektC,GACvBovD,EAASlpG,IAAIopG,EAAU3qG,EAAI4qG,EAAQ5qG,EAAI,EAAG2qG,EAAU1qG,EAAI2qG,EAAQ3qG,EAAI,EAAG2qG,EAAQ5qG,EAAG4qG,EAAQ3qG,GAG1FirG,EAAkB3pG,IAAIiqG,EAAWxrG,EAAGwrG,EAAWvrG,EAAGy4C,EAAWiD,iBAIxDovD,EAAiBzlC,UAAUmlC,GAC5B,OAAO9wD,EAAgBC,UAG3B,MAAM6yD,EAAa/zD,EAAW/3B,QAE9B,OAAIqqF,EAIOyB,EAAa9yD,EAAgBE,SAAWF,EAAgBC,WAG/DuxD,IAIAvH,EAAO3+B,QAAQ2lC,GACfA,EAAQz8F,eAAektC,GAAS,EAAI,EAAAqxD,iCACpCjC,EAASlpG,IACLopG,EAAU3qG,EAAI4qG,EAAQ5qG,EAAI,EAC1B2qG,EAAU1qG,EAAI2qG,EAAQ3qG,EAAI,EAC1B2qG,EAAQ5qG,EACR4qG,EAAQ3qG,KAKXM,EAAMk/C,gBAAkBsrD,EAAiB4B,YAAYlC,GAE/CgC,EAAa9yD,EAAgBE,SAAWF,EAAgBC,WAQ/Dr5C,EAAMqsG,mBACN7B,EAAiB8B,SAASpC,GAK1BU,IACA5qG,EAAM26C,sBAAmB3+C,GAM7Bm8C,EAAWo0D,cAAgBhC,EAEpBnxD,EAAgBjE,KAQ3B,SAAS01D,EAAmBt/D,EAAwBg/D,GAGhDh/D,EAAW+F,gBAAgBhsB,oBAAsB,EAAA/C,oBAAoBgoF,EAAUnkF,GAC/EmlB,EAAW+F,gBAAgB/rB,kBAAoB,EAAA9C,oBAAoB8nF,EAAUpvG,GA1apE,EAAA6vG,+BAAiC,IAAI5xG,EAAMoG,QAAQ,EAAG,GAStD,EAAA2sG,+BAAiC,GAE9C,SAAY/yD,GACR,eACA,2BACA,6BAHJ,CAAYA,EAAA,EAAAA,kBAAA,EAAAA,gBAAe,KAiB3B,qBACIZ,EACAp5B,EACAqpB,EACAiS,EACAt+C,EACAouG,GAGA,OADA,EAAAgC,YAAYC,qBAAqBrtF,EAASqpB,EAAgBiS,EAAat+C,EAAK8tG,GACvEM,EAAiBzlC,UAAUmlC,IAKL,IAAvB9qF,EAAQ2B,aAAwBypF,EAAiB4B,YAAYlC,GAK1D9wD,EAAgBjE,GAFZqD,EAAgBusB,YAAc3rB,EAAgBE,SAAWF,EAAgBC,UAPzED,EAAgBC,WAkC/B,2BACIlB,EACA1P,EACAqS,EACAvP,EACAnvC,EACAouG,EACAC,EACAE,EACA+B,GAAuB,GAEvB,EAAApmG,YAA0CtK,IAAnCm8C,EAAWhmB,QAAQxR,aAE1B,MAAMA,EAAcw3B,EAAWhmB,QAAQxR,YAIjCgsF,GAAYx0D,EAAW/3B,QAC7B,OAAIqqF,GAAckC,EACPvzD,EAAgBC,YAG3BqzD,EACIA,QAA0C1wG,IAA3B2kB,EAAY6E,YAA4B7E,EAAY6E,WAAWlqB,OAAS,IAEvEmvG,EA4JxB,SACItyD,EACA1P,EACAqS,EACAvP,EACAnvC,EACAouG,EACAC,EACAE,GAEA,EAAArkG,YAA0CtK,IAAnCm8C,EAAWhmB,QAAQxR,aAG1B,MAAMisF,EAAgBz0D,EAAWo0D,cAcjC,OAbejC,EACXnyD,EACA1P,EACAmkE,EACA9xD,EACAvP,EACAnvC,EACAouG,EACAC,GACCtyD,EAAW/3B,QACZuqF,GAnLOkC,CACH10D,EACA1P,EACAqS,EACAvP,EACAnvC,EACAouG,EACAC,EACAE,GAsCZ,SACIxyD,EACA1P,EACAqS,EACAvP,EACAnvC,EACAouG,EACAG,GAEA,EAAArkG,YAA0CtK,IAAnCm8C,EAAWhmB,QAAQxR,aAE1B,MAAM3gB,EAAQm4C,EAAWhmB,QAGnB+5E,EAAa/zD,EAAW/3B,QAIxBwsF,EAAgBz0D,EAAWo0D,cAC3B/mF,EAAaxlB,EAAM2gB,YAAa6E,WAChCsnF,EAAgBtnF,EAAWlqB,OAG3ByxG,EAAWvnF,EAAWu4D,UAAU7kF,GAAKA,EAAEktB,IAAMwmF,EAAcxmF,GAAKltB,EAAEiC,IAAMyxG,EAAczxG,GAC5F,EAAAmL,OAAOymG,GAAY,GAEnB,IAAIC,GAAwB,EAE5B,IAAK,IAAI51G,EAAI21G,EAAU31G,EAAI01G,EAAgBC,IAAY31G,EAAG,CACtD,MAAM61G,EAAkBznF,EAAWpuB,EAAI01G,GAIjCI,EAAkB91G,IAAM21G,GAAYb,EAEpCiB,EAAkB7C,EACpBnyD,EACA1P,EACAwkE,EACAnyD,EACAvP,EACAnvC,EACAouG,GACA,GACC0C,EACDvC,GAWJ,GAPIuC,IACA,EAAA5mG,YAAwBtK,IAAjBgE,EAAMmyC,QACbg3D,EAAqB7/F,KAAKqhG,GAC1BvB,EAAmB9/F,KAAKtJ,EAAMmyC,SAI9Bg7D,IAAoB/zD,EAAgBC,YAKpC2zD,GAAe,EAIfG,IAAoB/zD,EAAgBE,UAKxC,OAAOF,EAAgBjE,GAS3B,OANAw1D,EAAkBrhG,KAAK6/F,GACvBnpG,EAAMmyC,OAAQ7oC,KAAK8/F,GAGnByB,EAAmBt/D,EAAYqhE,GAExBI,EAED5zD,EAAgBC,UAChB6yD,EAEA9yD,EAAgBE,SAEhBF,EAAgBC,UAvHX+zD,CACHj1D,EACA1P,EACAqS,EACAvP,EACAnvC,EACAouG,EACAG,IAiUZ,0BACIxyD,EACAf,EACA3O,EACA8C,EACAi/D,GAaA,GATAZ,EAAqB1oF,KAAOk2B,EAC5BwyD,EAAqBkB,sBAAwBnB,EAC7CC,EAAqBhhE,gBAAkBuP,EAAWhmB,QAAQ0W,gBAOrD0C,EAAWq/D,YAAYzyD,EAAWhmB,QAAQ6W,OAASq6D,EAAQuG,GAC5D,OAAOxwD,EAAgBE,SAK3B,GADAwwD,EAAgBxgG,KAAK+5F,EAAOM,UAAUl7D,KACjC+hE,EAAiBzlC,UAAU+kC,GAC5B,OAAO1wD,EAAgBC,UAG3B,IACIg0D,EADAC,GAAsB,EAErBn1D,EAAWhmB,QAAQ+sB,iBACpBmuD,EAAiB7C,EAAiB+C,OAAOzD,GACzCwD,EAAsBD,EAAe/xG,OAAS,GAGlD,MAAMkyG,GAAqBhD,EAAiBiD,eAAe3D,GAG3DD,EAAkBvuG,OAASquG,EAASruG,OACpC,IAAK,IAAIlE,EAAI,EAAGA,EAAIuyG,EAASruG,SAAUlE,EAAG,CACtC,MAAMs2G,EAAW/D,EAASvyG,GAAGusG,UAAUl7D,GACvC,IAAIklE,EAAe9D,EAAkBzyG,GAOrC,QANqB4E,IAAjB2xG,GACAA,EAAe,IAAI,EAAA5D,aAAa2D,GAChC7D,EAAkBzyG,GAAKu2G,GAEvBA,EAAarkG,KAAKokG,GAElBF,IAAsBhD,EAAiBzlC,UAAU4oC,GACjD,OAAOv0D,EAAgBC,UAG3B,GACIi0D,GACA9C,EAAiBoD,kBAAkBD,EAAcN,GAEjD,OAAOj0D,EAAgBE,SAI/B,GAAInB,EAAWhmB,QAAQk6E,kBAAmB,CACtC,MAAMsB,EAAe,IAAI,EAAAE,qBAAqB/D,EAAiBD,EAAkBvpG,SACjFupG,EAAkBvuG,OAAS,EAC3BkvG,EAAiB8B,SAASqB,GAE9B,OAAOv0D,EAAgBjE,IAU3B,+BACIrY,EACAgxE,EACAC,GAEA,EAAAznG,OAAOw2B,EAAYlzB,OAAS,EAAAgX,gBAAgBE,WAI5CitF,EAAgBzyG,OAAS,EACzB,IAAI0yG,GAAkB,EAEtB,IAAK,MAAM12D,KAAMxa,EAAYxxB,OAA2B,MAKhCtP,KAHAgyG,EACdF,EAAgBvyD,QAAQjE,EAAI0yD,GAC5B8D,EAAgBG,gBAAgB32D,EAAI0yD,MAI1CgE,GAAkB,EAElBD,EAAgB7tG,KAAK8pG,EAAkBnjG,UAU3C,IAAKmnG,EACD,OAAO,EAKX,MAAME,EAp2BqB,EAo2BJpxE,EAAYtd,KAAKlkB,OAKxC,OAHA+nG,EAAOr6B,cAAc+kC,GACC1K,EAAOv/F,IAAIgJ,IAAIu2F,EAAOz/F,KAAKuqG,WAE7BD,EAAiBA,IACjCpxE,EAAY8T,iBAAkB,GACvB,IAMf,MAAMw9D,EAAiB,IAAI,EAAA/yE,aAa3B,4BACIgzE,EACAllG,EACA/M,EACAkyG,G,QAEA,MAAMC,EAAwB,EAAArnF,iBACmB,QADH,EACzB,QAAhB,EAAAmnF,EAASjvF,eAAO,eAAEkH,iBAA0B,eAAEkoF,YAC/CpyG,GAGJ,GADAkyG,WAAkBhlG,KAAK+kG,EAAStmG,UAE5BwmG,cAE6BvyG,IAA7BqyG,EAASluF,gBACX,CACEhX,EAAW+F,kBAAkBm/F,EAAStmG,SAAUqmG,GAChD,MAAMK,EAAwBL,EAAevmG,MACvC6mG,EAAqBt1G,EAAMkJ,UAAUW,SAASorG,EAASluF,iBAE7DsuF,EAAsBE,eAAeP,EAAetmG,MAAMiF,SAAU2hG,GAEpEJ,EAAiBz9C,gBAAgBu9C,EAAevmG,MAAO0mG,GAE3D,OAAOD,I,mGCn7BX,aACA,OAEA,OACA,OAGA,SAIA,SAEM9nG,EAAS,EAAAC,cAAcxM,SAASvB,OAAO,eAGvCk2G,EAAU,IAAIx1G,EAAMuG,QAAQ,GAM5BkvG,EAAe,IAAIz1G,EAAMsqB,MAAM,EAAG,EAAG,GAKrCorF,EAAe,IAAI11G,EAAMsqB,MAc/B,kBAAMqrF,EAgBF,YACa7mG,EACAyqB,EACAq8E,EACA1uF,GAHA,KAAApY,UACA,KAAAyqB,QACA,KAAAq8E,YACA,KAAA1uF,cAYb,YAC2BtkB,IAAnBhC,KAAKi1G,WACLj1G,KAAKk1G,QAOb,aAC2BlzG,IAAnBhC,KAAKi1G,WACLj1G,KAAKm1G,OAETn1G,KAAKi1G,UAAWzsE,QAMpB,cAC2BxmC,IAAnBhC,KAAKi1G,WACLj1G,KAAKm1G,OAETn1G,KAAKi1G,UAAWG,uBASpB,kBAAkB/gD,QACSryD,IAAnBhC,KAAKi1G,WACLj1G,KAAKi1G,UAAUI,kBAAkBhhD,GAOjC,QAEJ,MAEMl9C,EAAU,IAAI/X,EAAM8Y,QACtBlY,KAAKg1G,UAAUM,UACfl2G,EAAMm2G,eACNvzG,OACAA,GACA+yG,EAAqBS,UAAYp2G,EAAMu+F,cACvCoX,EAAqBS,UAAYp2G,EAAMusG,yBAA2BvsG,EAAMu+F,aACxEv+F,EAAMw+F,YAENmX,EAAqBS,WAAax1G,KAAKg1G,UAAUS,UAEjDt+F,EAAQu+F,QAAU11G,KAAKg1G,UAAUS,QACjCt+F,EAAQG,MAAQH,EAAQu+F,QAAQ,IAEpCv+F,EAAQ4Y,OAAQ,EAChB5Y,EAAQw+F,kBAjBmB,EAkB3Bx+F,EAAQ5K,aAAc,EAEtBvM,KAAK41G,WAAa,IAAI,EAAAC,aAAa,CAC/B9vG,IAAKoR,IAGTnX,KAAKi1G,UAAY,IAAI,EAAAa,UAAU91G,KAAK41G,WAAY51G,KAAKsmB,aAErD,MAAM5E,EAAO1hB,KAAKi1G,UAAUvzF,KAE5BA,EAAKmwC,eAAgB,EAErB7xD,KAAK24B,MAAMx4B,IAAIuhB,GAEf1hB,KAAKkO,QAAQmkC,UAErB,OA3GW,EAAAmjE,WAAqB,EA2GhC,GA7GA,GAkHA,MAAMO,EAaF,YAAqB7nG,EAA2BqjC,GAA3B,KAAArjC,UAA2B,KAAAqjC,aAZvC,KAAAykE,QAAkC,GAC1B,KAAAC,WAA+C,IAAI9zG,IAkBpE,YAAYijB,GACR,MAAM,UAAE4vF,EAAS,aAAE7uD,EAAY,iBAAE+vD,GAAqB9wF,EAEtD,QACkBpjB,IAAdgzG,QACqBhzG,IAArBk0G,QACiBl0G,IAAjBmkD,EAGA,OAzKiB,EA4KrB,MAAM7/B,EAAclB,EAAQkB,YAItB6vF,EAAWhwD,EAAa7uC,MAC9B,IACI8+F,EACAC,EAFAC,EAAWt2G,KAAKi2G,WAAWh4G,IAAIk4G,GAUnC,QANiBn0G,IAAbs0G,IACAA,EAAW,IAAIn0G,IACfnC,KAAKi2G,WAAWjvG,IAAImvG,EAAUG,IAGlCF,EAAcE,EAASr4G,IAAIqoB,QACPtkB,IAAhBo0G,EACA,OAAOA,EAEXA,EAAcp2G,KAAKg2G,QAAQ10G,OAE3B,IAAIqtC,EAAQ3uC,KAAKuxC,WAAWyF,SAAS1wB,GAerC,YAdctkB,IAAV2sC,IACA3uC,KAAKuxC,WAAWxC,QAAQ,GAAI6lE,EAAS,CAAEjmE,MAAOroB,IAC9CqoB,EAAQ3uC,KAAKuxC,WAAWyF,SAAS1wB,IAGrC+vF,EAAc,IAAItB,EACd/0G,KAAKkO,QACLygC,EAAOuI,QAAQve,MACfq8E,EACA1uF,GAEJ+vF,EAAYlB,OACZmB,EAAStvG,IAAIsf,EAAa8vF,GAC1Bp2G,KAAKg2G,QAAQ9vG,KAAKmwG,GACXD,EAWX,OAAOhxF,EAAkBmxF,EAAuBtgE,EAAsB/qB,GAClE,MAEMsrF,OADyBx0G,IAA3BojB,EAAQC,iBA5NS,IA4NuBD,EAAQC,eACjBD,EAAQC,eAAkBrlB,KAAKy2G,YAAYrxF,GAC9E,IA9NqB,IA8NjBoxF,EACA,OA/NiB,EAyOrB,IAAIvrF,EAoBJ,OA5BA,EAAA3e,OAAOkqG,GAAc,GACrB,EAAAlqG,OAAOkqG,EAAax2G,KAAKg2G,QAAQ10G,QACjC,EAAAgL,YAAyBtK,IAAlBojB,EAAQsxF,YAE4B10G,IAAvChC,KAAKg2G,QAAQQ,GAAYvB,WACzBj1G,KAAKg2G,QAAQQ,GAAYrB,YAIEnzG,IAA3BojB,EAAQohC,gBACRv7B,EAAQ6pF,EAAaplC,UAAUtqD,EAAQohC,qBACbxkD,IAAtBojB,EAAQmhC,YACRt7B,EAAQ6pF,EAAaz/F,SAAS+P,EAAQmhC,aAG1Ct7B,OAD6BjpB,IAAtBojB,EAAQmhC,UACPnhC,EAAQmhC,UAERsuD,EAEZ70G,KAAKg2G,QAAQQ,GAAYvB,UAAW0B,OAChCJ,EACAnxF,EAAQsxF,MACRzrF,EACAC,EACA+qB,EACA7wB,EAAQ0d,aAGL0zE,EASX,SAAS97F,GACL,GAAIA,GAAS,EAET,OADA,EAAApO,OAAOoO,EAAQ1a,KAAKg2G,QAAQ10G,QACrBtB,KAAKg2G,QAAQt7F,GAU5B,QACI,IAAK,MAAMk8F,KAAS52G,KAAKg2G,QACrBY,EAAMpuE,QAOd,SACI,IAAK,MAAMouE,KAAS52G,KAAKg2G,QACrBY,EAAMvkE,SAWd,iBACI5D,EACAwlB,GAEA,IAAK,MAAM2iD,KAAS52G,KAAKg2G,aACGh0G,IAApB40G,EAAM3B,WACN2B,EAAMzB,OAEVyB,EAAM3B,UAAW4B,UAAUpoE,EAAgBwlB,EAAc2iD,EAAM5B,UAAUM,WASjF,kBAAkBjhD,GACd,IAAK,MAAMuiD,KAAS52G,KAAKg2G,QAAS,CAC9B,QAAkCh0G,IAA9B40G,EAAM5B,UAAUM,UAAyB,CACzC,MAAM99F,EACFo/F,EAAM5B,UAAUM,UAAU79F,MAAQm/F,EAAM5B,UAAUM,UAAUpkG,OAAS,EACzEmjD,EAAK38C,UAAYF,EACjB68C,EAAK18C,SAAWH,OAEIxV,IAApB40G,EAAM3B,WACN2B,EAAM3B,UAAUI,kBAAkBhhD,KAUlD,kBAAam+C,EAwDT,YAAqBtkG,EAA2BqjC,GAA3B,KAAArjC,UAA2B,KAAAqjC,aATxC,KAAAulE,gBAAkB,IAAI,EAAA70D,OAAOkuD,IAUjCnwG,KAAK+2G,eAAiB,IAAIhB,EAAgB7nG,EAASqjC,GA7CvD,4BACInsB,EACAqpB,EACAqS,EACA1+C,EACUm0G,EAAwB,IAAI,EAAAt0D,OAAOkuD,KAE7C,EAAA7jG,YAAkCtK,IAA3BojB,EAAQC,gBACf,EAAA/Y,QAjWqB,IAiWd8Y,EAAQC,gBAEf,MAAM5N,EAAQ2N,EAAQmsF,cAAiBzwD,EACjC5vC,EAASkU,EAAQosF,eAAkB1wD,EACnCx0B,EAAYlH,EAAQkH,UACpBq5B,EAAc,EAAAz4B,iBAAiBZ,EAAUq5B,YAAavjD,GACtDwjD,EAAc,EAAA14B,iBAAiBZ,EAAUs5B,YAAaxjD,GAEtD40G,EACFvoE,EAAehpC,GAA4B,iBAAhBkgD,EAA2BA,EAAc,GAAK7E,EACvEm2D,EACFxoE,EAAe/oC,GAA4B,iBAAhBkgD,EAA2BA,EAAc,GAAK9E,EAO7E,OALAy1D,EAAU9wG,EAAIuxG,EAAUv/F,EAAQ,EAChC8+F,EAAU7wG,EAAIuxG,EAAU/lG,EAAS,EACjCqlG,EAAUzwG,EAAI2R,EACd8+F,EAAUnqF,EAAIlb,EAEPqlG,EA+BX,cAAcl4D,EAAyBj8C,GACnC,MAAMgjB,EAAUi5B,EAAWj5B,QAC3B,YAAgBpjB,IAAZojB,SAG2BpjB,IAA3BojB,EAAQC,gBACRrlB,KAAKk3G,WAAW74D,EAAYj8C,QAEEJ,IAA3BojB,EAAQC,gBAOnB,QACIrlB,KAAK+2G,eAAevuE,QAcxB,UACIpjB,EACAqpB,EACA+hE,EACAv6D,EACA6K,EACAq2D,EACAjsF,EACA9oB,GAEA,EAAAkK,YAAkCtK,IAA3BojB,EAAQC,gBAEfmtF,EAAYC,qBAAqBrtF,EAASqpB,EAAgBqS,EAAO1+C,EAAKpC,KAAK82G,iBAEvEK,GACA3G,EAAiB8B,SAAStyG,KAAK82G,iBAGnC92G,KAAK+2G,eAAeK,OAAOhyF,EAASplB,KAAK82G,gBAAiB7gE,EAAc/qB,GAM5E,SACIlrB,KAAK+2G,eAAe1kE,SAUxB,iBACI5D,EACAwlB,GAEAj0D,KAAK+2G,eAAevjE,iBAAiB/E,EAAgBwlB,GAQzD,eAAeI,GACXr0D,KAAK+2G,eAAe1B,kBAAkBhhD,GAOlC,WAAWhW,EAAyBj8C,GACxC,MAAMgjB,EAAUi5B,EAAWj5B,QAC3B,QAAgBpjB,IAAZojB,IAA0Bi5B,EAAWj4B,QACrC,OAGJ,QAA+BpkB,IAA3BojB,EAAQC,iBAAoD,IAApBD,EAAQ05B,QAEhD,OAGJ,QAA6B98C,IAAzBojB,EAAQiyF,aAA4B,CACpC,IAAIr3G,KAAKkO,QAAQ0oE,WAAW04B,sBAAsBjxD,GAO9C,OANA,IAAKA,EAAWj4B,QAEZ,OAQZ,MAAM8vF,EAAmB9wF,EAAQ8wF,iBAE3B/vD,EAAenmD,KAAKkO,QAAQ0oE,WAAW0gC,gBAAgBpB,GAC7D,QAAqBl0G,IAAjBmkD,EAOA,YAL+DnkD,IAA3DwwG,EAAY+E,qBAAqBt5G,IAAIi4G,KACrC1D,EAAY+E,qBAAqBvwG,IAAIkvG,GAAkB,GACvD1pG,EAAO+R,MAAM,0CAA0C23F,kBAE3D9wF,EAAQ05B,SAAU,GAItB,MAAM04D,EAAkBrxD,EAAa7uC,MAErC,IAAI09F,EAAYh1G,KAAKkO,QAAQupG,WAAWC,gBAAgBF,GACxD,QAAkBx1G,IAAdgzG,EAGA,OAFAxoG,EAAO+R,MAAM,uCAAuCi5F,WACpDpyF,EAAQ05B,SAAU,GAItB,IAAKk2D,EAAU2C,OAAQ,CACnB,QAAiC31G,IAA7BgzG,EAAUrS,eAEV,OAEJ,MAAMiV,EAAW5C,EAAUvxD,IACrBzgC,EAAUhjB,KAAKkO,QAAQupG,WAAWI,UAAU7C,GAClD,GAAIhyF,aAAmBi1B,QAanB,YAZAj1B,EACKgiB,KAAK8yE,SACsB91G,IAApB81G,EAIJ93G,KAAK+3G,aAAa3yF,EAAS+gC,EAAc2xD,EAAiB11G,GAHtDoK,EAAO+R,MAAM,0CAA0Cq5F,OAK9DzyE,MAAM5mB,IACH/R,EAAO+R,MAAM,0CAA0Cq5F,IAAYr5F,GACnE6G,EAAQ05B,SAAU,IAI1Bk2D,EAAYhyF,EAIpBhjB,KAAK+3G,aAAa3yF,EAAS+gC,EAAc6uD,EAAW5yG,GAYhD,aACJgjB,EACA+gC,EACA6uD,EACA5yG,GAIA,GAFA,EAAAkK,YAAyBtK,IAAlBojB,EAAQsxF,YAEG10G,IAAdgzG,QAAmDhzG,IAAxBgzG,EAAUM,UAKrC,OAJA9oG,EAAO+R,MAAM,8CAEb6G,EAAQC,gBArkBS,OAskBjBD,EAAQ05B,SAAU,GAItB,MAAMxyB,EAAYlH,EAAQkH,UAEpB0rF,EAAahD,EAAUM,UAAU79F,MACjCwgG,EAAcjD,EAAUM,UAAUpkG,OAClCgnG,EAAa,EAAAC,gBAAgBC,cAAcJ,EAAYC,GACvDI,EAAqBtD,EAAqBS,WAAaR,EAAUS,QACjE6C,EAAmBD,EAAqBH,EAAWzgG,MAAQugG,EAC3DO,EAAoBF,EAAqBH,EAAWhnG,OAAS+mG,EAE7DO,OAAmCx2G,IAAvBmkD,EAAa1uC,MAAsB0uC,EAAa1uC,MAAQugG,EACpES,OAAqCz2G,IAAxBmkD,EAAaj1C,OAAuBi1C,EAAaj1C,OAAS+mG,EAE7E,IAAIS,EAAO,EACPC,EAAO,EACPC,EAAO,EACPC,EAAO,EAEPC,OAAqC92G,IAAxBsqB,EAAUu5B,UAA0Bv5B,EAAUu5B,UAAY,EACvEkzD,OAAqC/2G,IAAxBsqB,EAAUu5B,UAA0Bv5B,EAAUu5B,UAAY,EAE3E,MAAMpuC,OAA+BzV,IAAvBmkD,EAAa1uC,MAAsB0uC,EAAa1uC,MAAQugG,EAChE9mG,OAAiClP,IAAxBmkD,EAAaj1C,OAAuBi1C,EAAaj1C,OAAS+mG,EACnEryF,OAAmC5jB,IAAzBmkD,EAAavgC,QAAwBugC,EAAavgC,QAAU,EACtEC,OAAmC7jB,IAAzBmkD,EAAatgC,QAAwBsgC,EAAatgC,QAAU,EAE5E6yF,EAAO9yF,EAAU0yF,EACjBK,GAAQ/yF,EAAUnO,GAAS6gG,EAOvBM,EAAO/yF,EAAU0yF,EACjBM,GAAQhzF,EAAU3U,GAAUqnG,EAShC,MAAMxyD,EAAc,EAAA74B,iBAAiBZ,EAAUy5B,YAAa3jD,QACxCJ,IAAhB+jD,IACAgzD,EAAaD,EAAa/yD,EAAcyyD,GAG5C,MAAM1yD,EAAe,EAAA54B,iBAAiBZ,EAAUw5B,aAAc1jD,QACzCJ,IAAjB8jD,IACAizD,EAAajzD,EAAe2yD,OACRz2G,IAAhB+jD,IACA+yD,EAAaC,IAKrB3zF,EAAQmsF,cAAgBiH,EAAYM,EACpC1zF,EAAQosF,eAAiBiH,EAAaM,EACtC3zF,EAAQsxF,MAAQ,CACZsC,GAAIN,EACJO,GAAIJ,EACJK,GAAIP,EACJQ,GAAIP,GAERxzF,EAAQ4vF,UAAYA,EACpB5vF,EAAQ+gC,aAAeA,EACvB/gC,EAAQC,eAAiBrlB,KAAK+2G,eAAeN,YAAYrxF,GACzDA,EAAQ05B,SAAU,EAElB,EAAAxyC,YAAkCtK,IAA3BojB,EAAQC,iBAEvB,OA5RmB,EAAAkyF,qBAA6C,IAAIp1G,IA4RpE,GArUA,GAAa,EAAAqwG,e,uGC5Vb,aAIMjsB,EAA2B,oBAAXt6C,OAOtB,MAAaksE,EAkBT,cACS5xB,IACDvmF,KAAKo5G,gBAAkBC,SAASC,cAAc,UAC9Ct5G,KAAKu5G,iBAAmBv5G,KAAKo5G,gBAAgBI,WAAW,MACxDx5G,KAAKy5G,eAAiBJ,SAASC,cAAc,UAC7Ct5G,KAAK05G,gBAAkB15G,KAAKy5G,eAAeD,WAAW,OAjB9D,qBAAqB/hG,EAAevG,GAChC,MAAO,CACHuG,MAAOrY,EAAMkJ,UAAUqxG,eAAeliG,GACtCvG,OAAQ9R,EAAMkJ,UAAUqxG,eAAezoG,IAyB/C,2BAA2BoG,GACvB,GAAIivE,EACA,MAAM,IAAI9iF,MAAM,0CAGpB,QAAwBzB,IAApBsV,EAAMg+F,UACN,MAAM,IAAI7xG,MAAM,qDAEpB,MAAM6xG,EAAYh+F,EAAMg+F,UAClBG,EAAuB,IAGrBh+F,MAAOmiG,EAAa1oG,OAAQ2oG,GAAiB1B,EAAgBC,cACjE9C,EAAU79F,MACV69F,EAAUpkG,QAEdlR,KAAK85G,qBAAqBxE,EAAWsE,EAAaC,GAClDpE,EAAQvvG,KAAKlG,KAAKu5G,iBAAkBQ,aAAa,EAAG,EAAGH,EAAaC,IAEpE,IAAIpiG,EAAsB,GAAdmiG,EACR1oG,EAAwB,GAAf2oG,EACb,KAAOpiG,GAAS,GAAKvG,GAAU,GAAG,CAC9B,MACM8oG,EAAgBvE,EADFA,EAAQn0G,OACgB,GAE5Cm0G,EAAQvvG,KAAKlG,KAAKi6G,YAAYD,EAAeviG,EAAOvG,IACpDuG,GAAS,GACTvG,GAAU,GAGd,OAAOukG,EAUH,qBACJn+F,EACAG,EACAvG,GA0CA,OAxCAlR,KAAKo5G,gBAAiB3hG,MAAQA,EAC9BzX,KAAKo5G,gBAAiBloG,OAASA,EAE/BlR,KAAKu5G,iBAAkBW,UAAU,EAAG,EAAGziG,EAAOvG,GAC1CoG,aAAiB6iG,YACjBn6G,KAAKu5G,iBAAkBa,UAAU9iG,EAAO,EAAG,GAE3CtX,KAAKu5G,iBAAkBc,aAAa/iG,EAAO,EAAG,GAI9CA,EAAMG,QAAUA,GAChBzX,KAAKu5G,iBAAkBa,UACnBp6G,KAAKo5G,gBACL9hG,EAAMG,MAAQ,EACd,EACA,EACAH,EAAMpG,OACNoG,EAAMG,MACN,EACAA,EAAQH,EAAMG,MACdH,EAAMpG,QAKVoG,EAAMpG,SAAWA,GACjBlR,KAAKu5G,iBAAkBa,UACnBp6G,KAAKo5G,gBACL,EACA9hG,EAAMpG,OAAS,EACfuG,EACA,EACA,EACAH,EAAMpG,OACNuG,EACAvG,EAASoG,EAAMpG,QAIhBlR,KAAKo5G,gBAcR,YAAY9hG,EAAkBG,EAAevG,GAEjD,MAAMopG,EAAct6G,KAAK85G,qBAAqBxiG,EAAOA,EAAMG,MAAOH,EAAMpG,QAQxE,OALAlR,KAAKy5G,eAAgBhiG,MAAQA,EAC7BzX,KAAKy5G,eAAgBvoG,OAASA,EAC9BlR,KAAK05G,gBAAiBQ,UAAU,EAAG,EAAGziG,EAAOvG,GAC7ClR,KAAK05G,gBAAiBU,UAAUE,EAAa,EAAG,EAAG7iG,EAAOvG,GAEnDlR,KAAK05G,gBAAiBK,aAAa,EAAG,EAAGtiG,EAAOvG,IA/I/D,qB,wLCXA,aACA,OACA,QAKMqpG,EAAQ,EAAQ,KAEhB/tG,EAAS,EAAAC,cAAcxM,SAASvB,OAAO,qBAS7C,MAAaqxG,UAAqB,EAAA9tD,OAAOkuD,IACrC,YAAYnzF,GACRha,aACYhB,IAARgb,GACAhd,KAAKsP,KAAK0N,GAIlB,KAAKA,GAQD,OAPIA,aAAe,EAAAilC,OAAOkuD,IACtBnwG,KAAKgH,IAAIgW,EAAIvX,EAAGuX,EAAItX,EAAGsX,EAAIlX,EAAGkX,EAAIoP,GAC3BpP,aAAe5d,EAAM42D,KAC5Bh2D,KAAKgH,IAAIgW,EAAIpT,IAAInE,EAAGuX,EAAIpT,IAAIlE,EAAGsX,EAAIlT,IAAIrE,EAAIuX,EAAIpT,IAAInE,EAAGuX,EAAIlT,IAAIpE,EAAIsX,EAAIpT,IAAIlE,GAE1E1F,KAAKgH,IAAIgW,EAAI83B,KAAM93B,EAAIg4B,KAAMh4B,EAAI+3B,KAAO/3B,EAAI83B,KAAM93B,EAAI8e,KAAO9e,EAAIg4B,MAE9Dh1C,KAEX,WACI,OAAOA,KAAKyF,EAEhB,SAASqvC,GACL90C,KAAKyF,EAAIqvC,EAEb,WACI,OAAO90C,KAAKyF,EAAIzF,KAAK8F,EAEzB,SAASivC,GACL/0C,KAAK8F,EAAIivC,EAAO/0C,KAAKyF,EAEzB,WACI,OAAOzF,KAAK0F,EAEhB,SAASsvC,GACLh1C,KAAK0F,EAAIsvC,EAEb,WACI,OAAOh1C,KAAK0F,EAAI1F,KAAKosB,EAEzB,SAAS0P,GACL97B,KAAKosB,EAAI0P,EAAO97B,KAAK0F,GAxC7B,iBAgDA,MAAamuG,UAA6B9D,EACtC,YAAY/yF,EAA8Cw9F,GACtDx3G,MAAMga,GADgD,KAAAw9F,eAS9D,SAAgBC,EAAgBz9F,GAC5B,YAAuChb,IAA/Bgb,EAAsB03B,KAXlC,yBAUA,oBAIA,MAAMo7D,EAAkB,IAAIC,EAE5B,MAAajxC,EAWT,cATS,KAAA47C,aAAe,IAAI,EAAAz4D,OAAOkuD,IAI3B,KAAAwK,MAAQ,IAAIJ,EAYpB,QACIv6G,KAAK26G,MAAM30E,QASf,OAAOvuB,EAAevG,GAClBlR,KAAK06G,aAAa1zG,IAAIyQ,GAAS,EAAGvG,GAAU,EAAGuG,EAAOvG,GACtDlR,KAAKwoC,QAST,SAAS2P,GACL,MAAMyiE,EAASziE,aAAkB43D,EAA2C53D,EAA3B,IAAI43D,EAAa53D,GAClEn4C,KAAK26G,MAAME,OAAOD,GAStB,eAAeziE,GACXn4C,KAAK26G,MAAMxoF,KAAKgmB,GAQpB,OAAOn7B,GACH,OAAOhd,KAAK26G,MAAMpH,OAAOv2F,GAQ7B,YAAYm7B,GACR,MAAMw7D,EAAex7D,aAAkB43D,EAAe53D,EAAS23D,EAAgBxgG,KAAK6oC,GAC9EoD,EAAUv7C,KAAKuzG,OAAOI,GAC5B,OAAO3zG,KAAK4zG,kBAAkBD,EAAcp4D,GAQhD,UAAUpD,GACN,OAAOn4C,KAAK06G,aAAap1B,WAAWntC,GAQxC,eAAeA,GACX,OAAOn4C,KAAK06G,aAAaI,YAAY3iE,GAYzC,kBAAkB4iE,EAAuB5mE,GACrC,IAAK,MAAMn3B,KAAOm3B,EACd,GAAIn3B,aAAe62F,GACf,IAAK,MAAMmH,KAAah+F,EAAIw9F,YACxB,GAAIQ,EAAU11B,WAAWy1B,GACrB,OAAO,MAGZ,KAAIN,EAAgBz9F,GAMvB,OAAO,EANsB,CAC7B,MAAMi+F,EAAcj+F,EACpB,GAAIhd,KAAKk7G,eAAeH,EAASE,GAC7B,OAAO,GAMnB,OAAO,EAQH,eAAeL,EAAoBK,GACvC,MAAMvmE,EAAOumE,EAAYvmE,KAInBymE,EAAuBzmE,EAAKE,IAAInvC,EAAIivC,EAAK3K,MAAMtkC,EAGrD,IAAI21G,EACAC,EACAC,EACAC,EACJ,GAA6B,IAAzBJ,EAA4B,CAC5B,MAAMK,EAAuB9mE,EAAKE,IAAIlvC,EAAIgvC,EAAK3K,MAAMrkC,EAC/C+1G,EAAUD,EACVE,GAAWP,EACX/qB,EAAI17C,EAAK3K,MAAMrkC,EAAK81G,EAAuBL,EAAwBzmE,EAAK3K,MAAMtkC,EAEpF21G,EAAS/xG,KAAKD,KAAKwxG,EAAK9lE,KAAO2mE,GAAWb,EAAK5lE,KAAOo7C,GAAKsrB,GAC3DL,EAAShyG,KAAKD,KAAKwxG,EAAK7lE,KAAO0mE,GAAWb,EAAK5lE,KAAOo7C,GAAKsrB,GAC3DJ,EAASjyG,KAAKD,KAAKwxG,EAAK9lE,KAAO2mE,GAAWb,EAAK9+E,KAAOs0D,GAAKsrB,GAC3DH,EAASlyG,KAAKD,KAAKwxG,EAAK7lE,KAAO0mE,GAAWb,EAAK9+E,KAAOs0D,GAAKsrB,QAE3DN,EAAS/xG,KAAKD,KAAKwxG,EAAK9lE,KAAOJ,EAAK3K,MAAMtkC,GAC1C41G,EAAShyG,KAAKD,KAAKwxG,EAAK7lE,KAAOL,EAAK3K,MAAMtkC,GAC1C61G,EAASjyG,KAAKD,KAAKwxG,EAAK9lE,KAAOJ,EAAK3K,MAAMtkC,GAC1C81G,EAASlyG,KAAKD,KAAKwxG,EAAK7lE,KAAOL,EAAK3K,MAAMtkC,GAE9C,OAAO21G,IAAWC,GAAUD,IAAWE,GAAUF,IAAWG,GA1JpE,qBAuKA,sCAA2Cz8C,EAavC,YAAY68C,GACR34G,QAZI,KAAA44G,gBAAmD,KACnD,KAAAC,oBAAqB,EACrB,KAAAC,iBAAmB,EACnB,KAAAC,qBAAuB,EACvB,KAAAC,iBAAmB,EACnB,KAAAC,+BAAiC,EACjC,KAAAC,2BAA6B,EAQ7BP,UACA37G,KAAK47G,gBAAkBD,EAAYnC,WAAW,OAQtD,QACIx2G,MAAMwlC,QAENxoC,KAAK87G,iBAAmB,EACxB97G,KAAK+7G,qBAAuB,EAC5B/7G,KAAKg8G,iBAAmB,EACxBh8G,KAAKi8G,+BAAiC,EACtCj8G,KAAKk8G,2BAA6B,EAUtC,OAAOzkG,EAAevG,GACdlR,KAAK67G,oBACLrvG,EAAOytB,IAEH,gBAAgBj6B,KAAK87G,sCAAsC97G,KAAK+7G,sCAAsC/7G,KAAKg8G,kDAAkDh8G,KAAKi8G,4DAA4Dj8G,KAAKk8G,+BAI3Ol5G,MAAMqvC,OAAO56B,EAAOvG,GAES,OAAzBlR,KAAK47G,kBACL57G,KAAK47G,gBAAgBptE,OAAO/2B,MAAQA,EACpCzX,KAAK47G,gBAAgBptE,OAAOt9B,OAASA,GAKzClR,KAAK67G,mBAAqB,EAAA7iE,aAAaC,SAAS,2BASpD,SAASd,GACLn1C,MAAMsvG,SAASn6D,GAEfn4C,KAAK87G,mBAED97G,KAAK67G,oBAA+C,OAAzB77G,KAAK47G,kBAChC57G,KAAK47G,gBAAgBO,YAAc,UACnCn8G,KAAK47G,gBAAgBQ,WACjBjkE,EAAO1yC,EAAIzF,KAAK06G,aAAaj1G,EAC7BzF,KAAK06G,aAAah1G,EAAI1F,KAAK06G,aAAatuF,EAAI+rB,EAAOzyC,EACnDyyC,EAAOryC,GACNqyC,EAAO/rB,IAMpB,eAAeiwF,GACX,IAAK,MAAMlkE,KAAUkkE,EACjBr8G,KAAK87G,mBAED97G,KAAK67G,oBAA+C,OAAzB77G,KAAK47G,kBAChC57G,KAAK47G,gBAAgBO,YAAc,UACnCn8G,KAAK47G,gBAAgBQ,WACjBjkE,EAAOrD,KAAO90C,KAAK06G,aAAaj1G,EAChCzF,KAAK06G,aAAah1G,EAAI1F,KAAK06G,aAAatuF,EAAI+rB,EAAOnD,KACnDmD,EAAOpD,KAAOoD,EAAOrD,OACnBqD,EAAOrc,KAAOqc,EAAOnD,QAInChyC,MAAMiyC,eAAeonE,GAIzB,kBAAkBtB,EAAuB5mE,GACrC,MAAMmoE,EAAiBt5G,MAAM4wG,kBAAkBmH,EAAS5mE,GACxD,GAAIn0C,KAAK67G,oBAA+C,OAAzB77G,KAAK47G,gBAA0B,CAC1D,MAAMW,EAAUD,EAAiB,EAAI,EACrCt8G,KAAK47G,gBAAgBO,YAAcG,EAAiB,UAAY,UAChEt8G,KAAK47G,gBAAgBQ,WACjBrB,EAAQt1G,EAAIzF,KAAK06G,aAAaj1G,EAAI82G,EAClCv8G,KAAK06G,aAAah1G,EAAI1F,KAAK06G,aAAatuF,EAAI2uF,EAAQr1G,EAAI62G,EACxDxB,EAAQj1G,EAAI,EAAIy2G,GACfxB,EAAQ3uF,EAAI,EAAImwF,GAUzB,OANID,EACAt8G,KAAKg8G,mBAELh8G,KAAK+7G,uBAGFO,EASX,UAAUnkE,GACN,MAAM/xB,EAAUpjB,MAAM+nE,UAAU5yB,GAOhC,OALI/xB,EACApmB,KAAKi8G,iCAELj8G,KAAKk8G,6BAEF91F,K,gBC1YqDjpB,EAAOD,QAAwF,WAAW,aAAa,SAASoB,EAAEA,EAAEJ,EAAEwG,EAAE8E,EAAE4iB,IAAI,SAAS9tB,EAAEO,EAAEX,EAAEwG,EAAE8E,EAAE4iB,GAAG,KAAK5iB,EAAE9E,GAAG,CAAC,GAAG8E,EAAE9E,EAAE,IAAI,CAAC,IAAI7G,EAAE2L,EAAE9E,EAAE,EAAEvF,EAAEjB,EAAEwG,EAAE,EAAErH,EAAEgM,KAAK4wB,IAAIp8B,GAAG2+G,EAAE,GAAGnzG,KAAK+wB,IAAI,EAAE/8B,EAAE,GAAG4rG,EAAE,GAAG5/F,KAAK+H,KAAK/T,EAAEm/G,GAAG3+G,EAAE2+G,GAAG3+G,IAAIsB,EAAEtB,EAAE,EAAE,GAAG,EAAE,GAA+ES,EAAEO,EAAEX,EAA9EmL,KAAKS,IAAIpF,EAAE2E,KAAKmtB,MAAMt4B,EAAEiB,EAAEq9G,EAAE3+G,EAAEorG,IAAM5/F,KAAKO,IAAIJ,EAAEH,KAAKmtB,MAAMt4B,GAAGL,EAAEsB,GAAGq9G,EAAE3+G,EAAEorG,IAAc78E,GAAG,IAAIltB,EAAEL,EAAEX,GAAGR,EAAEgH,EAAEe,EAAE+D,EAAE,IAAIpM,EAAEyB,EAAE6F,EAAExG,GAAGkuB,EAAEvtB,EAAE2K,GAAGtK,GAAG,GAAG9B,EAAEyB,EAAE6F,EAAE8E,GAAG9L,EAAE+H,GAAG,CAAC,IAAIrI,EAAEyB,EAAEnB,EAAE+H,GAAG/H,IAAI+H,IAAI2mB,EAAEvtB,EAAEnB,GAAGwB,GAAG,GAAGxB,IAAI,KAAK0uB,EAAEvtB,EAAE4G,GAAGvG,GAAG,GAAGuG,IAAI,IAAI2mB,EAAEvtB,EAAE6F,GAAGxF,GAAG9B,EAAEyB,EAAE6F,EAAEe,GAAGrI,EAAEyB,IAAI4G,EAAE+D,GAAG/D,GAAGvH,IAAIwG,EAAEe,EAAE,GAAGvH,GAAGuH,IAAI+D,EAAE/D,EAAE,IAA3Z,CAAganH,EAAEJ,EAAEwG,GAAG,EAAE8E,GAAGlL,EAAEgD,OAAO,EAAE8qB,GAAGvtB,GAAG,SAASzB,EAAEkB,EAAElB,EAAEyB,GAAG,IAAIX,EAAEI,EAAElB,GAAGkB,EAAElB,GAAGkB,EAAEO,GAAGP,EAAEO,GAAGX,EAAE,SAASW,EAAEP,EAAElB,GAAG,OAAOkB,EAAElB,GAAG,EAAEkB,EAAElB,EAAE,EAAE,EAAE,IAAIc,EAAE,SAASI,QAAG,IAASA,IAAIA,EAAE,GAAG0B,KAAKy8G,YAAYpzG,KAAKS,IAAI,EAAExL,GAAG0B,KAAK08G,YAAYrzG,KAAKS,IAAI,EAAET,KAAKuW,KAAK,GAAG5f,KAAKy8G,cAAcz8G,KAAKgmC,SAAS,SAASthC,EAAEpG,EAAElB,EAAEyB,GAAG,IAAIA,EAAE,OAAOzB,EAAEu1B,QAAQr0B,GAAG,IAAI,IAAIJ,EAAE,EAAEA,EAAEd,EAAEkE,OAAOpD,IAAI,GAAGW,EAAEP,EAAElB,EAAEc,IAAI,OAAOA,EAAE,OAAO,EAAE,SAASsL,EAAElL,EAAElB,GAAGgvB,EAAE9tB,EAAE,EAAEA,EAAE4jB,SAAS5gB,OAAOlE,EAAEkB,GAAG,SAAS8tB,EAAE9tB,EAAElB,EAAEyB,EAAEX,EAAEwG,GAAGA,IAAIA,EAAExF,EAAE,OAAOwF,EAAEowC,KAAK,IAAIpwC,EAAEswC,KAAK,IAAItwC,EAAEqwC,MAAK,IAAKrwC,EAAEo3B,MAAK,IAAK,IAAI,IAAItyB,EAAEpM,EAAEoM,EAAE3K,EAAE2K,IAAI,CAAC,IAAI4iB,EAAE9tB,EAAE4jB,SAAS1Y,GAAG3L,EAAE6G,EAAEpG,EAAEq+G,KAAKz+G,EAAEkuB,GAAGA,GAAG,OAAO1nB,EAAE,SAAS7G,EAAES,EAAElB,GAAG,OAAOkB,EAAEw2C,KAAKzrC,KAAKO,IAAItL,EAAEw2C,KAAK13C,EAAE03C,MAAMx2C,EAAE02C,KAAK3rC,KAAKO,IAAItL,EAAE02C,KAAK53C,EAAE43C,MAAM12C,EAAEy2C,KAAK1rC,KAAKS,IAAIxL,EAAEy2C,KAAK33C,EAAE23C,MAAMz2C,EAAEw9B,KAAKzyB,KAAKS,IAAIxL,EAAEw9B,KAAK1+B,EAAE0+B,MAAMx9B,EAAE,SAASa,EAAEb,EAAElB,GAAG,OAAOkB,EAAEw2C,KAAK13C,EAAE03C,KAAK,SAASz3C,EAAEiB,EAAElB,GAAG,OAAOkB,EAAE02C,KAAK53C,EAAE43C,KAAK,SAASwnE,EAAEl+G,GAAG,OAAOA,EAAEy2C,KAAKz2C,EAAEw2C,OAAOx2C,EAAEw9B,KAAKx9B,EAAE02C,MAAM,SAASi0D,EAAE3qG,GAAG,OAAOA,EAAEy2C,KAAKz2C,EAAEw2C,MAAMx2C,EAAEw9B,KAAKx9B,EAAE02C,MAAM,SAASx3C,EAAEc,EAAElB,GAAG,OAAOkB,EAAEw2C,MAAM13C,EAAE03C,MAAMx2C,EAAE02C,MAAM53C,EAAE43C,MAAM53C,EAAE23C,MAAMz2C,EAAEy2C,MAAM33C,EAAE0+B,MAAMx9B,EAAEw9B,KAAK,SAASr+B,EAAEa,EAAElB,GAAG,OAAOA,EAAE03C,MAAMx2C,EAAEy2C,MAAM33C,EAAE43C,MAAM12C,EAAEw9B,MAAM1+B,EAAE23C,MAAMz2C,EAAEw2C,MAAM13C,EAAE0+B,MAAMx9B,EAAE02C,KAAK,SAAS91C,EAAEZ,GAAG,MAAM,CAAC4jB,SAAS5jB,EAAE4S,OAAO,EAAEyrG,MAAK,EAAG7nE,KAAK,IAAIE,KAAK,IAAID,MAAK,IAAKjZ,MAAK,KAAM,SAASp+B,EAAEN,EAAEyB,EAAEX,EAAEwG,EAAE8E,GAAG,IAAI,IAAI4iB,EAAE,CAACvtB,EAAEX,GAAGkuB,EAAE9qB,QAAQ,MAAMpD,EAAEkuB,EAAE2vD,QAAQl9E,EAAEutB,EAAE2vD,QAAQr3E,GAAG,CAAC,IAAI7G,EAAEgB,EAAEwK,KAAKuW,MAAM1hB,EAAEW,GAAG6F,EAAE,GAAGA,EAAEpG,EAAElB,EAAES,EAAEgB,EAAEX,EAAEsL,GAAG4iB,EAAElmB,KAAKrH,EAAEhB,EAAEA,EAAEK,IAAI,OAAOA,EAAEc,UAAUk5C,IAAI,WAAW,OAAOl4C,KAAK48G,KAAK58G,KAAKsnC,KAAK,KAAKppC,EAAEc,UAAUu0G,OAAO,SAASj1G,GAAG,IAAIlB,EAAE4C,KAAKsnC,KAAKzoC,EAAE,GAAG,IAAIpB,EAAEa,EAAElB,GAAG,OAAOyB,EAAE,IAAI,IAAIX,EAAE8B,KAAK68G,OAAOn4G,EAAE,GAAGtH,GAAG,CAAC,IAAI,IAAIoM,EAAE,EAAEA,EAAEpM,EAAE8kB,SAAS5gB,OAAOkI,IAAI,CAAC,IAAI4iB,EAAEhvB,EAAE8kB,SAAS1Y,GAAG3L,EAAET,EAAEu/G,KAAKz+G,EAAEkuB,GAAGA,EAAE3uB,EAAEa,EAAET,KAAKT,EAAEu/G,KAAK99G,EAAEqH,KAAKkmB,GAAG5uB,EAAEc,EAAET,GAAGmC,KAAK48G,KAAKxwF,EAAEvtB,GAAG6F,EAAEwB,KAAKkmB,IAAIhvB,EAAEsH,EAAEq3E,MAAM,OAAOl9E,GAAGX,EAAEc,UAAU89G,SAAS,SAASx+G,GAAG,IAAIlB,EAAE4C,KAAKsnC,KAAK,IAAI7pC,EAAEa,EAAElB,GAAG,OAAM,EAAG,IAAI,IAAIyB,EAAE,GAAGzB,GAAG,CAAC,IAAI,IAAIc,EAAE,EAAEA,EAAEd,EAAE8kB,SAAS5gB,OAAOpD,IAAI,CAAC,IAAIwG,EAAEtH,EAAE8kB,SAAShkB,GAAGsL,EAAEpM,EAAEu/G,KAAK38G,KAAK68G,OAAOn4G,GAAGA,EAAE,GAAGjH,EAAEa,EAAEkL,GAAG,CAAC,GAAGpM,EAAEu/G,MAAMn/G,EAAEc,EAAEkL,GAAG,OAAM,EAAG3K,EAAEqH,KAAKxB,IAAItH,EAAEyB,EAAEk9E,MAAM,OAAM,GAAI79E,EAAEc,UAAUmzB,KAAK,SAAS7zB,GAAG,IAAIA,IAAIA,EAAEgD,OAAO,OAAOtB,KAAK,GAAG1B,EAAEgD,OAAOtB,KAAK08G,YAAY,CAAC,IAAI,IAAIt/G,EAAE,EAAEA,EAAEkB,EAAEgD,OAAOlE,IAAI4C,KAAK66G,OAAOv8G,EAAElB,IAAI,OAAO4C,KAAK,IAAInB,EAAEmB,KAAK+8G,OAAOz+G,EAAEgI,QAAQ,EAAEhI,EAAEgD,OAAO,EAAE,GAAG,GAAGtB,KAAKsnC,KAAKplB,SAAS5gB,OAAO,GAAGtB,KAAKsnC,KAAKp2B,SAASrS,EAAEqS,OAAOlR,KAAKg9G,WAAWh9G,KAAKsnC,KAAKzoC,OAAO,CAAC,GAAGmB,KAAKsnC,KAAKp2B,OAAOrS,EAAEqS,OAAO,CAAC,IAAIhT,EAAE8B,KAAKsnC,KAAKtnC,KAAKsnC,KAAKzoC,EAAEA,EAAEX,EAAE8B,KAAKi9G,QAAQp+G,EAAEmB,KAAKsnC,KAAKp2B,OAAOrS,EAAEqS,OAAO,GAAE,QAASlR,KAAKsnC,KAAKzoC,EAAE,OAAOmB,MAAM9B,EAAEc,UAAU67G,OAAO,SAASv8G,GAAG,OAAOA,GAAG0B,KAAKi9G,QAAQ3+G,EAAE0B,KAAKsnC,KAAKp2B,OAAO,GAAGlR,MAAM9B,EAAEc,UAAUgnC,MAAM,WAAW,OAAOhmC,KAAKsnC,KAAKpoC,EAAE,IAAIc,MAAM9B,EAAEc,UAAUqkC,OAAO,SAAS/kC,EAAElB,GAAG,IAAIkB,EAAE,OAAO0B,KAAK,IAAI,IAAInB,EAAEX,EAAEsL,EAAE4iB,EAAEpsB,KAAKsnC,KAAKzpC,EAAEmC,KAAK68G,OAAOv+G,GAAGa,EAAE,GAAG9B,EAAE,GAAG+uB,GAAGjtB,EAAEmC,QAAQ,CAAC,GAAG8qB,IAAIA,EAAEjtB,EAAE48E,MAAM79E,EAAEiB,EAAEA,EAAEmC,OAAO,GAAGzC,EAAExB,EAAE0+E,MAAMvyE,GAAE,GAAI4iB,EAAEuwF,KAAK,CAAC,IAAIH,EAAE93G,EAAEpG,EAAE8tB,EAAElK,SAAS9kB,GAAG,IAAI,IAAIo/G,EAAE,OAAOpwF,EAAElK,SAASikB,OAAOq2E,EAAE,GAAGr9G,EAAE+G,KAAKkmB,GAAGpsB,KAAKk9G,UAAU/9G,GAAGa,KAAKwJ,GAAG4iB,EAAEuwF,OAAOn/G,EAAE4uB,EAAEvuB,GAAGK,GAAGW,IAAIutB,EAAEluB,EAAEgkB,SAASrjB,GAAG2K,GAAE,GAAI4iB,EAAE,MAAMjtB,EAAE+G,KAAKkmB,GAAG/uB,EAAE6I,KAAKrH,GAAGA,EAAE,EAAEX,EAAEkuB,EAAEA,EAAEA,EAAElK,SAAS,IAAI,OAAOliB,MAAM9B,EAAEc,UAAU69G,OAAO,SAASv+G,GAAG,OAAOA,GAAGJ,EAAEc,UAAUm+G,YAAY,SAAS7+G,EAAElB,GAAG,OAAOkB,EAAEw2C,KAAK13C,EAAE03C,MAAM52C,EAAEc,UAAUo+G,YAAY,SAAS9+G,EAAElB,GAAG,OAAOkB,EAAE02C,KAAK53C,EAAE43C,MAAM92C,EAAEc,UAAUq+G,OAAO,WAAW,OAAOr9G,KAAKsnC,MAAMppC,EAAEc,UAAU2H,SAAS,SAASrI,GAAG,OAAO0B,KAAKsnC,KAAKhpC,EAAE0B,MAAM9B,EAAEc,UAAU49G,KAAK,SAASt+G,EAAElB,GAAG,IAAI,IAAIyB,EAAE,GAAGP,GAAGA,EAAEq+G,KAAKv/G,EAAE8I,KAAKo3G,MAAMlgH,EAAEkB,EAAE4jB,UAAUrjB,EAAEqH,KAAKo3G,MAAMz+G,EAAEP,EAAE4jB,UAAU5jB,EAAEO,EAAEk9E,MAAM,OAAO3+E,GAAGc,EAAEc,UAAU+9G,OAAO,SAASz+G,EAAElB,EAAEyB,EAAEX,GAAG,IAAIwG,EAAE0nB,EAAEvtB,EAAEzB,EAAE,EAAES,EAAEmC,KAAKy8G,YAAY,GAAGrwF,GAAGvuB,EAAE,OAAO2L,EAAE9E,EAAExF,EAAEZ,EAAEgI,MAAMlJ,EAAEyB,EAAE,IAAImB,KAAK68G,QAAQn4G,EAAExG,IAAIA,EAAEmL,KAAKuW,KAAKvW,KAAK4wB,IAAI7N,GAAG/iB,KAAK4wB,IAAIp8B,IAAIA,EAAEwL,KAAKuW,KAAKwM,EAAE/iB,KAAK2N,IAAInZ,EAAEK,EAAE,MAAMwG,EAAExF,EAAE,KAAKy9G,MAAK,EAAGj4G,EAAEwM,OAAOhT,EAAE,IAAIiB,EAAEkK,KAAKuW,KAAKwM,EAAEvuB,GAAGR,EAAE8B,EAAEkK,KAAKuW,KAAKvW,KAAK+H,KAAKvT,IAAIH,EAAEY,EAAElB,EAAEyB,EAAExB,EAAE2C,KAAKm9G,aAAa,IAAI,IAAIX,EAAEp/G,EAAEo/G,GAAG39G,EAAE29G,GAAGn/G,EAAE,CAAC,IAAI4rG,EAAE5/F,KAAKO,IAAI4yG,EAAEn/G,EAAE,EAAEwB,GAAGnB,EAAEY,EAAEk+G,EAAEvT,EAAE9pG,EAAEa,KAAKo9G,aAAa,IAAI,IAAI5/G,EAAEg/G,EAAEh/G,GAAGyrG,EAAEzrG,GAAG2B,EAAE,CAAC,IAAI1B,EAAE4L,KAAKO,IAAIpM,EAAE2B,EAAE,EAAE8pG,GAAGvkG,EAAEwd,SAAShc,KAAKlG,KAAK+8G,OAAOz+G,EAAEd,EAAEC,EAAES,EAAE,KAAK,OAAOsL,EAAE9E,EAAE1E,KAAK68G,QAAQn4G,GAAGxG,EAAEc,UAAUu+G,eAAe,SAASj/G,EAAElB,EAAEyB,EAAEX,GAAG,KAAKA,EAAEgI,KAAK9I,IAAIA,EAAEu/G,MAAMz+G,EAAEoD,OAAO,IAAIzC,GAAG,CAAC,IAAI,IAAI6F,EAAE,IAAI8E,EAAE,IAAI4iB,OAAE,EAAOvuB,EAAE,EAAEA,EAAET,EAAE8kB,SAAS5gB,OAAOzD,IAAI,CAAC,IAAIsB,EAAE/B,EAAE8kB,SAASrkB,GAAGR,EAAEm/G,EAAEr9G,GAAG8pG,GAAGzrG,EAAEc,EAAEb,EAAE0B,GAAGkK,KAAKS,IAAIrM,EAAEs3C,KAAKv3C,EAAEu3C,MAAM1rC,KAAKO,IAAInM,EAAEq3C,KAAKt3C,EAAEs3C,QAAQzrC,KAAKS,IAAIrM,EAAEq+B,KAAKt+B,EAAEs+B,MAAMzyB,KAAKO,IAAInM,EAAEu3C,KAAKx3C,EAAEw3C,OAAO33C,GAAG4rG,EAAEz/F,GAAGA,EAAEy/F,EAAEvkG,EAAErH,EAAEqH,EAAErH,EAAEqH,EAAE0nB,EAAEjtB,GAAG8pG,IAAIz/F,GAAGnM,EAAEqH,IAAIA,EAAErH,EAAE+uB,EAAEjtB,GAAG/B,EAAEgvB,GAAGhvB,EAAE8kB,SAAS,GAAG,IAAI1kB,EAAEC,EAAE,OAAOL,GAAGc,EAAEc,UAAUi+G,QAAQ,SAAS3+G,EAAElB,EAAEyB,GAAG,IAAIX,EAAEW,EAAEP,EAAE0B,KAAK68G,OAAOv+G,GAAGoG,EAAE,GAAG8E,EAAExJ,KAAKu9G,eAAer/G,EAAE8B,KAAKsnC,KAAKlqC,EAAEsH,GAAG,IAAI8E,EAAE0Y,SAAShc,KAAK5H,GAAGT,EAAE2L,EAAEtL,GAAGd,GAAG,GAAGsH,EAAEtH,GAAG8kB,SAAS5gB,OAAOtB,KAAKy8G,aAAaz8G,KAAKw9G,OAAO94G,EAAEtH,GAAGA,IAAI4C,KAAKy9G,oBAAoBv/G,EAAEwG,EAAEtH,IAAIc,EAAEc,UAAUw+G,OAAO,SAASl/G,EAAElB,GAAG,IAAIyB,EAAEP,EAAElB,GAAGc,EAAEW,EAAEqjB,SAAS5gB,OAAOoD,EAAE1E,KAAK08G,YAAY18G,KAAK09G,iBAAiB7+G,EAAE6F,EAAExG,GAAG,IAAIkuB,EAAEpsB,KAAK29G,kBAAkB9+G,EAAE6F,EAAExG,GAAGL,EAAEqB,EAAEL,EAAEqjB,SAASikB,OAAO/Z,EAAEvtB,EAAEqjB,SAAS5gB,OAAO8qB,IAAIvuB,EAAEqT,OAAOrS,EAAEqS,OAAOrT,EAAE8+G,KAAK99G,EAAE89G,KAAKnzG,EAAE3K,EAAEmB,KAAK68G,QAAQrzG,EAAE3L,EAAEmC,KAAK68G,QAAQz/G,EAAEkB,EAAElB,EAAE,GAAG8kB,SAAShc,KAAKrI,GAAGmC,KAAKg9G,WAAWn+G,EAAEhB,IAAIK,EAAEc,UAAUg+G,WAAW,SAAS1+G,EAAElB,GAAG4C,KAAKsnC,KAAKpoC,EAAE,CAACZ,EAAElB,IAAI4C,KAAKsnC,KAAKp2B,OAAO5S,EAAE4S,OAAO,EAAElR,KAAKsnC,KAAKq1E,MAAK,EAAGnzG,EAAExJ,KAAKsnC,KAAKtnC,KAAK68G,SAAS3+G,EAAEc,UAAU2+G,kBAAkB,SAASr/G,EAAElB,EAAEyB,GAAG,IAAI,IAAIX,EAAEwG,EAAE8E,EAAE3L,EAAEsB,EAAE9B,EAAE4rG,EAAEzrG,EAAE,IAAIC,EAAE,IAAIyB,EAAE9B,EAAE8B,GAAGL,EAAEzB,EAAE8B,IAAI,CAAC,IAAIxB,EAAE0uB,EAAE9tB,EAAE,EAAEY,EAAEc,KAAK68G,QAAQp3G,EAAE2mB,EAAE9tB,EAAEY,EAAEL,EAAEmB,KAAK68G,QAAQ17G,GAAGuD,EAAEhH,EAAE8L,EAAE/D,EAAsC5H,EAAEwL,KAAKS,IAAIpF,EAAEowC,KAAKtrC,EAAEsrC,MAAM31C,EAAEkK,KAAKS,IAAIpF,EAAEswC,KAAKxrC,EAAEwrC,MAAM33C,EAAEgM,KAAKO,IAAIlF,EAAEqwC,KAAKvrC,EAAEurC,MAAMk0D,EAAE5/F,KAAKO,IAAIlF,EAAEo3B,KAAKtyB,EAAEsyB,MAAMzyB,KAAKS,IAAI,EAAEzM,EAAEQ,GAAGwL,KAAKS,IAAI,EAAEm/F,EAAE9pG,IAAIy+G,EAAEpB,EAAE9+G,GAAG8+G,EAAE/2G,GAAGtE,EAAE3D,GAAGA,EAAE2D,EAAEjD,EAAEgB,EAAEzB,EAAEmgH,EAAEngH,EAAEmgH,EAAEngH,GAAG0D,IAAI3D,GAAGogH,EAAEngH,IAAIA,EAAEmgH,EAAE1/G,EAAEgB,GAAG,OAAOhB,GAAGW,EAAEzB,GAAGc,EAAEc,UAAU0+G,iBAAiB,SAASp/G,EAAElB,EAAEyB,GAAG,IAAIX,EAAEI,EAAEq+G,KAAK38G,KAAKm9G,YAAYh+G,EAAEuF,EAAEpG,EAAEq+G,KAAK38G,KAAKo9G,YAAY//G,EAAE2C,KAAK69G,eAAev/G,EAAElB,EAAEyB,EAAEX,GAAG8B,KAAK69G,eAAev/G,EAAElB,EAAEyB,EAAE6F,IAAIpG,EAAE4jB,SAAS0mB,KAAK1qC,IAAIA,EAAEc,UAAU6+G,eAAe,SAASv/G,EAAElB,EAAEyB,EAAEX,GAAGI,EAAE4jB,SAAS0mB,KAAK1qC,GAAG,IAAI,IAAIwG,EAAE1E,KAAK68G,OAAOrzG,EAAE4iB,EAAE9tB,EAAE,EAAElB,EAAEsH,GAAGvF,EAAEitB,EAAE9tB,EAAEO,EAAEzB,EAAEyB,EAAE6F,GAAGrH,EAAE4rG,EAAEz/F,GAAGy/F,EAAE9pG,GAAGq9G,EAAEp/G,EAAEo/G,EAAE39G,EAAEzB,EAAEo/G,IAAI,CAAC,IAAIh/G,EAAEc,EAAE4jB,SAASs6F,GAAG3+G,EAAE2L,EAAElL,EAAEq+G,KAAKj4G,EAAElH,GAAGA,GAAGH,GAAG4rG,EAAEz/F,GAAG,IAAI,IAAI/L,EAAEoB,EAAEzB,EAAE,EAAEK,GAAGL,EAAEK,IAAI,CAAC,IAAIyB,EAAEZ,EAAE4jB,SAASzkB,GAAGI,EAAEsB,EAAEb,EAAEq+G,KAAKj4G,EAAExF,GAAGA,GAAG7B,GAAG4rG,EAAE9pG,GAAG,OAAO9B,GAAGa,EAAEc,UAAUy+G,oBAAoB,SAASn/G,EAAElB,EAAEyB,GAAG,IAAI,IAAIX,EAAEW,EAAEX,GAAG,EAAEA,IAAIL,EAAET,EAAEc,GAAGI,IAAIJ,EAAEc,UAAUk+G,UAAU,SAAS5+G,GAAG,IAAI,IAAIlB,EAAEkB,EAAEgD,OAAO,EAAEzC,OAAE,EAAOzB,GAAG,EAAEA,IAAI,IAAIkB,EAAElB,GAAG8kB,SAAS5gB,OAAOlE,EAAE,GAAGyB,EAAEP,EAAElB,EAAE,GAAG8kB,UAAUikB,OAAOtnC,EAAE8zB,QAAQr0B,EAAElB,IAAI,GAAG4C,KAAKgmC,QAAQx8B,EAAElL,EAAElB,GAAG4C,KAAK68G,SAAS3+G,EAAxuMd,I,sGCMnF,aAYA,OAmBA,OACA,QACA,QAKMoP,EAAS,EAAAC,cAAcxM,SAASvB,OAAO,kBAEvCo/G,EAAyB,IAAI,EAAAt3F,gBAAgB,CAC/CqE,SAAU,CACN5B,KAAM,EAAAjB,SAASmB,MACf/H,KAAM,GACNgI,eAAgB,GAEpB6B,MAAO,EAAA2vC,WAAW36D,SAAS89G,SAAS,WACpC7yF,QAAS,EACTC,gBAAiB,EAAAyvC,WAAW36D,SAAS89G,SAAS,WAC9C3yF,kBAAmB,KAIjB4yF,EAAyB,IAAI,EAAAt3F,gBAAgB,CAC/C6E,kBAAmB,EAAApD,kBAAkBipF,OACrC9lF,oBAAqB,EAAAlD,oBAAoBgpF,OACzC5lF,WAAY,KAwZhB,SAASyyF,EACLhyF,EACAC,EACAgyF,GAOA,MAAM1yF,EAAyC0yF,EAuBnD,SAAkCC,GAE9B,MAAM3yF,EAA6B,GAanC,OAZyB2yF,EACnBA,EACKC,cACAhyG,QAAQ,IAAK,IACbiyG,MAAM,KACX,IACWh+G,QAAQnB,IACrB,MAAM46B,EAQd,SAAsC56B,GAElC,GAAIA,EAAEoC,OAAS,GAAKpC,EAAEoC,OAAS,EAC3B,OAGJ,MAAMixG,EAA+B,CACjCnmF,EAAG,EAAAxD,oBAAoBwoF,OACvBjwG,EAAG,EAAAwnB,kBAAkByoF,QAGzB,IAAIkN,EAAWp/G,EAAEm9B,OAAO,GACpB0e,GAAiB,EACrB,OAAQujE,GAEJ,KAAK,EAAAhmB,eAAe6Y,IACpB,KAAK,EAAA7Y,eAAeimB,MAChBhM,EAAcpxG,EAAI,EAAAwnB,kBAAkBwoF,IACpC,MAEJ,KAAK,EAAA7Y,eAAe+Y,OACpB,KAAK,EAAA/Y,eAAekmB,MAChBjM,EAAcpxG,EAAI,EAAAwnB,kBAAkB0oF,OACpC,MACJ,QAEI,GADAt2D,GAAQ,EACS,IAAb77C,EAAEoC,OAEF,OAGZ,GAAIy5C,GAAsB,IAAb77C,EAAEoC,OACX,OAAOixG,EAGX,OADA+L,EAAwB,IAAbp/G,EAAEoC,OAAepC,EAAEm9B,OAAO,GAAKn9B,EAAEm9B,OAAO,GAC3CiiF,GAEJ,KAAK,EAAAhmB,eAAe4Y,MACpB,KAAK,EAAA5Y,eAAemmB,KAChBlM,EAAcnmF,EAAI,EAAAxD,oBAAoBsoF,MACtC,MAEJ,KAAK,EAAA5Y,eAAe7tE,KACpB,KAAK,EAAA6tE,eAAeomB,KAChBnM,EAAcnmF,EAAI,EAAAxD,oBAAoB6B,KACtC,MACJ,QAEI,OAER,OAAO8nF,EA1DSoM,CAA6Bz/G,QAC7B8C,IAAR83B,GACAtO,EAAWtlB,KAAK4zB,KAGjBtO,EArCDozF,CAAyBV,QACzBl8G,EAEN,OAAO,EAAAypB,6BAOX,SAAmCQ,GAC/B,MAAsB,SAAfA,GAAwC,WAAfA,GAA0C,UAAfA,EACrD,EAAA7D,oBAAoB6D,GACpB+xF,EAAuB1yF,oBATzBuzF,CAA0B5yF,GAYlC,SAAmCC,GAC/B,MAAsB,UAAfA,GAAyC,WAAfA,GAA0C,UAAfA,EACtD,EAAA/D,kBAAkB+D,GAClB8xF,EAAuBzyF,kBAdzBuzF,CAA0B5yF,GAC1BV,GAvZR,uBASI,YAAoBqkB,GAAA,KAAAA,UARZ,KAAAkvE,aAA8C,IAAI58G,IAClD,KAAA68G,eAAmC,CACvCrhH,KAlBmB,UAmBnBo6C,YAAa,GACbtyB,aAAcq4F,EAAuBzgG,OACrCqI,aAAcs4F,EAAuB3gG,QAKzC,kCAAkCg7B,QACEr2C,IAA5BhC,KAAK6vC,QAAQw5B,aACbrpE,KAAK6vC,QAAQw5B,WAAa,IAE9B,MAAMK,EAAS1pE,KAAK6vC,QAAQw5B,WAEtB41C,EAAqBv1C,EAAOxxC,KAAKnS,GAhCpB,YAgC6BA,EAAMpoB,WAC3BqE,IAAvBi9G,EACAj/G,KAAKg/G,eAAiBh/G,KAAKk/G,uBACvBD,EAnCW,gBAsC0Bj9G,IAAlChC,KAAK6vC,QAAQy5B,iBACpBtpE,KAAKg/G,eAAiBh/G,KAAKk/G,uBACvBl/G,KAAK6vC,QAAQy5B,iBAxCF,WA2CRI,EAAOpoE,OAAS,IACvBtB,KAAKg/G,eAAiBh/G,KAAKk/G,uBAAuBx1C,EAAO,GA5C1C,YA8CnB1pE,KAAKg/G,eAAejnE,YAAcM,EAGtC,4BACIQ,EACAD,EACAumE,GAGA,QAAwCn9G,IAApChC,KAAKg/G,eAAejnE,YAA2B,CAC/C,MAAMqnE,EAAqBD,EAAcjnF,KACrCoZ,GAAgBA,EAAayG,cAAgB/3C,KAAKg/G,eAAejnE,aAErE/3C,KAAKg/G,eAAeztE,gBACOvvC,IAAvBo9G,EAAmCA,EAAmB7tE,gBAAavvC,EACvEhC,KAAKg/G,eAAezrE,iBACOvxC,IAAvBo9G,EAAmCA,EAAmB7rE,iBAAcvxC,OAErCA,IAAnChC,KAAKg/G,eAAeztE,kBACoBvvC,IAApChC,KAAKg/G,eAAejnE,aACpBvrC,EAAOuJ,KACH,gBAAgB/V,KAAKg/G,eAAejnE,kCAChC/3C,KAAKg/G,eAAerhH,8CAEpBi7C,EAAmBb,YAAYp6C,UAI3CqC,KAAKg/G,eAAeztE,WAAaqH,EACjC54C,KAAKg/G,eAAezrE,YAAcsF,GAItC74C,KAAK6vC,QAAQw5B,WAAYhpE,QAAQ83B,IAC7Bn4B,KAAK++G,aAAa/3G,IACdmxB,EAAQx6B,KACRqC,KAAKk/G,uBAAuB/mF,EAASA,EAAQx6B,SAIrD,IAAK,MAAO,CAAEooB,KAAU/lB,KAAK++G,aACzB,QAAyB/8G,IAArB+jB,EAAMwrB,WAA0B,CAChC,QAA0BvvC,IAAtB+jB,EAAMgyB,YAA2B,CACjC,MAAMqnE,EAAqBD,EAAcjnF,KACrCoZ,GAAgBA,EAAayG,cAAgBhyB,EAAMgyB,aAEvDhyB,EAAMwrB,gBACqBvvC,IAAvBo9G,EACMA,EAAmB7tE,gBACnBvvC,EACV+jB,EAAMwtB,iBACqBvxC,IAAvBo9G,EACMA,EAAmB7rE,iBACnBvxC,OAEWA,IAArB+jB,EAAMwrB,kBACoBvvC,IAAtB+jB,EAAMgyB,aACNvrC,EAAOuJ,KACH,gBAAgBgQ,EAAMgyB,kCAClBhyB,EAAMpoB,8CAENi7C,EAAmBb,YAAYp6C,UAI3CooB,EAAMwrB,WAAaqH,EACnB7yB,EAAMwtB,YAAcsF,IAUpC,oBAAoBwmE,GAChB,IAAIl5G,EASJ,YARgBnE,IAAZq9G,EACAl5G,EAASnG,KAAKg/G,gBAEd74G,EAASnG,KAAK++G,aAAa9gH,IAAIohH,QAChBr9G,IAAXmE,IACAA,EAASnG,KAAKg/G,iBAGf74G,EAQX,kBACIsc,EACA6J,GAEA,MAAMpe,EAAUuU,EAAKvU,QACf0I,EAAY1I,EAAQ0I,UACpBqlE,EAAoB5yE,KAAKmtB,MAAM5f,GAG/BslE,EAAkB,IAAI,EAAApa,OAAO,CAAE6N,MAAOsM,GAAqB/tE,EAAQ9L,KAEnEk9G,EAAsBt/G,KAAKg/G,eAAev5F,aAG1C85F,EAAiB,EAAA3wC,eAAe0wC,EAAoBp0F,QAAS,GAEnE,IAKID,EALAC,EAAU,EAAAgC,iBACV,EAAA0hD,eAAetiD,EAAUpB,QAASq0F,GAClCrjC,GAKJ,QAAwBl6E,IAApBsqB,EAAUrB,MAAqB,CAC/B,IAAIu0F,EAAW,EAAAlyF,sBAAsBhB,EAAUrB,MAAOixD,GACtD,QAAiBl6E,IAAbw9G,EAAwB,CACxB,GAAI,EAAAjyF,WAAWC,cAAcgyF,GAAW,CAEpCt0F,GADc,EAAAqC,WAAWuJ,gBAAgB0oF,GAEzCA,EAAW,EAAAjyF,WAAWE,mBAAmB+xF,GAE7Cv0F,EAAQ,EAAA2vC,WAAW36D,SAAS89G,SAASyB,IAK7C,MAAMC,EAAwB,EAAA7wC,eAC1B0wC,EAAoBz0F,SAAUzB,eAC9B,GAEEA,EAAiB,EAAA8D,iBACnB,EAAA0hD,eAAetiD,EAAUlD,eAAgBq2F,GACzCvjC,GAGEwjC,OAC4B19G,IAA9BsqB,EAAUnB,sBACmBnpB,IAA7BsqB,EAAUlD,gBACVA,EAAiB,EAMfu2F,EAA2B,EAAA/wC,eAAe0wC,EAAoBl0F,kBAAmB,GACvF,IAQID,EARAC,EAAoB,EAAA8B,iBACpB,EAAA0hD,eACItiD,EAAUlB,kBACVs0F,EAAuB,EAAMC,GAEjCzjC,GAKJ,QAAkCl6E,IAA9BsqB,EAAUnB,gBAA+B,CACzC,IAAIy0F,EAAa,EAAAtyF,sBAAsBhB,EAAUnB,gBAAiB+wD,GAClE,QAAmBl6E,IAAf49G,EAA0B,CAC1B,GAAI,EAAAryF,WAAWC,cAAcoyF,GAAa,CAEtCx0F,GADc,EAAAmC,WAAWuJ,gBAAgB8oF,GAEzCA,EAAa,EAAAryF,WAAWE,mBAAmBmyF,GAE/Cz0F,EAAkB,EAAAyvC,WAAW36D,SAAS89G,SAAS6B,IAIvD,MAAMn6F,EAAe,CACjBmF,SAAU,EAAAgkD,eAAetiD,EAAU1B,SAAU00F,EAAoB10F,UACjEC,SAAU,CACN5B,KAAM,EAAAjB,SAASmB,MACf/H,KAAM,EAAA8L,iBACF,EAAA0hD,eAAetiD,EAAUlL,KAAMk+F,EAAoBz0F,SAAUzJ,MAC7D86D,GAEJ9yD,kBAEJ0B,UAC4B,YAAxBwB,EAAUxB,WACc,SAAxBwB,EAAUxB,WACc,WAAxBwB,EAAUxB,WACc,eAAxBwB,EAAUxB,UACJ,EAAA7C,UAAUqE,EAAUxB,WACpBw0F,EAAoBx0F,UAC9BC,YAC8B,YAA1BuB,EAAUvB,aACgB,YAA1BuB,EAAUvB,aACgB,cAA1BuB,EAAUvB,YACJ,EAAA7C,YAAYoE,EAAUvB,aACtBu0F,EAAoBv0F,YAC9BC,SAAU,EAAA4jD,eAAetiD,EAAUtB,SAAUs0F,EAAoBt0F,UACjEC,MAAO,EAAA2jD,eACH3jD,EACA,EAAA2jD,eAAe0wC,EAAoBr0F,MAAO,EAAA3C,iBAAiBmB,gBAE/D0B,gBAAiB,EAAAyjD,eACbzjD,EACA,EAAAyjD,eACI0wC,EAAoBn0F,gBACpB,EAAA7C,iBAAiBsB,2BAGzBsB,UACAE,qBAGEy0F,EAAoB7/G,KAAKs2C,oBAAoBhqB,EAAUvG,OAAON,aAMpE,OALoB,IAAI,EAAAe,gBAAgB,OAAD,wBAChCq5F,GACAp6F,IAcX,kBACIhD,EACA6J,G,gBAEA,MAAMpe,EAAUuU,EAAKvU,QACf4xG,EAAiBz2G,KAAKmtB,MAAM/T,EAAKvU,QAAQ0I,WAEzCslE,EAAkB,IAAI,EAAApa,OAAO,CAAE6N,MAAOmwC,GAAkB5xG,EAAQ9L,KAEhE29G,EAAsB//G,KAAKg/G,eAAet5F,aAE1CuG,EAAa,EAAAiB,iBAAiBZ,EAAUL,WAAYiwD,GACpDhwD,EAAa,EAAAgB,iBAAiBZ,EAAUJ,WAAYgwD,GAGpD8jC,EAAiB,EAAAllC,eAAexuD,GAC/B,EAAAY,iBAAkBZ,EAA2Bd,WAAY0wD,GAG1D,MAEA,oBAAE5wD,EAAmB,kBAAEC,EAAiB,WAAEC,GAAeyyF,EAC3DhyF,EACAC,EACA8zF,GAGEC,EAAW,EAAA/yF,iBAAiBZ,EAAUN,aAAckwD,GAEpDlwD,EACW,SAAbi0F,GAAoC,cAAbA,GAAyC,SAAbA,EAC7C,EAAA53F,aAAa43F,GACbF,EAAoB/zF,aAExBtG,EAAe,CACjBgG,SACyD,QADjD,EACJ,EAAAwB,iBAAiBZ,EAAUZ,SAAUwwD,UAAgB,QACrD6jC,EAAoBr0F,SACxBC,QACwD,QADjD,EACH,EAAAuB,iBAAiBZ,EAAUX,QAASuwD,UAAgB,QAAI6jC,EAAoBp0F,QAChFC,SACyD,QADjD,EACJ,EAAAsB,iBAAiBZ,EAAUV,SAAUswD,UAAgB,QACrD6jC,EAAoBn0F,SACxBC,UAC0D,QADjD,EACL,EAAAqB,iBAAiBZ,EAAUT,UAAWqwD,UAAgB,QACtD6jC,EAAoBl0F,UACxBC,eAC+D,QADjD,EACV,EAAAoB,iBAAiBZ,EAAUR,eAAgBowD,UAAgB,QAC3D6jC,EAAoBj0F,eACxBC,aAC6D,QADjD,EACR,EAAAmB,iBAAiBZ,EAAUP,aAAcmwD,UAAgB,QACzD6jC,EAAoBh0F,aACxBC,eACAV,sBACAC,oBACAC,cAGE00F,EAAoBlgH,KAAKs2C,oBAAoBhqB,EAAUvG,OAM7D,OALoB,IAAI,EAAAW,gBAAgB,OAAD,wBAChCw5F,GACAx6F,IAMH,uBACJK,EACAo6F,GAEA,MAAM,oBAAE70F,EAAmB,kBAAEC,EAAiB,WAAEC,GAAeyyF,EAC3Dl4F,EAAMkG,WACNlG,EAAMmG,WACNnG,EAAMyF,YAEV,MAAO,CACH7tB,KAAMwiH,EACNpoE,YAAa,EAAA62B,eAAe7oD,EAAMq6F,gBAAiBpgH,KAAKg/G,eAAejnE,aACvEtyB,aAAc,CACVmF,SAAU7E,EAAM6E,SAChBC,SAAU,CACN5B,KAAM,EAAAjB,SAASmB,MACf/H,KAAM,GACNgI,eAAgBrD,EAAMqD,gBAAkB,GAE5C0B,UACwB,YAApB/E,EAAM+E,WACc,SAApB/E,EAAM+E,WACc,WAApB/E,EAAM+E,WACc,eAApB/E,EAAM+E,UACA,EAAA7C,UAAUlC,EAAM+E,gBAChB9oB,EACV+oB,YAC0B,YAAtBhF,EAAMgF,aACgB,YAAtBhF,EAAMgF,aACgB,cAAtBhF,EAAMgF,YACA,EAAA7C,YAAYnC,EAAMgF,kBAClB/oB,EACVgpB,SAAUjF,EAAMiF,SAChBC,WACoBjpB,IAAhB+jB,EAAMkF,MACA,EAAA2vC,WAAW36D,SAAS89G,SAASh4F,EAAMkF,YACnCjpB,EACVmpB,qBAC8BnpB,IAA1B+jB,EAAMoF,gBACA,EAAAyvC,WAAW36D,SAAS89G,SAASh4F,EAAMoF,sBACnCnpB,EACVkpB,QAASnF,EAAMmF,QACfE,kBAAmBrF,EAAMqF,mBAE7B1F,aAAc,CACVgG,SAAU3F,EAAM2F,SAChBC,QAAS5F,EAAM4F,QACfC,SAAU7F,EAAM6F,SAChBC,UAAW9F,EAAM8F,UACjBC,eAAgB/F,EAAM+F,eACtBC,aAAchG,EAAMgG,aACpBC,aAC2B,SAAvBjG,EAAMiG,cACiB,cAAvBjG,EAAMiG,cACiB,SAAvBjG,EAAMiG,aACA,EAAA3D,aAAatC,EAAMiG,cACnB,EAAA3D,aAAagC,KACvBkB,oBACAD,sBACAE,kB,yGCpchB,SAAY60F,GAER,+CAEA,mCAJJ,CAAY,EAAAA,oBAAA,EAAAA,kBAAiB,M,yGCJ7B,eAcA,0BASI,YAAmBnyG,GAAA,KAAAA,UARX,KAAAoyG,WAAkC,IAAIn+G,IACtC,KAAAo+G,WAAoC,IAAIp+G,IAgBhD,cACIxE,EACA8lD,EACAnsC,GAEA,QAAatV,IAATrE,EAAoB,CACpB,GAAIqC,KAAKwgH,QAAQ7iH,GACb,MAAM,IAAI8F,MAAM,2BAGpB,MAAMg9G,EAAWzgH,KAAKugH,WAAWtiH,IAAIwlD,QACpBzhD,IAAby+G,EACIA,EAAS9tF,QAAQh1B,GAAQ,GACzB8iH,EAASv6G,KAAKvI,GAGlBqC,KAAKugH,WAAWv5G,IAAIy8C,EAAK,CAAC9lD,IAE9BqC,KAAKsgH,WAAWt5G,IAAIrJ,EAAM8lD,GAG9B,MAAMuxD,EAAY,EAAA0L,WAAWzgH,SAAS0gH,UAAUl9D,GAChD,YAAkBzhD,IAAdgzG,EACO,EAAA0L,WAAWzgH,SAAS2gH,cAAc5gH,KAAKkO,QAASu1C,EAAKnsC,GAEzD09F,EAWX,SACIr3G,EACA8lD,EACAo9D,GAAe,GAEf,MAAM7L,EAAYh1G,KAAK4gH,cAAcjjH,EAAM8lD,OAAKzhD,GAChD,OAAqB,IAAjB6+G,EACO,EAAAH,WAAWzgH,SAAS43G,UAAU7C,GAGlCA,EAQX,gBAAgBr3G,GACZ,MAAM8lD,EAAMzjD,KAAKsgH,WAAWriH,IAAIN,GAChC,QAAYqE,IAARyhD,EAGJ,OAAO,EAAAi9D,WAAWzgH,SAAS0gH,UAAUl9D,GAQzC,eAAeA,GACX,OAAO,EAAAi9D,WAAWzgH,SAAS0gH,UAAUl9D,GAQzC,UAAUuxD,GACN,OAAO,EAAA0L,WAAWzgH,SAAS43G,UAAU7C,GAUzC,QACI,EAAA0L,WAAWzgH,SAAS+lC,MAAMhmC,KAAKkO,SAC/BlO,KAAKsgH,WAAa,IAAIn+G,IACtBnC,KAAKugH,WAAa,IAAIp+G,IAM1B,oBACI,OAAOnC,KAAKsgH,WAAWl/F,KAM3B,mBACI,OAAOphB,KAAKugH,WAAWn/F,KAQ3B,QAAQzjB,GACJ,YAAqCqE,IAA9BhC,KAAKsgH,WAAWriH,IAAIN,GAO/B,OAAO8lD,GACH,YAAoCzhD,IAA7BhC,KAAKugH,WAAWtiH,IAAIwlD,GAM/B,UAAUA,GACN,OAAOzjD,KAAKugH,WAAWtiH,IAAIwlD,M,kGClKnC,aACA,OAIA,SAEMj3C,EAAS,EAAAC,cAAcxM,SAASvB,OAAO,cACvCoiH,EAAkB,IAAI,EAAA3I,gBA+C5B,MAAauI,EAAb,cAqBY,KAAAK,SAAwC,IAAI5+G,IAjBpD,sBAII,YAH8BH,IAA1B0+G,EAAWn1E,aACXm1E,EAAWn1E,WAAa,IAAIm1E,GAEzBA,EAAWn1E,WAOtB,iBACIm1E,EAAWn1E,gBAAavpC,EAc5B,cACIkM,EACAu1C,EACA6xD,GAEA,IAAI0L,EAAiBhhH,KAAKihH,mBAAmBx9D,GAC7C,QAAuBzhD,IAAnBg/G,EAIA,YAHgBh/G,IAAZkM,GAAyB8yG,EAAeE,SAASvuF,QAAQzkB,GAAW,GACpE8yG,EAAeE,SAASh7G,KAAKgI,GAE1B8yG,EAAehM,UAG1B,MAAMkM,EAAsB,GAgB5B,YAfgBl/G,IAAZkM,GACAgzG,EAASh7G,KAAKgI,GAGlB8yG,EAAiB,CACbhM,UAAW,CACPvxD,MACA6xD,YACAqC,QAAQ,GAEZuJ,YAGJlhH,KAAK+gH,SAAS/5G,IAAIy8C,EAAKu9D,GAEhBA,EAAehM,UAU1B,SACI9mG,EACAu1C,EACAo9D,GAAe,GAEf,MAAM7L,EAAYh1G,KAAK4gH,cAAc1yG,EAASu1C,OAAKzhD,GACnD,YAAkBA,IAAdgzG,IAA4C,IAAjB6L,EACpB7gH,KAAK63G,UAAU7C,GAGnBA,EASX,UAAUvxD,GACN,MAAMuxD,EAAYh1G,KAAK+gH,SAAS9iH,IAAIwlD,GACpC,QAAkBzhD,IAAdgzG,EACA,OAAOA,EAAUA,UAWzB,MAAM9mG,GACF,MAAMizG,EAA0B,GAEhCnhH,KAAK+gH,SAAS1gH,QAAQ20G,IAClB,MAAMoM,EAAepM,EAAUkM,SAASvuF,QAAQzkB,GAC5CkzG,GAAgB,GAChBpM,EAAUkM,SAAS/6E,OAAOi7E,EAAc,GAEV,IAA9BpM,EAAUkM,SAAS5/G,QACnB6/G,EAAcj7G,KAAK8uG,EAAUA,UAAUvxD,OAI/C,IAAK,MAAM49D,KAAeF,EACtBnhH,KAAK+gH,SAASh6G,OAAOs6G,GAO7B,WACIrhH,KAAK+gH,SAAW,IAAI5+G,IAMxB,WACI,OAAOnC,KAAK+gH,SAAS3/F,KAUzB,UAAU4zF,GACN,QAA4BhzG,IAAxBgzG,EAAUM,UACV,OAAON,EAGX,QAAiChzG,IAA7BgzG,EAAUrS,eACV,OAAOqS,EAAUrS,eAGrB,MAAM2e,EAAc,IAAIliH,EAAMmiH,YA+B9B,OA7BAvM,EAAUrS,eAAiB,IAAI1qD,QAAQqzB,IACnC9+D,EAAO2iC,MAAM,kBAAkB6lE,EAAUvxD,OACzC69D,EAAYnvF,KACR6iF,EAAUvxD,IACVnsC,IACI9K,EAAO2iC,MAAM,+BAA+B6lE,EAAUvxD,OACtDzjD,KAAKwhH,YAAYxM,EAAW19F,GACvB0tB,KAAK,KACFgwE,EAAUS,QAAUqL,EAAgBW,2BAChCzM,GAEJA,EAAUrS,oBAAiB3gG,EAC3BspE,EAAQ0pC,KAEX7vE,MAAMu8E,IACHl1G,EAAO+R,MAAM,6BAA6By2F,EAAUvxD,SAASi+D,KAC7Dp2C,OAAQtpE,WAIpBA,EACA2/G,IACIn1G,EAAO+R,MAAM,6BAA6By2F,EAAUvxD,SAASk+D,KAE7D3M,EAAUrS,oBAAiB3gG,EAC3BspE,OAAQtpE,OAIbgzG,EAAUrS,eAQb,mBAAmBl/C,GACvB,OAAOzjD,KAAK+gH,SAAS9iH,IAAIwlD,GAUrB,YACJuxD,EACA19F,GAEA,OAAO,IAAI2gC,QAAQ,CAACqzB,EAAS41B,KAGzB,GAAiC,mBAAtB0gB,kBAAkC,CACzC,MAAM3rG,EAA8B,CAChC0/F,iBAAkB,WAGtBnpG,EAAO2iC,MAAM,0BAA0B6lE,EAAUvxD,OACjDm+D,kBAAkBtqG,EAAO,EAAG,EAAGA,EAAMG,MAAOH,EAAMpG,OAAQ+E,GACrD+uB,KAAK68E,IACFr1G,EAAO2iC,MAAM,uCAAuC6lE,EAAUvxD,OAE9DuxD,EAAUrS,oBAAiB3gG,EAC3BgzG,EAAUM,UAAYuM,EACtB7M,EAAU2C,QAAS,EACnBrsC,EAAQu2C,KAEX18E,MAAMu8E,IACHl1G,EAAO+R,MAAM,6BAA6By2F,EAAUvxD,SAASi+D,KAC7Dp2C,OAAQtpE,UAGhB,IAC4B,oBAAbq3G,WACP7sG,EAAO+R,MAAM,2DACb2iF,EACI,IAAIz9F,MACA,8FAUZ,MAAM+qC,EAAS6qE,SAASC,cAAc,UACtC9qE,EAAO/2B,MAAQH,EAAMG,MACrB+2B,EAAOt9B,OAASoG,EAAMpG,OAEtB,MAAMhR,EAAUsuC,EAAOgrE,WAAW,MAClC,GAAgB,OAAZt5G,EAAkB,CAClBsM,EAAO2iC,MAEH,iDAAiD6lE,EAAUvxD,OAAOnsC,KAEtEpX,EAAQk6G,UACJ9iG,EACA,EACA,EACAA,EAAMG,MACNH,EAAMpG,OACN,EACA,EACAs9B,EAAO/2B,MACP+2B,EAAOt9B,QAEX,MAAMokG,EAAYp1G,EAAQ65G,aAAa,EAAG,EAAGziG,EAAMG,MAAOH,EAAMpG,QAChE8jG,EAAUM,UAAYA,EACtBN,EAAU2C,QAAS,EACnBrsC,EAAQgqC,QAER9oG,EAAO+R,MAAM,iCACb2iF,EAAO,IAAIz9F,MAAM,6CAEvB,MAAOi+G,GACLl1G,EAAO+R,MAAM,uBAAuBmjG,KACpC1M,EAAUM,eAAYtzG,EACtBgzG,EAAU2C,QAAS,EACnBzW,EAAO,IAAIz9F,MAAM,kCAAkCi+G,UAnRvE,gB,kGCtDA,aASA,OA+DA,iCACY,KAAAI,UAAyB,GAKjC,eACI,OAAO9hH,KAAK8hH,UAOhB,IAAIC,GACA/hH,KAAK8hH,UAAU57G,KAAK67G,GAUxB,OAAOA,GACH,MAAMrnG,EAAQ1a,KAAK8hH,UAAU/9B,UAAU5rD,GAAWA,IAAY4pF,GAC1DrnG,GAAS,GACT1a,KAAK8hH,UAAU37E,OAAOzrB,EAAO,GAOrC,QACI1a,KAAK8hH,UAAUxgH,OAAS,EAc5B,OACI6N,EACA6yG,EACAC,EACAC,EACA14C,GAEA,MAAMn1D,EAAgB,IAAIjV,EAAMuG,QAEhC3F,KAAK8hH,UAAUzhH,QAAS0hH,IACpB,QAA2B//G,IAAvB+/G,EAAUjpC,SAAwB,CAClC,MAAMnzD,EAAW6jD,aAAU,EAAVA,EAAYua,UACzBC,GACIA,EAAMrhD,QAAUo/E,EAAUjpC,UAAYkL,EAAMF,WAAai+B,EAAUj+B,eAG1D9hF,IAAb2jB,IAAwC,IAAdA,IAC1Bo8F,EAAUz7F,YAA+B,IAAhBX,EAAW,IAI5C,MAAMw8F,OAEwBngH,IAA1B+/G,EAAUK,YAA4BL,EAAUK,YAAcL,EAAUI,YAC7DngH,IAAXmgH,IACI,EAAAr1C,cAAcq1C,GACd9tG,EAAcrN,IAAIm7G,EAAO18G,EAAG08G,EAAOz8G,EAAGy8G,EAAOv8G,GACtC,EAAAkD,qBAAqBq5G,IAC5BhzG,EAAWsB,aAAa0xG,EAAQ9tG,GAEpC0tG,EAAUh0G,SAASuB,KAAK+E,GAAevB,IAAIkvG,KAGrB,IAAtBD,EAAUM,QACVH,EAAgB/hH,IAAI4hH,GAEpBE,EAAS9hH,IAAI4hH,Q,kGC9J7B,aACA,OACA,OAMA,mBAWI,YAAoBhiD,GAAA,KAAAA,UAVZ,KAAAuiD,WAAqB,EACrB,KAAAriD,MAAmB,IAAI7gE,EAAMmjH,IAAI,GACjC,KAAAC,gBAA0B,EAC1B,KAAAC,cAAuB,CAAE/4C,OAAQ,IAgBzC,YAAYg5C,GACR1iH,KAAKsiH,UAAYI,EACbA,GAAa1iH,KAAKwiH,gBAAuC,OAArBxiH,KAAK+/D,QAAQlxC,IACjD7uB,KAAKG,MACGuiH,GAAkC,OAArB1iH,KAAK+/D,QAAQlxC,KAClC7uB,KAAKqjC,SAOb,cACI,OAAOrjC,KAAKsiH,UAahB,MAAM5jD,GACF1+D,KAAKyiH,cAAgB/jD,OAEP18D,IAAV08D,QACc18D,IAAd08D,EAAM7vC,UACc7sB,IAApB08D,EAAM7vC,IAAI5D,YACejpB,IAAzB08D,EAAM7vC,IAAI8zF,YAEV3iH,KAAKwiH,gBAAiB,EACtBxiH,KAAKigE,MAAMh1C,MAAMjkB,IAAI03D,EAAM7vC,IAAI5D,OAC3BjrB,KAAKsiH,WAAkC,OAArBtiH,KAAK+/D,QAAQlxC,KAC/B7uB,KAAKG,QAGTH,KAAKwiH,gBAAiB,EACG,OAArBxiH,KAAK+/D,QAAQlxC,KACb7uB,KAAKqjC,UAUjB,OAAOn1B,EAAkB+nC,GACrB,GACyB,OAArBj2C,KAAK+/D,QAAQlxC,UACU7sB,IAAvBhC,KAAKyiH,eACLziH,KAAKyiH,cAAc5zF,UACmB7sB,IAAtChC,KAAKyiH,cAAc5zF,IAAI8zF,kBACC3gH,IAAvBkM,EAAQQ,OAAOiQ,UAAsC3c,IAAjBi0C,GACvC,CAIE,MAAM2sE,OAA6B5gH,IAAjBi0C,EAA6BA,EAAe/nC,EAAQQ,OAAOiQ,IAGvEkkG,EAAoB,EAEpBC,EAAkB,EAGlBH,EAAa3iH,KAAKyiH,cAAc5zF,IAAI8zF,WAEpCI,EAAW,EACjB,EAAAz2G,OAAOq2G,GAAcI,GACrB,MAAMzkH,EAAI+K,KAAK2S,IAAI3S,KAAKkH,IAAIrC,EAAQS,OAC9Bq0G,EAAU,EAAA16G,UAAU26G,WAAWJ,EAAmBC,EAAiBxkH,GACzE0B,KAAKigE,MAAMvhD,KAAO,EAAApW,UAAUo1B,KAAKklF,EAAYD,EAAYC,EAAW,EAAMI,GAC1EhjH,KAAKigE,MAAMthD,IAAM,EAAArW,UAAUo1B,KAAKklF,EAAYG,EAAUH,EAAWI,GACjEhjH,KAAKigE,MAAMvhD,KAAOrV,KAAKO,IAAI5J,KAAKigE,MAAMvhD,KAAMxQ,EAAQQ,OAAOiQ,KAC3D3e,KAAKigE,MAAMthD,IAAMtV,KAAKO,IAAI5J,KAAKigE,MAAMthD,IAAKzQ,EAAQQ,OAAOiQ,MAOzD,MAEJ3e,KAAK+/D,QAAQlxC,IAAM7uB,KAAKigE,MAExBjgE,KAAKkjH,4BAA2B,GAM5B,SAEJljH,KAAK+/D,QAAQlxC,IAAM,KAEnB7uB,KAAKkjH,4BAA2B,GAS5B,2BAA2BR,GAC/B1iH,KAAK+/D,QAAQj6B,SAAShnC,IACZA,aAAkBM,EAAM40B,MAGxBl1B,EAAO2L,oBAAoBrL,EAAM+jH,WAInCrkH,EAAO2L,oBAAoB,EAAAmkB,2BAI3B9vB,EAAO2L,SAASokB,MAAQ6zF,IAG5B5jH,EAAO2L,SAASokB,IAAM6zF,EAItB5jH,EAAO2L,SAAS8B,aAAc,S,kGC/J1C,aAeA,OACA,OACA,OACA,QAEA,QACA,QAIMC,EAAS,EAAAC,cAAcxM,SAASvB,OAAO,cAuB7C,kBAAa8iE,EAwDT,YAAqBtzD,GAAA,KAAAA,UARb,KAAAk1G,gBAA6C,IAAIjhH,IACjD,KAAAkhH,kBAAyC,IAAIlhH,IAvC7C,6BACJk1G,EACArxD,QAEqBhkD,IAAjBq1G,IACAA,EAAe,kBAEwCr1G,IAAvDw/D,EAAW8hD,sBAAsBrlH,IAAIo5G,KACrC71C,EAAW8hD,sBAAsBt8G,IAAIqwG,GAAc,QAClCr1G,IAAbgkD,GAA2BA,EAASu9D,SAGpC/2G,EAAO+R,MACH,kDAAkD84F,aAHtD7qG,EAAO+R,MAAM,oDAAoD84F,QAcrE,wBAAwBpxD,EAAiBoxD,QAC7Br1G,IAAZikD,IACAA,EAAU,aAEd,MAAMtnD,EAAc,GAAG04G,KAAgBpxD,UACMjkD,IAAzCw/D,EAAWgiD,iBAAiBvlH,IAAIU,KAChC6iE,EAAWgiD,iBAAiBx8G,IAAIrI,GAAK,GACrC6N,EAAOuJ,KACH,0BACI,6BAA6BkwC,gBAAsBoxD,QAyBnE,QAAQ50F,EAAYohB,GAChB,MAAMg+C,EAAgB,EAAA4hC,aAAa5/E,EAAYg+C,eACzCzO,EAAe3wD,EAAK4wD,sBAE1B,IAAK,MAAMqwC,KAAe7hC,EAAe,CACrC,EAAAv1E,YAAiCtK,IAA1B0hH,EAAYp3F,WACnB,MAAM8wD,EAAiB,EAAAqmC,aAAaC,EAAYp3F,WAC1CA,EAAYuX,EAAY02C,WAAW6C,GAEzC,IAC6B,IAAzB9wD,EAAUkuD,aACR,EAAAO,sBAAsBzuD,KAAe,EAAAwuD,eAAexuD,GAEtD,SAKJ,IAA4B,IAAxBA,EAAUi5B,UACV,SAGJ,MAAMgK,EAAY,IAAInwD,EAAM0a,gBACxB,IAAI0X,aAAakyF,EAAYn0D,UAAU7+B,QACvCgzF,EAAYn0D,UAAU97B,WAGtB,EAAAsnD,sBAAsBzuD,IAAcijC,EAAUx1C,MAAQ,EACtD/Z,KAAK2jH,cAAclhG,EAAMihG,EAAap3F,EAAWijC,EAAW6jB,GACrD,EAAA0H,eAAexuD,IACtBtsB,KAAKo3G,OAAO30F,EAAMihG,EAAap3F,EAAWijC,EAAW6jB,IAiBjE,gBAAgBvpB,EAAmBktB,GAC/BzO,MAAMyO,GACD/xC,KAAKujC,IACF,IAAKA,EAASq7C,GACV,MAAM,IAAIngH,MACN,8CAA8C8kE,EAASs7C,cAI/D,OAAOt7C,EAAS3mE,SAEnBojC,KAAM8+E,IACH,QAAkB9hH,IAAd8hH,EAAJ,CAKA,IACIt3G,EAAO2iC,MACH,0CAA0C4nC,iBAAqBltB,MAEnE,IAAK,MAAMC,KAAehsD,OAAOy0B,oBAAoBuxF,GAAY,CAC7D,MAAMC,EAAkBD,EAAUh6D,GAE5B3D,EAA6B,CAC/BxoD,KAAMmsD,EACNxyC,MAAOuyC,EACPjkC,QAASm+F,EAAgBt+G,EACzBogB,QAASk+F,EAAgBr+G,EACzB+R,MAAOssG,EAAgBtsG,MACvBvG,OAAQ6yG,EAAgB7yG,QAG5BlR,KAAKi3E,gBAAgB9wB,IAE3B,MAAOu7D,GACLl1G,EAAO+R,MACH,gDAAkD,IAAIw4D,QAAY2qC,KAG1E1hH,KAAKkO,QAAQmkC,cA3BT7lC,EAAO6nD,KAAK,wCAAwC0iB,OA8B3D5xC,MAAO6+E,IACJx3G,EAAO+R,MAAM,iDAAiDw4D,QAAYitC,OAWtF,gBAAgB79D,QACcnkD,IAAtBmkD,EAAaxoD,WAImCqE,IAAhDhC,KAAKojH,gBAAgBnlH,IAAIkoD,EAAaxoD,OACtC6O,EAAOuJ,KACH,uCAAuCowC,EAAaxoD,OAAS,oBAIrEqC,KAAKojH,gBAAgBp8G,IAAIm/C,EAAaxoD,KAAMwoD,IATxC35C,EAAO+R,MAAM,iCAAkC4nC,GAkBvD,gBAAgBxoD,GACZ,OAAOqC,KAAKojH,gBAAgBnlH,IAAIN,GAmBpC,sBAAsB0gD,GAClB,MAAMj5B,EAAUi5B,EAAWj5B,QAG3B,QACgBpjB,IAAZojB,QACyBpjB,IAAzBojB,EAAQiyF,mBACYr1G,IAApBojB,EAAQ6gC,QAER,OAAO,EAIX,MAAMoxD,EAAejyF,EAAQiyF,aACvBrxD,EAAWhmD,KAAKkO,QAAQ+U,gBAAgBghG,YAAY5M,GAG1D,QAAiBr1G,IAAbgkD,GAA0BA,EAASljC,UAEnC,OAAO,EAOX,GAHAsC,EAAQiyF,kBAAer1G,OAGNA,IAAbgkD,IAA2BA,EAASu9D,SAEpC,OADA/hD,EAAW0iD,sBAAsB7M,EAAcrxD,IACxC,EAIX,MAAMC,EAAU7gC,EAAQ6gC,QAClBk+D,EAAgBn+D,EAASo+D,SAASn+D,GACxC,YAAsBjkD,IAAlBmiH,GACA3iD,EAAW6iD,iBAAiBp+D,EAASoxD,IAC9B,SAGoBr1G,IAA3BmiH,EAAcG,UAA0BH,EAAcG,SAAShjH,OAAS,IACxE8jB,EAAQ8wF,iBAAmB,EAAAqO,4BACvBJ,EAAcG,SACdl/F,EAAQkH,YAIhB+xB,EAAWj4B,aACmBpkB,IAA1BmiH,EAAc/9F,QAAwB+9F,EAAc/9F,QAAUi4B,EAAWj4B,QAC7Ei4B,EAAW14B,cACoB3jB,IAA3BmiH,EAAcx+F,SAAyBw+F,EAAcx+F,SAAW04B,EAAW14B,SAC/EP,EAAQoC,sBAC2BxlB,IAA/BmiH,EAAcK,aACRL,EAAcK,aACdp/F,EAAQoC,iBAClBpC,EAAQuC,sBAC2B3lB,IAA/BmiH,EAAcM,aACRN,EAAcM,aACdr/F,EAAQuC,iBAClBvC,EAAQqC,sBAC2BzlB,IAA/BmiH,EAAcO,aACRP,EAAcO,aACdt/F,EAAQqC,iBAClBrC,EAAQwC,sBAC2B5lB,IAA/BmiH,EAAcQ,aACRR,EAAcQ,aACdv/F,EAAQwC,iBAElBy2B,EAAWumE,qCAEJ,GAMX,QACI5kH,KAAKojH,gBAAgBp9E,QACrBhmC,KAAKqjH,kBAAkBr9E,QAQnB,cACJvjB,EACAihG,EACAp3F,EACAijC,EACA6jB,GAEA,MAAMhxE,EAAMpC,KAAKkO,QAAQ9L,IAEzB,IASI0f,EACAgE,EAVAowF,OAC2Bl0G,IAA3BsqB,EAAU65B,aACJ,EAAAo+D,4BACI,EAAAr3F,iBAAiBZ,EAAU65B,aAAc/jD,GACzCkqB,QAEJtqB,EAENwjB,EAAe,QAIexjB,IAA9B0hH,EAAYhnC,gBACZ,EAAApwE,OAAOo3G,EAAY7mC,MAAMv7E,OAAS,GAClCkkB,EAAOk+F,EAAYhnC,cAAcgnC,EAAY7mC,MAAM,KAAO,QAC7B76E,IAAzB0hH,EAAYhjF,WACZ5e,EAAW4hG,EAAYhjF,SAAS,GAChC5a,EAAY,EAAA2uD,aAAa3yD,SAGK9f,IAA9B0hH,EAAYx6C,gBACZ,EAAA58D,OAAOo3G,EAAYx6C,cAAc5nE,OAAS,GAC1C40G,EAAmBwN,EAAYhnC,cAAcgnC,EAAYx6C,cAAc,MAO/E,MAAM27C,EAAWh1D,OAAOqmD,GAAoB,IAAM1wF,EAClD,IAAIm8B,EAAmB3hD,KAAKqjH,kBAAkBplH,IAAI4mH,QACzB7iH,IAArB2/C,IACAA,EAAmB3hD,KAAKqjH,kBAAkBjiG,KAC1CphB,KAAKqjH,kBAAkBr8G,IAAI69G,EAAUljE,IAMzC,MAAMmjE,EAAiC,GACvC,IAAK,IAAI1nH,EAAI,EAAGA,EAAImyD,EAAUx1C,MAAO3c,GAAK,EAAG,CACzC,MAAMqI,EAAI8pD,EAAU4E,KAAK/2D,GAAKg2E,EACxB1tE,EAAI6pD,EAAU6E,KAAKh3D,GACnBwI,EAAI2pD,EAAUqtB,KAAKx/E,GACzB0nH,EAAc5+G,KAAK,IAAI9G,EAAMuG,QAAQF,EAAGC,EAAGE,IAE/C,MAAMk9B,EAAc9iC,KAAK+kH,uBACrBtiG,EACA+C,EACA8G,EACA4pF,OACAl0G,OACAA,EACA2/C,EACA77B,EACAg/F,OACA9iH,OACAA,OACAA,EACA8f,GAKJghB,EAAY6c,gBAAiB,EAC7Bl9B,EAAKsgB,eAAeD,GAMhB,OACJrgB,EACAihG,EACAp3F,EACAijC,EACA6jB,GAEA,QAAkCpxE,IAA9B0hH,EAAYhnC,cACZ,OAGJ,MAAMt6E,EAAMqgB,EAAKvU,QAAQ9L,IAEnB4iH,OACyBhjH,IAA3BsqB,EAAU65B,aACJ,EAAAo+D,4BACI,EAAAr3F,iBAAiBZ,EAAU65B,aAAc/jD,GACzCkqB,QAEJtqB,EAEJijH,EAAe34F,EACf+qF,EAAe4N,EAAaj/D,SAClC,IAAIC,EAAUg/D,EAAah/D,QAE3B,IAAK,IAAI7oD,EAAI,EAAGA,EAAImyD,EAAUx1C,QAAS3c,EAAG,CACtC,MAAMqI,EAAI8pD,EAAU4E,KAAK/2D,GAAKg2E,EACxB1tE,EAAI6pD,EAAU6E,KAAKh3D,GACnBwI,EAAI2pD,EAAUqtB,KAAKx/E,GAEzB,EAAAkP,OAAOo3G,EAAY7mC,MAAMv7E,OAASlE,GAClC,IAAI84G,EAAmB8O,EACvB,MAAMx/F,EAAek+F,EAAYhnC,cAAcgnC,EAAY7mC,MAAMz/E,KAAO,GAClE0kB,OACuB9f,IAAzB0hH,EAAYhjF,SAAyBgjF,EAAYhjF,SAAStjC,QAAK4E,EAC7D8jB,EAAY,EAAA2uD,aAAa3yD,GACzBqE,OAC+BnkB,IAAjC0hH,EAAYwB,iBAAiC,EAAIxB,EAAYwB,iBAAiB9nH,QAChD4E,IAA9B0hH,EAAYx6C,eAA+Bw6C,EAAYx6C,cAAc9rE,IAAM,IAC3E,EAAAkP,OAAOo3G,EAAYx6C,cAAc5nE,OAASlE,GAC1C84G,EAAmBwN,EAAYhnC,cAAcgnC,EAAYx6C,cAAc9rE,UAEtD4E,IAAjBq1G,IAMApxD,OAC6BjkD,IAAzBijH,EAAah/D,QAAwBiwD,EAAmB+O,EAAah/D,QAEzEiwD,OAAmBl0G,GAGvB,MAAM8gC,EAAc9iC,KAAK+kH,uBACrBtiG,EACA+C,EACA8G,EACA4pF,EACAmB,EACApxD,EACA,EACAngC,EACArgB,EACAC,EACAE,EACAugB,EACArE,GAGJW,EAAKsgB,eAAeD,IAYpB,uBACJrgB,EACA+C,EACA8G,EACA4pF,EACAmB,EACApxD,EACAtE,EACA77B,EACArgB,EACAC,EACAE,EACAugB,EACArE,GAEA,MAAM6D,OAAkC3jB,IAAvBsqB,EAAU3G,SAAyB2G,EAAU3G,SAAW,EACnE4pC,EAAYnuD,MAAMC,QAAQoE,GAAMA,EAAwB,IAAIrG,EAAMuG,QAAQF,EAAGC,EAAGE,GAKhFxD,EAAMpC,KAAKkO,QAAQ9L,IACnB4jB,OACqBhkB,IAAvBsqB,EAAUtG,SACJ,EAAAkH,iBAAiBZ,EAAUtG,SAAU5jB,GACrCkqB,EAAUtG,SACdC,OACoBjkB,IAAtBsqB,EAAUrG,QACJ,EAAAiH,iBAAiBZ,EAAUrG,QAAS7jB,GACpCkqB,EAAUrG,QACdL,EAAU,EAAAsH,iBAAiBZ,EAAU1G,QAASxjB,GAC9CyjB,EAAU,EAAAqH,iBAAiBZ,EAAUzG,QAASzjB,GAE9C0gC,EAA2B,IAAI,EAAAvd,YACjC,EAAA62D,0BAA0Bn8E,SAASo8E,QAAQ72D,GAC3C+pC,EACA9sC,EAAKu5D,eAAeM,eAAehwD,GACnC7J,EAAKu5D,eAAeO,eAAejwD,GACnC,EAAAY,iBAAiBvH,EAAUvjB,QACfJ,IAAZ4jB,EAAwBA,EAAU,OACtB5jB,IAAZ6jB,EAAwBA,EAAU,EAClCC,EACAwG,EAAUvG,MACVC,EACAC,EACAxD,EAAKoB,OACLsC,GAiBJ,GAdA2c,EAAY/b,YAA0C,IAA7BuF,EAAU44B,eACnCpiB,EAAY9b,cAA8C,IAA/BsF,EAAU84B,iBACrCtiB,EAAYwiB,aAAwC,IAA1Bh5B,EAAUg5B,YACpCxiB,EAAYhhB,SAAWA,OAGE9f,IAArBk0G,QAAmDl0G,IAAjBq1G,EAClCnB,EAAmB,QACSl0G,IAArBk0G,QAAmDl0G,IAAjBq1G,GACzC7qG,EAAOuJ,KACH,kFAIiB/T,IAArBk0G,EAAgC,CAChC,MAAMh2D,GAA8C,IAA7B5zB,EAAU4zB,eAC3BN,GAA8C,IAA7BtzB,EAAUszB,eAC3BS,KAAsE,IAAxC/zB,EAAU+zB,2BACxC8E,OAC2BnjD,IAA7BsqB,EAAU64B,eACJriB,EAAYoiB,gBACiB,IAA7B54B,EAAU64B,eACdE,OAC6BrjD,IAA/BsqB,EAAU+4B,iBACJviB,EAAYuvE,mBACmB,IAA/B/lF,EAAU+4B,iBAEd8/D,EAAe74F,EAAUi6B,UACzB,EAAAr5B,iBAAiBZ,EAAUi6B,UAAWnkD,GACtC,KACAmkD,EACe,OAAjB4+D,EAAwB,EAAAvqD,WAAW36D,SAAS89G,SAASoH,QAAgBnjH,EAEzE8gC,EAAY1d,QAAU,CAClBkH,YACA4pF,mBACAmB,eACApxD,UACAtE,mBACA7e,cACAod,iBACAN,iBACAS,4BACAt5B,WAAYo+B,EACZn+B,aAAcq+B,EACdv/B,YACA0gC,eAAgBl6B,EAAUk6B,eAC1BD,YACA/+B,iBAAkB8E,EAAU9E,iBAC5BG,iBAAkB2E,EAAU3E,iBAC5BF,iBAAkB6E,EAAU7E,iBAC5BG,iBAAkB0E,EAAU1E,kBAEhCkb,EAAY8hF,8CAIqB5iH,IAA7B8gC,EAAY/iB,eACZ+iB,EAAY/iB,aAAeuM,EAAU7E,uBAGRzlB,IAA7B8gC,EAAY9iB,eACZ8iB,EAAY9iB,aAAesM,EAAU1E,kBAW7C,OAPAkb,EAAYzc,mBACoBrkB,IAA5BsqB,EAAUjG,cACJiG,EAAUjG,cACV,EAAAknB,4BAGVzK,EAAYiK,KAAOzgB,EAAUygB,KACtBjK,GAEf,OAnkBmB,EAAAwgF,sBAA8C,IAAInhH,IAClD,EAAAqhH,iBAAyC,IAAIrhH,IAkkBhE,GArkBA,GAAa,EAAAq/D,c,kHCjDb,aAWMh1D,EAJN,KAIeC,cAAcxM,SAASvB,OAAO,YAK7C,MAAM0mH,EAQF,kBAAkBC,GACd,IAAIC,EAC0B,iBAAnBD,EAAU1nH,MACjB0nH,EAAU1nH,KAAK2D,OAAS,SACAU,IAAvBqjH,EAAUE,UAA0BnkH,MAAMC,QAAQgkH,EAAUE,kBACpCvjH,IAAxBqjH,EAAU7/D,WACiB,QAAxB6/D,EAAU7/D,WACc,OAAxB6/D,EAAU7/D,WACc,WAAxB6/D,EAAU7/D,kBACSxjD,IAAtBqjH,EAAUj/F,SAAsD,kBAAtBi/F,EAAUj/F,gBAC7BpkB,IAAvBqjH,EAAU1/F,UAAwD,iBAAvB0/F,EAAU1/F,iBAC1B3jB,IAA3BqjH,EAAUb,cAAgE,iBAA3Ba,EAAUb,qBAC9BxiH,IAA3BqjH,EAAUZ,cAAgE,iBAA3BY,EAAUZ,qBAC9BziH,IAA3BqjH,EAAUX,cAAgE,iBAA3BW,EAAUX,qBAC9B1iH,IAA3BqjH,EAAUV,cAAgE,iBAA3BU,EAAUV,cAE9D,GAAIW,QAA+BtjH,IAAvBqjH,EAAUE,SAAwB,CAC1C,MAAMA,EAAWF,EAAUE,SAC3B,IAAK,MAAMl4B,KAAOk4B,EACd,GAAmB,iBAARl4B,EAAkB,CACzBi4B,GAAO,EACP,OAKZ,OAAOA,EAkCX,MAAMD,GAWF,OAVArlH,KAAKrC,KAAO0nH,EAAU1nH,KACtBqC,KAAKulH,SAAWF,EAAUE,SAC1BvlH,KAAKskH,SAAWe,EAAUf,SAC1BtkH,KAAKomB,QAAUi/F,EAAUj/F,QACzBpmB,KAAK2lB,SAAW0/F,EAAU1/F,SAC1B3lB,KAAKwkH,aAAea,EAAUb,aAC9BxkH,KAAKykH,aAAeY,EAAUZ,aAC9BzkH,KAAK0kH,aAAeW,EAAUX,aAC9B1kH,KAAK2kH,aAAeU,EAAUV,aAEtBU,EAAU7/D,WACd,IAAK,MACDxlD,KAAKwlD,UAAY,EAAA6yC,aAAamtB,KAC9B,MACJ,IAAK,KACDxlH,KAAKwlD,UAAY,EAAA6yC,aAAaotB,KAC9B,MACJ,IAAK,SACDzlH,KAAKwlD,UAAY,EAAA6yC,aAAaqtB,aAqB9C,MAAaC,EAuBT,YAAqBhoH,EAAuBioH,GAAvB,KAAAjoH,OAAuB,KAAAioH,oBAnB3B,KAAAC,QAA2B,IAAIzkH,MAQ/B,KAAA0kH,QAA+B,IAAI3jH,IAC5C,KAAA4jH,aAAc,EACd,KAAAC,gBAAkChkH,EAgB1C,gBACI,OAAOhC,KAAK+lH,YAQhB,eACI,OAA2B,IAApB/lH,KAAKgmH,WAUhB,SAAS//D,GACL,MAAMggE,EAA+BjmH,KAAK8lH,QAAQ7nH,IAAIgoD,GACtD,QAAiBjkD,IAAbikH,EAAwB,CACxB,GAAIA,EAAWjmH,KAAK6lH,QAAQvkH,OACxB,OAAOtB,KAAK6lH,QAAQI,GAEpB,MAAM,IAAIxiH,MAAM,8CAc5B,WAAWyiH,GACP,QAAwBlkH,IAApBhC,KAAKgmH,WAEL,OAAO,EAGXhmH,KAAKgmH,YAAa,EAElB,MAAMz9C,QAAiBD,MAAM49C,GAE7B,IAAK39C,EAASq7C,GACV,MAAM,IAAIngH,MACN,kCAAkCyiH,KAAiB,IAAI39C,EAASs7C,cAIxE,MAAMsC,QAAsB59C,EAAS3mE,OACrC,QAAqBI,IAAjBmkH,EAEA,OADA35G,EAAO6nD,KAAK,6BAA6B6xD,MAClC,EAGXlmH,KAAK6gH,eAEL,IAGI,GAFAr0G,EAAO2iC,MAAM,4BAA4B+2E,iBAA2BlmH,KAAKrC,cAE5CqE,IAAzBmkH,EAAaN,SAAyBzkH,MAAMC,QAAQ8kH,EAAaN,SACjE,IAAK,MAAMO,KAAcD,EAAaN,QAClC,GAAIT,EAAciB,WAAWD,GAAa,CACtC,MAAME,EAAc,IAAIlB,EACxBkB,EAAYpR,MAAMkR,GAClB,MAAMH,EAAWjmH,KAAK6lH,QAAQ3/G,KAAKogH,GAAe,EAElD,GAAKtmH,KAAK4lH,kBAWN,QAC6B5jH,IAAzBskH,EAAYf,UACZe,EAAYf,SAASjkH,OAAS,EAG9B,IAAK,MAAMilH,KAAWD,EAAYf,SAC9BvlH,KAAK8lH,QAAQ9+G,IAAIu/G,EAASN,QAG9Bz5G,EAAO2iC,MACH,qCAAqC+2E,QACjC,sCAAsCz+G,KAAKC,UACvC0+G,iBArBSpkH,IAArBskH,EAAY3oH,KACZ6O,EAAOuJ,KACH,qCAAqCmwG,QACjC,2BAA2BE,MAGnCpmH,KAAK8lH,QAAQ9+G,IAAIs/G,EAAY3oH,KAAMsoH,QAqB3Cz5G,EAAOuJ,KACH,qCAAqCmwG,QAAkBz+G,KAAKC,UACxD0+G,MAMpBpmH,KAAKgmH,YAAa,EAClBhmH,KAAKkjB,kBACP,MAAOw+F,GAIL,OAHAl1G,EAAO+R,MAAM,kCAAoC,IAAI2nG,QAAkBxE,KACvE1hH,KAAKgmH,YAAa,EAClBhmH,KAAKkjB,mBACE,EAEX,OAAO,EAGH,eACJljB,KAAK+lH,aAAc,EAGf,kBACJ/lH,KAAK+lH,aAAc,GA7J3B,aAqKA,wBAQI,YAAqB73G,GAAA,KAAAA,UAPb,KAAA63G,aAAc,EACd,KAAAS,YAAqC,IAAIrkH,IAsBjD,oBAAoBu8D,GA+ChB,OA9CiB,IAAIzmB,QAAcqzB,IAI/B,GAHAtrE,KAAKgmC,aAGmBhkC,IAApB08D,EAAMyK,UAAyB,CAC/BnpE,KAAK6gH,eAGL,MAAM4F,EAAwC,IAAIrlH,MAElDs9D,EAAMyK,UAAU9oE,QAASqmH,IACrB,QACoB1kH,IAAhB0kH,QACqB1kH,IAArB0kH,EAAY/oH,MACgB,iBAArB+oH,EAAY/oH,KACrB,CACE,MAAMqoD,EAAW,IAAI2/D,EACjBe,EAAY/oH,MACsB,IAAlC+oH,EAAYd,wBAEQ5jH,IAApB0kH,EAAYjjE,KAAgD,iBAApBijE,EAAYjjE,KACpDzjD,KAAK2mH,SAAS3gE,GACdygE,EAAavgH,KAAK8/C,EAAS7zB,KAAKu0F,EAAYjjE,OAE5Cj3C,EAAO+R,MAAM,0CAA0CmoG,UAG3Dl6G,EAAO+R,MAAM,2CAA2CmoG,OAI5DD,EAAanlH,OAAS,EACtB22C,QAAQC,IAAIuuE,GAAcG,QAAQ,KAC9B5mH,KAAK6mH,gBACLv7C,OAGJtrE,KAAK6mH,gBACLv7C,UAGJtrE,KAAK6mH,gBACLv7C,MAUZ,QACItrE,KAAKwmH,YAAc,IAAIrkH,IAM3B,gBACI,OAAOnC,KAAKwmH,YAUhB,SAASxgE,GACLhmD,KAAKwmH,YAAYx/G,IAAIg/C,EAASroD,KAAMqoD,GAWxC,YAAYqxD,GACR,YAAwBr1G,IAAjBq1G,OAA6Br1G,EAAYhC,KAAKwmH,YAAYvoH,IAAIo5G,GAQzE,sBACI,OAAQr3G,KAAK+lH,YAGT,eACJ/lH,KAAK+lH,aAAc,EAGf,gBACJ/lH,KAAK+lH,aAAc,K,2GC7Z3B,aAEA,OAOA,SACA,OASA,QACA,QACA,QACA,QAwBA,MAAar/C,UAA4B,EAAAmR,WAUrC,aAAY,KACRl6E,EAAO,QAAO,aACd4oE,EAAY,aACZ0R,EAAY,aACZC,EAAY,gBACZC,EAAe,gBACfC,EAAe,mBACfM,GAAqB,EAAE,oBACvB/R,EAAsB,EAAC,WACvBmgD,GAAa,IAEb9jH,MAAM,CACFrF,OACA4oE,eACA0R,eACAC,eACAC,kBACAC,kBACAM,uBA3BA,KAAAuZ,eAA+B,EAAA80B,kBAC/B,KAAAC,cAAgB5nH,EAAMkJ,UAAUC,SAAS,EAAAwxB,kBAAkBC,kBA6B/Dh6B,KAAKinH,sBAAwBtgD,EAC7B3mE,KAAKknH,aAAeJ,EACpB9mH,KAAK83E,WAAY,EAIrB,UACQ93E,KAAKmnH,mBACLnnH,KAAKmnH,iBAAiB18G,SAASg7B,iBACxBzlC,KAAKmnH,kBAEZnnH,KAAKonH,mBACLpnH,KAAKonH,iBAAiB38G,SAASg7B,iBACxBzlC,KAAKonH,kBAEZpnH,KAAKqnH,4BACErnH,KAAKqnH,oBAIpB,oBAAoBt6E,GAChB,IAAK/sC,KAAKqnH,oBACN,OAEJ,MAAMjlH,EAAM,IAAI,EAAA0/D,OAAO,CACnBwlD,cAAe,UACfC,OAAQ,QACRx6E,SAEEwtC,EAAav6E,KAAKqnH,oBAAoBG,sBAAsBplH,GAElE,GAA0B,IAAtBm4E,EAAWj5E,OACX,OAEJ,MAAMgrB,EAAYiuD,EAAW,GACvB9vE,EAAW,EAAAizE,eAAe,CAAEpxD,YAAWlqB,IAAKpC,KAAKkO,QAAQ9L,MAC/D,OAAKqI,EAGE,CAAEA,WAAU6hB,kBAHnB,EAOJ,YAAYwsD,EAAqBj3E,EAA2ByhB,GACxDtjB,KAAKylC,eAEYzjC,IAAb82E,IACA94E,KAAKqnH,oBAAsB,IAAI,EAAAI,kBAAkB3uC,EAAUj3E,GAE3D7B,KAAKmnH,iBAAmBnnH,KAAK0nH,oBAAoB,cACjD1nH,KAAKonH,iBAAmBpnH,KAAK0nH,oBAAoB,eAGrD1nH,KAAKkO,QAAQy/D,eAAe3tE,MAIhC,SAAS0+D,EAAcp7C,GACnB,MAAMw1D,OACqB92E,IAAtBhC,KAAKumE,cAA8B7H,EAAMgL,QAAUhL,EAAMgL,OAAO1pE,KAAKumE,eACtE,GAEJvmE,KAAK2nH,YAAY7uC,EAAUpa,EAAM78D,YAAayhB,GAIlD,WAAW1M,EAAmBgN,GAC1B,GAAIhN,IAAcgN,EAAQhI,OAASgI,EAAQhI,MAAQ,EAC/C,OAAO,EAGX,MAAM,MAAEY,EAAK,MAAEC,GAAUzc,KAAKiyF,eAAe77D,UAAUxS,GAEvD,OAAOpH,EAAQxc,KAAKgnH,eAAiBvqG,GAASzc,KAAKgnH,cAIvD,gBAAgBpwG,EAAmBgN,GAC/B,GAAIhN,GAAagN,EAAQhI,MACrB,OAAO,EAGX,MAAM,MAAEY,EAAK,MAAEC,GAAUzc,KAAKiyF,eAAe77D,UAAUxS,GAEvD,OAAOpH,EAAQxc,KAAKgnH,eAAiBvqG,GAASzc,KAAKgnH,cAIvD,kBACI,OAAOhnH,KAAKiyF,eAIhB,QAAQruE,GACJ,MAAMnB,EAAO,IAAI,EAAAsrE,KAAK/tF,KAAM4jB,GAI5B,OAFA5jB,KAAK4nH,mBAAmBnlG,GAEjBA,EAGX,0BACI,OAAOziB,KAAKinH,sBAGhB,wBAAwBtgD,GACpB3mE,KAAKinH,sBAAwBtgD,EAGzB,cAAcx+D,EAAkBqB,EAAmBE,GACvD,MAAMm+G,EAAOr+G,EAAErB,SACT2/G,EAAOp+G,EAAEvB,SAEf,IAAI4/G,EAAOv+G,EAAEpB,UACT4/G,EAAOt+G,EAAEtB,UAEU,KAAnBiB,KAAK2S,IAAI6rG,KACTE,EAAOC,GAEY,KAAnB3+G,KAAK2S,IAAI8rG,KACTE,EAAOD,GAEX,MACM54B,EAAW64B,EAAOD,EAClBjnE,GAAS34C,EAAW0/G,IAFTC,EAAOD,GAIxB,OAAO,IAAI,EAAA3/G,eAAeC,EAAU4/G,EAAO54B,EAAWruC,EAAO,GAGzD,mBAAmBr+B,GACvB,MAAM,MAAEjG,EAAK,MAAEC,GAAUgG,EAAKyT,OAExB+xF,EAAczrG,EAAQ,GAAKC,GAAS,EACpCyrG,EAAiBD,EAAcjoH,KAAKmnH,iBAAmBnnH,KAAKonH,iBAClE,QAAuBplH,IAAnBkmH,EAEA,YADAzlG,EAAKuhB,kBAAiB,GAI1B,MAAMmkF,EAAgBnoH,KAAKiyF,eAAe9iF,WACpCi5G,EAAgBpoH,KAAKmP,WAErBk5G,EAASroH,KAAKgnH,cACdsB,EAAUL,EAAcI,GAAUA,EAElCrrG,EAAMhd,KAAKiyF,eAAet8D,qBAAqBU,YAAY5T,EAAKmB,SAEhE2kG,EAAMJ,EAAchyG,eAAe,IAAI/W,EAAMuG,QAAQqX,EAAIpT,IAAInE,EAAGuX,EAAIpT,IAAIlE,EAAG,IAC3E8iH,EAAML,EAAchyG,eAAe,IAAI/W,EAAMuG,QAAQqX,EAAIlT,IAAIrE,EAAGuX,EAAIpT,IAAIlE,EAAG,IAC3E+iH,EAAMN,EAAchyG,eAAe,IAAI/W,EAAMuG,QAAQqX,EAAIlT,IAAIrE,EAAGuX,EAAIlT,IAAIpE,EAAG,IAC3EgjH,EAAMP,EAAchyG,eAAe,IAAI/W,EAAMuG,QAAQqX,EAAIpT,IAAInE,EAAGuX,EAAIlT,IAAIpE,EAAG,IAEjF,IAAI4L,EACAq3G,GAAmB,EAGvB,GAA2B,IAAvBlmG,EAAKmB,QAAQhI,MAAa,CAC1B,MAAMgtG,EAA2B,IAAd5rG,EAAIpT,IAAInE,EAErBojH,EAAQD,EAAa5rG,EAAIlT,IAAIrE,EAAIuX,EAAIpT,IAAInE,EACzCqjH,GAAS9rG,EAAIlT,IAAIpE,EAAIsX,EAAIpT,IAAIlE,GAAK,EAClCqjH,EAAQZ,EAAchyG,eAAe,IAAI/W,EAAMuG,QAAQkjH,EAAOC,EAAO,IAGrEE,EAAMJ,EAAaL,EAAMC,EAE/Bl3G,EAAS22G,EACHW,EACI,CAACG,EAAON,EAAKO,EAAKR,GAClB,CAACO,EAAOR,EAAKS,EAAKN,GACtBE,EACA,CAACG,EAAOP,EAAKQ,EAAKP,GAClB,CAACM,EAAOL,EAAKM,EAAKT,GAExBI,GAAmB,MAChB,CAEHr3G,EAAS22G,EAAc,CAACM,EAAKC,EAAKC,EAAKC,GAAO,CAACH,EAAKG,EAAKD,EAAKD,GAE9D,MAAMS,EAAO33G,EAAOvL,IAAI7G,GAAKA,EAAEiJ,UACzB+gH,EAAO7/G,KAAKS,OAAOm/G,GACnBE,EAAO9/G,KAAKO,OAAOq/G,GAGzB,GADuBhB,EAAciB,EAAOZ,EAAUa,EAAOb,EAEzD,OAMJ,GAFAK,EADwBV,EAAckB,EAAOb,EAAUY,EAAOZ,EAG1DK,EAAkB,CAClB,MAAMS,EAAUH,EAAKt2F,QAAQs1F,EAAciB,EAAOC,GAClD,GAAgB,IAAZC,EACA,IAAK,IAAIhsH,EAAI,EAAGA,EAAIgsH,EAAShsH,IACzBkU,EAAOpL,KAAKoL,EAAOm2F,UAMnC,GAAIkhB,EAAkB,CAClB,MAAM3R,GAAWh6F,EAAIpT,IAAInE,EAAIuX,EAAIlT,IAAIrE,GAAK,EACpCwxG,GAAWj6F,EAAIpT,IAAIlE,EAAIsX,EAAIlT,IAAIpE,GAAK,EACpCuX,EAASkrG,EAAchyG,eAAe,IAAI/W,EAAMuG,QAAQqxG,EAASC,EAAS,IAEhF,EAAAnoB,wBAAwByC,eAAejgF,EAAQ2L,GAO/C,MAAMzT,EAAI8H,EAAO,GACX5H,EAAI4H,EAAO,GACX7T,EAAI6T,EAAO,GACX5T,EAAI4T,EAAO,GAEX+3G,EAAWhgH,KAAK2S,IAAItS,EAAEvB,WAAakgH,EACnCiB,EAAWjgH,KAAK2S,IAAIte,EAAEyK,WAAakgH,EAEnCkB,EAAWF,EACXrpH,KAAKwpH,cAAclB,EAAS5+G,EAAGjM,GAC/BuC,KAAKwpH,cAAclB,EAAS9+G,EAAGE,GAE/B+/G,EAASH,EACTtpH,KAAKwpH,cAAclB,EAAS5qH,EAAGD,GAC/BuC,KAAKwpH,cAAclB,EAAS9+G,EAAG9L,GAErC4T,EAAO60B,OAAOkjF,EAAW,EAAI,EAAG,EAAGE,GAEnC,MAAM3tG,EAAQ6G,EAAKmB,QAAQhI,MAAQ5b,KAAK04E,mBAAqB14E,KAAKinH,sBAG5DnnF,EAAO,KADQ,GAAKz2B,KAAKS,IAAI,EAAG8R,IAGhC8tG,EAAgBrgH,KAAKmtB,OAAO+yF,EAASnhH,UAAY,KAAO03B,GACxD6pF,EAActgH,KAAKuW,MAAM6pG,EAAOrhH,UAAY,KAAO03B,GAEzD,IAAK,IAAI1iC,EAAIssH,EAAgB,EAAGtsH,EAAIusH,EAAavsH,IAC7CkU,EAAOpL,KAAK,IAAI,EAAAgC,eAAeogH,EAASlrH,EAAI0iC,EAAO,IAAK,IAG5DxuB,EAAOpL,KAAKujH,GACRH,GACAh4G,EAAOpL,KAAKxI,GAIpB,MAAMmwB,EAAI,IAAIzuB,EAAMgb,SAEpB,IAAK,MAAM5I,KAASF,EAAQ,CACxB,MAAMu/E,EAAYu3B,EAAc33G,aAAae,EAAO,IAAIpS,EAAMuG,SAC9DkoB,EAAExT,SAASnU,KAAK2qF,EAAU/9E,IAAI2P,EAAKxF,SAGvC,IAAK,IAAI7f,EAAI,EAAGA,EAAIkU,EAAOhQ,OAAS,EAAGlE,IACnCywB,EAAEvT,MAAMpU,KAAK+hH,EAAc,IAAI7oH,EAAMwqH,MAAM,EAAGxsH,EAAGA,EAAI,GAAK,IAAIgC,EAAMwqH,MAAM,EAAGxsH,EAAI,EAAGA,IAGxF,MAAM8c,EAAW,IAAI9a,EAAMob,eAC3BN,EAAS2vG,aAAah8F,GACtBA,EAAE4X,UAEF,MAAM/jB,EAAO,IAAItiB,EAAM40B,KAAK9Z,EAAUguG,EAAez9G,UAMrD,GALAiX,EAAKI,SAAW,CACZ6e,WAAY3gC,KAAKrC,KACjBimB,QAASnB,EAAKmB,SAGd5jB,KAAKknH,aAAc,CACnB,MAAMj8F,EAAQ5hB,KAAKggC,MAA2D,SAArDhgC,KAAK2S,IAAI3S,KAAKsH,IAAI,GAAK8R,EAAKmB,QAAQO,gBAC7DzC,EAAKjX,SAAW,IAAIrL,EAAM+Y,kBAAkB,CAAE8S,QAAOvgB,aAAa,EAAMwgB,QAAS,KAEjFzI,EAAKme,QAAQ16B,KACT,IAAI9G,EAAM40B,KAAK9Z,EAAU,IAAI9a,EAAM+Y,kBAAkB,CAAE8S,QAAO2uB,WAAW,MAIjF,EAAAhN,iBAAiBluC,OAAOgjB,EAAM,CAC1B4K,UAAW47F,EAAe57F,UAC1BygB,KAAM,CAACk7E,EAAc,EAAAlwB,qBAAqB+xB,MAAQ,EAAA/xB,qBAAqBvU,cAG3E/gE,EAAKme,QAAQ16B,KAAKwb,IA3T1B,yB,qJC7CA,aACA,OAEMlV,EAAS,EAAAC,cAAcxM,SAASvB,OAAO,qBAU7C,IAAYqrH,EALC,EAAAC,uBAAyB,EAKtC,SAAYD,GACR,6BACA,6BACA,6BACA,6BACA,6BACA,6BANJ,CAAYA,EAAA,EAAAA,mBAAA,EAAAA,iBAAgB,KAY5B,0BAQI,YAAYjhD,GACR,MAAMxuD,EAAQta,KAAKiqH,uBAAuBnhD,GAC1C9oE,KAAKkqH,cACSloH,IAAVsY,GAAsB,IAAI,EAAA6vG,mBAAoBh4F,KAAK7X,GAAS,IAAI,EAAA8vG,YAMxE,UACIpqH,KAAKkqH,SAASzkF,UAMlB,cACI,OAAOzlC,KAAKkqH,SAQhB,cAAcphD,GACV,MAAMxuD,EAAQta,KAAKiqH,uBAAuBnhD,QAC5B9mE,IAAVsY,IAGJta,KAAKkqH,UAAW,IAAI,EAAAC,mBAAoBh4F,KAAK7X,IAGzC,uBAAuBwuD,GAC3B,MAAMxuD,EAAmC,MACrCtY,OACAA,OACAA,OACAA,OACAA,OACAA,GAEJ,IAAK,IAAI5E,EAAI,EAAGA,EAAI,EAAA4sH,yBAA0B5sH,EAAG,CAC7C,MAAMitH,EAA4BvhD,EAAYihD,EAAiB3sH,IAC/D,QAAa4E,IAATqoH,EAEA,YADA79G,EAAO+R,MAAM,SAASwrG,EAAiB3sH,wBAG3Ckd,EAAMld,GAAKitH,EAGf,OAAO/vG,K,0ICrFf,aACA,QAcA,OAYA,SAEA,MAEa,EAAAgwG,qCAAuC,EAgEpD,MAAa3hD,EAyBT,kBACIjK,EACAzoD,GAGA,GADAA,EAAUA,GAAW,GACA,iBAAVyoD,EAAoB,CAC3B,MAAM6D,EAActsD,EAAQssD,YACtBgoD,OAA2BvoH,IAAhBugE,EAA4BA,EAAYG,WAAWhE,GAASA,EACvE6J,QAAiBD,MAAMiiD,EAAU,CAAE/oB,OAAQvrF,EAAQurF,SACzD,IAAKj5B,EAASq7C,GACV,MAAM,IAAIngH,MAAM,wCAAwC8kE,EAASs7C,eAErEnlD,QAAe6J,EAAS3mE,QAClB6hD,IAAM,EAAA+mE,oBAAoB,EAAAC,gBAAiBF,GACjD7rD,EAAQ1+D,KAAK0qH,YAAYhsD,EAAOzoD,aACXjU,IAAd08D,EAAMjb,KAEbib,EAAMjb,IAAM,EAAAgnE,gBACZ/rD,EAAQ1+D,KAAK0qH,YAAYhsD,EAAOzoD,IAEhCyoD,EAAQ1+D,KAAK2qH,iBAAiBjsD,GAGlC,GAAIA,QACA,MAAM,IAAIj7D,MAAM,uDAGpBklE,EAAYiiD,sBAAsBlsD,GAElC,MAAMmsD,EAAqB,EAAAj8C,eAAwB34D,EAAQ40G,oBAAoB,GAE/E,GADAnsD,QAAciK,EAAYmiD,kBAAkBpsD,EAAOzoD,GAC/C40G,EAAoB,CACpB,MAAME,EAAgB,IAAI,EAAAC,cACtB/0G,EAAQzJ,QAAU2qF,QAClB,yBAAyBz4B,EAAMjb,QAEnCklB,EAAYsiD,uBAAuBvsD,EAAOqsD,GAE9C,OAAOrsD,EAQX,qBAAqBA,GACjB,YAAyB18D,IAAlB08D,EAAMwsD,QAajB,uBAAuBX,GACnB,OAAO5hD,EAAYx2C,KAAKo4F,GAYpB,mBAAmB7rD,EAA0BzoD,GAIjD,QAAkBjU,KADlB08D,EAAQiK,EAAYgiD,iBAAiBjsD,IAC3Bjb,IACN,OAAOib,EAGX,MAAMysD,EAAmB,EAAAC,oBACrBn1G,aAAO,EAAPA,EAASssD,YACT,IAAI,EAAA8oD,oBAAoB3sD,EAAMjb,MAG5B6nE,OAA8BtpH,IAAZiU,MAA0D,IAA/BA,EAAQs1G,oBAkB3D,OAjBI7sD,EAAMwsD,SAAWI,IACjB5sD,EAAMwsD,SAAW9pH,MAAMC,QAAQq9D,EAAMwsD,SAAWxsD,EAAMwsD,QAAU,CAACxsD,EAAMwsD,UAAUnlH,IAC7EylH,GAC6B,iBAAdA,EACAL,EAAiBzoD,WAAW8oD,QAEbxpH,IAAlBwpH,EAAU/nE,IACH+nE,GAEPA,EAAU/nE,IAAMib,EAAMjb,IACfzjD,KAAK0qH,YAAYc,EAAWv1G,MAOlD0yD,EAAYgiD,iBAAiBjsD,UAIG18D,IAAZiU,MAA2D,IAAhCA,EAAQw1G,uBAExD9iD,EAAY+iD,iBAAiBhtD,EAAOysD,GAGjCzsD,GARIA,EAWP,6BAA6BA,GACjC,QAAqB18D,IAAjB08D,EAAMgL,OACN,IAAK,MAAMnD,KAAgB7H,EAAMgL,OAC7B,GAAKhL,EAAMgL,OAAOzqE,eAAesnE,GAGjC,IAAK,MAAMxgD,KAAS24C,EAAMgL,OAAOnD,GACpBxgD,EAAcuG,UAsB/B,8BAA8BoyC,EAAcitD,GAChD,QAA0B3pH,IAAtB08D,EAAM78D,YAA2B,CACjC8pH,EAAcC,SAAS,eAKvB,IAAK,MAAMC,KAAkBntD,EAAM78D,YAAa,CAC5C,IAAK68D,EAAM78D,YAAY5C,eAAe4sH,GAClC,SAGJ,MAAM7rF,EAAM0+B,EAAM78D,YAAYgqH,GAC9B,GAAI,EAAAC,2BAA2B9rF,GAAM,CACjC2rF,EAAcC,SAASC,GACvB,MAAME,EAAcpjD,EAAYqjD,aAC5BhsF,EACA0+B,EAAM78D,YACN8pH,GAEJA,EAAc5vC,WACM/5E,IAAhB+pH,GACAJ,EAAcC,SAASC,GACvBF,EAAc51G,KAAK,wCACnB41G,EAAc5vC,aACPrd,EAAM78D,YAAYgqH,IAEzBntD,EAAM78D,YAAYgqH,GAAkBE,GAIhDJ,EAAc5vC,MAElB,QAAqB/5E,IAAjB08D,EAAMgL,OACN,IAAK,MAAMnD,KAAgB7H,EAAMgL,OACxBhL,EAAMgL,OAAOzqE,eAAesnE,KAGjColD,EAAcC,SAAS,UACvBD,EAAcC,SAASrlD,GAEvB7H,EAAMgL,OAAOnD,GAAgBoC,EAAYsjD,gBACrCvtD,EAAMgL,OAAOnD,GACb7H,EAAM78D,YACN8pH,GAEJA,EAAc5vC,MACd4vC,EAAc5vC,OAGtB,OAAOrd,EAMH,uBACJoa,EACAj3E,EACA8pH,GAEA,MAAMxlH,EAA2B,GAEjC,IAAK,IAAIuU,EAAQ,EAAGA,EAAQo+D,EAASx3E,SAAUoZ,EAAO,CAClD,MAAMwxG,EAAepzC,EAASp+D,GAC9BixG,EAAcQ,UAAUzxG,GACxB,MAAM0xG,EAAgBzjD,EAAYqjD,aAC9BE,EACArqH,EACA8pH,QAEkB3pH,IAAlBoqH,EACAjmH,EAAOD,KAAKkmH,GAEZT,EAAc51G,KAAK,0BAEvB41G,EAAc5vC,MAElB,OAAO51E,EAMH,oBACJ4f,EACAlkB,EACA8pH,GAEA,GAAI,EAAAU,oBAAoBtmG,GAAQ,CAG5B,MAAMia,EAAMn+B,GAAeA,EAAYkkB,EAAM,IAE7C,IAAKia,EAED,YADA2rF,EAAc51G,KAAK,sBAAsBgQ,EAAM,mBAGnD,IAAK,EAAA+lG,2BAA2B9rF,GAE5B,YADA2rF,EAAc51G,KAAK,sBAAsBgQ,EAAM,mCAKnDA,EAAQ,EAAAumG,UAAUtsF,GAItB,GAFAja,EAAQA,EAEJ3kB,MAAMC,QAAQ0kB,EAAMwmG,MAAO,CAC3BZ,EAAcC,SAAS,QACvB,MAAMY,EAAexsH,KAAKysH,4BACtB1mG,EAAMwmG,KACN1qH,EACA8pH,GAGJ,GADAA,EAAc5vC,WACO/5E,IAAjBwqH,EACA,OAEJzmG,EAAMwmG,KAAOC,EAGjB,QAAmBxqH,IAAf+jB,EAAMk4D,KAAoB,CAC1B,MAAMA,EAAOl4D,EAAMk4D,KAEnB0tC,EAAcC,SAAS,QACvB,IAAK,MAAMh5F,KAAQqrD,EAAM,CACrB,IAAKA,EAAKh/E,eAAe2zB,GACrB,SAGJ,MAAMv0B,EAAQ4/E,EAAKrrD,GAEnB,IAAKxxB,MAAMC,QAAQhD,GACf,SAGJstH,EAAcC,SAASh5F,GACvB,MAAM85F,EAAgB1sH,KAAKysH,4BACvBpuH,EACAwD,EACA8pH,GAEJA,EAAc5vC,WAEQ/5E,IAAlB0qH,EACAzuC,EAAKrrD,GAAQ85F,SAENzuC,EAAKrrD,GAGpB+4F,EAAc5vC,MAElB,OAAOh2D,EAQH,mCACJ1nB,EACAwD,EACA8pH,GAEA,IAAIgB,GAAS,EA6Bb,MAAMzuH,EA5BN,SAAS0uH,EAAgB/nH,GACrB,GAAI,EAAAwnH,oBAAoBxnH,GAAO,CAC3B,MAAMgoH,EAAUhoH,EAAK,GACfm7B,EAAMn+B,GAAeA,EAAYgrH,GACvC,YAAY7qH,IAARg+B,GACA2rF,EAAc51G,KAAK,sBAAsB82G,uBACzCF,GAAS,IAGT,EAAAjmH,oBAAoBs5B,IAAQ,EAAA9+B,WAAW8+B,GAChCA,EAEP,EAAAp5B,kBAAkBo5B,GACXA,EAAI3hC,OAEfstH,EAAc51G,KAAK,sBAAsB82G,uCACzCF,GAAS,IAEN,GAAIvrH,MAAMC,QAAQwD,GAAO,CAC5B,MAAMsB,EAAS,IAAItB,GACnB,IAAK,IAAIzH,EAAI,EAAGA,EAAI+I,EAAO7E,SAAUlE,EACjC+I,EAAO/I,GAAKwvH,EAAgBzmH,EAAO/I,IAEvC,OAAO+I,EAEP,OAAOtB,EAGL+nH,CAAgBvuH,GAC1B,IAAIsuH,EAGJ,OAAOzuH,EAYH,+BACJwgE,EACAzoD,GAGA,GADAA,EAAUA,GAAW,QACCjU,IAAlB08D,EAAMwsD,QACN,OAAOxsD,EAGX,MAAMouD,EAAsB,EAAAl+C,eACxB34D,EAAQ62G,oBACR,EAAAxC,sCAEJ,GAAIwC,GAAuB,EACvB,MAAM,IAAIrpH,MAAM,kEAGpB,MAAMspH,EAAc3rH,MAAMC,QAAQq9D,EAAMwsD,SAA6BxsD,EAAMwsD,QAAxB,CAACxsD,EAAMwsD,gBACnDxsD,EAAMwsD,QACb,IAAI8B,EAA0B,GAC9B,IAAK,MAAMxB,KAAauB,EAAY,CAChC,MAAME,QAAwBtkD,EAAYx2C,KAAKq5F,EAAW,OAAF,wBACjDv1G,GAAO,CACV40G,oBAAoB,EACpBiC,oBAAqBA,EAAsB,KAG/CE,EAAmBrkD,EAAYukD,YAAYD,EAAiBD,GAEhE,OAAOrkD,EAAYukD,YAAYxuD,EAAOsuD,GAGlC,mBAAmBtuD,EAAc8sD,GACrC,MAAM3pH,EAAc,OAAH,wBAAQ2pH,EAAU3pH,aAAgB68D,EAAM78D,aAEzD,IAAI6nE,EAEJ,GAAI8hD,EAAU9hD,QAAUhL,EAAMgL,OAAQ,CAClC,MAAMyjD,EAAmBrvH,OAAO89D,KAAK4vD,EAAU9hD,QACzC0jD,EAAoBtvH,OAAO89D,KAAK8C,EAAMgL,QAE5CA,EAAS,GAETyjD,EAAiB9sH,QAAQkmE,IACrB,MAAM7rD,EAAQ0yG,EAAkBz6F,QAAQ4zC,IAEzB,IAAX7rD,GAGAgvD,EAAOnD,GAAgB,IAChBilD,EAAU9hD,OAAQnD,MAClB7H,EAAMgL,OAAQnD,IAGrB6mD,EAAkBjnF,OAAOzrB,EAAO,IAGhCgvD,EAAOnD,GAAgBilD,EAAU9hD,OAAQnD,KAKjD6mD,EAAkB/sH,QAAQnB,IACtBwqE,EAAOxqE,GAAKw/D,EAAMgL,OAAQxqE,UAEvBssH,EAAU9hD,OACjBA,EAAS,OAAH,UAAQ8hD,EAAU9hD,QACjBhL,EAAMgL,SACbA,EAAS,OAAH,UAAQhL,EAAMgL,SAExB,OAAO,OAAP,sCAAY8hD,GAAc9sD,GAAK,CAAE78D,cAAa6nE,WAG1C,wBAAwBhL,GAC5B,GAAIt9D,MAAMC,QAAQq9D,EAAMgL,QAAS,CAE7B,MAAMA,EAAiB,GACvBhL,EAAMgL,OAAOrpE,QAAQ0lB,IACjB,GAAI,EAAA7kB,WAAW6kB,GACX,MAAM,IAAItiB,MAAM,oCAEpB,MAAM8iE,EAAexgD,EAAM+yD,SAC3B,QAAqB92E,IAAjBukE,EACA,MAAM,IAAI9iE,MAAM,kCAEfimE,EAAOnD,KACRmD,EAAOnD,GAAgB,IAE3BmD,EAAOnD,GAAcrgE,KAAK6f,KAE9B24C,EAAMgL,OAASA,EAEnB,OAAOhL,EAGH,wBAAwBA,EAAcysD,GAC1C,GAAIzsD,EAAMoK,KAA0B,YAAnBpK,EAAMoK,IAAIl5D,KACvB,IAAK,IAAIxS,EAAI,EAAGA,EAAI,EAAA4sH,yBAA0B5sH,EAAG,CAC7C,MAAMiwH,EAA+B3uD,EAAMoK,IAAY,EAAAihD,iBAAiB3sH,SACxD4E,IAAZqrH,IACC3uD,EAAMoK,IAAY,EAAAihD,iBAAiB3sH,IAAM+tH,EAAiBzoD,WAAW2qD,IAIlF,GAAI3uD,EAAMuK,OACN,IAAK,MAAMtrE,KAAQG,OAAO89D,KAAK8C,EAAMuK,QAAS,CAC1C,MAAM3xD,EAAQonD,EAAMuK,OAAOtrE,GAC3B2Z,EAAMmsC,IAAM0nE,EAAiBzoD,WAAWprD,EAAMmsC,UAC1BzhD,IAAhBsV,EAAMy/D,QACNz/D,EAAMy/D,MAAQo0C,EAAiBzoD,WAAWprD,EAAMy/D,QAI5D,GAAIrY,EAAM6K,aACN,IAAK,MAAMja,KAAQoP,EAAM6K,aACrBja,EAAK7L,IAAM0nE,EAAiBzoD,WAAWpT,EAAK7L,KAGpD,GAAIib,EAAMyK,UACN,IAAK,MAAMnjB,KAAY0Y,EAAMyK,UACzBnjB,EAASvC,IAAM0nE,EAAiBzoD,WAAW1c,EAASvC,KAI5D,QAAqBzhD,IAAjB08D,EAAMgL,OACN,IAAK,MAAMnD,KAAgB7H,EAAMgL,OAAQ,CACrC,IAAKhL,EAAMgL,OAAOzqE,eAAesnE,GAC7B,SAEJ,MAAMuS,EAAWpa,EAAMgL,OAAOnD,GAC9B,IAAK,MAAMxgD,KAAS+yD,EACX/yD,EAAMk4D,MAGX,CAAC,MAAO,YAAa,kBAAmB,gBAAgB59E,QACpDivB,IACI,MAAMC,EAAmBxJ,EAAMk4D,KAAc3uD,GACzCC,GAA8C,iBAApBA,IACzBxJ,EAAMk4D,KACH3uD,GACA67F,EAAiBzoD,WAAWnzC,QAzgBhE,iB,gIC/FA,aAQA,QACA,OACA,OACA,QAOA,QAMA,IAAY6uC,EAMPkvD,GANL,SAAYlvD,GACR,uCACA,qCAFJ,CAAYA,EAAA,EAAAA,0BAAA,EAAAA,wBAAuB,KAMnC,SAAKkvD,GACD,mBACA,eACA,mBACA,mBAJJ,CAAKA,MAAe,KAmEpB,MAAMC,EAyBF,YACIC,EACAC,EAA+BrvD,EAAwBC,gBAL1C,KAAAqvD,gBAA0B,GAOvC1tH,KAAK2tH,0BAA4BF,EACjCztH,KAAK4tH,YAAc,IAAI,EAAAC,SAAuBL,EAAY/qG,GAClDziB,KAAK2tH,4BAA8BvvD,EAAwBC,eAEpD57C,EAAKmxB,aAhDV,EAAM,SAkDD,GAGf5zC,KAAK4tH,YAAYE,iBAAmB,CAACntH,EAAG8hB,UACZzgB,IAApBygB,EAAKE,YAELF,EAAKE,WAAW4jB,SAEpBvmC,KAAK0tH,gBAAgBxnH,KAAKuc,IAE9BziB,KAAK4tH,YAAYG,SAAW,CAACptH,EAAG8hB,KAEpBA,EAAKsoD,UAvCrB,cAAc5mD,EAAoBN,EAAgB8c,GAC9C,MAAO,GAAGA,EAAWhjC,QAAQwmB,KAAcN,IAQ/C,qBAAqBpB,GACjB,OAAO8qG,EAAgBS,OAAOvrG,EAAKmB,QAAQO,aAAc1B,EAAKoB,OAAQpB,EAAKke,YAgD/E,8BACI,OAAO3gC,KAAK2tH,0BAYhB,eACI,OAAO3tH,KAAK4tH,YAAYzmF,SAS5B,WACI,OAAOnnC,KAAK4tH,YAAYxsG,KAW5B,YAAYA,EAAcqsG,GACtBztH,KAAK2tH,0BAA4BF,EACjCztH,KAAK4tH,YAAYK,sBAAsB7sG,EAAOqB,GACtCziB,KAAK2tH,4BAA8BvvD,EAAwBC,eAEpD57C,EAAKmxB,aAzHV,EAAM,SA2HD,GAYnB,IAAIzvB,EAAoBN,EAAgB8c,GACpC,OAAO3gC,KAAK4tH,YAAY3vH,IAAIsvH,EAAgBS,OAAO7pG,EAAYN,EAAQ8c,IAW3E,IAAIxc,EAAoBN,EAAgB8c,EAAwBle,GAC5DziB,KAAK4tH,YAAY5mH,IAAIumH,EAAgBS,OAAO7pG,EAAYN,EAAQ8c,GAAale,GASjF,OAAOA,GACH,MAAMmB,EAAU2pG,EAAgBW,cAAczrG,GAC9CziB,KAAKmuH,YAAYvqG,GAYrB,YAAYA,GACR5jB,KAAK4tH,YAAY7mH,OAAO6c,GAM5B,eACI5jB,KAAK0tH,gBAAgBrtH,QAAQoiB,IACzBA,EAAKgjB,YAGTzlC,KAAK0tH,gBAAgBpsH,OAAS,EAWlC,mBACItB,KAAK4tH,YAAYQ,mBAMrB,WACIpuH,KAAK4tH,YAAYS,WAQrB,cAAcC,GACVtuH,KAAK4tH,YAAYW,cAAcD,GAWnC,QAAQloF,EAAkDooF,GACtDxuH,KAAK4tH,YAAYvtH,QAAQ,CAAC2jF,EAAarlF,UACdqD,IAAjBwsH,GAA8BxqC,EAAMrjD,aAAe6tF,GACnDpoF,EAAS49C,EAAOrlF,MA+DhC,uBAcI,YACqB8vH,EACA7oD,EACV3vD,GAFU,KAAAw4G,wBACA,KAAA7oD,wBACV,KAAA3vD,UAhBX,KAAAuM,mBAA2C,GAC3C,KAAAW,uBAAiC,EAEhB,KAAAurG,iBAAmB,IAAItvH,EAAMq6D,kBAEtC,KAAAk1D,YAA0B,CAAEjwG,KAAM,GAAKC,IAAK9U,IAAUitD,QAAS,GAAK7M,QAASpgD,KAG7E,KAAA+kH,cAAgB,IAAIzsH,IAEpB,KAAAwrH,0BACJvvD,EAAwBC,eAOxBr+D,KAAK2tH,+BACmC3rH,IAApCiU,EAAQkoD,wBACFC,EAAwBC,eACxBpoD,EAAQkoD,wBAClBn+D,KAAK6uH,kBAAoB,IAAItB,EACzBvtH,KAAKiW,QAAQioD,cACbl+D,KAAK2tH,2BAOb,yBACI,OAAO3tH,KAAKiW,QAAQioD,cAWxB,uBACI98C,EACA0tG,EAA2C1wD,EAAwBC,gBAEnEr+D,KAAKiW,QAAQioD,cAAgB98C,EAE7BphB,KAAKm+D,wBAA0B2wD,EAMnC,0BACI,OAAO9uH,KAAKiW,QAAQ+nD,0BAQxB,wBAAwB58C,GACpBphB,KAAKiW,QAAQ+nD,0BAA4B58C,EAO7C,8BACI,OAAOphB,KAAK2tH,0BAWhB,4BAA4BmB,GACxB9uH,KAAK2tH,0BAA4BmB,EACjC9uH,KAAK6uH,kBAAkBE,YAAY/uH,KAAKiW,QAAQioD,cAAe4wD,GAMnE,iBAAiB/6F,EAAuBD,QACf9xB,IAAjB+xB,IACA/zB,KAAKiW,QAAQ4sD,oBAAoB9uC,aAAeA,QAE/B/xB,IAAjB8xB,IACA9zB,KAAKiW,QAAQ4sD,oBAAoB/uC,aAAeA,GAEpD,MAAM,OAAEplB,EAAM,WAAES,EAAU,kBAAEiM,GAAsBpb,KAAKyuH,sBAAsBvgH,QAM7E,OALAlO,KAAK2uH,YAAc3uH,KAAKiW,QAAQ4sD,oBAAoBmsD,mBAChDtgH,EACAS,EACAiM,GAEGpb,KAAK2uH,YAWhB,iBACIv0E,EACAxjC,EACAo3D,EACAH,GAEA,IAAI1qD,GAAiC,EAErC,MAAM8rG,EAAwBjvH,KAAKkvH,iCAC/Bt4G,EACAo3D,EACAH,GAEJ7tE,KAAKwiB,mBAAqB,GAC1BxiB,KAAK4uH,cAAc5oF,QACnB,IAAK,MAAM,WAAErF,EAAU,gBAAEwuF,KAAqBF,EAAsBG,SAAU,CAO1ED,EAAgBvmF,KAAK,CAACp/B,EAAiBE,KACnC,MAAM2lH,EAAe7lH,EAAEwF,SAAWtF,EAAEsF,SAG9BsgH,EAAsC,MAA3B9lH,EAAEwF,SAAWtF,EAAEsF,UAEhC,OAAO3F,KAAK2S,IAAIqzG,GAAgBC,EAC1B9lH,EAAEoa,QAAQO,aAAeza,EAAEka,QAAQO,aACnCkrG,IAGV,MAAME,EAA+B,GACrC,IAAIC,GAA2B,EAC3BntG,EAAkB,EAEtB,MAAMotG,EAAgB9uF,EAAWu1D,iBAAiBt/E,GAClD,IACI,IAAIxZ,EAAI,EACRA,EAAI+xH,EAAgB7tH,QACpBiuH,EAAqBjuH,OAAStB,KAAKiW,QAAQ+nD,0BAC3C5gE,IACF,CACE,MAAMsyH,EAAYP,EAAgB/xH,GAE5BqlB,EAAOziB,KAAK2vH,QAAQhvF,EAAY+uF,EAAU9rG,QAAS8rG,EAAU7rG,aACtD7hB,IAATygB,IAIJ+sG,EAA2BA,GAA4B/sG,EAAKoiB,kBACvDpiB,EAAKoiB,mBAGNpiB,EAAKue,mBAGLhhC,KAAK4vH,oBAAoBjvF,EAAYle,GAEjCA,EAAKqe,gBAAkB,IAEvBre,EAAKqe,gBAAkBH,EAAWzyB,QAAQs0B,cAT9CngB,IAcJI,EAAKotG,YAAcH,EAAUlsF,KAC7B/gB,EAAKoR,eAAiB67F,EAEtBH,EAAqBrpH,KAAKuc,IAG9BziB,KAAK4lE,sBAAsBkqD,YAAYP,GAEvCvvH,KAAKwiB,mBAAmBtc,KAAK,CACzBy6B,aACAyZ,eACAxjC,UAAW64G,EACXM,qBAAsBP,EACtBntG,kBACAK,aAAc6sG,EACd59E,cAAe,IAAIxvC,MAEvBghB,EAAwBA,GAAyBqsG,EAoBrD,IAAI17F,EACAC,EAlBJ/zB,KAAKmjB,sBACDA,GAAyB8rG,EAAsBe,sBAEnDhwH,KAAKiwH,wBAELjwH,KAAK0tE,kBAAkBjrD,IAIdA,EAAKsoD,gBAAiC/oE,IAApBygB,EAAKE,YAA6BF,EAAKE,WAAWC,YAErE5iB,KAAKkwH,YAAYztG,KAIzBziB,KAAK6uH,kBAAkBT,mBAIvBpuH,KAAKwiB,mBAAmBniB,QAAQ+zC,IAIdA,EAAgBzC,cACxBtxC,QAAQoiB,IACVA,EAAK4vB,OAAO+B,EAAgBx9B,WAC5Bkd,EAAe,EAAAxrB,UAAUif,KAAKuM,EAAcrR,EAAKyT,OAAOf,aACxDpB,EAAe,EAAAzrB,UAAUof,KAAKqM,EAActR,EAAKyT,OAAOb,sBAI3CrzB,IAAjB8xB,IACAA,EAAe,QAEE9xB,IAAjB+xB,IACAA,EAAe,GAInB,IAAIq+C,GAA6B,EACjC,MAAM+9C,EAAgBnwH,KAAK2uH,YACrByB,EAAgBpwH,KAAKwvE,iBAAiBz7C,EAAcD,GA0mBlE,IAAyBtqB,EAAeE,EAvmBhC,OAFA0oE,GAAsE,IAymBtC1oE,EAzmBmBymH,GAymBlC3mH,EAzmBmB4mH,GA2mBlCzxG,MAAQjV,EAAEiV,KAAOnV,EAAEygD,UAAYvgD,EAAEugD,SAAWzgD,EAAEstD,UAAYptD,EAAEotD,SAAWttD,EAAEkV,OAAShV,EAAEgV,MAzmB/E,CACHutC,WAAYmkE,EACZh+C,qBAaR,QAAQzxC,EAAwB/c,EAAkBC,EAAiB,GAE/D,OAAO7jB,KAAKqwH,YAAY1vF,EAAY/c,EAASC,GAD3B,GAYtB,cAAc8c,EAAwB/c,EAAkBC,EAAiB,GACrE,EAAAvX,OAAOq0B,EAAWm3C,WAElB,OAAO93E,KAAKqwH,YAAY1vF,EAAY/c,EAASC,GAD3B,GAYtB,gBACI8c,EACA/c,EACAC,EAAiB,GAEjB,MAAMysG,EAA4BtwH,KAAKwiB,mBAAmB0V,KAAKoW,GACpDA,EAAK3N,aAAeA,GAG/B,QAAkC3+B,IAA9BsuH,EAIJ,OAAOA,EAA0B3+E,cAAc1zC,IAC3C,EAAAylB,gBAAgBC,0BAA0BC,EAASC,IAW3D,0BACI8c,EACAh4B,EACAkb,EAAiB,GAEjB,MAAMysG,EAA4BtwH,KAAKwiB,mBAAmB0V,KAAKoW,GACpDA,EAAK3N,aAAeA,GAG/B,QAAkC3+B,IAA9BsuH,EACA,OAGJ,MAAMt+B,EAAerxD,EAAWsB,kBAC1BsuF,EAAeD,EAA0B15G,UACzC45G,EAAiBx+B,EAAay+B,WAAW9nH,EAAU4nH,GAEzD,IAAKC,EACD,OAGJ,IAAI/tG,EAAO6tG,EAA0B3+E,cAAc1zC,IAC/C,EAAAylB,gBAAgBC,0BAA0B6sG,EAAgB3sG,IAG9D,QAAa7hB,IAATygB,EACA,OAAOA,EAGX,MAAM,eAAEiuG,EAAc,iBAAEC,GAAqB3wH,KAAK4wH,mBAC9CjwF,EACA4vF,GAGJ,IAAIM,EAAgBL,EACpB,IAAK,IAAItvF,EAAc,EAAGA,GAAewvF,IAAkBxvF,EAMvD,GALA2vF,EAAgBA,EAActxF,SAE9B9c,EAAO6tG,EAA0B3+E,cAAc1zC,IAC3C,EAAAylB,gBAAgBC,0BAA0BktG,EAAehtG,SAEhD7hB,IAATygB,EACA,OAAOA,EAIf,MAAM4X,EAAa23D,EAAa7iF,WAAWsB,aAAa9H,GAExD,IAAK,IAAIu4B,EAAc,EAAGA,GAAeyvF,IAAoBzvF,EAAa,CACtE,MAAM4vF,EAAaP,EAAervF,EAC5B01D,EAAe,EAAA5gE,aAAai9D,0BAC9BjB,EACA33D,EACAy2F,GAEJ,GAAIl6B,IACAn0E,EAAO6tG,EAA0B3+E,cAAc1zC,IAC3C,EAAAylB,gBAAgBC,0BAA0BizE,EAAc/yE,SAG/C7hB,IAATygB,GACA,OAAOA,GAYvB,iBAAiBke,GACb3gC,KAAK0nE,eAAe/mC,GACpB3gC,KAAKwiB,mBAAqBxiB,KAAKwiB,mBAAmBgQ,OAC9ClQ,GAAYA,EAASqe,aAAeA,GAc5C,eAAeA,QACQ3+B,IAAf2+B,EACA3gC,KAAK6uH,kBAAkBN,cAAc,CAAC9rG,EAAY9hB,IACvC8hB,EAAKke,aAAeA,GAG/B3gC,KAAK6uH,kBAAkBR,WAa/B,eAAe1tF,GACX,QAAmB3+B,IAAf2+B,EACA3gC,KAAKwiB,mBAAmBniB,QAAQ+zC,IAC5Bp0C,KAAK+wH,yBAAyB38E,SAE/B,CACH,MAAMA,EAAkBp0C,KAAKwiB,mBAAmB0V,KAAKxzB,GAAKA,EAAEi8B,aAAeA,GAC3E,QAAwB3+B,IAApBoyC,EACA,OAEJp0C,KAAK+wH,yBAAyB38E,IAOtC,sBACIp0C,KAAK6uH,kBAAkBmC,eAQ3B,mBAAmBxjD,GACf,IAAK,MAAMyjD,KAAajxH,KAAKwiB,mBACzByuG,EAAUt/E,cAActxC,QAAQmtE,GAaxC,kBAAkBA,EAA2B7sC,GACzC3gC,KAAK6uH,kBAAkBxuH,QAAQ,CAACoiB,EAAM9hB,IAAM6sE,EAAI/qD,GAAOke,GAM3D,YAAYle,GAERziB,KAAK6uH,kBAAkB9nH,OAAO0b,GAC9BA,EAAKgjB,UAOD,oBAAoB9E,EAAwBle,GAChD,GAAIziB,KAAKiW,QAAQ9G,WAAWS,OAAS,EAAAC,eAAee,WAKhD+vB,EAAWuwF,kBAAmB,CAC9B,MAAMvyH,EAAM8jB,EAAK0uG,UACXntC,EAAQhkF,KAAK4uH,cAAc3wH,IAAIU,QACvBqD,IAAVgiF,GAGAvhE,EAAK0e,eAAgB,EACrBnhC,KAAK4uH,cAAc5nH,IAAIrI,EAAK8jB,IAIxBuhE,EAAMrjD,sBAAsB,EAAA0lC,qBAC5B2d,EAAM7iD,eAAgB,EACfR,aAAsB,EAAA0lC,uBAC7B5jD,EAAK0e,eAAgB,IAO7B,mBACJR,EACA4vF,GAEA,MAAMG,EAAiBrnH,KAAKO,IACxB5J,KAAKiW,QAAQqoD,yBACbj1D,KAAKS,IAAI,EAAGymH,EAAe5vF,EAAWs3C,eAEpC04C,EAAmBtnH,KAAKO,IAC1B5J,KAAKiW,QAAQsoD,2BACbl1D,KAAKS,IAAI,EAAG62B,EAAWu3C,aAAeq4C,IAU1C,MAAO,CAAEa,gBAPLT,EAAmB,GAAKD,EAAiB,EACnCpD,EAAgB+D,KAChBV,EAAmB,EACnBrD,EAAgBgE,KAChBZ,EAAiB,EACjBpD,EAAgBiE,GAChBjE,EAAgBkE,KACAd,iBAAgBC,oBActC,wBACJ3wH,KAAKwiB,mBAAmBniB,QAAQ+zC,IAC5B,MAAMzC,EAAgByC,EAAgBzC,cAGhC8/E,EAA4B,GAKlCr9E,EAAgB1xB,aAAariB,QAAQoiB,IACjCA,EAAKye,YAAc,EACfze,EAAKkiB,YACLgN,EAAc3qC,IAAIyb,EAAK0uG,UAAW1uG,GAIlCgvG,EAAgBvrH,KAAKuc,EAAK0uG,aAIlC,MAAMxwF,EAAayT,EAAgBzT,WACnC,GAA+B,IAA3B8wF,EAAgBnwH,SAAqD,IAArCq/B,EAAW03C,sBAG3C,OAGJ,MAAMo3C,EAAgBr7E,EAAgBx9B,WAChC,gBAAEw6G,GAAoBpxH,KAAK4wH,mBAAmBjwF,EAAY8uF,GAK1DiC,EAAe,IAAIvvH,IAIzB,IAAK,MAAMkiG,KAAeotB,GAElBL,IAAoB9D,EAAgB+D,MACpCD,IAAoB9D,EAAgBiE,KAGhCvxH,KAAK2xH,OACDttB,EACAorB,EACA99E,EACA+/E,EACA/wF,MASRywF,IAAoB9D,EAAgB+D,MACpCD,IAAoB9D,EAAgBgE,MAEpCtxH,KAAK4xH,SAASvtB,EAAaorB,EAAe99E,EAAehR,MAMjE,SACJ0jE,EACAorB,EACA99E,EACAhR,GAEA,MAAM,OAAE9c,EAAM,WAAEM,GAAe,EAAAT,gBAAgBU,iCAC3CigF,GAEEzgF,EAAU,EAAAY,QAAQC,eAAeN,GAEjC6tE,EAAerxD,EAAWsB,kBAChC,IAAK,MAAM20D,KAAgB5E,EAAa6E,eAAejzE,GAAU,CAC7D,MAAMiuG,EAAgB,EAAAnuG,gBAAgBC,0BAA0BizE,EAAc/yE,GACxEiuG,EAAY9xH,KAAK6uH,kBAAkB5wH,IACrC24F,EAAazyE,aACbN,EACA8c,GAGEoxF,EAAgB1oH,KAAK2S,IAAI46E,EAAah7E,MAAQ6zG,QAClCztH,IAAd8vH,GAA2BA,EAAUntF,aAErCgN,EAAc3qC,IAAI6qH,EAAeC,GACjCA,EAAU5wF,YAAc6wF,GAKxBA,EAAgB/xH,KAAKiW,QAAQsoD,4BAC7Bv+D,KAAK4xH,SAASC,EAAepC,EAAe99E,EAAehR,IAe/D,OACJ0jE,EACAorB,EACA99E,EACA+/E,EACA/wF,GAEA,MAAMqxF,EAAa,EAAAtuG,gBAAgBY,oBAAoB+/E,GAEvD,QAAsCriG,IAAlC2vC,EAAc1zC,IAAI+zH,GAClB,OAAO,EAEX,MAAMC,EAASP,EAAazzH,IAAI+zH,GAChC,QAAehwH,IAAXiwH,EACA,OAAOA,EAGX,MAAM,OAAEpuG,EAAM,WAAEM,GAAe,EAAAT,gBAAgBU,iCAAiC4tG,GAC1EE,EAAalyH,KAAK6uH,kBAAkB5wH,IAAIkmB,EAAYN,EAAQ8c,GAC5DkwF,EAAgBqB,EAAaA,EAAWtuG,QAAU,EAAAY,QAAQC,eAAeN,GACzE4tG,EAAgB1oH,KAAK2S,IAAIyzG,EAAgBoB,EAAcj1G,OAC7D,QAAmB5Z,IAAfkwH,GAA4BA,EAAWvtF,YAQvC,OAPA+sF,EAAa1qH,IAAIgrH,GAAY,GAE7BrgF,EAAc3qC,IAAIgrH,EAAYE,GAG9BA,EAAWhxF,aAAe6wF,GAEnB,EAMX,GAJIL,EAAa1qH,IAAIgrH,GAAY,GAI7BD,EAAgB/xH,KAAKiW,QAAQqoD,0BAAoD,IAAxBuyD,EAAcj1G,MAAa,CACpF,MAAMu2G,EAAUnyH,KAAK2xH,OACjBK,EACAvC,EACA99E,EACA+/E,EACA/wF,GAKJ,GADA+wF,EAAa1qH,IAAIgrH,EAAYG,GACzBA,EACA,OAAO,EAGf,OAAO,EAGH,YACJxxF,EACA/c,EACAC,EACAuuG,GAEA,SAASC,EAAWC,QACKtwH,IAAjBswH,IAIJA,EAAazxF,sBAAwBF,EAAWzyB,QAAQs0B,aAG5D,IAAK7B,EAAWm3C,YAAcs6C,EAAW,CACrC,MAAMG,EAAa5xF,EAAWgvF,QAAQ/rG,GAEtC,OADAyuG,EAAWE,GACJA,EAGX,MAAMC,EAAYxyH,KAAK6uH,kBACvB,IAAIpsG,EAAO+vG,EAAUv0H,IAAI2lB,EAAQO,aAAcN,EAAQ8c,GAEvD,YAAa3+B,IAATygB,GAAsBA,EAAKoB,SAAWA,GACtCwuG,EAAW5vG,GACJA,GAGP2vG,OAAJ,GAIA3vG,EAAOke,EAAWgvF,QAAQ/rG,QAEb5hB,IAATygB,IACAA,EAAKoB,OAASA,EACdwuG,EAAW5vG,GACX+vG,EAAUxrH,IAAI4c,EAAQO,aAAcN,EAAQ8c,EAAYle,GACxDziB,KAAK4lE,sBAAsB6sD,SAAShwG,IAEjCA,GAGH,yBAAyB2xB,GAC7B,MAAMs+E,EAAkB1yH,KAAK6uH,kBACvB8D,EAAkC,IAAIhzH,IAE5C,SAASizH,EAAcnwG,EAAYowG,GAC/B,MAAMjvG,EAAU2pG,EAAgBW,cAAczrG,GACzCkwG,EAAcpsH,IAAIqd,KACnB+uG,EAAcxyH,IAAIyjB,QACc5hB,IAA5BygB,EAAKI,oBACLJ,EAAKI,mBAAmB2lB,QAK5B/lB,EAAKwjB,oBAELxjB,EAAK0P,QAIbiiB,EAAgB1xB,aAAariB,QAAQoiB,IACjCmwG,EAAcnwG,EAAMziB,KAAK4lE,yBAE7BxxB,EAAgBzC,cAActxC,QAAQoiB,IAClCmwG,EAAcnwG,EAAMziB,KAAK4lE,yBAG7B8sD,EAAgBryH,QAAQ,CAACoiB,EAAM9jB,KACtBg0H,EAAcpsH,IAAI5H,KACnB+zH,EAAgBvE,YAAYxvH,GAC5B8jB,EAAKgjB,YAEV2O,EAAgBzT,YAIf,iCACJ/pB,EACAo3D,EACAH,GAKA,MAAMuhD,EAAWhuH,QACjB,IAAI4uH,GAAiC,EAErC,GAA2B,IAAvBhiD,EAAY1sE,OACZ,MAAO,CAAE8tH,WAAUY,yBAGvB,MAAM8C,EAAoB,IAAI3wH,IAC9B6rE,EAAY3tE,QAAQsgC,IAChB,MAAMqxD,EAAerxD,EAAWsB,kBAC1B8wF,EAASD,EAAkB70H,IAAI+zF,QACtBhwF,IAAX+wH,EACAD,EAAkB9rH,IAAIgrF,EAAc,CAACrxD,IAErCoyF,EAAO7sH,KAAKy6B,UAOS3+B,IAAzB6rE,GACA7tE,KAAK0uH,iBAAiBp/G,KAAKtP,KAAKyuH,sBAAsB//G,QACtD1O,KAAK0uH,iBAAiBhwG,KAAOrV,KAAKO,IAC9B5J,KAAK0uH,iBAAiBhwG,KACtB1e,KAAK2uH,YAAY73D,SAErB92D,KAAK0uH,iBAAiB/vG,IAAMtV,KAAKS,IAC7B9J,KAAK0uH,iBAAiB/vG,IACtB3e,KAAK2uH,YAAY1kE,SAErBjqD,KAAK0uH,iBAAiBj/C,yBACtBzvE,KAAKyuH,sBAAsBuE,cAAchzH,KAAK0uH,iBAAiBv6G,mBAE/DnU,KAAKyuH,sBAAsBuE,gBAK/B,IAAK,MAAOhhC,EAAc+gC,KAAWD,EAAmB,CACpD,MAAMlzF,EAAamzF,EAAOhtH,IAAI46B,GAAcA,EAAWu1D,iBAAiBt/E,IAClEzQ,EAASnG,KAAKyuH,sBAAsBwE,QACtCjhC,EACAnkB,EACAjuC,EACAmzF,GAGJ/C,EAAwBA,GAAyB7pH,EAAO+sH,iBAExD,IAAK,MAAMvyF,KAAcoyF,EAAQ,CAG7B,MAAM5D,EAAkC,GAClCM,EAAgB9uF,EAAWu1D,iBAAiBt/E,GAClD,IAAK,MAAMu8G,KAAgBhtH,EAAOitH,eAAen1H,IAAIwxH,GAAgB9vF,SAC7DgB,EAAW0yF,WAAW5D,EAAe0D,EAAavvG,UAClDurG,EAAgBjpH,KAAKitH,GAG7B/D,EAASlpH,KAAK,CAAEy6B,aAAYwuF,qBAIpC,MAAO,CAAEC,WAAUY,4B,iHC5sC3B,aAOMzV,EAAQ,EAAQ,KAkDtB,gDAEuB,KAAA/tG,OAAkB,EAAAC,cAAcxM,SAASvB,OAAO,6BAQnE,UACI,YAAiCsD,IAA7BhC,KAAKszH,sBAITtzH,KAAKszH,oBAAsBtzH,KAAKuzH,2BAC3BvuF,KAAKwuF,GAAgBxzH,KAAKyzH,UAAUD,IACpCruF,MAAM5mB,IACHve,KAAKwM,OAAO+R,MAAMA,GACX,IAAIg8F,KAPRv6G,KAAKszH,oBAcpB,oBAAoBp9F,EAAgBta,GAChC,MAEMzV,EAA0B,GAE1ButH,SAJa1zH,KAAK2zH,WAI0BpgB,OAAO,CACrDz+D,KAAM5e,EAAOrZ,KACbm4B,KAAM9e,EAAOzZ,MACbs4B,KAAM7e,EAAOtZ,KACbkf,KAAM5F,EAAO1Z,QAGjB,IAAK,MAAMwnE,KAAS0vC,EAAiB,CACjC,MAAMz9B,EAAW,EAAArnB,eAAeoV,EAAMiS,SAAU,GAC1C29B,EAAW,EAAAhlD,eAAeoV,EAAM4vC,SAAU/pH,KAE5C+R,GAASq6E,GAAYr6E,GAASg4G,QACuB5xH,IAAjDmE,EAAO+xB,KAAK27F,GAAQA,EAAK9kG,KAAOi1D,EAAMh+E,QACtCG,EAAOD,KAAK,CAAE6oB,GAAIi1D,EAAMh+E,QAKpC,OAAOG,EASX,UAAUm5B,GACN,MAAMw0F,EAAO,IAAIvZ,EAEjB,IAAKj7E,EAED,OADAt/B,KAAKwM,OAAOuJ,KAAK,uCACV+9G,EAGX,IAAK,MAAM9vC,KAAS1kD,EAAS,CACzB,MAAM,SAAE22D,EAAQ,SAAE29B,EAAQ,MAAE5tH,EAAK,IAAE+tH,GAAQ/vC,EAE3C,GAAKA,EAAM7vC,MAYP,IAAK,MAAMn3B,KAAOgnE,EAAM7vC,MAAO,CAC3B,MAAOa,EAAMF,EAAMhZ,EAAMiZ,GAAQ/3B,EACjC82G,EAAKjZ,OAAO,CACR/lE,OACAE,OACAD,OACAjZ,OACAm6D,WACA29B,WACA5tH,QACA+tH,aArBRD,EAAKjZ,OAAO,CACR/lE,MAAO,IACPE,MAAO,GACPD,KAAM,IACNjZ,KAAM,IACNm6D,WACA29B,WACA5tH,QACA+tH,QAmBZ,OAAOD,K,iYCnJf,a,+TCNA,aACA,SACA,OAEMtnH,EAAS,EAAAC,cAAcxM,SAASvB,OAAO,gBAiD7C,0BAA+Bs1H,GAO3B,MAAqC,mBAAvBA,EAAIC,iBAA0D,IAAzBD,EAAIC,kBA0C3D,8BAAmCD,GAC/B,MAAyC,mBAA3BA,EAAIE,qBAAkE,IAA7BF,EAAIE,sBA0B/D,MAAsBC,EAQlB,YACar1H,EACAylF,EACUpqE,GAFV,KAAArb,SACA,KAAAylF,eACU,KAAApqE,iBAVb,KAAA4vB,OAAiB,EACjB,KAAA6K,KAAe,EACf,KAAAw/E,aAAuB,EACvB,KAAAC,WAAqB,EAS3B,EAAA/nH,SAASxN,GAEmB,mBAAxBqb,EAAevK,MACfpD,EAAO+R,MACH,8EAGR,EAAAjS,OAC4B,mBAAxB6N,EAAevK,KACf,8EAIJ5P,KAAK+N,SAAW/N,KAAKma,eAAeikE,aAAa,YACjDp+E,KAAKga,SAAWha,KAAK+N,SAASiM,SAEzBha,KAAK+N,UACNvB,EAAOuJ,KACH,kFAKJ/V,KAAK+N,SAAS4L,MAAM26G,cAAgB9iG,cACpChlB,EAAOuJ,KACH,0FAWZ,WACI,OAAO/V,KAAK+N,SAASgM,MAQzB,kBACI,OAAO/Z,KAAKlB,OAAOwnB,YAGvB,SAASyjB,EAAe6K,EAAaw/E,EAAuB,EAAGC,EAAqB,GAChF,EAAA/nH,OAAOy9B,GAAS,GAChB,EAAAz9B,OAAOsoC,GAAO,GACd,EAAAtoC,OAAOy9B,GAAS6K,GAChB50C,KAAK+pC,MAAQA,EACb/pC,KAAK40C,IAAMA,EACX50C,KAAKo0H,aAAeA,EACpBp0H,KAAKq0H,WAAaA,EAMtB,YAII,MAAMtW,EAAYtzG,IACd,MAAM4N,EAAe5N,EACrB,GAC0B,sBAAtB4N,EAAazI,MACS,yBAAtByI,EAAazI,KAEb,OAAOyI,EAAa4S,MACjB,GAA0B,sBAAtB5S,EAAazI,KAA8B,CAClD,MAAM2kH,EAAoB9pH,EAE1B,GAA+B,sBAA3B8pH,EAAkB52H,KAClB,OAAO42H,EAAkBv8G,SAASw8G,QAAQn2H,MAG9CmO,EAAOuJ,KACH,+DACAw+G,EAAkB52H,WAGtB6O,EAAOuJ,KACH,wDACAsC,EAAazI,OAOzB,GAAIxO,MAAMC,QAAQrB,KAAKlB,OAAO2L,UAAW,CACrC,MAAM8wC,EAAU,IAAIn6C,MACdugB,EAAY3hB,KAAKlB,OAAO2L,SAE9B,IAAK,MAAMA,KAAYkX,EACnB45B,EAAQr1C,KAAK63G,EAAStzG,IAG1B,OAAO8wC,EAEP,OAAOwiE,EAAS/9G,KAAKlB,OAAO2L,WArHxC,iCA6HA,MAAsBgqH,UAAiCN,EASnD,YACar1H,EACAylF,EACUpqE,EACT4/D,GAEV/2E,MAAMlE,EAAQylF,EAAcpqE,GALnB,KAAArb,SACA,KAAAylF,eACU,KAAApqE,iBACT,KAAA4/D,SAKd,QACI,EAAAztE,OAAOtM,KAAK00H,aAAc,sCAE1B,MAAMC,EAAiB30H,KAAK+N,SAAS4L,MAE/BowB,EAAQ/pC,KAAK+pC,MAAQ/pC,KAAKga,SAC1B46B,EAAM50C,KAAK40C,IAAM50C,KAAKga,SAE5B,IAAK,IAAI5c,EAAI2sC,EAAO3sC,EAAIw3C,EAAKx3C,IACzBu3H,EAAev3H,GAAK,EAGxB4C,KAAK+N,SAASxB,aAAc,EAGhC,cACI,EAAAD,OAAOtM,KAAK00H,aAAc,sCAE1B,MAAM3qF,EAAQ/pC,KAAK+pC,MACb6K,EAAM50C,KAAK40C,IAEjB,OAAQ50C,KAAK+N,SAAS4L,MAAuBi7G,SACzC7qF,EAAQ/pC,KAAKga,SACb46B,EAAM50C,KAAKga,UAIT,aACN,YACsBhY,IAAlBhC,KAAK+N,eACU/L,IAAfhC,KAAK+pC,YACQ/nC,IAAbhC,KAAK40C,KACL50C,KAAK+pC,OAAS,GACd/pC,KAAK40C,KAAO50C,KAAK+N,SAASgM,OAC1B/Z,KAAK+pC,OAAS/pC,KAAK40C,KApD/B,6BA4DA,6CAAkD6/E,EAE9C,YACa31H,EACAylF,EACApqE,GAETnX,MAAMlE,EAAQylF,EAAcpqE,EAAgB,GAJnC,KAAArb,SACA,KAAAylF,eACA,KAAApqE,iBAKb,iBACI,OAAO,EAGX,YAEI,EAAA7N,OAAOtM,KAAK00H,aAAc,8CAQlC,iDAAsDD,EAElD,YACa31H,EACAylF,EACApqE,GAETnX,MAAMlE,EAAQylF,EAAcpqE,EAAgB,GAJnC,KAAArb,SACA,KAAAylF,eACA,KAAApqE,iBAKb,qBACI,OAAO,EAIX,cACI,OAAOnX,MAAM6xH,gBAOrB,MAAsBC,UAAwCX,EAY1D,YACar1H,EACAylF,EACUpqE,EAEnB4vB,EAEA6K,GAEA5xC,MAAMlE,EAAQylF,EAAcpqE,GARnB,KAAArb,SACA,KAAAylF,eACU,KAAApqE,iBAQnBna,KAAK0lF,QAC6B,OAA9B1lF,KAAKma,eAAeO,MACb1a,KAAKma,eAAeO,MAAMf,WACzB3X,EAEPhC,KAAK0lF,QAMA1lF,KAAK0lF,mBAAmBp0D,cAC1B9kB,EAAOuJ,KACH,oFAGJ,EAAAzJ,OAAOtM,KAAK0lF,mBAAmBp0D,eAVnC9kB,EAAOuJ,KACH,4EAEJ,EAAAzJ,SAAStM,KAAK0lF,UAmBtB,WACI,OAAO1lF,KAAK0lF,QAAQpkF,OAGd,aACN,QACMtB,KAAK0lF,cACQ1jF,IAAfhC,KAAK+pC,YACQ/nC,IAAbhC,KAAK40C,KACL50C,KAAK+pC,OAAS,GACd/pC,KAAK40C,KAAO50C,KAAK0lF,QAAQpkF,QACzBtB,KAAK+pC,OAAS/pC,KAAK40C,KA9D/B,oCAsEA,oDAAyDkgF,EAErD,YACah2H,EACAylF,EACApqE,GAETnX,MAAMlE,EAAQylF,EAAcpqE,EAAgB,GAJnC,KAAArb,SACA,KAAAylF,eACA,KAAApqE,iBAKb,iBACI,OAAO,EAQX,YAGI,GAFA,EAAA7N,OAAOtM,KAAK00H,aAAc,mDAEtB10H,KAAKukF,eAAiB,EAAAoD,aAAaC,aAAc,CACjD,MAAM79C,EAAQ/pC,KAAK+pC,MAAQ/pC,KAAKo0H,aAC1BtP,EAAgB9kH,KAAK+N,SAAS4L,MACpC,OAAO,EAAAo7G,qBAAqBjQ,EAAe/6E,IAMnD,QACI,EAAAz9B,OAAOtM,KAAK00H,aAAc,mDAE1B,MAAM3qF,EAAQ/pC,KAAK+pC,MACb6K,EAAM50C,KAAK40C,IAEjB,IAAK,IAAIx3C,EAAI2sC,EAAO3sC,EAAIw3C,EAAKx3C,IACzB4C,KAAK0lF,QAAQtoF,GAAK,EAGY,OAA9B4C,KAAKma,eAAeO,QACpB1a,KAAKma,eAAeO,MAAMnO,aAAc,GAIhD,cACI,EAAAD,OAAOtM,KAAK00H,aAAc,mDAE1B,MAAM16G,EAAWha,KAAKga,SAEhB+vB,EAAQ/pC,KAAK+pC,MACb6K,EAAM50C,KAAK40C,IAEXzuC,EAAS,IAAIqrB,cAAcojB,EAAM7K,GAAS/vB,GAC1C8qG,EAAgB9kH,KAAK+N,SAAS4L,MAEpC,GAAiB,IAAbK,EACA,IAAK,IAAI5c,EAAI2sC,EAAOiY,EAAI,EAAG5kD,EAAIw3C,EAAKx3C,IAAK4kD,GAAKhoC,EAAU,CACpD,MAAMU,EAAQ1a,KAAK0lF,QAAQtoF,GAC3B+I,EAAO67C,EAAI,GAAK8iE,EAAcpqG,EAAQV,EAAW,GACjD7T,EAAO67C,EAAI,GAAK8iE,EAAcpqG,EAAQV,EAAW,GAGzD,GAAiB,IAAbA,EACA,IAAK,IAAI5c,EAAI2sC,EAAOiY,EAAI,EAAG5kD,EAAIw3C,EAAKx3C,IAAK4kD,GAAKhoC,EAAU,CACpD,MAAMU,EAAQ1a,KAAK0lF,QAAQtoF,GAC3B+I,EAAO67C,EAAI,GAAK8iE,EAAcpqG,EAAQV,EAAW,GACjD7T,EAAO67C,EAAI,GAAK8iE,EAAcpqG,EAAQV,EAAW,GACjD7T,EAAO67C,EAAI,GAAK8iE,EAAcpqG,EAAQV,EAAW,QAGrD,IAAK,IAAI5c,EAAI2sC,EAAOiY,EAAI,EAAG5kD,EAAIw3C,EAAKx3C,IAAK4kD,IAAK,CAC1C,MAAMtnC,EAAQ1a,KAAK0lF,QAAQtoF,GAC3B,IAAK,IAAI43H,EAAI,EAAGA,EAAIh7G,EAAUg7G,IAC1B7uH,EAAO67C,EAAIhoC,EAAWg7G,GAAKlQ,EAAcpqG,EAAQV,EAAWg7G,GAKxE,OAAO7uH,K,kKCjgBf,aAEM8uH,EAAS,IAAI71H,EAAMuG,QAAQ,EAAG,EAAG,GACjCuvH,EAAS,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,GACzBC,EAAe,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAGjDC,EAAO/rH,KAAKyF,GADQ,EAa1B,SAASumH,EACL5vH,EACAC,EACA4vH,EACA5lH,EACA2K,EACAqrE,GAEA,MAAMnzB,EAAal4C,EAAS/Y,OAAS,EAGrC+Y,EAASnU,KAAKT,EAAGC,EAAG,GAEpB,IAAK,IAAItI,EAAI,EAAGA,EAAIm4H,IAAyBn4H,EAAG,CAC5C,MAAMo4H,EAAQJ,EAAOh4H,EAAIiM,KAAKyF,GAAK,EAAIwmH,EACvCj7G,EAASnU,KAAKT,EAAIiK,EAASrG,KAAKkH,IAAIilH,GAAQ9vH,EAAIgK,EAASrG,KAAKsH,IAAI6kH,GAAQ,GAE1E9vC,EAAQx/E,KACJqsD,EACAA,EAAan1D,EAAI,EACjBm1D,GAAen1D,EAAI,GAAK,EAA2B,IAW/D,2BAAgCyuB,GAC5B,OAAO0pG,GAaX,2BACIjkH,EACAmG,EACA4C,EACAqrE,EACA+vC,GAAkB,EAClBC,EAAgBD,GAEhB,GAAInkH,EAAOhQ,OAAS,EAChB,OAIJ,MAAMq0H,EAAW,IAAIv2H,EAAMoG,QAE3B,GAAIiwH,EAAiB,CAEjB,MAAMH,EACgB,IAAlBhkH,EAAOhQ,OACDq0H,EAAS3uH,IAAIsK,EAAO,GAAKA,EAAO,GAAIA,EAAO,GAAKA,EAAO,IAAIkkH,QAC3D,EAEVH,EAAU/jH,EAAO,GAAIA,EAAO,GAAIgkH,EAAW79G,EAAO4C,EAAUqrE,GAGhE,MAAMnzB,EAAal4C,EAAS/Y,OAAS,EAG/Bs0H,EAAS,IAAIx2H,EAAMuG,QACnBzG,EAAI,IAAIE,EAAMuG,QACd9G,EAAI,IAAIO,EAAMuG,QACdkwH,EAAK,IAAIz2H,EAAMuG,QACfmwH,EAAY,IAAI12H,EAAMuG,QACtB2E,EAAK,IAAIlL,EAAMuG,QACf4E,EAAK,IAAInL,EAAMuG,QACfowH,EAAK,IAAI32H,EAAMuG,QACfqwH,EAAK,IAAI52H,EAAMuG,QAEfswH,EAAI3kH,EAAOhQ,OAAS,EAE1B,IAAIsxD,EAAe,EACnB,IAAK,IAAIx1D,EAAI,EAAGA,EAAI64H,IAAK74H,EAAG,CACxB,IAAI84H,GAAW,EAGf,GAFAh3H,EAAE8H,IAAIsK,EAAW,EAAJlU,GAAQkU,EAAW,EAAJlU,EAAQ,GAAIkU,EAAW,EAAJlU,EAAQ,IAEnDA,EAAI,EAAI64H,EAAG,CAUX,GATAp3H,EAAEmI,IAAIsK,EAAiB,GAATlU,EAAI,IAASkU,EAAiB,GAATlU,EAAI,GAAS,GAAIkU,EAAiB,GAATlU,EAAI,GAAS,IAEzEy4H,EAAGvmH,KAAKzQ,GACHiU,IAAI5T,GACJ2R,YACA6F,MAAMu+G,GAEXa,EAAUxmH,KAAKumH,GAEXz4H,EAAI,IACJ04H,EAAU31H,IAAIy1H,GAAQhiH,eAAe,EAAM,GAAMiiH,EAAGngH,IAAIkgH,IAExDM,EAAWN,EAAOnkH,QAAQokH,GAAMxsH,KAAKyF,GAAK,EAEtConH,GAAU,CACV,MAAMC,EAAe1+G,EAAQpO,KAAKkH,IAAIslH,EAAGpkH,QAAQmkH,GAAU,GAE3DtrH,EAAGgF,KAAKumH,GACH11H,IAAIy1H,GACJ/kH,YACA+C,gBAAgBuiH,GAChBh2H,IAAIjB,GAETqL,EAAG+E,KAAKsmH,GACHhiH,eAAe6D,GACftX,IAAIjB,GAGT62H,EAAGzmH,KAAKumH,GACH11H,IAAIy1H,GACJ/kH,YACA+C,eAAeuiH,GACfh2H,IAAIjB,GAET82H,EAAG1mH,KAAKumH,GACHjiH,eAAe6D,GACftX,IAAIjB,GAIbg3H,EACA77G,EAASnU,KACLoE,EAAG7E,EACH6E,EAAG5E,EACH4E,EAAG1E,EACH2E,EAAG9E,EACH8E,EAAG7E,EACH6E,EAAG3E,EACHmwH,EAAGtwH,EACHswH,EAAGrwH,EACHqwH,EAAGnwH,EACHowH,EAAGvwH,EACHuwH,EAAGtwH,EACHswH,EAAGpwH,IAGP0E,EAAGgF,KAAKwmH,GACHliH,gBAAgB6D,GAChBtX,IAAIjB,GAETqL,EAAG+E,KAAKwmH,GACHliH,eAAe6D,GACftX,IAAIjB,GAETmb,EAASnU,KAAKoE,EAAG7E,EAAG6E,EAAG5E,EAAG4E,EAAG1E,EAAG2E,EAAG9E,EAAG8E,EAAG7E,EAAG6E,EAAG3E,IAGnDgwH,EAAOtmH,KAAKumH,QAEZvrH,EAAGgF,KAAKsmH,GACHhiH,gBAAgB6D,GAChBtX,IAAIjB,GAETqL,EAAG+E,KAAKsmH,GACHhiH,eAAe6D,GACftX,IAAIjB,GAETmb,EAASnU,KAAKoE,EAAG7E,EAAG6E,EAAG5E,EAAG4E,EAAG1E,EAAG2E,EAAG9E,EAAG8E,EAAG7E,EAAG6E,EAAG3E,GAG/CxI,IAAM64H,EAAI,KACTC,EAAWf,EAAeD,GAAQ70H,QAAQxC,GACvC6nF,EAAQx/E,KAAKqsD,EAAaK,EAAe/0D,IAE7C+0D,GAAgBsjE,EAAW,EAAI,GAIvC,GAAIR,EAAe,CACf,MAAMJ,EACgB,IAAlBhkH,EAAOhQ,OACDq0H,EACK3uH,IACGsK,EAAiB,GAAT2kH,EAAI,IAAU3kH,EAAiB,GAAT2kH,EAAI,IAClC3kH,EAAiB,GAAT2kH,EAAI,GAAS,GAAK3kH,EAAiB,GAAT2kH,EAAI,GAAS,IAElDT,QACLnsH,KAAKyF,GAEfumH,EACI/jH,EAAiB,GAAT2kH,EAAI,IACZ3kH,EAAiB,GAAT2kH,EAAI,GAAS,GACrBX,EACA79G,EACA4C,EACAqrE,KAYZ,2BAAgC0wC,EAAwBC,GACpD,MAAMC,EAAY,IAAI9kG,aAAa4kG,EAAS90H,OAAS,GAErD,IAAK,IAAIlE,EAAkB,EAAdi5H,EAAiBE,EAAS,EAAJn5H,EAAOA,EAAIk5H,EAAUh1H,OAAQlE,GAAK,EAAGm5H,GAAM,EAC1ED,EAAUl5H,GAAKg5H,EAASG,GAA0C,IAAnCH,EAASG,EAAK,GAAKH,EAASG,IAC3DD,EAAUl5H,EAAI,GAAKg5H,EAASG,EAAK,GAAiD,IAA3CH,EAASG,EAAK,EAAI,GAAKH,EAASG,EAAK,IAC5ED,EAAUl5H,EAAI,GAAKg5H,EAASG,EAAK,GAAiD,IAA3CH,EAASG,EAAK,EAAI,GAAKH,EAASG,EAAK,IAEhF,OAAOD,GASX,gCAAqCF,EAAwB95G,GACzD,MAAMk6G,EAAKJ,EAAsB,EAAb95G,EAAiB,GAAK85G,EAAsB,EAAb95G,GAC7Cm6G,EAAKL,EAAsB,EAAb95G,EAAiB,EAAI,GAAK85G,EAAsB,EAAb95G,EAAiB,GAClEo6G,EAAKN,EAAsB,EAAb95G,EAAiB,EAAI,GAAK85G,EAAsB,EAAb95G,EAAiB,GAExE,MAAgD,GAAzCjT,KAAK+H,KAAKolH,EAAKA,EAAKC,EAAKA,EAAKC,EAAKA,K,sICzP9C,aAEA,OACA,QAsCA,MAAatqC,UAAmChtF,EAAMm1B,KAalD,YACIra,EACAzP,EACA8kD,EACAtkC,EACAC,GAEAloB,WAAmBhB,IAAbkY,EAAyB,IAAI9a,EAAMob,eAAmBN,EAAUzP,QAErDzI,IAAbyI,IACAA,EAAW,IAAI,EAAAmkB,0BAA0B,CACrC3D,MAAOA,GAAgB,EAAA2D,0BAA0BnF,cACjDyB,aAAqBlpB,IAAZkpB,EAAwBA,EAAU,EAAA0D,0BAA0BjF,mBAI7E3pB,KAAKiwE,mBAAqB,IAAI7wE,EAAMsO,QAEhC6hD,GACAvvD,KAAK2qF,aAAap7B,GAI1B,qBACI,OAAOvvD,KAAKka,SAGhB,qBACI,OAAOla,KAAKyK,SAGhB,aAAa8kD,GACT,EAAAs5B,mBAAmB8B,aAAa3qF,KAAMuvD,GAG1C,oBACIvvD,KAAKosD,eAAiB,CAClBuqE,EACAC,EACAloH,EACAmoH,EACAC,EACAC,KAEA,EAAAluC,mBAAmBiC,iBAAiB9qF,KAAM0O,EAAQ1O,KAAK+qF,iBAI/D,kBAAkBoK,GACd,MAAM6hC,EAA6Bh3H,KAAKi3H,wBAA0B9hC,EAElEnyF,MAAM+R,kBAAkBogF,GAEpB6hC,GACAh3H,KAAKiwE,mBAAmB/7D,WAAWlU,KAAK+R,cAnEpD,+BA2EA,MAAas6E,UAA0BjtF,EAAM40B,KAazC,YACI9Z,EACAzP,EACA8kD,EACAtkC,EACAC,GAEAloB,WAAmBhB,IAAbkY,EAAyB,IAAI9a,EAAMob,eAAmBN,EAAUzP,QAErDzI,IAAbyI,IACAA,EAAW,IAAI,EAAAmkB,0BAA0B,CACrC3D,MAAOA,GAAgB,EAAA2D,0BAA0BnF,cACjDyB,aAAqBlpB,IAAZkpB,EAAwBA,EAAU,EAAA0D,0BAA0BjF,mBAI7E3pB,KAAKiwE,mBAAqB,IAAI7wE,EAAMsO,QAEhC6hD,GACAvvD,KAAK2qF,aAAap7B,GAI1B,qBACI,OAAOvvD,KAAKka,SAGhB,qBACI,OAAOla,KAAKyK,SAGhB,aAAa8kD,GACT,EAAAs5B,mBAAmB8B,aAAa3qF,KAAMuvD,GAG1C,oBACIvvD,KAAKosD,eAAiB,CAClBuqE,EACAC,EACAloH,EACAmoH,EACAC,EACAC,KAEA,EAAAluC,mBAAmBiC,iBAAiB9qF,KAAM0O,EAAQ1O,KAAK+qF,iBAI/D,kBAAkBoK,GACd,MAAM6hC,EAA6Bh3H,KAAKi3H,wBAA0B9hC,EAElEnyF,MAAM+R,kBAAkBogF,GAEpB6hC,GACAh3H,KAAKiwE,mBAAmB/7D,WAAWlU,KAAK+R,cAnEpD,uB,mHCrHA,MAEA,aAOA,QAQMvF,EAPN,KAOeC,cAAcxM,SAASvB,OAAO,cAM7C,MAAaw4H,EAuDT,YACcv2F,EACA/c,EACAuzG,EACAC,EACHzxG,GAJG,KAAAgb,aACA,KAAA/c,UACA,KAAAuzG,eACA,KAAAC,cACH,KAAAzxG,WAxDX,KAAAo4B,MAAyB,EAAAxd,gBAAgBoX,YAoB/B,KAAA0/E,oBAAsB,IAAIC,gBA4CpC,gBACI,OAAQt3H,KAAK+9C,OACT,KAAK,EAAAxd,gBAAgBg3F,QACrB,KAAK,EAAAh3F,gBAAgBsX,OACrB,KAAK,EAAAtX,gBAAgBi3F,SAEjB,OAAOx3H,KAAKy3H,YAEhB,KAAK,EAAAl3F,gBAAgB2E,MACrB,KAAK,EAAA3E,gBAAgB8E,OACrB,KAAK,EAAA9E,gBAAgBoX,YACrB,KAAK,EAAApX,gBAAgB6E,SAGjB,OADAplC,KAAK6gH,eACE7gH,KAAKy3H,aAUxB,cACI,OAAKz3H,KAAKy3H,YAGHz3H,KAAKy3H,YAFDx/E,QAAQqzB,QAAQtrE,KAAK+9C,OASpC,SACI,OAAQ/9C,KAAK+9C,OACT,KAAK,EAAAxd,gBAAgBg3F,QACjBv3H,KAAKq3H,oBAAoBK,QACzB13H,KAAKq3H,oBAAsB,IAAIC,gBAC/B,MAEJ,KAAK,EAAA/2F,gBAAgBi3F,SACbx3H,KAAKihG,oBACLjhG,KAAKihG,kBAAkBy2B,QACvB13H,KAAKihG,uBAAoBj/F,GAKrChC,KAAK23H,OAAO,EAAAp3F,gBAAgB6E,UAMhC,iBACI,OACIplC,KAAK+9C,QAAU,EAAAxd,gBAAgB2E,OAC/BllC,KAAK+9C,QAAU,EAAAxd,gBAAgB6E,UAC/BplC,KAAK+9C,QAAU,EAAAxd,gBAAgB8E,OAQvC,eAAe1f,GACX3lB,KAAK2lB,SAAWA,OACe3jB,IAA3BhC,KAAKihG,oBACLjhG,KAAKihG,kBAAkBt7E,SAAWA,GAOhC,eACN,MAAMiyG,EAA0B53H,KAAKq3H,oBAAoB71B,OACzDxhG,KAAKm3H,aACAxH,QAAQ3vH,KAAK4jB,QAASg0G,GACtB5yF,KAAK6yF,IACF,GAAID,EAAwBn2B,QAAS,CAEjC,MAAMC,EAAM,IAAIj+F,MAAM,WAEtB,MADAi+F,EAAI/jG,KAAO,aACL+jG,EAEV1hG,KAAK83H,SAASD,KAEjB1yF,MAAM5mB,IAEgB,eAAfA,EAAM5gB,MAA2C,wBAAlB4gB,EAAMusB,SAGzC9qC,KAAKmwB,QAAQ5R,UAGIvc,IAArBhC,KAAKy3H,cACLz3H,KAAKy3H,YAAc,IAAIx/E,QAAyB,CAACqzB,EAAS41B,KACtDlhG,KAAK+3H,mBAAqBzsD,EAC1BtrE,KAAKg4H,oBAAsB92B,KAGnClhG,KAAK+9C,MAAQ,EAAAxd,gBAAgBg3F,QAQvB,SAASM,GACf73H,KAAK+9C,MAAQ,EAAAxd,gBAAgBsX,OAC7B73C,KAAK63H,QAAUA,EAII,IAFCA,EAA4BI,YAG3CJ,EAAQvD,cAAgBx2H,QAA0C,IAAhCA,OAAO89D,KAAKi8D,GAASv2H,OAGxDtB,KAAK23H,OAAO,EAAAp3F,gBAAgB2E,OAKhCllC,KAAKk4H,kBAMC,kBACN,MAAML,EAAU73H,KAAK63H,QACrB,QAAgB71H,IAAZ61H,EAEA,YADArrH,EAAO+R,MAAM,6DAIjBve,KAAK+9C,MAAQ,EAAAxd,gBAAgBi3F,SAC7Bx3H,KAAK63H,aAAU71H,EAIf,MAAMi/F,EAAoB,IAAI,EAAAU,kBAAkB3hG,KAAK2lB,UACrD3lB,KAAKihG,kBAAoBA,EAEzB,MAAMtgE,EAAa3gC,KAAK2gC,WACxB3gC,KAAKo3H,YACAe,WAAWN,EAAS73H,KAAK4jB,QAAS+c,EAAWxxB,WAAY8xF,GACzDj8D,KAAKnB,IACEo9D,EAAkBO,OAAOC,SAK7BzhG,KAAKo4H,UAAUv0F,KAElBsB,MAAM5mB,IAEgB,eAAfA,EAAM5gB,MAA2C,wBAAlB4gB,EAAMusB,SAIzC9qC,KAAKmwB,QAAQ5R,KASf,UAAUslB,GAChB7jC,KAAK6jC,YAAcA,EACnB7jC,KAAK23H,OAAO,EAAAp3F,gBAAgB2E,OAMtB,sBACyBljC,IAA3BhC,KAAKihG,oBAELjhG,KAAKihG,kBAAkBy2B,QACvB13H,KAAKihG,uBAAoBj/F,GAUvB,OAAOq2H,GACTr4H,KAAK+3H,oBAAsBM,IAAc,EAAA93F,gBAAgB2E,MACzDllC,KAAK+3H,mBAAmBM,GACjBr4H,KAAKg4H,qBACZh4H,KAAKg4H,oBAAoBK,GAE7Br4H,KAAK+3H,wBAAqB/1H,EAC1BhC,KAAKg4H,yBAAsBh2H,EAC3BhC,KAAKy3H,iBAAcz1H,EACnBhC,KAAK+9C,MAAQs6E,EAQP,QAAQ95G,GACd,GAAIve,KAAK+9C,QAAU,EAAAxd,gBAAgB6E,SAG/B,OAEJ,MAAMzE,EAAa3gC,KAAK2gC,WACxBn0B,EAAO+R,MACH,IAAIoiB,EAAWhjC,8BAA8BqC,KAAK4jB,QAAQO,eAC1D5F,GAGJve,KAAKue,MAAQA,EAEbve,KAAK23H,OAAO,EAAAp3F,gBAAgB8E,SAxSpC,eAgTA,+BAAoC6xF,EAItB,kBACN,MAAMW,EAAU73H,KAAK63H,QACrB,QAAgB71H,IAAZ61H,EAEA,YADArrH,EAAO+R,MAAM,iEAIjBve,KAAK+9C,MAAQ,EAAAxd,gBAAgBi3F,SAC7Bx3H,KAAK63H,aAAU71H,EAIf,MAAMi/F,EAAoB,IAAI,EAAAU,kBAAkB3hG,KAAK2lB,UACrD3lB,KAAKihG,kBAAoBA,EAEzB,MAAMtgE,EAAa3gC,KAAK2gC,WACxB3gC,KAAKo3H,YACAkB,YAAYT,EAAS73H,KAAK4jB,QAAS+c,EAAWxxB,WAAY8xF,GAC1Dj8D,KAAKgC,IACEi6D,EAAkBO,OAAOC,UAI7BzhG,KAAKgnC,SAAWA,EAEhBhnC,KAAK23H,OAAO,EAAAp3F,gBAAgB2E,UAE/BC,MAAM5mB,IAEgB,eAAfA,EAAM5gB,MAA2C,wBAAlB4gB,EAAMusB,SAIzC9qC,KAAKmwB,QAAQ5R,Q,gOC3W7B,MAGA,eAGM/R,EAFN,KAEeC,cAAcxM,SAASvB,OAAO,iBAG7C,IAAY65H,EA8HAC,GA9HZ,SAAYD,GAoBR,uBAgBA,2BAgBA,uBAgBA,yBAgBA,uBAgBA,2BAgBA,2BApHJ,CAAYA,EAAA,EAAAA,YAAA,EAAAA,UAAS,KA8HrB,SAAYC,GACR,iCACA,iDAFJ,CAAYA,EAAA,EAAAA,uBAAA,EAAAA,qBAAoB,KAenB,EAAAC,yBAAqD,CAC9DC,OAAQF,EAAqBG,oBAC7Bh7H,KAAM,UAQG,EAAAi7H,2BAAuD,CAChEF,OAAQF,EAAqBK,YAC7Bl7H,KAAM,OAGG,EAAAm7H,8BAA0D,CACnEJ,OAAQF,EAAqBK,YAC7Bl7H,KAAM,gBAiGV,sBAII,YAAqB0f,GAAA,KAAAA,SACjBrd,KAAK+4H,qBAC0B/2H,IAA3Bqb,EAAO07G,gBACD,EAAAC,gBAAgB/4H,WAChBod,EAAO07G,gBACjB/4H,KAAKi5H,eAAiCj3H,IAArBqb,EAAO47G,UAA0B,GAAK57G,EAAO47G,UAIlE,iBAKA,QACI,OAAO,EA+BX,cACIr1G,EACAs1G,GAEA,MAAM/jB,EAAoB,CAAE3T,OAAQ03B,GAEpC,IAAIC,EAAUn5H,KAAKo5H,QAAQx1G,GAE3B,MAAMy1G,QAA2Br5H,KAAKs5H,8BAKtC,OAHAH,EAAUn5H,KAAKu5H,cAAcJ,EAAShkB,EAAMkkB,GAC5CF,EAAUn5H,KAAKw5H,eAAeL,EAASn5H,KAAKi5H,WAExCj5H,KAAKqd,OAAOo8G,YAAclB,EAAUmB,QAC7B15H,KAAK+4H,gBAAgBY,aAAaR,EAAShkB,GAG/Cn1G,KAAK+4H,gBAAgBa,oBAAoBT,EAAShkB,GAMrD,oCACJ,MAA8C,iBAAnCn1G,KAAKqd,OAAOg8G,mBACZr5H,KAAKqd,OAAOg8G,wBACuBr3H,IAAnChC,KAAKqd,OAAOg8G,mBACZr5H,KAAKqd,OAAOg8G,0BAEmBr3H,IAA/BhC,KAAKqd,OAAOw8G,eAEZ75H,KAAKqd,OAAOw8G,sBAEnB,EAOA,uBAEJ,QAAmC73H,IAA/BhC,KAAKqd,OAAOw8G,eACZ,OAAO,EAAApB,yBAGX,OAAQz4H,KAAKqd,OAAOo8G,WAChB,KAAKlB,EAAUuB,OACX,OAAO,EAAArB,yBACX,KAAKF,EAAUwB,SACf,KAAKxB,EAAUyB,OACf,KAAKzB,EAAU0B,OACf,KAAK1B,EAAU2B,SACf,KAAK3B,EAAUmB,QACX,OAAO,EAAAZ,8BACX,KAAKP,EAAU4B,SACX,OAAO,EAAAvB,2BACX,QAII,YAHApsH,EAAOuJ,KACH,oDAAoD/V,KAAKqd,OAAOo8G,cAcxE,cAAch2E,EAAa0xD,EAAmBkkB,GAClD,QAA2Br3H,IAAvBq3H,EACA,OAAO51E,EAEX,MAAM22E,EAAap6H,KAAKqd,OAAOg9G,sBAAwBr6H,KAAKs6H,uBAC5D,QAAmBt4H,IAAfo4H,EACA,OAAO32E,EAGX,GAAI22E,EAAW1B,SAAWF,EAAqBG,oBAAqB,MAC3C32H,IAAjBmzG,EAAKolB,UACLplB,EAAKolB,QAAU,IAAIC,SAEvB,MAAMC,EAAWL,EAAWz8H,MAAQ,SACnCw3G,EAAKolB,QAAoBG,OAAO,gBAAiB,GAAGD,KAAYpB,UAC9D,GAAIe,EAAW1B,SAAWF,EAAqBK,YAAa,CAC/D,MACM8B,EAAwC,GAC9CA,EAFyBP,EAAWz8H,MAAQ,gBAErB07H,EACvB51E,EAAMzjD,KAAKw5H,eAAe/1E,EAAKk3E,GAEnC,OAAOl3E,EAMH,QAAQ7/B,GACZ,QAAwB5hB,IAApBhC,KAAKqd,OAAOomC,IACZ,OAAOzjD,KAAKqd,OAAOomC,IACdr3C,QAAQ,MAAOyjD,OAAOjsC,EAAQqY,SAC9B7vB,QAAQ,MAAOyjD,OAAOjsC,EAAQoY,MAC9B5vB,QAAQ,MAAOyjD,OAAOjsC,EAAQhI,QAEvC,IAAIsL,EAAO,CAAC,IAAItD,EAAQhI,QAASgI,EAAQqY,OAAQrY,EAAQoY,KAAKo6C,KAC1Dp2E,KAAKqd,OAAOo8G,YAAclB,EAAU2B,UAChCl6H,KAAKqd,OAAOo8G,YAAclB,EAAUmB,QAClC,IACA,KAEV,OAAQ15H,KAAKqd,OAAOo8G,WAChB,KAAKlB,EAAUuB,OACf,KAAKvB,EAAUyB,OACX9yG,GAAQ,OACR,MACJ,KAAKqxG,EAAUwB,SAGf,KAAKxB,EAAU0B,OACX/yG,GAAQ,OACR,MACJ,KAAKqxG,EAAUmB,QACX,MACJ,KAAKnB,EAAU2B,SACXhzG,GAAQ,OACR,MACJ,KAAKqxG,EAAU4B,SACXjzG,GAAQ,OACR,MACJ,QACI1a,EAAOuJ,KAAK,6BAA6B/V,KAAKqd,OAAOo8G,aAI7D,OAAOz5H,KAAKqd,OAAOkmC,QAAUr8B,EAGzB,eAAeu8B,EAAam3E,GAChC,IAAIC,EAAc,GACdC,GAAqC,IAAtBr3E,EAAI9wB,QAAQ,KAAc,IAAM,IAQnD,OAPA70B,OAAOy0B,oBAAoBqoG,GAAav6H,QAAQtB,IAE5C87H,GAAeC,EADF/7H,EACwB,IAAM67H,EAD9B77H,GAEQ,MAAjB+7H,IACAA,EAAe,OAGhBr3E,EAAMo3E,K,8EC9crB,aACA,QACA,SACA,SAGMn8D,EAAQ,EAAQ,KAEtB,OAEA,MAAMq8D,EAAS,4BAGf1hB,SAAS2hB,cAAiC,kBAAmB34B,KAAO04B,EAAS,mBAC7E1hB,SAAS2hB,cAAiC,cAAe34B,KAAO04B,EAAS,cACzE1hB,SAAS2hB,cAAiC,aAAc34B,KAAO04B,EAAS,cACxE1hB,SAAS2hB,cAAiC,iBAAkB34B,KAAO04B,EAAS,mBAC5E1hB,SAAS2hB,cAAiC,oBAAqB34B,KAAO04B,EAAS,cAG9E1hB,SAAS4hB,eAAe,QAA2BC,UAAY,IAAG,IAAItxD,MAAOuxD,gBAE9E,MAAMC,EAAW,CACb,CACIC,KAAM,SACNC,KAAM,SACNC,QAAS,eAGXC,EAAWniB,SAAS2hB,cAAc,yBAExC1yD,MAAM,mBACDtjC,KAAKy2F,GAAOA,EAAI75H,QAChBojC,KAAKy2F,IACFL,EAASl1H,QAAQu1H,GACjBL,EAAS/6H,QAAQq7H,IACb,MAAM30C,EAASsyB,SAASC,cAAc,UACtCvyB,EAAOm0C,UAAYQ,EAAQH,QAC3BC,EAASG,YAAY50C,KAGzBy0C,EAASI,SAAW,KAChB,MAAMC,EAAWL,EAASR,cAAiC,kBACrDU,EAAUN,EAASljG,KAAKzyB,GAAKA,EAAE81H,UAAYM,EAASX,WAC1D,IAAKQ,EACD,OAEJ,MAAMJ,EAAOI,EAAQJ,KACfC,EAAUG,EAAQH,QAGxBliB,SAAS2hB,cAAiC,kBAAmB34B,KACzD04B,EAASO,EAAO,aACpBjiB,SAAS2hB,cAAiC,kBAAmBE,UACzD,YAAuB,WAATI,EAAoB,KAAKC,KAAa,IAGxDliB,SAAS2hB,cAAiC,cAAe34B,KAAO04B,EAASO,EAAO,QAChFjiB,SAAS2hB,cAAiC,cAAeE,UACrD,iBAA4B,WAATI,EAAoB,KAAKC,KAAa,OAGpEp2F,MAAM,KAEH,MAAM4hD,EAASsyB,SAASC,cAAc,UACtCvyB,EAAOm0C,UAAY,SACnBM,EAASG,YAAY50C,KAG7B,WACI,MAAMv4C,EAAS6qE,SAAS4hB,eAAe,OACjCl1H,EAAM,IAAI,EAAA44D,QAAQ,CACpBnwB,SACAi0B,WAAY,oBACZ/D,MAAQA,EACRV,0BAA2B,GAC3B8H,gBAAgB,EAChB5H,cAAe,MAEnBn4D,EAAIg3E,yBAAyB/9D,SAAU,EAEvC,MAAM88G,EAAgB,IAAI,EAAAC,cAAc,CACpCx4E,QAAS,oDACTk2E,UAAW,EAAAlB,UAAUyB,OACrBzzD,aAAc,UACd8yD,mBAAoB,EAAA2C,OACpB3B,qBAAsB,CAClB3B,OAAQ,EAAAF,qBAAqBK,YAC7Bl7H,KAAM,UAEV6mC,cAAA,EAAAA,gBAEJz+B,EAAIugE,cAAcw1D,GAElB/1H,EAAIkvE,OAAOhpC,OAAOgwF,WAAY,KAC9BhwF,OAAO83B,iBAAiB,SAAU,IAAMh+D,EAAIkvE,OAAOhpC,OAAOgwF,WAAY,MAEtE,MAAMrlH,EAAY,EAAA5I,aAAa0R,+BAA+B3Z,EAAK,MAE7DkQ,EAAU,CAAE1H,OADH,IAAI,EAAArG,eAAe,WAAY,WACZ0O,YAAWjI,KAAM,KAAMC,QAAS,KAClE7I,EAAIgJ,OAAOkH,GAEXlQ,EAAIg+D,iBAAiB,EAAAlI,kBAAkBa,cAAe,KAClDluB,EAAOzoB,MAAMmF,QAAU,IAEvBnlB,EAAIg+D,iBAAiB,EAAAlI,kBAAkBO,OAAQ,IAC3Cr2D,EAAIgJ,OAAO,CAAEH,QAAS7I,EAAI6I,QAAU,MAExCqnE,WAAW,KACPlwE,EAAIm2H,kBACL,MAIXC,I,0GClGA,8BAAmC90H,GAC/B,OACIA,GACe,iBAARA,GACqB,iBAArBA,EAAI4tB,cACkB,iBAAtB5tB,EAAI6tB,gB,0GCvBnB,cACA,OAEA,QACA,OACA,QAEA,QAEA,OAEA,MAAMknG,UAA2B,EAAAviG,WAAjC,c,oBAEa,KAAAjqB,KAAuB,EAAAC,eAAeC,OAG/C,eAAe0rB,GACX,OAAO,EAIX,YACIrG,EACAE,EACAlvB,GAWA,OATKA,IACDA,EAAU,IAAI/G,EAAMm7B,MAExBp0B,EAAOyD,IAAInE,GAAK4D,KAAKyF,GACrB3I,EAAOyD,IAAIlE,EAAe,IAAV2D,KAAKyF,GACrB3I,EAAOyD,IAAIhE,EAAIuvB,EACfhvB,EAAO2D,IAAIrE,EAAI4D,KAAKyF,GACpB3I,EAAO2D,IAAIpE,EAAc,GAAV2D,KAAKyF,GACpB3I,EAAO2D,IAAIlE,EAAIyvB,EACRlvB,EAIX,aACIwC,EACAxC,GASA,OAPKA,IAEDA,EAAS,CAAEV,EAAG,EAAGC,EAAG,EAAGE,EAAG,IAE9BO,EAAOV,EAAIrG,EAAMkJ,UAAUW,SAASN,EAASP,WAC7CjC,EAAOT,EAAItG,EAAMkJ,UAAUW,SAASN,EAASR,UAC7ChC,EAAOP,EAAI+C,EAASN,UAAY,EACzBlC,EAIX,eAAek0B,GAEX,OADiB,EAAAnyB,eAAeyyB,YAAYN,EAAW30B,EAAG20B,EAAW50B,EAAG40B,EAAWz0B,GAKvF,kBAAkBy0B,GACd,OAAOA,EAAWz0B,EAItB,WACIswB,EACA/vB,GAEKA,IACDA,EAAU,IAAI/G,EAAMm7B,MAExB,MAAM3wB,EAAM5J,KAAKyQ,aACb,IAAI,EAAAvI,eAAeguB,EAAOzZ,MAAOyZ,EAAOrZ,KAAMqZ,EAAOf,cAEnDrrB,EAAM9J,KAAKyQ,aACb,IAAI,EAAAvI,eAAeguB,EAAO1Z,MAAO0Z,EAAOtZ,KAAMsZ,EAAOb,cAoBzD,OAlBI,EAAA4F,WAAW90B,IACXA,EAAOyD,IAAInE,EAAImE,EAAInE,EACnBU,EAAOyD,IAAIlE,EAAIkE,EAAIlE,EACnBS,EAAOyD,IAAIhE,EAAIgE,EAAIhE,EACnBO,EAAO2D,IAAIrE,EAAIqE,EAAIrE,EACnBU,EAAO2D,IAAIpE,EAAIoE,EAAIpE,EACnBS,EAAO2D,IAAIlE,EAAIkE,EAAIlE,GACZ,EAAAs1B,mBAAmB/0B,KAC1B,EAAAmC,UAAUyB,WAAW,EAAG,EAAG,EAAG5D,EAAOyH,OACrC,EAAAtF,UAAUyB,WAAW,EAAG,EAAG,EAAG5D,EAAO0H,OACrC,EAAAvF,UAAUyB,WAAW,EAAG,EAAG,EAAG5D,EAAO2H,OACrC3H,EAAO4H,SAAStI,EAAsB,IAAjBmE,EAAInE,EAAIqE,EAAIrE,GACjCU,EAAO4H,SAASrI,EAAsB,IAAjBkE,EAAIlE,EAAIoE,EAAIpE,GACjCS,EAAO4H,SAASnI,EAAsB,IAAjBgE,EAAIhE,EAAIkE,EAAIlE,GACjCO,EAAO6e,QAAQvf,EAAsB,IAAjBqE,EAAIrE,EAAImE,EAAInE,GAChCU,EAAO6e,QAAQtf,EAAsB,IAAjBoE,EAAIpE,EAAIkE,EAAIlE,GAChCS,EAAO6e,QAAQpf,EAAIyD,KAAKS,IAAIge,OAAOqT,QAA2B,IAAjBrxB,EAAIlE,EAAIgE,EAAIhE,KAEtDO,EAIX,aAAai1B,GACT,MAAMC,EAASr7B,KAAKmW,eAAeilB,EAASxxB,KACtC0xB,EAASt7B,KAAKmW,eAAeilB,EAAStxB,KAC5C,OAAO,EAAA+qB,OAAO0G,gBAAgBF,EAAQC,GAI1C,eAAejB,GACX,OAAOA,EAAWz0B,EAItB,oBAAoBy0B,GAEhB,OADAA,EAAWz0B,EAAI,EACRy0B,EAIX,cAAcmB,EAA0BjmB,GAQpC,YAPevT,IAAXuT,EACAA,EAAS,CAAE9P,EAAG,EAAGC,EAAG,EAAGE,EAAG,IAE1B2P,EAAO9P,EAAI,EACX8P,EAAO7P,EAAI,EACX6P,EAAO3P,EAAI,GAER2P,GAOF,EAAA8mH,mBAAiC,IAAID,EAAmB,I,wGCpIrE,aACA,QACA,QACA,OACA,QAGA,QACA,QACA,QAEA,OA8BA,SAASE,EAAqBl0H,GAC1B,MAAMm0H,EAAY,EAAIlzH,KAAKyF,GACrB0tH,EAAgBnzH,KAAKmtB,MAAM,GAAKpuB,EAAYm0H,EAAY,IAC9D,OAAOn9H,EAAMkJ,UAAU6B,MAAMqyH,EAAe,EAAG,GAGnD,SAASC,EAAgBpiG,GAIrB,OAHUhxB,KAAK+H,KACXipB,EAAW50B,EAAI40B,EAAW50B,EAAI40B,EAAW30B,EAAI20B,EAAW30B,EAAI20B,EAAWz0B,EAAIy0B,EAAWz0B,GAW9F,SAAS82H,EACLxmG,EACAkF,EACAnW,GAEA,MAAM03G,EAAiE,IAAzC13G,GAAaiR,EAAOb,aAAe,IAE3DunG,EAAex9H,EAAMkJ,UAAUW,SAASitB,EAAOrZ,MAC/CggH,EAAez9H,EAAMkJ,UAAUW,SAASitB,EAAOtZ,MAE/CkgH,EAAuBR,EAAqBM,GAC5CG,EAAuBT,EAAqBO,GAElD,IAAIG,EAAO3zH,KAAKkH,IAAIqsH,GAChBK,EAAOD,EACPE,EAAO7zH,KAAKsH,IAAIisH,GAChBO,EAAOD,EAEX,IACI,IAAIV,EAAgBM,EAAuB,EAC3CN,GAAiBO,EACjBP,IACF,CAEE,MAAM/2H,GAAM+2H,EAAgB,EAAK,KAAuB,EAAhBA,GAAqB,GAC7DQ,EAAO3zH,KAAKO,IAAInE,EAAGu3H,GACnBC,EAAO5zH,KAAKS,IAAIrE,EAAGw3H,GAGnB,MAAMv3H,GAAqB,EAAhB82H,KAAuC,EAAhBA,GAAqB,GACvDU,EAAO7zH,KAAKO,IAAIlE,EAAGw3H,GACnBC,EAAO9zH,KAAKS,IAAIpE,EAAGy3H,GAGvB,MAAMC,EAAkB/zH,KAAKkH,IAAIssH,GACjCG,EAAO3zH,KAAKO,IAAIwzH,EAAiBJ,GACjCC,EAAO5zH,KAAKS,IAAIszH,EAAiBH,GAEjC,MAAMI,EAAkBh0H,KAAKsH,IAAIksH,GACjCK,EAAO7zH,KAAKO,IAAIyzH,EAAiBH,GACjCC,EAAO9zH,KAAKS,IAAIuzH,EAAiBF,GAEjC,MAAMG,GAAWL,EAAOD,GAAQL,EAC1BY,GAAWN,EAAOD,GAAQL,EAE1Ba,GAAWL,EAAOD,GAAQP,EAC1Bc,GAAWN,EAAOD,GAAQP,EAG1Be,EAAct+H,EAAMkJ,UAAUW,SAASitB,EAAOzZ,OAC9CkhH,EAAcv+H,EAAMkJ,UAAUW,SAASitB,EAAO1Z,OAE9CohH,EAAOv0H,KAAKsH,IAAIgtH,GAChBE,EAAOx0H,KAAKsH,IAAI+sH,GAEhBI,GAAWF,EAAOC,GAAQlB,EAC1BoB,GAAWH,EAAOC,GAAQlB,EAShC,OAPAvhG,EAASxxB,IAAInE,EAAI63H,EAAUC,EAC3BniG,EAASxxB,IAAIlE,EAAI83H,EAAUC,EAC3BriG,EAASxxB,IAAIhE,EAAIk4H,EAAUC,EAC3B3iG,EAAStxB,IAAIrE,EAAI63H,EAAUC,EAC3BniG,EAAStxB,IAAIpE,EAAI83H,EAAUC,EAC3BriG,EAAStxB,IAAIlE,EAAIk4H,EAAUC,EAEpB3iG,EAwBX,MAAM4iG,UAAyB,EAAAnkG,WAA/B,c,oBAEa,KAAAjqB,KAAuB,EAAAC,eAAee,UAG/C,YACIqtH,EACAlqG,EACA5tB,EAAkB,IAAI/G,EAAMm7B,MAE5B,MAAM7qB,EAAS1P,KAAKilB,UAAY8O,EAOhC,OANA5tB,EAAOyD,IAAInE,GAAKiK,EAChBvJ,EAAOyD,IAAIlE,GAAKgK,EAChBvJ,EAAOyD,IAAIhE,GAAK8J,EAChBvJ,EAAO2D,IAAIrE,EAAIiK,EACfvJ,EAAO2D,IAAIpE,EAAIgK,EACfvJ,EAAO2D,IAAIlE,EAAI8J,EACRvJ,EAIX,aACIwC,EACAxC,EAA2B,EAAAmC,UAAUyB,WAAW,EAAG,EAAG,IAEtD,OAxCR,SACIpB,EACAu1H,EACAj5G,GAEA,MAAMvV,EAASuV,GAAatc,EAASN,UAAY,GAC3CF,EAAW/I,EAAMkJ,UAAUW,SAASN,EAASR,UAC7CC,EAAYhJ,EAAMkJ,UAAUW,SAASN,EAASP,WAC9C+1H,EAAc90H,KAAKkH,IAAIpI,GAI7B,OAHA+1H,EAAWz4H,EAAIiK,EAASyuH,EAAc90H,KAAKkH,IAAInI,GAC/C81H,EAAWx4H,EAAIgK,EAASyuH,EAAc90H,KAAKsH,IAAIvI,GAC/C81H,EAAWt4H,EAAI8J,EAASrG,KAAKsH,IAAIxI,GAC1B+1H,EA4BI38E,CAAQ54C,EAAUxC,EAAQnG,KAAKilB,WAI1C,eAAezT,GACX,MAAM4sH,EAAmB5sH,EAAM/L,EAAI+L,EAAM/L,EAAI+L,EAAM9L,EAAI8L,EAAM9L,EACvD24H,EAAiBh1H,KAAK+H,KAAKgtH,GAC3Bj9H,EAAIqQ,EAAM5L,EAAIy4H,EAEpB,GAAIn1H,MAAM/H,GACN,OAAO,EAAA+G,eAAeyyB,YAAY,EAAG,GAAI36B,KAAKilB,WAGlD,MAAMvV,EAASrG,KAAK+H,KAAKgtH,EAAmB5sH,EAAM5L,EAAI4L,EAAM5L,GAE5D,OAAO,EAAAsC,eAAeyyB,YAClBtxB,KAAKoX,KAAKtf,GACVkI,KAAKmN,MAAMhF,EAAM9L,EAAG8L,EAAM/L,GAC1BiK,EAAS1P,KAAKilB,WAKtB,kBAAkBzT,GACd,MAAM4sH,EAAmB5sH,EAAM/L,EAAI+L,EAAM/L,EAAI+L,EAAM9L,EAAI8L,EAAM9L,EAAI8L,EAAM5L,EAAI4L,EAAM5L,EACjF,OAAOyD,KAAK+H,KAAKgtH,GAAoB,EAAApxH,eAAeC,kBAIxD,WACIipB,EACA/vB,EAAkB,IAAI/G,EAAMm7B,MAE5B,GAAI,EAAAU,WAAW90B,GACX,OAAOu2H,EAASxmG,EAAQ/vB,EAAQnG,KAAKilB,WAClC,GAAI,EAAAiW,mBAAmB/0B,GAAS,CACnC,GAAI+vB,EAAOhB,eAAiB,GAAI,CAC5B,MAAMijB,EAASukF,EAASxmG,EAAQ,IAAI92B,EAAMm7B,KAAoBv6B,KAAKilB,WAUnE,OATA,EAAA3c,UAAUyB,WAAW,EAAG,EAAG,EAAG5D,EAAOyH,OACrC,EAAAtF,UAAUyB,WAAW,EAAG,EAAG,EAAG5D,EAAO0H,OACrC,EAAAvF,UAAUyB,WAAW,EAAG,EAAG,EAAG5D,EAAO2H,OACrC3H,EAAO4H,SAAStI,EAAoC,IAA/B0yC,EAAOruC,IAAIrE,EAAI0yC,EAAOvuC,IAAInE,GAC/CU,EAAO4H,SAASrI,EAAoC,IAA/ByyC,EAAOruC,IAAIpE,EAAIyyC,EAAOvuC,IAAIlE,GAC/CS,EAAO4H,SAASnI,EAAoC,IAA/BuyC,EAAOruC,IAAIlE,EAAIuyC,EAAOvuC,IAAIhE,GAC/CO,EAAO6e,QAAQvf,EAAoC,IAA/B0yC,EAAOruC,IAAIrE,EAAI0yC,EAAOvuC,IAAInE,GAC9CU,EAAO6e,QAAQtf,EAAoC,IAA/ByyC,EAAOruC,IAAIpE,EAAIyyC,EAAOvuC,IAAIlE,GAC9CS,EAAO6e,QAAQpf,EAAoC,IAA/BuyC,EAAOruC,IAAIlE,EAAIuyC,EAAOvuC,IAAIhE,GACvCO,EAGX,MAAM,MAAEsW,EAAK,KAAEI,EAAI,MAAEL,EAAK,KAAEI,EAAMK,OAAQmsB,GAAQlT,EAC5CooG,EAAOl1F,EAAIhhC,UACXm2H,EAAOn1F,EAAIjhC,SACXq2H,EAAWn1H,KAAKkH,IAAInR,EAAMkJ,UAAUW,SAASwT,IAC7CgiH,EAAWp1H,KAAKsH,IAAIvR,EAAMkJ,UAAUW,SAASwT,IAC7CiiH,EAAUr1H,KAAKkH,IAAInR,EAAMkJ,UAAUW,SAAS4T,IAC5C8hH,EAAUt1H,KAAKsH,IAAIvR,EAAMkJ,UAAUW,SAAS4T,IAC5C+hH,EAAWv1H,KAAKkH,IAAInR,EAAMkJ,UAAUW,SAASuT,IAC7CqiH,EAAWx1H,KAAKsH,IAAIvR,EAAMkJ,UAAUW,SAASuT,IAC7CsiH,EAAUz1H,KAAKkH,IAAInR,EAAMkJ,UAAUW,SAAS2T,IAC5CmiH,EAAU11H,KAAKsH,IAAIvR,EAAMkJ,UAAUW,SAAS2T,IAC5CoiH,EAAU31H,KAAKkH,IAAInR,EAAMkJ,UAAUW,SAASq1H,IAC5CW,EAAU51H,KAAKsH,IAAIvR,EAAMkJ,UAAUW,SAASq1H,IAC5CY,EAAU71H,KAAKkH,IAAInR,EAAMkJ,UAAUW,SAASs1H,IAC5CY,EAAU91H,KAAKsH,IAAIvR,EAAMkJ,UAAUW,SAASs1H,IAWlD,IAAI9mH,EACAu9B,EACAlZ,EARJ,EAAAxzB,UAAUyB,WAAWi1H,EAAUE,EAASD,EAAUC,EAASC,EAASh5H,EAAO2H,OAG3E,EAAAxF,UAAUyB,YAAYk1H,EAASD,EAAS,EAAG74H,EAAOyH,OAClD,EAAAtF,UAAUyB,YAAYi1H,EAAUG,GAAUF,EAAUE,EAASD,EAAS/4H,EAAO0H,OAMzE4O,GAAS,GAEThF,EAAQpO,KAAK2S,IACTwiH,GAAYQ,GAAWL,EAAUI,GAAWE,GAAWH,EAAUJ,KAIrE1pF,EAAOkqF,EAAUT,EAAWU,EAAUX,EAGtC1iG,EACIojG,EAAUL,EACVM,EAAUP,GAAYI,EAAUF,EAAUG,EAAUF,KAEpDviH,GAAS,GAET/E,EAAQpO,KAAK2S,IACT4iH,GAAYI,GAAWL,EAAUI,GAAWE,GAAWH,EAAUJ,KAIrE5iG,EAAOojG,EAAUL,EAAWM,EAAUP,IAGtCnnH,EAAQpO,KAAK2S,IAAIgjH,GAAWL,EAAUI,GAAWE,GAAWH,EAAUJ,IAGtE5iG,EACIojG,EAAUL,EACVM,EAAUP,GAAYK,EAAUF,EAAUC,EAAUF,IAI5D9pF,EACIkqF,EAAUT,EACVU,EAAUX,GAAYQ,EAAUF,EAAUG,EAAUF,IAG5D,MAAMK,EAAsD,IAA9Cp/H,KAAKilB,WAAaiR,EAAOb,aAAe,IAChDgqG,EAAsD,IAA9Cr/H,KAAKilB,WAAaiR,EAAOf,aAAe,IAIhDz3B,EAAIwhI,GAAWF,EAAUF,EAAUG,EAAUF,GAE7C9tC,EAAO5nF,KAAKO,IACdg1H,EAAWlhI,EAAImhI,EAAWM,EAC1BX,EAAW9gI,EAAI+gI,EAAWU,GAkB9B,OAfA,EAAA72H,UAAUyB,WACN0N,EAAQ2nH,GACPtjG,EAAOkZ,GAAQoqF,EAChBA,EAAOnuC,EAAOouC,EACdl5H,EAAO6e,SAGX,EAAA1c,UAAUyB,WAAW,GAAIirC,EAAOlZ,GAAQsjG,EAAMA,EAAOA,EAAMj5H,EAAO4H,UAtS9E,SACIH,EACAC,EACAC,EACA3M,GAEA,MAAMsE,EAAImI,EAAMnI,EAAItE,EAAEsE,EAAIoI,EAAMpI,EAAItE,EAAEuE,EAAIoI,EAAMrI,EAAItE,EAAEyE,EAChDF,EAAIkI,EAAMlI,EAAIvE,EAAEsE,EAAIoI,EAAMnI,EAAIvE,EAAEuE,EAAIoI,EAAMpI,EAAIvE,EAAEyE,EAChDA,EAAIgI,EAAMhI,EAAIzE,EAAEsE,EAAIoI,EAAMjI,EAAIzE,EAAEuE,EAAIoI,EAAMlI,EAAIzE,EAAEyE,EACtDzE,EAAEsE,EAAIA,EACNtE,EAAEuE,EAAIA,EACNvE,EAAEyE,EAAIA,EA6RE03G,CAAMn3G,EAAOyH,MAAOzH,EAAO0H,MAAO1H,EAAO2H,MAAO3H,EAAO4H,UAEvD5H,EAAO4H,SAAStI,EAAIU,EAAO4H,SAAStI,EAAIU,EAAO2H,MAAMrI,EAAIU,EAAO6e,QAAQpf,EACxEO,EAAO4H,SAASrI,EAAIS,EAAO4H,SAASrI,EAAIS,EAAO2H,MAAMpI,EAAIS,EAAO6e,QAAQpf,EACxEO,EAAO4H,SAASnI,EAAIO,EAAO4H,SAASnI,EAAIO,EAAO2H,MAAMlI,EAAIO,EAAO6e,QAAQpf,EAEjEO,EAGX,MAAM,IAAI1C,MAAM,wBAIpB,aAAa67H,GACT,MAAM,IAAI77H,MAAM,2BAIpB,eAAe+3B,GACX,OAAO,EAIX,eAAenB,GACX,OAAOoiG,EAAgBpiG,GAAcr6B,KAAKilB,UAI9C,oBAAoBoV,GAChB,MAAMymB,EAAQ9gD,KAAKilB,WAAaw3G,EAAgBpiG,IAAe,GAI/D,OAHAA,EAAW50B,GAAKq7C,EAChBzmB,EAAW30B,GAAKo7C,EAChBzmB,EAAWz0B,GAAKk7C,EACTzmB,EAIX,cAAcA,EAAyB9kB,QACpBvT,IAAXuT,IACAA,EAAS,CAAE9P,EAAG,EAAGC,EAAG,EAAGE,EAAG,IAE9B,MAAMk7C,EAAQ,GAAK27E,EAAgBpiG,IAAe,GAIlD,OAHA9kB,EAAO9P,EAAI40B,EAAW50B,EAAIq7C,EAC1BvrC,EAAO7P,EAAI20B,EAAW30B,EAAIo7C,EAC1BvrC,EAAO3P,EAAIy0B,EAAWz0B,EAAIk7C,EACnBvrC,EAIX,eACI2P,EACAC,EACAhf,GAEA,GAAI+e,IAAqB,EAAAwW,oBAAsBxW,IAAqB,EAAAuW,sBAAuB,CACvF,MAAM,EAAEh2B,EAAC,EAAEC,EAAC,EAAEE,GAAMuf,EACdjnB,EAAI8B,KAAKilB,UACTs6G,EAAK95H,EAAIvH,EAAImL,KAAKyF,GAClB0wH,EAAK95H,EAAIxH,EAAImL,KAAKyF,GAClBhJ,EAAIuD,KAAK+wB,IAAIolG,GACb9hI,EAAIoI,EAAIA,EACR25H,EAAM,EAAI35H,GAAMpI,EAAI,GACpBgiI,GAAMhiI,EAAI,IAAMA,EAAI,GACpBojD,EAAQ5iD,EAAI0H,EAelB,YAbe5D,IAAXmE,IAEAA,EAAS,IAGbA,EAAOV,EAAI4D,KAAKkH,IAAIgvH,GAAME,EAAK3+E,EAC/B36C,EAAOT,EAAI2D,KAAKsH,IAAI4uH,GAAME,EAAK3+E,EAC/B36C,EAAOP,EAAI85H,EAAK5+E,EAEZ57B,IAAqB,EAAAuW,wBACrBt1B,EAAOP,GAAKO,EAAOP,GAGhBO,EAGX,OAAOnD,MAAM24B,eAAezW,EAAkBC,EAAUhf,GAI5D,kBACIqL,EACArL,GAEA,IAAIwC,EACA,EAAAG,qBAAqB0I,IACrBxR,KAAKyQ,aAAae,EAAOrL,EAAO4H,UAChCpF,EAAW6I,IAEX,EAAAlJ,UAAU0B,YAAYwH,EAAOrL,EAAO4H,UACpCpF,EAAW3I,KAAKmW,eAAe3E,IAGnC,MAAMrJ,EAAW/I,EAAMkJ,UAAUW,SAASN,EAASR,UAC7CC,EAAYhJ,EAAMkJ,UAAUW,SAASN,EAASP,WAE9Cu3H,EAAet2H,KAAKkH,IAAInI,GACxBw3H,EAAev2H,KAAKsH,IAAIvI,GACxB+1H,EAAc90H,KAAKkH,IAAIpI,GACvB03H,EAAcx2H,KAAKsH,IAAIxI,GAiB7B,OAfA,EAAAG,UAAUyB,WACN41H,EAAexB,EACfyB,EAAezB,EACf0B,EACA15H,EAAO2H,OAGX,EAAAxF,UAAUyB,YAAY61H,EAAcD,EAAc,EAAGx5H,EAAOyH,OAE5D,EAAAtF,UAAUyB,YACL41H,EAAeE,GACfD,EAAeC,EAChB1B,EACAh4H,EAAO0H,OAEJ1H,GAIF,EAAA4yF,iBAA+B,IAAIilC,EAAiB,EAAAhxH,eAAeC,oB,gGCrbhF,cAMA,iBAaI,YAAqB+kF,GAAA,KAAAA,eA0BrB,MAAMjyF,GACFC,KAAK8/H,aAAa,EAAAt7G,QAAQ8X,mBAAmB,EAAG,EAAG,GAAIv8B,GAY3D,aAAa6jB,EAAkB7jB,GAG3B,GAAKA,EAAO6jB,EAFG5jB,KAAKgyF,aAAa57D,UAAUxS,IAM3C,IAAK,MAAMm8G,KAAc//H,KAAKgyF,aAAa6E,eAAejzE,GACtD5jB,KAAK8/H,aAAaC,EAAYhgI,M,uLCnE1C,cACA,QACA,QAQa,EAAAigI,iBAAmB,IAAI,EAAAC,aAChC,EAAAttC,8BACA,EAAApE,sC,+GCZJ,cACA,QACA,QAKa,EAAAmX,wBAA0B,IAAI,EAAAu6B,aACvC,EAAAlkG,0BACA,EAAAN,wB,4GCTJ,cACA,QACA,QAOa,EAAAykG,qBAAuB,IAAI,EAAAD,aAAa,EAAAlkG,0BAA2B,EAAAL,qB,yGCThF,cACA,QACA,QAMa,EAAAqrF,kBAAoB,IAAI,EAAAkZ,aACjC,EAAAlkG,0BACA,EAAAg2D,+B,qGCUJ,yBAA8B5wF,GAC1B,OAAOA,GAAoB,iBAARA,EAAEsE,GAAiC,iBAARtE,EAAEuE,GAAiC,iBAARvE,EAAEyE,I,uGCY/E,2BAAgC9G,GAC5B,MAAMmW,EAAYnW,EAClB,YAC2BkD,IAAvBiT,EAAUlH,eACU/L,IAApBiT,EAAUrH,YACU5L,IAApBiT,EAAUpH,YACU7L,IAApBiT,EAAUnH,Q,oGCvClB,aAGA,SAASqyH,EACLC,EACAlhI,EACAmhI,EACArrG,EACA12B,GAEA,MACMoG,EAAI27H,EAAK3qH,IAAIxW,GACbs9G,EAAI6jB,EAAK3qH,IAAI0qH,GACnB,GAAI/2H,KAAK2S,IAAIwgG,GAHG,MAKZ,OAAOnzG,KAAK2S,IAAItX,IAAMswB,EAI1B,MAAMsrG,EAAO,EAAI9jB,EACXrD,GAAMz0G,EAAIswB,GAAUsrG,EACpBC,GAAM77H,EAAIswB,GAAUsrG,EAkB1B,OAjBInnB,EAAKonB,GAEDA,EAAKjiI,EAAEsL,MACPtL,EAAEsL,IAAM22H,GAERpnB,EAAK76G,EAAEwL,MACPxL,EAAEwL,IAAMqvG,KAIRA,EAAK76G,EAAEsL,MACPtL,EAAEsL,IAAMuvG,GAERonB,EAAKjiI,EAAEwL,MACPxL,EAAEwL,IAAMy2H,IAGTjiI,EAAEsL,KAAOtL,EAAEwL,KAAOxL,EAAEwL,KAAO,EAGtC,MAAM02H,EAAS,IAAI,EAAA76H,QACb86H,EAAO,CAAE72H,KAAMC,IAAUC,IAAKD,KAEpC,MAAaw3B,EA6CT,YAAYtzB,EAAoB2yH,EAA0B17G,GAzCjD,KAAAjX,SAAW,IAAI,EAAApI,QAKf,KAAAiI,MAAQ,IAAI,EAAAjI,QAAQ,EAAG,EAAG,GAK1B,KAAAkI,MAAQ,IAAI,EAAAlI,QAAQ,EAAG,EAAG,GAK1B,KAAAmI,MAAQ,IAAI,EAAAnI,QAAQ,EAAG,EAAG,GAK1B,KAAAqf,QAAU,IAAI,EAAArf,aAsBF3D,IAAb+L,GACA/N,KAAK+N,SAASuB,KAAKvB,QAGA/L,IAAnB0+H,GACAA,EAAehqE,aAAa12D,KAAK4N,MAAO5N,KAAK6N,MAAO7N,KAAK8N,YAG7C9L,IAAZgjB,GACAhlB,KAAKglB,QAAQ1V,KAAK0V,GAO1B,QACI,MAAM27G,EAAS,IAAIt/F,EAEnB,OADAs/F,EAAOrxH,KAAKtP,MACL2gI,EAOX,KAAKr3H,GACDtJ,KAAK+N,SAASuB,KAAKhG,EAAMyE,UACzB/N,KAAK4N,MAAM0B,KAAKhG,EAAMsE,OACtB5N,KAAK6N,MAAMyB,KAAKhG,EAAMuE,OACtB7N,KAAK8N,MAAMwB,KAAKhG,EAAMwE,OACtB9N,KAAKglB,QAAQ1V,KAAKhG,EAAM0b,SAQ5B,UAAU/H,EAAS,IAAI,EAAAtX,SACnB,OAAOsX,EAAO3N,KAAKtP,KAAK+N,UAQ5B,QAAQqT,EAAO,IAAI,EAAAzb,SACf,OAAOyb,EAAK9R,KAAKtP,KAAKglB,SAASpR,eAAe,GAOlD,kBAAkBgtH,EAAkB,IAAI,EAAAlzH,SACpC,OAAOkzH,EAAOzrH,UAAUnV,KAAK4N,MAAO5N,KAAK6N,MAAO7N,KAAK8N,OAQzD,WAAW+yH,GACP,MAAMC,EAAkB1/H,MAAMC,QAAQw/H,GAChCA,EACAA,EAAgBC,OAEtB,IAAK,MAAMC,KAASD,EAAQ,CACxB,MAAM5iI,EACFmL,KAAK2S,IAAI+kH,EAAMxrH,OAAOG,IAAI1V,KAAK4N,OAAS5N,KAAKglB,QAAQvf,GACrD4D,KAAK2S,IAAI+kH,EAAMxrH,OAAOG,IAAI1V,KAAK6N,OAAS7N,KAAKglB,QAAQtf,GACrD2D,KAAK2S,IAAI+kH,EAAMxrH,OAAOG,IAAI1V,KAAK8N,OAAS9N,KAAKglB,QAAQpf,GAIzD,GAFUm7H,EAAMC,gBAAgBhhI,KAAK+N,UAE7B7P,EAAI,EACR,OAAO,EAIf,OAAO,EASX,cAAc6R,GAKV,GAHA0wH,EAAK72H,KAAOC,IACZ42H,EAAK32H,IAAMD,IACX22H,EAAOlxH,KAAKtP,KAAK+N,UAAU+E,IAAI/C,EAAIy1E,QAC9B26C,EAAepwH,EAAIggD,UAAWywE,EAAQxgI,KAAK4N,MAAO5N,KAAKglB,QAAQvf,EAAGg7H,IAGlEN,EAAepwH,EAAIggD,UAAWywE,EAAQxgI,KAAK6N,MAAO7N,KAAKglB,QAAQtf,EAAG+6H,IAGlEN,EAAepwH,EAAIggD,UAAWywE,EAAQxgI,KAAK8N,MAAO9N,KAAKglB,QAAQpf,EAAG66H,GAIvE,OAAOA,EAAK72H,IAAM,EAAI62H,EAAK72H,IAAM62H,EAAK32H,IAQ1C,SAAS0H,GACL,MAAM40E,EAAK50E,EAAM/L,EAAIzF,KAAK+N,SAAStI,EAC7B4gF,EAAK70E,EAAM9L,EAAI1F,KAAK+N,SAASrI,EAC7Bu7H,EAAKzvH,EAAM5L,EAAI5F,KAAK+N,SAASnI,EAC7BH,EAAI4D,KAAK2S,IAAIoqE,EAAKpmF,KAAK4N,MAAMnI,EAAI4gF,EAAKrmF,KAAK4N,MAAMlI,EAAIu7H,EAAKjhI,KAAK4N,MAAMhI,GACrEF,EAAI2D,KAAK2S,IAAIoqE,EAAKpmF,KAAK6N,MAAMpI,EAAI4gF,EAAKrmF,KAAK6N,MAAMnI,EAAIu7H,EAAKjhI,KAAK6N,MAAMjI,GACrEA,EAAIyD,KAAK2S,IAAIoqE,EAAKpmF,KAAK8N,MAAMrI,EAAI4gF,EAAKrmF,KAAK8N,MAAMpI,EAAIu7H,EAAKjhI,KAAK8N,MAAMlI,GAC3E,QAAIH,EAAIzF,KAAKglB,QAAQvf,GAAKC,EAAI1F,KAAKglB,QAAQtf,GAAKE,EAAI5F,KAAKglB,QAAQpf,GAWrE,gBAAgB4L,GACZ,OAAOnI,KAAK+H,KAAKpR,KAAKkhI,uBAAuB1vH,IAQjD,uBAAuBA,GACnB,MAAM9T,EAAI,IAAI,EAAAiI,QACdjI,EAAEyjI,WAAW3vH,EAAOxR,KAAK+N,UAEzB,MAAMqzH,EAAU,CAAC1jI,EAAEgY,IAAI1V,KAAK4N,OAAQlQ,EAAEgY,IAAI1V,KAAK6N,OAAQnQ,EAAEgY,IAAI1V,KAAK8N,QAElE,IAAI3H,EAAS,EAEb,IAAK,IAAI/I,EAAI,EAAGA,EAAI,IAAKA,EAAG,CACxB,MAAMkE,EAAS8/H,EAAQhkI,GACjB43B,EAASh1B,KAAKglB,QAAQq8G,aAAajkI,GACzC,GAAIkE,GAAU0zB,EAAQ,CAClB,MAAMssG,EAAKtsG,EAAS1zB,EACpB6E,GAAUm7H,EAAKA,OACZ,GAAIhgI,EAAS0zB,EAAQ,CACxB,MAAMssG,EAAKhgI,EAAS0zB,EACpB7uB,GAAUm7H,EAAKA,GAIvB,OAAOn7H,GAhNf,kB,iYC7CA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,WACA,YACA,YACA,a,+HCEA,MAAao7H,EACT,YAAqB57G,EAAyBohB,EAAgB,IAAI3lC,OAA7C,KAAAukB,WAAyB,KAAAohB,WAO9C,QACI,OAAO,IAAIw6F,EAAqBvhI,KAAK2lB,SAAU3lB,KAAK+mC,SAASzgC,SAQjE,OAAO6xB,GACH,MAAMqpG,EAAaxhI,KAAK+mC,SAASpU,QAAQwF,GACzC,OAAoB,IAAhBqpG,IAGJxhI,KAAK+mC,SAASZ,OAAOq7F,EAAY,IAC1B,IAvBf,sBAoCA,MAAaC,EAAb,cACa,KAAA7+F,OAAkC,IAAIzgC,IAM/C,IAAIg2B,GACAn4B,KAAK0hI,SAASvpG,EAAQxS,UAAUohB,SAAS7gC,KAAKiyB,GAYlD,OAAOA,GACH,MAAMwK,EAAQ3iC,KAAK2hI,UAAUxpG,EAAQxS,UACrC,aAAc3jB,IAAV2gC,IAAuBA,EAAMU,OAAOlL,MACN,IAA1BwK,EAAMoE,SAASzlC,QACftB,KAAK4iC,OAAO77B,OAAO47B,EAAMhd,WAGtB,GAQf,QACI3lB,KAAK4iC,OAAOoD,QAQhB,MAAM18B,GACF,IAAK,MAAMs4H,KAAct4H,EAAMs5B,OAAQ,CACnC,MAAMD,EAAQ3iC,KAAK2hI,UAAUC,EAAW,GAAGj8G,eAC7B3jB,IAAV2gC,EAIJA,EAAMoE,SAAWpE,EAAMoE,SAAS8L,OAAO+uF,EAAW,GAAG76F,UAHjD/mC,KAAK4iC,OAAO57B,IAAIqC,KAAKmtB,MAAMorG,EAAW,GAAGj8G,UAAWi8G,EAAW,GAAG/0H,SAK1E,OAAO7M,KAGX,QACI,MAAM6M,EAAQ,IAAI40H,EAClB,IAAK,MAAO97G,EAAUgd,KAAU3iC,KAAK4iC,OACjC/1B,EAAM+1B,OAAO57B,IAAI2e,EAAUgd,EAAM91B,SAErC,OAAOA,EAQX,QAAQ2gE,GACJ,IAAK,MAAM7qC,KAAS3iC,KAAK4iC,OACrBD,EAAM,GAAGoE,SAAS1mC,QAAQmtE,GAOlC,QACI,IAAI3uE,EAAI,EACR,IAAK,MAAM8jC,KAAS3iC,KAAK4iC,OACrB/jC,GAAK8jC,EAAM,GAAGoE,SAASzlC,OAE3B,OAAOzC,EAQH,UAAU8mB,GACd,MAAMk8G,EAAqBx4H,KAAKmtB,MAAM7Q,GAEtC,OADc3lB,KAAK4iC,OAAO3kC,IAAI4jI,GAS1B,SAASl8G,GACb,IAAIgd,EAAQ3iC,KAAK2hI,UAAUh8G,GAE3B,QAAc3jB,IAAV2gC,EAAqB,CACrB,MAAMk/F,EAAqBx4H,KAAKmtB,MAAM7Q,GACtCgd,EAAQ,IAAI4+F,EAAqBM,GACjC7hI,KAAK4iC,OAAO57B,IAAI27B,EAAMhd,SAAUgd,GAGpC,OAAOA,GA/Gf,yB,iYCrDA,WACA,YACA,WACA,WACA,YACA,YACA,Y,oLCLA,eAiBA,sBAGI,sBACI,OAAO3iC,KAAKurC,aAAevrC,KAAKurC,WAAa,IAAI,EAAAu2F,sB,yGCtBzD,cAIA,QACA,QAOA,0BAKI,cAHiB,KAAAC,UAAuB,GAIpC/hI,KAAKgiI,QACe,oBAATnqC,WAAiD,IAAlBA,KAAKwhB,SACrC,IAAI,EAAA4oB,eACJ,IAAI,EAAAC,cAGlB,iBACI,OAAOliI,KAAK+hI,UAAUh8H,IAAIyG,GAAUA,EAAO7O,MAG/C,UAAUA,GACN,OAAOqC,KAAK+hI,UAAU7pG,KAAK1rB,GAAUA,EAAO7O,OAASA,GAGzD,OAAOwkI,EAAoBlsH,EAAyB,SAElBjU,IAA1BhC,KAAKoiI,wBACcpgI,IAAlBiU,EAAQ2F,OAAuB3F,EAAQ2F,MAAQ5b,KAAKoiI,oBAErDnsH,EAAQ2F,MAAQ5b,KAAKoiI,kBAEzB,MAAM51H,EAAS,IAAI,EAAA61H,OAAOF,EAAYniI,KAAKgiI,QAAS/rH,GAEpD,OADAjW,KAAK+hI,UAAU77H,KAAKsG,GACbA,EAGX,QAAQA,GACJ,MAAMuuC,EAAQ/6C,KAAK+hI,UAAUpvG,QAAQnmB,GACrC,GAAIuuC,EAAQ,EACR,MAAM,IAAIt3C,MAAM,sBAAsB+I,mCAE1CxM,KAAK+hI,UAAU57F,OAAO4U,EAAO,GAGjC,UAAU9kC,GACN,IAAK,MAAMzJ,KAAUxM,KAAK+hI,UACtBv1H,EAAO6lC,OAAOp8B,GAItB,OAAOksH,EAAoBG,GACvB,IAAK,MAAM91H,KAAUxM,KAAK+hI,UAClBv1H,EAAO7O,OAASwkI,GAChB31H,EAAO6lC,OAAOiwF,GAK1B,UAAUtjH,GACN,IAAK,MAAMxS,KAAUxM,KAAK+hI,UACtBv1H,EAAOwS,QAAUA,EAIzB,OAAOmjH,EAAoB9jI,GACvB2B,KAAKqyC,OAAO8vF,EAAY,CAAEnjH,QAAS3gB,IAGvC,kBAAkBud,GACd5b,KAAKoiI,iBAAmBxmH,EACxB,IAAK,MAAMpP,KAAUxM,KAAK+hI,UACtBv1H,EAAOoP,MAAQA,EAIvB,YAAYumH,EAAoBvmH,GAC5B5b,KAAKqyC,OAAO8vF,EAAY,CAAEvmH,UAG9B,WAAWomH,GACPhiI,KAAKgiI,QAAUA,K,oGCnFvB,qBAEI,eAAeO,GADE,KAAAA,SAAuB,GAEpCviI,KAAKuiI,SAAWA,EAGpB,MAAMz3F,KAAkBosD,GACpB,IAAK,MAAM8qC,KAAWhiI,KAAKuiI,SACvBP,EAAQzjH,MAAMusB,KAAYosD,GAIlC,MAAMpsD,KAAkBosD,GACpB,IAAK,MAAM8qC,KAAWhiI,KAAKuiI,SACvBP,EAAQ7yF,MAAMrE,KAAYosD,GAIlC,KAAKpsD,KAAkBosD,GACnB,IAAK,MAAM8qC,KAAWhiI,KAAKuiI,SACvBP,EAAQ3tE,KAAKvpB,KAAYosD,GAIjC,IAAIpsD,KAAkBosD,GAClB,IAAK,MAAM8qC,KAAWhiI,KAAKuiI,SACvBP,EAAQ/nG,IAAI6Q,KAAYosD,GAIhC,MAAMpsD,KAAkBosD,GACpB,IAAK,MAAM8qC,KAAWhiI,KAAKuiI,SACvBP,EAAQ5qC,MAAMtsD,KAAYosD,GAIlC,KAAKpsD,KAAkBosD,GACnB,IAAK,MAAM8qC,KAAWhiI,KAAKuiI,SACvBP,EAAQjsH,KAAK+0B,KAAYosD,M,8FC3CrC,SAAiBj1C,GA4Fb,SAAgBC,EAAYsgF,EAAYC,EAAYC,EAAYC,GAC5D,OAAQH,EAAKE,IAAOF,EAAKE,IAAOD,EAAKE,IAAOF,EAAKE,GAxFxC,EAAAxyB,IAAb,MAUI,YAAmB1qG,EAAI,EAAUC,EAAI,EAAUI,EAAI,EAAUsmB,EAAI,GAA9C,KAAA3mB,IAAc,KAAAC,IAAc,KAAAI,IAAc,KAAAsmB,IAU7D,IAAI3mB,EAAWC,EAAWI,EAAWsmB,GACjCpsB,KAAKyF,EAAIA,EACTzF,KAAK0F,EAAIA,EACT1F,KAAK8F,EAAIA,EACT9F,KAAKosB,EAAIA,EASb,SAAS3mB,EAAWC,GAChB,OAAO1F,KAAKyF,GAAKA,GAAKzF,KAAKyF,EAAIzF,KAAK8F,GAAKL,GAAKzF,KAAK0F,GAAKA,GAAK1F,KAAK0F,EAAI1F,KAAKosB,GAAK1mB,EAQpF,YAAY4D,GACR,MAAMs5H,EAAOt5H,EAAM7D,EAAI6D,EAAMxD,EACvB+8H,EAAOv5H,EAAM5D,EAAI4D,EAAM8iB,EAC7B,OACIpsB,KAAKouG,SAAS9kG,EAAM7D,EAAG6D,EAAM5D,IAC7B1F,KAAKouG,SAASw0B,EAAMt5H,EAAM5D,IAC1B1F,KAAKouG,SAAS9kG,EAAM7D,EAAGo9H,IACvB7iI,KAAKouG,SAASw0B,EAAMC,GAS5B,WAAWv5H,GACP,OACItJ,KAAKyF,GAAK6D,EAAM7D,EAAI6D,EAAMxD,GAC1B9F,KAAKyF,EAAIzF,KAAK8F,GAAKwD,EAAM7D,GACzBzF,KAAK0F,GAAK4D,EAAM5D,EAAI4D,EAAM8iB,GAC1BpsB,KAAK0F,EAAI1F,KAAKosB,GAAK9iB,EAAM5D,IAwBrB,EAAAw8C,YAAW,EASX,EAAA4gF,yBAAhB,SAAyCpuF,GACrC,IAAIquF,EAA4B,EAEhC,MAAMzhI,EAASozC,EAAKpzC,OAAS,EAC7B,IAAK,IAAIlE,EAAI,EAAGA,EAAIkE,EAAQlE,GAAK,EAAG,CAChC,MAAM4lI,EAAQtuF,EAAKt3C,EAAI,GAAKs3C,EAAKt3C,GAC3B6lI,EAAQvuF,EAAKt3C,EAAI,GAAKs3C,EAAKt3C,EAAI,GACrC2lI,GAAqBC,EAAQA,EAAQC,EAAQA,EAEjD,OAAOF,GAcK,EAAAG,qBAAhB,SACIC,EACAC,EACAC,EACAC,EACAC,EACAC,GAEA,MAAMC,EAAmBvhF,EAAYmhF,EAAKC,EAAKC,EAAKC,GACpD,GAAyB,IAArBC,EACA,OAAOvhF,EAAYihF,EAAIC,EAAIC,EAAKC,GAEpC,IAAIhlI,IAAM6kI,EAAKE,IAAQE,EAAMF,IAAQD,EAAKE,IAAQE,EAAMF,IAAQG,EAEhE,OADAnlI,EAAI+K,KAAKS,IAAI,EAAGT,KAAKO,IAAI,EAAGtL,IACrB4jD,EAAYihF,EAAIC,EAAIC,EAAM/kI,GAAKilI,EAAMF,GAAMC,EAAMhlI,GAAKklI,EAAMF,KA1I3E,CAAiB,EAAArhF,SAAA,EAAAA,OAAM,M,iGCAvB,SAAiB35C,GAUb,SAAgB6B,EAAM9L,EAAeuL,EAAaE,GAC9C,OAAOzL,EAAQuL,EAAMA,EAAMvL,EAAQyL,EAAMA,EAAMzL,EADnC,EAAA8L,MAAK,EAgBL,EAAAuzB,KAAhB,SAAqBgmG,EAAeC,EAAe/lF,GAC/C,OAAO8lF,GAAS,EAAI9lF,GAAU+lF,EAAQ/lF,GAY1B,EAAAqlE,WAAhB,SAA2BygB,EAAeC,EAAel+H,GAIrD,OAFAA,EAAI0E,GAAO1E,EAAIi+H,IAAUC,EAAQD,GAAQ,EAAK,IAEnCj+H,GAAK,EAAI,EAAIA,IAgBZ,EAAAm+H,aAAhB,SAA6BF,EAAeC,EAAel+H,GAIvD,OAFAA,EAAI0E,GAAO1E,EAAIi+H,IAAUC,EAAQD,GAAQ,EAAK,IAEnCj+H,EAAIA,GAAKA,GAAS,EAAJA,EAAQ,IAAM,KAY3B,EAAAM,IAAhB,SAAoB+zB,EAAa+pG,EAAeC,EAAeC,EAAgBC,GAC3E,OAASlqG,EAAM+pG,IAAUG,EAASD,IAAYD,EAAQD,GAASE,GAWnD,EAAAx8G,KAAhB,SAAqB/d,EAAuBE,GACxC,IAAIvD,EASJ,YAPUnE,IAANwH,IACArD,EAASqD,QAEHxH,IAAN0H,IACAvD,OAAoBnE,IAAXmE,EAAuBuD,EAAIL,KAAKO,IAAIzD,EAAQuD,IAGlDvD,GAWK,EAAAuhB,KAAhB,SAAqBle,EAAuBE,GACxC,IAAIvD,EASJ,YAPUnE,IAANwH,IACArD,EAASqD,QAEHxH,IAAN0H,IACAvD,OAAoBnE,IAAXmE,EAAuBuD,EAAIL,KAAKS,IAAI3D,EAAQuD,IAGlDvD,GAcK,EAAA04C,UAAhB,SACIxgD,EACA4lI,EACAC,GAEA,aAAmBliI,IAAfiiI,GAA4B5lI,EAAQ4lI,WAGrBjiI,IAAfkiI,GAA4B7lI,EAAQ6lI,IAc5B,EAAAltC,eAAhB,SAA+BmtC,EAAoBC,EAAkB3yF,GAGjE,OAAO0yF,GAAcC,EAAWD,IAD5B1yF,EAAO,GAAM,EAAIA,EAAOA,EAAOA,GAAQA,EAAO,IAAM,EAAIA,EAAO,IAAM,EAAIA,EAAO,GAAK,IA5JjG,CAAiB,EAAAnpC,YAAA,EAAAA,UAAS,M,kICQ1B,uBAA4B+7H,EAAkBC,GAC1CA,EAAUjkI,QAAQkkI,IACdzmI,OAAOy0B,oBAAoBgyG,EAASvlI,WAAWqB,QAAQ1C,IACnD0mI,EAAYrlI,UAAUrB,GAAQ4mI,EAASvlI,UAAUrB,QAa7D,wCAA6C0mI,EAAkBC,GAC3DA,EAAUjkI,QAAQkkI,IACdzmI,OAAOy0B,oBAAoBgyG,EAASvlI,WAAWqB,QAAQ1C,IACnD,MAAM2G,EAAaxG,OAAO0mI,yBAAyBD,EAASvlI,UAAWrB,QAEpDqE,IAAfsC,QACmBtC,IAAnBsC,EAAWrG,KACF,gBAATN,IAEA0mI,EAAYrlI,UAAUrB,GAAQ4mI,EAASvlI,UAAUrB,U,6GChBjE,kBAAuBmD,EAAoBgqC,GACnC,GAOR,wBAAgC3S,EAAwB2S,GAQpD,OAAO3S,I,oLCEX,sBAOI,YAAqBssG,EAAmCC,GAAnC,KAAAD,WAAmC,KAAAC,gBANvC,KAAAxkI,QAAoB,GAC7B,KAAAykI,gBAAiB,EAgCzB,KAAA5uH,KAAO/V,KAAK4kI,gBAAgB,QAC5B,KAAAvwE,KAAOr0D,KAAK4kI,gBAAgB,QAC5B,KAAArmH,MAAQve,KAAK4kI,gBAAgB,SAtB7B,SAASjnI,GACLqC,KAAKE,QAAQgG,KAAK,GAAGlG,KAAKE,QAAQoB,OAAS,EAAI,IAAM,KAAK3D,KAQ9D,UAAU+c,GACN1a,KAAKE,QAAQgG,KAAK,IAAIwU,MAG1B,MACI1a,KAAKE,QAAQ67E,MAWT,gBAAgB8oD,GACpB,MAAO,CAAC/5F,KAAoBg6F,KACnB9kI,KAAK2kI,iBACN3kI,KAAKykI,SAASpwE,KAAKr0D,KAAK0kI,eACxB1kI,KAAK2kI,gBAAiB,GAE1B3kI,KAAKykI,SAASI,GAAU,GAAG7kI,KAAKE,QAAQk2E,KAAK,QAAQtrC,OAAcg6F,O,wGCzE/E,kBAAa78F,EAgBT,aACI,OAAOA,EAAiB88F,UAQpB,oBACJ,MAA2B,oBAAhB74F,kBAA0D,IAApBA,YAAYhE,IAClD,IAAMgE,YAAYhE,MAItB,KACI,IAAI0hC,MAAOo7D,WAG9B,OAd4B,EAAA/kI,SAAW,IAAIgoC,EAEf,EAAA88F,QAAwB98F,EAAiBg9F,aAYrE,GAnCA,GAAa,EAAAh9F,oB,wGCEb,qBAA6B5gC,GACzB,MAAMnF,EAA6B,IAAIC,IA4CjCjE,EA3CN,SAASgnI,EAAcC,GACnB,GAAY,OAARA,EACA,OAAO,KACJ,GAAmB,iBAARA,EAAkB,CAChC,MAAMC,EAASljI,EAAMjE,IAAIknI,GACzB,QAAenjI,IAAXojI,EACA,OAAOA,EAGX,GAAIhkI,MAAMC,QAAQ8jI,GAAM,CACpB,MAAMh/H,EAAgB,GACtBjE,EAAM8E,IAAIm+H,EAAKh/H,GACfA,EAAO7E,OAAS6jI,EAAI7jI,OACpB,IAAK,IAAIlE,EAAI,EAAGA,EAAI+I,EAAO7E,SAAUlE,EACjC+I,EAAO/I,GAAK8nI,EAAcC,EAAI/nI,IAElC,OAAO+I,EACJ,GAAIg/H,aAAev7D,KAAM,CAC5B,MAAMzjE,EAAS,IAAIyjE,KAAKu7D,EAAIH,WAE5B,OADA9iI,EAAM8E,IAAIm+H,EAAKh/H,GACRA,EACJ,GAAIg/H,aAAe3hF,OAAQ,CAC9B,MAAMr9C,EAAS,IAAIq9C,OAAO2hF,EAAI95G,OAAQ85G,EAAIE,OAE1C,OADAnjI,EAAM8E,IAAIm+H,EAAKh/H,GACRA,EACJ,GAAIg/H,EAAI7Q,cAAgBx2H,OAC3B,MAAM,IAAI2F,MAAM,4DACb,CACH,MAAM0C,EAAqB,GAC3BjE,EAAM8E,IAAIm+H,EAAKh/H,GACf,IAAK,MAAMxH,KAAOwmI,EACVA,EAAIlmI,eAAeN,KACnBwH,EAAOxH,GAAOumI,EAAcC,EAAIxmI,KAGxC,OAAOwH,GAIX,OAAOg/H,EAILD,CAAc79H,GAExB,OADAnF,EAAM8jC,QACC9nC,GAQX,gBAA0DY,EAAWwmI,GACjE,MAAMn/H,EAAc,GACpB,IAAK,MAAMw+E,KAAY2gD,EACfxmI,EAAOG,eAAe0lF,KACtBx+E,EAAOw+E,GAAY7lF,EAAO6lF,IAGlC,OAAOx+E,I,yHCzCX,6BAAqCw5B,GACjC,IAAK,MAAM6mE,KAAa7mE,EACpB,GAAI6mE,QACA,OAAOA,GAyDnB,4BAAmD++B,EAAetvH,GAI9D,MAAM9P,EAAS,iBAAMo/H,GACrB,GAAItvH,QACA,OAAO9P,EAEX,IAAK,MAAMysB,KAAQ2yG,EACf,GAAIA,EAAWtmI,eAAe2zB,GAAO,CACjC,MAAM4yG,EAAcvvH,EAAQ2c,GACxB4yG,UACAr/H,EAAOysB,GAAQ4yG,GAI3B,OAAOr/H,I,wJC1GX,cA4CA,6BACI,YAAqBtE,GAAA,KAAAA,cAErB,WAAW4jI,GACP,OAAO3nI,OAAO89D,KAAK57D,KAAK6B,aAAa28B,OAAO,CAACtgC,EAAGS,KAC5C,GAAIA,EAAIouB,SAAS,MAAQ7uB,EAAEklD,WAAWzkD,GAAM,CAExC,OADkBqB,KAAK6B,YAAYlD,GAChBT,EAAEolD,OAAO3kD,EAAI2C,QAC7B,OAAIpD,IAAMS,EACNqB,KAAK6B,YAAYlD,GAErBT,GACRunI,KAOX,4BACI,YAAqBziF,GAAA,KAAAA,YAErB,WAAWyiF,GACP,OAAO,EAAAjb,oBAAoBxqH,KAAKgjD,UAAWyiF,KAiBnD,kCAAuCC,GACnC,MAAO,CACHhjE,WAAWijE,GACAD,EAAUlnG,OAAO,CAACilB,EAAKo8C,SACT79F,IAAb69F,EACOA,EAASn9B,WAAWjf,GAEpBA,EAEZkiF,M,sGC1Ff,0BACIC,EACAC,GAEA,OAAO,YAAuBzlI,GAI1B,OAHIwlI,GACAA,EAAGtoB,MAAMt9G,KAAMI,GAEZylI,EAAGvoB,MAAMt9G,KAAMI,M,sGCQ9B,0BACI+W,EACAM,EACAvG,EACA+3F,EACA9nG,GAEA,MAAM2kI,EAAYruH,EAAQ,EACpBsuH,EAAY70H,EAAS,EAErB80H,EAAS/8B,EAAI68B,EACbG,EAAc58H,KAAKmtB,MAAMwvG,GACzBE,EAAS/kI,EAAI4kI,EACbI,EAAc98H,KAAKmtB,MAAM0vG,GACzBE,EAAUD,EAAc1uH,EAAQwuH,EAChCI,EAAUJ,EAAcH,EAAYM,EAAU,EAAIA,EAClDE,EAAUH,EAAcJ,EAAYK,EAAU3uH,EAAQ2uH,EACtDG,EAAUN,EAAcH,EAAYQ,EAAU,EAAIA,EAClDE,EAAcrvH,EAAQivH,GACtBK,EAActvH,EAAQkvH,GACtBK,EAAcvvH,EAAQmvH,GACtBK,EAAcxvH,EAAQovH,GAEtBK,EAAQ9+G,OAAO++G,UAAUb,GAAU,EAAIA,EAASC,EAChDa,EAAe,EAAIF,EACnBG,EAAQj/G,OAAO++G,UAAUX,GAAU,EAAIA,EAASC,EAChDa,EAAe,EAAID,EAQzB,OAJIP,EAAcM,EAAeE,EAC7BP,EAAcG,EAAQI,EACtBN,EAAcI,EAAeC,EAC7BJ,EAAcC,EAAQG,I,oLCpD9B,cAUA,2BACI,OAAO,EAAAxjF,QAAQtX,OAAOx1B,SAAS4rF,Q,cCMnC,IAAI4kC,EAAiB,CACnB,YAAe,CAAC,EAAE,EAAE,EAAE,GAAI,UAAa,CAAC,IAAI,IAAI,IAAI,GACpD,aAAgB,CAAC,IAAI,IAAI,IAAI,GAAI,KAAQ,CAAC,EAAE,IAAI,IAAI,GACpD,WAAc,CAAC,IAAI,IAAI,IAAI,GAAI,MAAS,CAAC,IAAI,IAAI,IAAI,GACrD,MAAS,CAAC,IAAI,IAAI,IAAI,GAAI,OAAU,CAAC,IAAI,IAAI,IAAI,GACjD,MAAS,CAAC,EAAE,EAAE,EAAE,GAAI,eAAkB,CAAC,IAAI,IAAI,IAAI,GACnD,KAAQ,CAAC,EAAE,EAAE,IAAI,GAAI,WAAc,CAAC,IAAI,GAAG,IAAI,GAC/C,MAAS,CAAC,IAAI,GAAG,GAAG,GAAI,UAAa,CAAC,IAAI,IAAI,IAAI,GAClD,UAAa,CAAC,GAAG,IAAI,IAAI,GAAI,WAAc,CAAC,IAAI,IAAI,EAAE,GACtD,UAAa,CAAC,IAAI,IAAI,GAAG,GAAI,MAAS,CAAC,IAAI,IAAI,GAAG,GAClD,eAAkB,CAAC,IAAI,IAAI,IAAI,GAAI,SAAY,CAAC,IAAI,IAAI,IAAI,GAC5D,QAAW,CAAC,IAAI,GAAG,GAAG,GAAI,KAAQ,CAAC,EAAE,IAAI,IAAI,GAC7C,SAAY,CAAC,EAAE,EAAE,IAAI,GAAI,SAAY,CAAC,EAAE,IAAI,IAAI,GAChD,cAAiB,CAAC,IAAI,IAAI,GAAG,GAAI,SAAY,CAAC,IAAI,IAAI,IAAI,GAC1D,UAAa,CAAC,EAAE,IAAI,EAAE,GAAI,SAAY,CAAC,IAAI,IAAI,IAAI,GACnD,UAAa,CAAC,IAAI,IAAI,IAAI,GAAI,YAAe,CAAC,IAAI,EAAE,IAAI,GACxD,eAAkB,CAAC,GAAG,IAAI,GAAG,GAAI,WAAc,CAAC,IAAI,IAAI,EAAE,GAC1D,WAAc,CAAC,IAAI,GAAG,IAAI,GAAI,QAAW,CAAC,IAAI,EAAE,EAAE,GAClD,WAAc,CAAC,IAAI,IAAI,IAAI,GAAI,aAAgB,CAAC,IAAI,IAAI,IAAI,GAC5D,cAAiB,CAAC,GAAG,GAAG,IAAI,GAAI,cAAiB,CAAC,GAAG,GAAG,GAAG,GAC3D,cAAiB,CAAC,GAAG,GAAG,GAAG,GAAI,cAAiB,CAAC,EAAE,IAAI,IAAI,GAC3D,WAAc,CAAC,IAAI,EAAE,IAAI,GAAI,SAAY,CAAC,IAAI,GAAG,IAAI,GACrD,YAAe,CAAC,EAAE,IAAI,IAAI,GAAI,QAAW,CAAC,IAAI,IAAI,IAAI,GACtD,QAAW,CAAC,IAAI,IAAI,IAAI,GAAI,WAAc,CAAC,GAAG,IAAI,IAAI,GACtD,UAAa,CAAC,IAAI,GAAG,GAAG,GAAI,YAAe,CAAC,IAAI,IAAI,IAAI,GACxD,YAAe,CAAC,GAAG,IAAI,GAAG,GAAI,QAAW,CAAC,IAAI,EAAE,IAAI,GACpD,UAAa,CAAC,IAAI,IAAI,IAAI,GAAI,WAAc,CAAC,IAAI,IAAI,IAAI,GACzD,KAAQ,CAAC,IAAI,IAAI,EAAE,GAAI,UAAa,CAAC,IAAI,IAAI,GAAG,GAChD,KAAQ,CAAC,IAAI,IAAI,IAAI,GAAI,MAAS,CAAC,EAAE,IAAI,EAAE,GAC3C,YAAe,CAAC,IAAI,IAAI,GAAG,GAAI,KAAQ,CAAC,IAAI,IAAI,IAAI,GACpD,SAAY,CAAC,IAAI,IAAI,IAAI,GAAI,QAAW,CAAC,IAAI,IAAI,IAAI,GACrD,UAAa,CAAC,IAAI,GAAG,GAAG,GAAI,OAAU,CAAC,GAAG,EAAE,IAAI,GAChD,MAAS,CAAC,IAAI,IAAI,IAAI,GAAI,MAAS,CAAC,IAAI,IAAI,IAAI,GAChD,SAAY,CAAC,IAAI,IAAI,IAAI,GAAI,cAAiB,CAAC,IAAI,IAAI,IAAI,GAC3D,UAAa,CAAC,IAAI,IAAI,EAAE,GAAI,aAAgB,CAAC,IAAI,IAAI,IAAI,GACzD,UAAa,CAAC,IAAI,IAAI,IAAI,GAAI,WAAc,CAAC,IAAI,IAAI,IAAI,GACzD,UAAa,CAAC,IAAI,IAAI,IAAI,GAAI,qBAAwB,CAAC,IAAI,IAAI,IAAI,GACnE,UAAa,CAAC,IAAI,IAAI,IAAI,GAAI,WAAc,CAAC,IAAI,IAAI,IAAI,GACzD,UAAa,CAAC,IAAI,IAAI,IAAI,GAAI,UAAa,CAAC,IAAI,IAAI,IAAI,GACxD,YAAe,CAAC,IAAI,IAAI,IAAI,GAAI,cAAiB,CAAC,GAAG,IAAI,IAAI,GAC7D,aAAgB,CAAC,IAAI,IAAI,IAAI,GAAI,eAAkB,CAAC,IAAI,IAAI,IAAI,GAChE,eAAkB,CAAC,IAAI,IAAI,IAAI,GAAI,eAAkB,CAAC,IAAI,IAAI,IAAI,GAClE,YAAe,CAAC,IAAI,IAAI,IAAI,GAAI,KAAQ,CAAC,EAAE,IAAI,EAAE,GACjD,UAAa,CAAC,GAAG,IAAI,GAAG,GAAI,MAAS,CAAC,IAAI,IAAI,IAAI,GAClD,QAAW,CAAC,IAAI,EAAE,IAAI,GAAI,OAAU,CAAC,IAAI,EAAE,EAAE,GAC7C,iBAAoB,CAAC,IAAI,IAAI,IAAI,GAAI,WAAc,CAAC,EAAE,EAAE,IAAI,GAC5D,aAAgB,CAAC,IAAI,GAAG,IAAI,GAAI,aAAgB,CAAC,IAAI,IAAI,IAAI,GAC7D,eAAkB,CAAC,GAAG,IAAI,IAAI,GAAI,gBAAmB,CAAC,IAAI,IAAI,IAAI,GAClE,kBAAqB,CAAC,EAAE,IAAI,IAAI,GAAI,gBAAmB,CAAC,GAAG,IAAI,IAAI,GACnE,gBAAmB,CAAC,IAAI,GAAG,IAAI,GAAI,aAAgB,CAAC,GAAG,GAAG,IAAI,GAC9D,UAAa,CAAC,IAAI,IAAI,IAAI,GAAI,UAAa,CAAC,IAAI,IAAI,IAAI,GACxD,SAAY,CAAC,IAAI,IAAI,IAAI,GAAI,YAAe,CAAC,IAAI,IAAI,IAAI,GACzD,KAAQ,CAAC,EAAE,EAAE,IAAI,GAAI,QAAW,CAAC,IAAI,IAAI,IAAI,GAC7C,MAAS,CAAC,IAAI,IAAI,EAAE,GAAI,UAAa,CAAC,IAAI,IAAI,GAAG,GACjD,OAAU,CAAC,IAAI,IAAI,EAAE,GAAI,UAAa,CAAC,IAAI,GAAG,EAAE,GAChD,OAAU,CAAC,IAAI,IAAI,IAAI,GAAI,cAAiB,CAAC,IAAI,IAAI,IAAI,GACzD,UAAa,CAAC,IAAI,IAAI,IAAI,GAAI,cAAiB,CAAC,IAAI,IAAI,IAAI,GAC5D,cAAiB,CAAC,IAAI,IAAI,IAAI,GAAI,WAAc,CAAC,IAAI,IAAI,IAAI,GAC7D,UAAa,CAAC,IAAI,IAAI,IAAI,GAAI,KAAQ,CAAC,IAAI,IAAI,GAAG,GAClD,KAAQ,CAAC,IAAI,IAAI,IAAI,GAAI,KAAQ,CAAC,IAAI,IAAI,IAAI,GAC9C,WAAc,CAAC,IAAI,IAAI,IAAI,GAAI,OAAU,CAAC,IAAI,EAAE,IAAI,GACpD,cAAiB,CAAC,IAAI,GAAG,IAAI,GAC7B,IAAO,CAAC,IAAI,EAAE,EAAE,GAAI,UAAa,CAAC,IAAI,IAAI,IAAI,GAC9C,UAAa,CAAC,GAAG,IAAI,IAAI,GAAI,YAAe,CAAC,IAAI,GAAG,GAAG,GACvD,OAAU,CAAC,IAAI,IAAI,IAAI,GAAI,WAAc,CAAC,IAAI,IAAI,GAAG,GACrD,SAAY,CAAC,GAAG,IAAI,GAAG,GAAI,SAAY,CAAC,IAAI,IAAI,IAAI,GACpD,OAAU,CAAC,IAAI,GAAG,GAAG,GAAI,OAAU,CAAC,IAAI,IAAI,IAAI,GAChD,QAAW,CAAC,IAAI,IAAI,IAAI,GAAI,UAAa,CAAC,IAAI,GAAG,IAAI,GACrD,UAAa,CAAC,IAAI,IAAI,IAAI,GAAI,UAAa,CAAC,IAAI,IAAI,IAAI,GACxD,KAAQ,CAAC,IAAI,IAAI,IAAI,GAAI,YAAe,CAAC,EAAE,IAAI,IAAI,GACnD,UAAa,CAAC,GAAG,IAAI,IAAI,GAAI,IAAO,CAAC,IAAI,IAAI,IAAI,GACjD,KAAQ,CAAC,EAAE,IAAI,IAAI,GAAI,QAAW,CAAC,IAAI,IAAI,IAAI,GAC/C,OAAU,CAAC,IAAI,GAAG,GAAG,GAAI,UAAa,CAAC,GAAG,IAAI,IAAI,GAClD,OAAU,CAAC,IAAI,IAAI,IAAI,GAAI,MAAS,CAAC,IAAI,IAAI,IAAI,GACjD,MAAS,CAAC,IAAI,IAAI,IAAI,GAAI,WAAc,CAAC,IAAI,IAAI,IAAI,GACrD,OAAU,CAAC,IAAI,IAAI,EAAE,GAAI,YAAe,CAAC,IAAI,IAAI,GAAG,IAEtD,SAASC,EAAe9pI,GAEtB,OADAA,EAAIiM,KAAKggC,MAAMjsC,IACJ,EAAI,EAAIA,EAAI,IAAM,IAAMA,EAGrC,SAAS+pI,EAAgB3qB,GACvB,OAAOA,EAAI,EAAI,EAAIA,EAAI,EAAI,EAAIA,EAGjC,SAAS4qB,EAAc/5C,GACrB,MAA4B,MAAxBA,EAAIA,EAAI/rF,OAAS,GACZ4lI,EAAel6G,WAAWqgE,GAAO,IAAM,KACzC65C,EAAe9qG,SAASixD,IAGjC,SAASg6C,EAAgBh6C,GACvB,MAA4B,MAAxBA,EAAIA,EAAI/rF,OAAS,GACZ6lI,EAAgBn6G,WAAWqgE,GAAO,KACpC85C,EAAgBn6G,WAAWqgE,IAGpC,SAASi6C,EAAeC,EAAIC,EAAIp7G,GAI9B,OAHIA,EAAI,EAAGA,GAAK,EACPA,EAAI,IAAGA,GAAK,GAEb,EAAJA,EAAQ,EAAUm7G,GAAMC,EAAKD,GAAMn7G,EAAI,EACnC,EAAJA,EAAQ,EAAUo7G,EACd,EAAJp7G,EAAQ,EAAUm7G,GAAMC,EAAKD,IAAO,EAAE,EAAIn7G,GAAK,EAC5Cm7G,EAwET,IAAMrqI,EAAQiiC,cArEd,SAAuBsoG,GAErB,IAeQC,EAfJr6C,EAAMo6C,EAAQr7H,QAAQ,KAAM,IAAIu7H,cAGpC,GAAIt6C,KAAO45C,EAAgB,OAAOA,EAAe55C,GAAK/mF,QAGtD,GAAe,MAAX+mF,EAAI,GACN,OAAmB,IAAfA,EAAI/rF,QACFomI,EAAKtrG,SAASixD,EAAI/pC,OAAO,GAAI,MACrB,GAAKokF,GAAM,KAChB,EAAQ,KAALA,IAAe,GAAY,KAALA,IAAe,EACjC,IAALA,GAAoB,IAALA,IAAc,EACxB,GAALA,GAAmB,GAALA,IAAa,EAC5B,GAJ8B,KAKd,IAAfr6C,EAAI/rF,SACTomI,EAAKtrG,SAASixD,EAAI/pC,OAAO,GAAI,MACrB,GAAKokF,GAAM,SAChB,EAAO,SAALA,IAAkB,IACb,MAALA,IAAgB,EACZ,IAALA,EACA,GAGH,KAGT,IAAInnI,EAAK8sF,EAAI16D,QAAQ,KAAMi1G,EAAKv6C,EAAI16D,QAAQ,KAC5C,IAAY,IAARpyB,GAAaqnI,EAAK,IAAMv6C,EAAI/rF,OAAQ,CACtC,IAAIumI,EAAQx6C,EAAI/pC,OAAO,EAAG/iD,GACtB8c,EAASgwE,EAAI/pC,OAAO/iD,EAAG,EAAGqnI,GAAIrnI,EAAG,IAAI89G,MAAM,KAC3C/qD,EAAQ,EACZ,OAAQu0E,GACN,IAAK,OACH,GAAsB,IAAlBxqH,EAAO/b,OAAc,OAAO,KAChCgyD,EAAQ+zE,EAAgBhqH,EAAO0+D,OAEjC,IAAK,MACH,OAAsB,IAAlB1+D,EAAO/b,OAAqB,KACzB,CAAC8lI,EAAc/pH,EAAO,IACrB+pH,EAAc/pH,EAAO,IACrB+pH,EAAc/pH,EAAO,IACrBi2C,GACV,IAAK,OACH,GAAsB,IAAlBj2C,EAAO/b,OAAc,OAAO,KAChCgyD,EAAQ+zE,EAAgBhqH,EAAO0+D,OAEjC,IAAK,MACH,GAAsB,IAAlB1+D,EAAO/b,OAAc,OAAO,KAChC,IAAI8qB,GAAOY,WAAW3P,EAAO,IAAM,IAAO,KAAO,IAAO,IAGpDle,EAAIkoI,EAAgBhqH,EAAO,IAC3BhgB,EAAIgqI,EAAgBhqH,EAAO,IAC3BmqH,EAAKnqI,GAAK,GAAMA,GAAK8B,EAAI,GAAK9B,EAAI8B,EAAI9B,EAAI8B,EAC1CooI,EAAS,EAAJlqI,EAAQmqI,EACjB,MAAO,CAACN,EAA+C,IAAhCI,EAAeC,EAAIC,EAAIp7G,EAAE,EAAE,IAC1C86G,EAA2C,IAA5BI,EAAeC,EAAIC,EAAIp7G,IACtC86G,EAA+C,IAAhCI,EAAeC,EAAIC,EAAIp7G,EAAE,EAAE,IAC1CknC,GACV,QACE,OAAO,MAIb,OAAO,MAGqC,MAAM5uD,M,4HClMpD,aAqBA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,QAEA,OACA,QAuBMojI,EAAsB,IAAI3lI,IAQhC,SAAS4lI,EAAa7nI,EAA+BL,G,UACjD,GAAIA,aAAgB,EAAAyD,kBAChB,OAAyB,QAAzB,EAAOzD,EAAKmoI,qBAAa,QAAInoI,EAAKxB,MAGtC,MAAMA,EAAQ6B,EAAQu5E,SAAS55E,GAE/B,MAAqB,iBAAVxB,GACwC,QAA/C,EAAwB,QAAxB,EAAO,EAAAyF,KAAKnC,MAAMtD,UAAM,QAAI,EAAA0F,OAAOpC,MAAMtD,UAAM,QAG5CA,EAkIX,6BACI,YACa4pI,EACA7lI,EACAC,EACAH,GAHA,KAAA+lI,YACA,KAAA7lI,MACA,KAAAC,QACA,KAAAH,QAQb,SAASrC,G,QACL,QAAamC,IAATnC,EACA,MAAM,IAAI4D,MAAM,iCAGpB,MAAMykI,EAAyB,QAAb,EAAGloI,KAAKkC,aAAK,eAAEjE,IAAI4B,GAErC,QAAqBmC,IAAjBkmI,EACA,OAAOA,EAGX,MAAM/hI,EAAStG,EAAKE,OAAOC,KAAKioI,UAAWjoI,MAE3C,OADU,QAAV,EAAAA,KAAKkC,aAAK,SAAE8E,IAAInH,EAAMsG,GACfA,EAQX,UAAU9H,GACN,OAAO,EAAAmD,KAAKuG,OAAO1J,GAASA,EAAQ,EAAA8E,YAAYglI,UAAU9pI,KASlE,MAAaiB,EACT,sBAAsBiB,EAAY6nI,GAC9BN,EAAoB9gI,IAAIzG,EAAI6nI,GAGhC,uBAAuBC,GACnBvqI,OAAOy0B,oBAAoB81G,GAAUhoI,QAAQnB,IACzCc,KAAKsoI,eAAeppI,EAAGmpI,EAASnpI,MAQxC,mBAAmBqB,GACf,OAAOunI,EAAoB7pI,IAAIsC,GAGnC,aAAaV,EAAeK,GACxB,MAAM7B,EAAQ6B,EAAQkC,IAAI6qB,OAAOptB,EAAKlC,MACtC,YAAiBqE,IAAV3D,EAAsBA,EAAQ,KAGzC,qBAAqBwB,EAAuBK,GACxC,OAAO,KAGX,wBAAwBL,EAA0BK,GAC9C,OAAOL,EAAKxB,MAGhB,uBAAuBwB,EAAyBK,GAC5C,OAAOL,EAAKxB,MAGhB,uBAAuBwB,EAAyBK,GAC5C,OAAOL,EAAKxB,MAGhB,uBAAuBwB,EAAyBK,GAC5C,OAAOL,EAAKxB,MAGhB,sBAAsBwB,EAAwBK,GAC1C,YAAyC8B,IAAlC9B,EAAQkC,IAAI6qB,OAAOptB,EAAKlC,MAGnC,eAAesgC,EAAkB/9B,GAC7B,MAAMhC,EAAIgC,EAAQu5E,SAASx7C,EAAM5/B,OACjC,IAAK,MAAO2H,EAAOC,KAASg4B,EAAMv9B,SAAU,CACxC,GAAIU,MAAMC,QAAQ2E,IAAWA,EAAgB8tE,SAAS51E,GAClD,OAAOgC,EAAQu5E,SAASxzE,GACrB,GAAID,IAAU9H,EACjB,OAAOgC,EAAQu5E,SAASxzE,GAGhC,OAAO/F,EAAQu5E,SAASx7C,EAAMp9B,UAGlC,cAAco9B,EAAiB/9B,GAC3B,GAAIA,EAAQmC,QAAU,EAAAd,UAAUe,MAAO,CACnC,MAAMimI,EAAwBtqG,EAAMv9B,SAASqjF,UAAU,EAAEjjF,EAAWH,KAChEG,EAAU6D,aAGd,IAA+B,IAA3B4jI,EAA8B,CAC9B,IAAI7nI,EAGJ,IAAK,IAAItD,EAAI,EAAGA,EAAI6gC,EAAMv9B,SAASY,SAAUlE,EAAG,CAC5C,MAAO0D,EAAWmF,GAAQg4B,EAAMv9B,SAAStD,GAEnCorI,EAAqBtoI,EAAQu5E,SAAS34E,GACtC2nI,EAAgBvoI,EAAQu5E,SAASxzE,GAEvC,GAAI7I,EAAImrI,GAAyBp0D,QAAQq0D,GACrC,OAAOC,EAGX,IAAK,EAAAjnI,KAAKuG,OAAOygI,IAAwBr0D,QAAQq0D,WAKhCxmI,IAAbtB,IACAA,EAAW,IAGfA,WAAUwF,KAAK,CACXhG,EAAQwoI,UAAUF,GAClBtoI,EAAQwoI,UAAUD,MAGjB,EAAAjnI,KAAKuG,OAAOygI,IAAuBr0D,QAAQq0D,IAE5C,OAAO,IAAI,EAAAvjI,SAASvE,EAAU,EAAAyC,YAAYglI,UAAU,OAI5D,MAAMtnI,EAAWX,EAAQu5E,SAASx7C,EAAMp9B,UAExC,YAAoBmB,IAAbtB,EACDG,EACA,IAAI,EAAAoE,SAASvE,EAAUR,EAAQwoI,UAAU7nI,KAIvD,IAAK,MAAOC,EAAWmF,KAASg4B,EAAMv9B,SAClC,GAAIR,EAAQu5E,SAAS34E,GACjB,OAAOZ,EAAQu5E,SAASxzE,GAIhC,OAAO/F,EAAQu5E,SAASx7C,EAAMp9B,UAGlC,cAAchB,EAAgBK,G,MAC1B,MAAMoE,EAA4B,QAAlB,EAAGzE,EAAKyE,kBAAU,QAAIwjI,EAAoB7pI,IAAI4B,EAAKU,IAEnE,GAAI+D,EAAY,CAGZ,IAAI6B,EAEJ,GAJAtG,EAAKyE,WAAaA,EAIdpE,EAAQmC,QAAU,EAAAd,UAAUe,OAASzC,EAAK8E,YAAa,CACvD,GAAI9E,EAAKyE,WAAWqkI,gBAChB,OAAO9oI,EAAKyE,WAAWqkI,gBAAgBzoI,EAASL,GAGpD,MAAMO,EAAOP,EAAKO,KAAK2F,IAAIiuH,GAChB9zH,EAAQwoI,UAAUxoI,EAAQu5E,SAASu6C,KAG9C,GAAI5zH,EAAK2E,MAAM,CAACivH,EAAK52H,IAAM42H,IAAQn0H,EAAKO,KAAKhD,IACzC,OAAOyC,EAGXsG,EAAS,IAAI,EAAA/B,SAASvE,EAAKU,GAAIH,QAE/B+F,EAAS7B,EAAW/G,KAAK2C,EAASL,GAGtC,OAAOsG,EAGX,MAAM,IAAI1C,MAAM,uBAAuB5D,EAAKU,OAGhD,cAAcV,EAAgBK,GAC1B,GAAIA,EAAQmC,QAAU,EAAAd,UAAUe,MAAO,CACnC,MAAMvB,EAAQb,EAAQu5E,SAAS55E,EAAKkB,OAC9BC,EAAed,EAAQu5E,SAAS55E,EAAKmB,cAC3C,OAAO,IAAI,EAAAoE,SACPlF,EAAQwoI,UAAU3nI,GAClBb,EAAQwoI,UAAU1nI,GAElBnB,EAAKoB,MAAM8E,IAAI,EAAEpH,EAAKN,MAClB,MAAM8C,EAAIjB,EAAQu5E,SAASp7E,GAC3B,MAAO,CAACM,EAAKuB,EAAQwoI,UAAUvnI,OAGpC,CACH,MAAMJ,EAAQb,EAAQu5E,SAAS55E,EAAKkB,OAEpC,GAAqB,iBAAVA,EACP,MAAM,IAAI0C,MAAM,UAAU1C,uBAG9B,GAAIA,EAAQlB,EAAKoB,MAAM,GAAG,GACtB,OAAOf,EAAQu5E,SAAS55E,EAAKmB,cAGjC,IAAI0Z,EAAQ7a,EAAKoB,MAAM8iF,UAAU5kF,GAAKA,EAAE,GAAK4B,GAM7C,OAJe,IAAX2Z,IACAA,EAAQ7a,EAAKoB,MAAMK,QAGhBpB,EAAQu5E,SAAS55E,EAAKoB,MAAMyZ,EAAQ,GAAG,KAItD,qBAAqB7a,EAAuBK,GACxC,GAAIA,EAAQmC,QAAU,EAAAd,UAAUe,MAAO,CACnC,MAAMvB,EAAQb,EAAQu5E,SAAS55E,EAAKkB,OACpC,OAAO,IAAI,EAAAuE,gBACPzF,EAAKtB,KACL2B,EAAQwoI,UAAU3nI,GAClBlB,EAAKoB,MAAM8E,IAAI,EAAEpH,EAAKN,MAClB,MAAM8C,EAAIjB,EAAQu5E,SAASp7E,GAC3B,MAAO,CAACM,EAAKuB,EAAQwoI,UAAUvnI,OAGpC,CACH,MAAMynI,EAAQ1oI,EAAQu5E,SAAS55E,EAAKkB,OAEpC,GAAqB,iBAAV6nI,EACP,MAAM,IAAInlI,MAAM,0BAGpB,GAAqB,UAAjB5D,EAAKtB,KAAK,GACV,OArXhB,SACI2B,EACAymG,EACAroG,GAEA,GAAIA,EAAIqoG,EAAO1lG,MAAM,GAAG,GACpB,OAAO8mI,EAAa7nI,EAASymG,EAAO1lG,MAAM,GAAG,IAC1C,GAAI3C,GAAKqoG,EAAO1lG,MAAM0lG,EAAO1lG,MAAMK,OAAS,GAAG,GAClD,OAAOymI,EAAa7nI,EAASymG,EAAO1lG,MAAM0lG,EAAO1lG,MAAMK,OAAS,GAAG,IAIvE,MAAMunI,EAAKliC,EAAO1lG,MAAM8iF,UAAUj6C,GAAQA,EAAK,GAAKxrC,GAC9CwqI,EAAKz/H,KAAKS,IAAI,EAAG++H,EAAK,GACtBE,EAAY,IAAPD,EAAWD,EAAKC,EAAK,EAC1BE,EAAKH,EAAKliC,EAAO1lG,MAAMK,OAAS,EAAIunI,EAAK,EAAIA,EAAK,EAGlDI,EAAKtiC,EAAO1lG,MAAM8nI,GAAI,GACtB9vB,EAAKtS,EAAO1lG,MAAM6nI,GAAI,GACtB3vB,EAAKxS,EAAO1lG,MAAM4nI,GAAI,GAGtBK,EAAiB,IAAX/vB,EAAKF,GACXkwB,EAAKD,GAAMjwB,EAAKgwB,GAChBG,EAAKF,GAJAviC,EAAO1lG,MAAM+nI,GAAI,GAIN7vB,GAChBj6G,GAAKZ,EAAI26G,IAAOE,EAAKF,GACrBowB,EAAKnqI,EAAIA,EACToqI,EAAMD,EAAKnqI,EAGXqqI,GAAMJ,EAAKG,EAAM,EAAIH,EAAKE,EAAKF,EAAKjqI,EACpCsqI,GAAM,EAAIL,GAAMG,IAAQ,IAAM,EAAIH,GAAME,IAAO,GAAMF,GAAMjqI,EAAI,EAC/DuqI,IAAO,EAAIL,GAAME,GAAO,IAAMF,GAAMC,EAAK,GAAMnqI,EAC/CwqI,EAAKN,EAAKE,EAAMF,EAAKC,EAGrB3gH,EAAKq/G,EAAa7nI,EAASymG,EAAO1lG,MAAM8nI,GAAI,IAC5C55E,EAAK44E,EAAa7nI,EAASymG,EAAO1lG,MAAM6nI,GAAI,IAC5Cz5E,EAAK04E,EAAa7nI,EAASymG,EAAO1lG,MAAM4nI,GAAI,IAC5Cc,EAAK5B,EAAa7nI,EAASymG,EAAO1lG,MAAM+nI,GAAI,IAElD,GACkB,iBAAPtgH,GACO,iBAAPymC,GACO,iBAAPE,GACO,iBAAPs6E,EAEP,OAAOJ,EAAK7gH,EAAK8gH,EAAKr6E,EAAKs6E,EAAKp6E,EAAKq6E,EAAKC,EACvC,GACHjhH,aAAc,EAAA5kB,MACdqrD,aAAc,EAAArrD,MACdurD,aAAc,EAAAvrD,MACd6lI,aAAc,EAAA7lI,KAEd,OAAO,IAAI,EAAAA,KACP1E,EAAMkJ,UAAU6B,MAAMo/H,EAAK7gH,EAAGxqB,EAAIsrI,EAAKr6E,EAAGjxD,EAAIurI,EAAKp6E,EAAGnxD,EAAIwrI,EAAKC,EAAGzrI,EAAG,EAAG,GACxEkB,EAAMkJ,UAAU6B,MAAMo/H,EAAK7gH,EAAGmF,EAAI27G,EAAKr6E,EAAGthC,EAAI47G,EAAKp6E,EAAGxhC,EAAI67G,EAAKC,EAAG97G,EAAG,EAAG,GACxEzuB,EAAMkJ,UAAU6B,MAAMo/H,EAAK7gH,EAAGhf,EAAI8/H,EAAKr6E,EAAGzlD,EAAI+/H,EAAKp6E,EAAG3lD,EAAIggI,EAAKC,EAAGjgI,EAAG,EAAG,GACxEtK,EAAMkJ,UAAU6B,MAAMo/H,EAAK7gH,EAAGlf,EAAIggI,EAAKr6E,EAAG3lD,EAAIigI,EAAKp6E,EAAG7lD,EAAIkgI,EAAKC,EAAGngI,EAAG,EAAG,IAEzE,GACHkf,aAAc,EAAA3kB,QACdorD,aAAc,EAAAprD,QACdsrD,aAAc,EAAAtrD,QACd4lI,aAAc,EAAA5lI,OAEd,OAAO,IAAI,EAAAA,OAAOwlI,EAAK7gH,EAAGrqB,MAAQmrI,EAAKr6E,EAAG9wD,MAAQorI,EAAKp6E,EAAGhxD,MAAQqrI,EAAKC,EAAGtrI,OACvE,GACHqqB,aAActpB,EAAMsqB,OACpBylC,aAAc/vD,EAAMsqB,OACpB2lC,aAAcjwD,EAAMsqB,OACpBigH,aAAcvqI,EAAMsqB,MAEpB,OAAO,IAAItqB,EAAMsqB,MACb6/G,EAAK7gH,EAAGxqB,EAAIsrI,EAAKr6E,EAAGjxD,EAAIurI,EAAKp6E,EAAGnxD,EAAIwrI,EAAKC,EAAGzrI,EAC5CqrI,EAAK7gH,EAAGmF,EAAI27G,EAAKr6E,EAAGthC,EAAI47G,EAAKp6E,EAAGxhC,EAAI67G,EAAKC,EAAG97G,EAC5C07G,EAAK7gH,EAAGhf,EAAI8/H,EAAKr6E,EAAGzlD,EAAI+/H,EAAKp6E,EAAG3lD,EAAIggI,EAAKC,EAAGjgI,GAE7C,GACHgf,aAActpB,EAAMoG,SACpB2pD,aAAc/vD,EAAMoG,SACpB6pD,aAAcjwD,EAAMoG,SACpBmkI,aAAcvqI,EAAMoG,QAEpB,OAAO,IAAIpG,EAAMoG,QACb+jI,EAAK7gH,EAAGjjB,EAAI+jI,EAAKr6E,EAAG1pD,EAAIgkI,EAAKp6E,EAAG5pD,EAAIikI,EAAKC,EAAGlkI,EAC5C8jI,EAAK7gH,EAAGhjB,EAAI8jI,EAAKr6E,EAAGzpD,EAAI+jI,EAAKp6E,EAAG3pD,EAAIgkI,EAAKC,EAAGjkI,GAE7C,GACHgjB,aAActpB,EAAMuG,SACpBwpD,aAAc/vD,EAAMuG,SACpB0pD,aAAcjwD,EAAMuG,SACpBgkI,aAAcvqI,EAAMuG,QAEpB,OAAO,IAAIvG,EAAMuG,QACb4jI,EAAK7gH,EAAGjjB,EAAI+jI,EAAKr6E,EAAG1pD,EAAIgkI,EAAKp6E,EAAG5pD,EAAIikI,EAAKC,EAAGlkI,EAC5C8jI,EAAK7gH,EAAGhjB,EAAI8jI,EAAKr6E,EAAGzpD,EAAI+jI,EAAKp6E,EAAG3pD,EAAIgkI,EAAKC,EAAGjkI,EAC5C6jI,EAAK7gH,EAAG9iB,EAAI4jI,EAAKr6E,EAAGvpD,EAAI6jI,EAAKp6E,EAAGzpD,EAAI8jI,EAAKC,EAAG/jI,GAE7C,GACH8iB,aAActpB,EAAMyG,SACpBspD,aAAc/vD,EAAMyG,SACpBwpD,aAAcjwD,EAAMyG,SACpB8jI,aAAcvqI,EAAMyG,QAEpB,OAAO,IAAIzG,EAAMyG,QACb0jI,EAAK7gH,EAAGjjB,EAAI+jI,EAAKr6E,EAAG1pD,EAAIgkI,EAAKp6E,EAAG5pD,EAAIikI,EAAKC,EAAGlkI,EAC5C8jI,EAAK7gH,EAAGhjB,EAAI8jI,EAAKr6E,EAAGzpD,EAAI+jI,EAAKp6E,EAAG3pD,EAAIgkI,EAAKC,EAAGjkI,EAC5C6jI,EAAK7gH,EAAG9iB,EAAI4jI,EAAKr6E,EAAGvpD,EAAI6jI,EAAKp6E,EAAGzpD,EAAI8jI,EAAKC,EAAG/jI,EAC5C2jI,EAAK7gH,EAAG5iB,EAAI0jI,EAAKr6E,EAAGrpD,EAAI2jI,EAAKp6E,EAAGvpD,EAAI4jI,EAAKC,EAAG7jI,GAE7C,GAAI1E,MAAMC,QAAQqnB,IAAOtnB,MAAMC,QAAQ8tD,IAAO/tD,MAAMC,QAAQguD,IAAOjuD,MAAMC,QAAQsoI,GAAK,CACzF,MAAM1T,EAAIvtG,EAAGpnB,OACPpD,EAAc,GACpB,IAAK,IAAId,EAAI,EAAGA,EAAI64H,IAAK74H,EACrBc,EAAEd,GAAKmsI,EAAK7gH,EAAGtrB,GAAKosI,EAAKr6E,EAAG/xD,GAAKqsI,EAAKp6E,EAAGjyD,GAAKssI,EAAKC,EAAGvsI,GAE1D,OAAOc,EAGX,MAAM,IAAIuF,MAAM,gCA4PGmmI,CAAiB1pI,EAASL,EAAM+oI,GAG3C,MAAMiB,EAAWhqI,EAAKoB,MAAM8iF,UAAUj6C,GAAQA,EAAK,GAAK8+F,GAExD,IAAkB,IAAdiB,EAEA,OAAO3pI,EAAQu5E,SAAS55E,EAAKoB,MAAMpB,EAAKoB,MAAMK,OAAS,GAAG,IACvD,GAAiB,IAAbuoI,EACP,OAAO3pI,EAAQu5E,SAAS55E,EAAKoB,MAAM,GAAG,IAG1C,MAAOtC,EAAKN,GAASwB,EAAKoB,MAAM4oI,IACzBC,EAASC,GAAalqI,EAAKoB,MAAM4oI,EAAW,GAE7C16E,EAAK44E,EAAa7nI,EAAS6pI,GAEjC,IAAIzrI,EAAI,EAER,OAAQuB,EAAKtB,KAAK,IACd,IAAK,WACD,OAAO4wD,EAEX,IAAK,SACD7wD,GAAKsqI,EAAQkB,IAAYnrI,EAAMmrI,GAC/B,MAEJ,IAAK,cAAe,CAChB,MAAME,EAAOnqI,EAAKtB,KAAK,GACvBD,GAAK+K,KAAK2N,IAAIgzH,EAAMpB,EAAQkB,GAAW,IAAMzgI,KAAK2N,IAAIgzH,EAAMrrI,EAAMmrI,GAAW,GAC7E,MAGJ,QACI,MAAM,IAAIrmI,MACN,sBAAsBgE,KAAKC,UAAU7H,EAAKtB,0BAItD,MAAM8wD,EAAK04E,EAAa7nI,EAAS7B,GAEjC,GAAkB,iBAAP8wD,GAAiC,iBAAPE,EACjC,OAAOjwD,EAAMkJ,UAAUo1B,KAAKyxB,EAAIE,EAAI/wD,GACjC,GAAI6wD,aAAc,EAAArrD,MAAQurD,aAAc,EAAAvrD,KAC3C,OAAOqrD,EAAGtiD,QAAQ6wB,KAAK2xB,EAAI/wD,GACxB,GAAI6wD,aAAc,EAAAprD,QAAUsrD,aAAc,EAAAtrD,OAC7C,OAAO,IAAI,EAAAA,OAAO3E,EAAMkJ,UAAUo1B,KAAKyxB,EAAG9wD,MAAOgxD,EAAGhxD,MAAOC,IACxD,GAAI6wD,aAAc/vD,EAAMsqB,OAAS2lC,aAAcjwD,EAAMsqB,MACxD,OAAOylC,EAAGtiD,QAAQ6wB,KAAK2xB,EAAI/wD,GACxB,GAAI6wD,aAAc/vD,EAAMoG,SAAW6pD,aAAcjwD,EAAMoG,QAC1D,OAAO2pD,EAAGtiD,QAAQ6wB,KAAK2xB,EAAI/wD,GACxB,GAAI6wD,aAAc/vD,EAAMuG,SAAW0pD,aAAcjwD,EAAMuG,QAC1D,OAAOwpD,EAAGtiD,QAAQ6wB,KAAK2xB,EAAI/wD,GACxB,GAAI6wD,aAAc/vD,EAAMyG,SAAWwpD,aAAcjwD,EAAMyG,QAC1D,OAAOspD,EAAGtiD,QAAQ6wB,KAAK2xB,EAAI/wD,GACxB,GAAI8C,MAAMC,QAAQ8tD,IAAO/tD,MAAMC,QAAQguD,IAAOF,EAAG7tD,SAAW+tD,EAAG/tD,OAClE,OAAO6tD,EAAGppD,IAAI,CAACN,EAAGrI,IAAMgC,EAAMkJ,UAAUo1B,KAAKj4B,EAAI4pD,EAAgBjyD,GAAIkB,IAGzE,MAAM,IAAImF,MAAM,aAAagE,KAAKC,UAAUynD,OAAQ1nD,KAAKC,UAAU2nD,OAAQ/wD,QArQvF,kBA0QAgB,EAAc2qI,gBAAgB,EAAAC,eAC9B5qI,EAAc2qI,gBAAgB,EAAAE,qBAC9B7qI,EAAc2qI,gBAAgB,EAAAG,eAC9B9qI,EAAc2qI,gBAAgB,EAAAI,iBAC9B/qI,EAAc2qI,gBAAgB,EAAAK,gBAC9BhrI,EAAc2qI,gBAAgB,EAAAM,eAC9BjrI,EAAc2qI,gBAAgB,EAAAO,eAC9BlrI,EAAc2qI,gBAAgB,EAAAQ,eAC9BnrI,EAAc2qI,gBAAgB,EAAAS,gBAC9BprI,EAAc2qI,gBAAgB,EAAAU,iBAC9BrrI,EAAc2qI,gBAAgB,EAAAW,kBAC9BtrI,EAAc2qI,gBAAgB,EAAAY,cAC9BvrI,EAAc2qI,gBAAgB,EAAAa,kB,sGCnhB9B,aAGMC,EAAsB,CAAC,UAAW,SAAU,UAElD,SAASC,EAAkBhX,EAAWr6G,GAClC,KAAMq6G,aAAe,EAAA1wH,mBAAuBynI,EAAoBj3D,SAASkgD,EAAI31H,QACzE,MAAM,IAAIoF,MACN,wDAAwDgE,KAAKC,UAAUssH,OAI/E,MAAMiX,EAAKjX,EAAI31H,MAEfsb,EAAMtZ,QAAQ,CAAC83B,EAASzd,KACpB,UAAWyd,IAAY8yG,EACnB,MAAM,IAAIxnI,MAAM,mCAAmCiX,mBAAuBuwH,QAiBtF,SAASC,EAAWhrI,EAA+B8zH,GAC/C,MAAM31H,EAAQ6B,EAAQu5E,SAASu6C,GAC/B,IAAK5yH,MAAMC,QAAQhD,GACf,MAAM,IAAIoF,MAAM,IAAIpF,sBAExB,OAAOA,EAGX,MAAM8sI,EAAY,CACdxxH,MAAO,CACHpc,KAAM,CAAC2C,EAA+B3C,KAClC,OAAQA,EAAK6C,KAAKkB,QACd,KAAK,EACD,MAAM,IAAImC,MAAM,wBACpB,KAAK,EACD,OAAOynI,EAAWhrI,EAAS3C,EAAK6C,KAAK,IACzC,KAAK,EAAG,CACJ,MAAMuZ,EAAQuxH,EAAWhrI,EAAS3C,EAAK6C,KAAK,IAE5C,OADA4qI,EAAkBztI,EAAK6C,KAAK,GAAIuZ,GACzBA,EAEX,KAAK,EAAG,CACJ,MAAMA,EAAQuxH,EAAWhrI,EAAS3C,EAAK6C,KAAK,IAG5C,OArCpB,SAA0B4zH,EAAWr6G,GACjC,KAAMq6G,aAAe,EAAA3wH,mBACjB,MAAM,IAAII,MAAM,uCAGpB,MAAMnC,EAAS0yH,EAAI31H,MAEnB,GAAIsb,EAAMrY,SAAWA,EACjB,MAAM,IAAImC,MAAM,uBAAuBnC,gBA2B3B8pI,CAAiB7tI,EAAK6C,KAAK,GAAIuZ,GAC/BqxH,EAAkBztI,EAAK6C,KAAK,GAAIuZ,GACzBA,EAEX,QACI,MAAM,IAAIlW,MAAM,yBAIhC,aAAc,CACVlG,KAAM,CAAC2C,EAA+B3C,KAClC,GAAyB,IAArBA,EAAK6C,KAAKkB,OACV,MAAM,IAAImC,MAAM,wBAEpB,MAAO,IAAIlG,EAAK6C,KAAK2F,IAAIiuH,GAAO9zH,EAAQu5E,SAASu6C,OAGzDqX,GAAI,CACA9tI,KAAM,CAAC2C,EAA+B3C,KAClC,MAAM6C,EAAO7C,EAAK6C,KACZsa,EAAQxa,EAAQu5E,SAASr5E,EAAK,IACpC,GAAqB,iBAAVsa,EACP,MAAM,IAAIjX,MAAM,iDAEpB,MAAMpF,EAAQ6B,EAAQu5E,SAASr5E,EAAK,IACpC,IAAKgB,MAAMC,QAAQhD,GACf,MAAM,IAAIoF,MAAM,qBAEpB,OAAOiX,GAAS,GAAKA,EAAQrc,EAAMiD,OAASjD,EAAMqc,GAAS,QAK1D,EAAAgwH,eAAwCS,G,qGCtFrD,MAAMA,EAAY,CACd,aAAc,CACV5tI,KAAM,CAAC2C,EAA+B3C,IAC3B42E,QAAQj0E,EAAQu5E,SAASl8E,EAAK6C,KAAK,MAIlD,YAAa,CACT7C,KAAM,CAAC2C,EAA+B3C,IAC3BsyD,OAAO3vD,EAAQu5E,SAASl8E,EAAK6C,KAAK,MAIjD,YAAa,CACT7C,KAAM,CAAC2C,EAA+B3C,KAClC,IAAK,MAAMy2H,KAAOz2H,EAAK6C,KAAM,CACzB,MAAM/B,EAAQypB,OAAO5nB,EAAQu5E,SAASu6C,IACtC,IAAK9qH,MAAM7K,GACP,OAAOA,EAGf,MAAM,IAAIoF,MAAM,2CAKf,EAAAymI,cAAuCiB,G,sGC7BpD,aAEA,QAGA,QAEMA,EAAY,CACd73E,MAAO,CACH/1D,KAAM,CAAC2C,EAA+B3C,KAClC,IAAI0tB,EAA2B/qB,EAAQu5E,SAASl8E,EAAK6C,KAAK,IAK1D,MAJqB,iBAAV6qB,IACPA,EAAQ,EAAAmD,wBAAwBnD,IAEL,iBAAVA,EAAqB,EAAAsC,WAAWuJ,gBAAgB7L,GAAS,IAItFqgH,KAAM,CACF/tI,KAAM,CAAC2C,EAA+B3C,KAClC,MAAMW,EAAIgC,EAAQu5E,SAASl8E,EAAK6C,KAAK,IAC/BytB,EAAI3tB,EAAQu5E,SAASl8E,EAAK6C,KAAK,IAC/BsJ,EAAIxJ,EAAQu5E,SAASl8E,EAAK6C,KAAK,IAC/BoJ,EAAItJ,EAAQu5E,SAASl8E,EAAK6C,KAAK,IACrC,GACiB,iBAANlC,GACM,iBAAN2vB,GACM,iBAANnkB,GACM,iBAANF,GACPtL,GAAK,GACL2vB,GAAK,GACLnkB,GAAK,GACLF,GAAK,GACLA,GAAK,EAEL,OA6ChB,SAAmBtL,EAAW2vB,EAAWnkB,EAAWF,GAEhD,OAAO,EAAA+jB,WAAWgJ,eACdn3B,EAAMkJ,UAAU6B,MAAMjM,EAAG,EAAG,KAAO,IACnCkB,EAAMkJ,UAAU6B,MAAM0jB,EAAG,EAAG,KAAO,IACnCzuB,EAAMkJ,UAAU6B,MAAMT,EAAG,EAAG,KAAO,IACnCtK,EAAMkJ,UAAU6B,MAAMX,EAAG,EAAG,IAnDb+hI,CAAUrtI,EAAG2vB,EAAGnkB,EAAGF,GAE9B,MAAM,IAAI/F,MAAM,uBAAuBvF,KAAK2vB,KAAKnkB,KAAKF,SAG9DgiI,IAAK,CACDjuI,KAAM,CAAC2C,EAA+B3C,KAClC,MAAMW,EAAIgC,EAAQu5E,SAASl8E,EAAK6C,KAAK,IAC/BytB,EAAI3tB,EAAQu5E,SAASl8E,EAAK6C,KAAK,IAC/BsJ,EAAIxJ,EAAQu5E,SAASl8E,EAAK6C,KAAK,IACrC,GACiB,iBAANlC,GACM,iBAAN2vB,GACM,iBAANnkB,GACPxL,GAAK,GACL2vB,GAAK,GACLnkB,GAAK,EAEL,OAqChB,SAAkBxL,EAAW2vB,EAAWnkB,GACpC,OAAO,EAAA6jB,WAAWkJ,cACdr3B,EAAMkJ,UAAU6B,MAAMjM,EAAG,EAAG,KAAO,IACnCkB,EAAMkJ,UAAU6B,MAAM0jB,EAAG,EAAG,KAAO,IACnCzuB,EAAMkJ,UAAU6B,MAAMT,EAAG,EAAG,KAAO,KAzCpB+hI,CAASvtI,EAAG2vB,EAAGnkB,GAE1B,MAAM,IAAIjG,MAAM,sBAAsBvF,KAAK2vB,KAAKnkB,SAKxDgiI,IAAK,CACDnuI,KAAM,CAAC2C,EAA+B3C,KAClC,MAAM6uB,EAAIlsB,EAAQu5E,SAASl8E,EAAK6C,KAAK,IAC/BjB,EAAIe,EAAQu5E,SAASl8E,EAAK6C,KAAK,IAC/B/C,EAAI6C,EAAQu5E,SAASl8E,EAAK6C,KAAK,IACrC,GACiB,iBAANgsB,GACM,iBAANjtB,GACM,iBAAN9B,GACP+uB,GAAK,GACLjtB,GAAK,GACL9B,GAAK,EAEL,OAyBhB,SAAkB+uB,EAAWjtB,EAAW9B,GACpC,OAAO,EAAAkwB,WAAWmJ,cACdt3B,EAAMkJ,UAAUqjI,gBAAgBv/G,EAAG,KAAO,IAC1ChtB,EAAMkJ,UAAU6B,MAAMhL,EAAG,EAAG,KAAO,IACnCC,EAAMkJ,UAAU6B,MAAM9M,EAAG,EAAG,KAAO,KA7BpBuuI,CAASx/G,EAAGjtB,EAAG9B,GAE1B,MAAM,IAAIoG,MAAM,sBAAsB2oB,KAAKjtB,MAAM9B,WA+BhD,EAAAitI,eAAwCa,G,6BCvGrD,SAASU,EAAQ3rI,EAA+B3C,EAAgBuuI,GAAkB,GAC9E,MAAMhtH,EAAO5e,EAAQu5E,SAASl8E,EAAK6C,KAAK,IAClCif,EAAQnf,EAAQu5E,SAASl8E,EAAK6C,KAAK,IAEzC,KAEyB,iBAAT0e,GAAsC,iBAAVO,GACnB,iBAATP,GAAsC,iBAAVO,IAGpCysH,EACA,MAAM,IAAIroI,MAAM,qBAAqBqb,WAAcO,oBAAwB9hB,EAAKgD,OAIxF,OAAQhD,EAAKgD,IACT,IAAK,IACD,OAAOue,EAAOO,EAClB,IAAK,IACD,OAAOP,EAAOO,EAClB,IAAK,KACD,OAAOP,GAAQO,EACnB,IAAK,KACD,OAAOP,GAAQO,EACnB,QACI,MAAM,IAAI5b,MAAM,gCAAgClG,EAAKgD,Q,8EAIjE,MAAM4qI,EAAY,CACd,IAAK,CACD5tI,KAAM,CAAC2C,EAA+B3C,KAC1B2C,EAAQu5E,SAASl8E,EAAK6C,KAAK,KAI3C,KAAM,CACF7C,KAAM,CAAC2C,EAA+B3C,IACrB2C,EAAQu5E,SAASl8E,EAAK6C,KAAK,MAC1BF,EAAQu5E,SAASl8E,EAAK6C,KAAK,KAKjD,KAAM,CACF7C,KAAM,CAAC2C,EAA+B3C,IACrB2C,EAAQu5E,SAASl8E,EAAK6C,KAAK,MAC1BF,EAAQu5E,SAASl8E,EAAK6C,KAAK,KAKjD,IAAK,CAAE7C,KAAM,CAAC2C,EAA+B3C,IAAmBsuI,EAAQ3rI,EAAS3C,IACjF,IAAK,CAAEA,KAAM,CAAC2C,EAA+B3C,IAAmBsuI,EAAQ3rI,EAAS3C,IACjF,KAAM,CAAEA,KAAM,CAAC2C,EAA+B3C,IAAmBsuI,EAAQ3rI,EAAS3C,IAClF,KAAM,CAAEA,KAAM,CAAC2C,EAA+B3C,IAAmBsuI,EAAQ3rI,EAAS3C,KAGzE,EAAA4sI,oBAA6CgB,G,wGC7D1D,cACA,OAIMA,EAAY,CACd,gBAAiB,CACb5tI,KAAM,CAAC2C,EAA+B3C,KAElC,OADqB2C,EAAQkC,IAAI6qB,OAAO,kBAEpC,IAAK,QACD,MAAO,QACX,IAAK,OACD,MAAO,aACX,IAAK,UACD,MAAO,UACX,QACI,OAAO,QAIvB,gBAAiB,CACbzoB,kBAAmB,KAAM,EACzBjH,KAAM,CAAC2C,EAA+B3C,K,QAClC,GAAI2C,EAAQmC,QAAU,EAAAd,UAAUi3F,QAC5B,MAAM,IAAI/0F,MAAM,gDAEpB,MAAM1E,EAAWmB,EAAQu5E,SAASl8E,EAAK6C,KAAK,IAC5C,GAAwB,iBAAbrB,EACP,MAAM,IAAI0E,MAAM,0DAEpB,MAAMs6C,EAAQ79C,EAAQkC,IAAI6qB,OAAO,UACjC,OAAI,EAAAoS,IAAI0sG,MAAMhuF,GACmB,QAA7B,EAAOA,EAAM9wB,OAAOluB,UAAS,QAAI,KAC1Bg/C,aAAiB57C,KACE,QAA1B,EAAO47C,EAAM9/C,IAAIc,UAAS,QAEvB,OAGfgwB,GAAI,CACAxxB,KAAM,CAAC2C,EAA+B3C,K,MAClC,OAAgC,QAAhC,EAAO2C,EAAQkC,IAAI6qB,OAAO,cAAM,QAAI,QAKnC,EAAA29G,iBAA0CO,G,6BC5CvD,SAASa,EAAgB9rI,EAA+B0P,EAAcxP,GAClE,OAAQwP,GACJ,IAAK,UACL,IAAK,SACL,IAAK,SACD,IAAK,MAAMtP,KAAaF,EAAM,CAC1B,MAAM/B,EAAQ6B,EAAQu5E,SAASn5E,GAC/B,UAAWjC,IAAUuR,EACjB,OAAOvR,EAGf,MAAM,IAAIoF,MAAM,eAAemM,MACnC,QACI,MAAM,IAAInM,MAAM,iBAAiBmM,O,wEAI7C,MAAMu7H,EAAY,CACdjzF,IAAK,CACD36C,KAAM,CAAC2C,EAA+B3C,KAClC,IAAK,MAAM+C,KAAa/C,EAAK6C,KACzB,IAAKF,EAAQu5E,SAASn5E,GAClB,OAAO,EAGf,OAAO,IAIf2rI,IAAK,CACD1uI,KAAM,CAAC2C,EAA+B3C,KAClC,IAAK,MAAM+C,KAAa/C,EAAK6C,KACzB,GAAIF,EAAQu5E,SAASn5E,GACjB,OAAO,EAGf,OAAO,IAIf4rI,KAAM,CACF3uI,KAAM,CAAC2C,EAA+B3C,KAClC,IAAK,MAAM+C,KAAa/C,EAAK6C,KACzB,GAAIF,EAAQu5E,SAASn5E,GACjB,OAAO,EAGf,OAAO,IAIf6rI,QAAS,CACL5uI,KAAM,CAAC2C,EAA+B3C,IAC3ByuI,EAAgB9rI,EAAS,UAAW3C,EAAK6C,OAIxDgsI,OAAQ,CACJ7uI,KAAM,CAAC2C,EAA+B3C,IAC3ByuI,EAAgB9rI,EAAS,SAAU3C,EAAK6C,OAIvDisI,OAAQ,CACJ9uI,KAAM,CAAC2C,EAA+B3C,IAC3ByuI,EAAgB9rI,EAAS,SAAU3C,EAAK6C,QAK9C,EAAAqqI,cAAuCU,G,oGCzEpD,aAGMA,EAAY,CACd,YAAa,CACT5tI,KAAM,CAAC2C,EAA+B3C,IACpB2C,EAAQu5E,SAASl8E,EAAK6C,KAAK,KACrB7C,EAAK6C,KAAK,GAAMF,EAAQu5E,SAASl8E,EAAK6C,KAAK,IAAiB,IAIxF,kBAAmB,CACfoE,kBAAmB,KACR,EAEXjH,KAAM,CAAC2C,EAA+B3C,KAClC,MAAM+uI,EAASpsI,EAAQu5E,SAASl8E,EAAK6C,KAAK,IACpCsgD,EAAcnjD,EAAK6C,KAAK,GAAMF,EAAQu5E,SAASl8E,EAAK6C,KAAK,IAAiB,EAC1Eye,EAAO3e,EAAQkC,IAAI6qB,OAAO,SAGhC,OADUq/G,GADQjjI,KAAK2N,IAAI,EAAG,IAAM3N,KAAK2N,IAAI,EAAG6H,IACjB6hC,IAIvC,2BAA4B,CACxBl8C,kBAAmB,KACR,EAEXjH,KAAM,CAAC2C,EAA+B3C,KAClC,MAAM+uI,EAASpsI,EAAQu5E,SAASl8E,EAAK6C,KAAK,IACpCsgD,EAAcnjD,EAAK6C,KAAK,GAAMF,EAAQu5E,SAASl8E,EAAK6C,KAAK,IAAiB,EAC1Eye,EAAO3e,EAAQkC,IAAI6qB,OAAO,SAGhC,OADUq/G,GADgBjjI,KAAK2N,IAAI,EAAG,MAAQ3N,KAAK2N,IAAI,EAAG3N,KAAKmtB,MAAM3X,KAC9B6hC,IAI/C6rF,IAAK,CACDhvI,KAAO2C,IACH,MAAMqsI,EAAMrsI,EAAQkC,IAAI6qB,OAAO,QAC/B,MAAmB,iBAARs/G,EACAA,EAEJ,KAGf1tH,KAAM,CACFra,kBAAmB,KACR,EAEXjH,KAAM,CAAC2C,EAA+B3C,K,MAClC,OAAI2C,EAAQmC,QAAU,EAAAd,UAAUe,MACrB/E,EAEuB,QAAlC,EAAO2C,EAAQkC,IAAI6qB,OAAO,gBAAQ,QAAI,QAKrC,EAAA49G,aAAsCM,G,qGCxDnD,aAEMA,EAAY,CACd,IAAK,CACD5tI,KAAM,CAAC2C,EAA+B3C,KAClC,MAAMiM,EAAItJ,EAAQu5E,SAASl8E,EAAK6C,KAAK,IAC/BsJ,EAAIxJ,EAAQu5E,SAASl8E,EAAK6C,KAAK,IACrC,GAAiB,iBAANoJ,GAA+B,iBAANE,EAEhC,MAAM,IAAIjG,MACN,4BAA4B+F,kBAAkBE,uBAGtD,OAAOL,KAAK2N,IAAIxN,EAAGE,KAI3B,IAAK,CACDnM,KAAM,CAAC2C,EAA+B3C,KAClC,GAAyB,IAArBA,EAAK6C,KAAKkB,OAAc,CACxB,MAAMjD,EAAQ6B,EAAQu5E,SAASl8E,EAAK6C,KAAK,IACzC,GAAqB,iBAAV/B,EACP,MAAM,IAAIoF,MAAM,2BAA2BpF,sBAG/C,OAAQA,EAGZ,MAAMmL,EAAItJ,EAAQu5E,SAASl8E,EAAK6C,KAAK,IAC/BsJ,EAAIxJ,EAAQu5E,SAASl8E,EAAK6C,KAAK,IACrC,GAAiB,iBAANoJ,GAA+B,iBAANE,EAChC,MAAM,IAAIjG,MACN,4BAA4B+F,kBAAkBE,uBAGtD,OAAOF,EAAIE,IAInB,IAAK,CACDnM,KAAM,CAAC2C,EAA+B3C,KAClC,MAAMiM,EAAItJ,EAAQu5E,SAASl8E,EAAK6C,KAAK,IAC/BsJ,EAAIxJ,EAAQu5E,SAASl8E,EAAK6C,KAAK,IACrC,GAAiB,iBAANoJ,GAA+B,iBAANE,EAEhC,MAAM,IAAIjG,MACN,4BAA4B+F,kBAAkBE,uBAGtD,OAAOF,EAAIE,IAInB,IAAK,CACDnM,KAAM,CAAC2C,EAA+B3C,KAClC,MAAMiM,EAAItJ,EAAQu5E,SAASl8E,EAAK6C,KAAK,IAC/BsJ,EAAIxJ,EAAQu5E,SAASl8E,EAAK6C,KAAK,IACrC,GAAiB,iBAANoJ,GAA+B,iBAANE,EAEhC,MAAM,IAAIjG,MACN,4BAA4B+F,kBAAkBE,uBAGtD,OAAOF,EAAIE,IAInB,IAAK,CACDnM,KAAM,CAAC2C,EAA+B3C,IAC3BA,EAAK6C,KAAKo+B,OAAO,CAACh1B,EAAGE,IAAMoe,OAAOte,GAAKse,OAAO5nB,EAAQu5E,SAAS/vE,IAAK,IAInF,IAAK,CACDnM,KAAM,CAAC2C,EAA+B3C,IAC3BA,EAAK6C,KAAKo+B,OAAO,CAACh1B,EAAGE,IAAMoe,OAAOte,GAAKse,OAAO5nB,EAAQu5E,SAAS/vE,IAAK,IAInFsS,IAAK,CACDze,KAAM,CAAC2C,EAA+B3C,KAClC,MAAMc,EAAQ6B,EAAQu5E,SAASl8E,EAAK6C,KAAK,IACzC,GAAqB,iBAAV/B,EACP,MAAM,IAAIoF,MAAM,oBAAoBpF,yBAExC,OAAOgL,KAAK2S,IAAI3d,KAIxBsX,KAAM,CACFpY,KAAM,CAAC2C,EAA+B3C,KAClC,MAAMc,EAAQ6B,EAAQu5E,SAASl8E,EAAK6C,KAAK,IACzC,GAAqB,iBAAV/B,EACP,MAAM,IAAIoF,MAAM,oBAAoBpF,0BAExC,OAAOgL,KAAKsM,KAAKtX,KAIzB4f,KAAM,CACF1gB,KAAM,CAAC2C,EAA+B3C,KAClC,MAAMc,EAAQ6B,EAAQu5E,SAASl8E,EAAK6C,KAAK,IACzC,GAAqB,iBAAV/B,EACP,MAAM,IAAIoF,MAAM,oBAAoBpF,0BAExC,OAAOgL,KAAK4U,KAAK5f,KAIzBoiB,KAAM,CACFljB,KAAM,CAAC2C,EAA+B3C,KAClC,MAAMc,EAAQ6B,EAAQu5E,SAASl8E,EAAK6C,KAAK,IACzC,GAAqB,iBAAV/B,EACP,MAAM,IAAIoF,MAAM,oBAAoBpF,0BAExC,OAAOgL,KAAKoX,KAAKpiB,KAIzBuhB,KAAM,CACFriB,KAAM,CAAC2C,EAA+B3C,KAClC,MAAMc,EAAQ6B,EAAQu5E,SAASl8E,EAAK6C,KAAK,IACzC,GAAqB,iBAAV/B,EACP,MAAM,IAAIoF,MAAM,oBAAoBpF,0BAExC,OAAOgL,KAAKuW,KAAKvhB,KAIzBkS,IAAK,CACDhT,KAAM,CAAC2C,EAA+B3C,KAClC,MAAMc,EAAQ6B,EAAQu5E,SAASl8E,EAAK6C,KAAK,IACzC,GAAqB,iBAAV/B,EACP,MAAM,IAAIoF,MAAM,oBAAoBpF,yBAExC,OAAOgL,KAAKkH,IAAIlS,KAIxBqG,EAAG,CACCnH,KAAM,IACK8L,KAAKknF,GAIpB/5D,MAAO,CACHj5B,KAAM,CAAC2C,EAA+B3C,KAClC,MAAMc,EAAQ6B,EAAQu5E,SAASl8E,EAAK6C,KAAK,IACzC,GAAqB,iBAAV/B,EACP,MAAM,IAAIoF,MAAM,oBAAoBpF,2BAExC,OAAOgL,KAAKmtB,MAAMn4B,KAI1BmuI,GAAI,CACAjvI,KAAM,CAAC2C,EAA+B3C,KAClC,MAAMc,EAAQ6B,EAAQu5E,SAASl8E,EAAK6C,KAAK,IACzC,GAAqB,iBAAV/B,EACP,MAAM,IAAIoF,MAAM,oBAAoBpF,wBAExC,OAAOgL,KAAK4wB,IAAI57B,KAIxBouI,IAAK,CACDlvI,KAAM,CAAC2C,EAA+B3C,KAClC,MAAMc,EAAQ6B,EAAQu5E,SAASl8E,EAAK6C,KAAK,IACzC,GAAqB,iBAAV/B,EACP,MAAM,IAAIoF,MAAM,oBAAoBpF,yBAExC,OAAOgL,KAAKyW,KAAKzhB,KAIzBquI,MAAO,CACHnvI,KAAM,CAAC2C,EAA+B3C,KAClC,MAAMc,EAAQ6B,EAAQu5E,SAASl8E,EAAK6C,KAAK,IACzC,GAAqB,iBAAV/B,EACP,MAAM,IAAIoF,MAAM,oBAAoBpF,2BAExC,OAAOgL,KAAKqjI,MAAMruI,KAI1ByL,IAAK,CACDvM,KAAM,CAAC2C,EAA+B3C,IAC3B8L,KAAKS,OAAOvM,EAAK6C,KAAK2F,IAAI5E,GAAK2mB,OAAO5nB,EAAQu5E,SAASt4E,OAItEyI,IAAK,CACDrM,KAAM,CAAC2C,EAA+B3C,IAC3B8L,KAAKO,OAAOrM,EAAK6C,KAAK2F,IAAI5E,GAAK2mB,OAAO5nB,EAAQu5E,SAASt4E,OAYtEgJ,MAAO,CACH5M,KAAM,CAAC2C,EAA+B3C,KAClC,MAAM4D,EAAIjB,EAAQu5E,SAASl8E,EAAK6C,KAAK,IAC/BwJ,EAAM1J,EAAQu5E,SAASl8E,EAAK6C,KAAK,IACjC0J,EAAM5J,EAAQu5E,SAASl8E,EAAK6C,KAAK,IAEvC,GAAiB,iBAANe,GAAiC,iBAARyI,GAAmC,iBAARE,EAC3D,MAAM,IAAIrG,MAAM,qBAAqBtC,OAAOyI,MAAQE,0BAExD,OAAO1K,EAAMkJ,UAAU6B,MAAMhJ,EAAGyI,EAAKE,KAI7C6iI,GAAI,CACApvI,KAAM,IACK8L,KAAKyF,IAIpBu6B,MAAO,CACH9rC,KAAM,CAAC2C,EAA+B3C,KAClC,MAAMc,EAAQ6B,EAAQu5E,SAASl8E,EAAK6C,KAAK,IACzC,GAAqB,iBAAV/B,EACP,MAAM,IAAIoF,MAAM,oBAAoBpF,2BAExC,OAAOgL,KAAKggC,MAAMhrC,KAI1BsS,IAAK,CACDpT,KAAM,CAAC2C,EAA+B3C,KAClC,MAAMc,EAAQ6B,EAAQu5E,SAASl8E,EAAK6C,KAAK,IACzC,GAAqB,iBAAV/B,EACP,MAAM,IAAIoF,MAAM,oBAAoBpF,yBAExC,OAAOgL,KAAKsH,IAAItS,KAIxB+S,KAAM,CACF7T,KAAM,CAAC2C,EAA+B3C,KAClC,MAAMc,EAAQ6B,EAAQu5E,SAASl8E,EAAK6C,KAAK,IACzC,GAAqB,iBAAV/B,EACP,MAAM,IAAIoF,MAAM,oBAAoBpF,0BAExC,OAAOgL,KAAK+H,KAAK/S,KAIzBsU,IAAK,CACDpV,KAAM,CAAC2C,EAA+B3C,KAClC,MAAMc,EAAQ6B,EAAQu5E,SAASl8E,EAAK6C,KAAK,IACzC,GAAqB,iBAAV/B,EACP,MAAM,IAAIoF,MAAM,oBAAoBpF,yBAExC,OAAOgL,KAAKsJ,IAAItU,MAKf,EAAA+rI,cAAuCe,G,qGCzQpD,MAAMA,EAAY,CACd7pI,OAAQ,CACJ/D,KAAM,CAAC2C,EAA+B3C,KAClC,MAAMc,EAAQ6B,EAAQu5E,SAASl8E,EAAK6C,KAAK,IACzC,GAAIgB,MAAMC,QAAQhD,IAA2B,iBAAVA,EAC/B,OAAOA,EAAMiD,OAEjB,MAAM,IAAImC,MAAM,oBAAoBpF,8BAG5CuuI,SAAU,CACNrvI,KAAM,CAAC2C,EAA+B3C,KAClC,IAAK,MAAM+C,KAAa/C,EAAK6C,KAAM,CAC/B,MAAM/B,EAAQ6B,EAAQu5E,SAASn5E,GAC/B,GAAc,OAAVjC,EACA,OAAOA,EAGf,OAAO,QAKN,EAAAmsI,cAAuCW,G,uGC1BpD,aAEA,QAGMlsI,EAAiBnB,OAAOkB,UAAUC,eAExC,IAAK4tI,EAKL,SAASC,EAAa5sI,EAA+BE,EAAc2sI,G,MAC/D,MAAMC,EAAa9sI,EAAQu5E,SAASr5E,EAAK,IAEzC,GAA0B,iBAAf4sI,EACP,MAAM,IAAIvpI,MAAM,qCAGpB,MAAM3E,EAASoB,EAAQu5E,SAASr5E,EAAK,IAErC,GAAItB,GAA4B,iBAAXA,EAAqB,CACtC,GAAI,EAAAugC,IAAI0sG,MAAMjtI,GAAS,CACnB,MAAMT,EAAiC,QAA5B,EAAGS,EAAOmuB,OAAO+/G,UAAW,QAAI,KAC3C,OAAOD,IAAeF,EAAW5uI,IAAMI,EAAkB,OAAVA,EAEnD,GAAIY,EAAe1B,KAAKuB,EAAQkuI,GAC5B,OAAOD,IAAeF,EAAW5uI,KAAMa,EAAOkuI,GAItD,OAAOD,IAAeF,EAAW5uI,KAAM,MAxB3C,SAAK4uI,GACD,iBACA,iBAFJ,CAAKA,MAAU,KA2Bf,MAAM1B,EAAY,CACd8B,GAAI,CACA1vI,KAAM,CAAC2C,EAA+B3C,KAClC,MAAMc,EAAQ6B,EAAQu5E,SAASl8E,EAAK6C,KAAK,IACnCtB,EAASoB,EAAQu5E,SAASl8E,EAAK6C,KAAK,IAC1C,OAAqB,iBAAV/B,GAAwC,iBAAXS,KAE7BsC,MAAMC,QAAQvC,KADdA,EAAOg1E,SAASz1E,KAQnCJ,IAAK,CACDV,KAAM,CAAC2C,EAA+B3C,IAClCuvI,EAAa5sI,EAAS3C,EAAK6C,KAAMysI,EAAW5uI,MAGpDsI,IAAK,CACDhJ,KAAM,CAAC2C,EAA+B3C,IAClCuvI,EAAa5sI,EAAS3C,EAAK6C,KAAMysI,EAAWtmI,MAGpD,qBAAsB,CAClB/B,kBAAmB,KAAM,EACzBjH,KAAM,CAAC2C,EAA+B3C,IAC9B2C,EAAQmC,QAAU,EAAAd,UAAUi3F,QACrBt4F,EAAQkC,IAEZ7E,IAKN,EAAAotI,gBAAyCQ,G,uGClEtD,MAAMA,EAAY,CACdt4F,OAAQ,CACJt1C,KAAM,CAAC2C,EAA+B3C,IAC3B,GAAGs1C,UAAUt1C,EAAK6C,KAAK2F,IAAIyD,GAAKqmD,OAAO3vD,EAAQu5E,SAASjwE,OAIvE0jI,SAAU,CACN3vI,KAAM,CAAC2C,EAA+B3C,IAC3BsyD,OAAO3vD,EAAQu5E,SAASl8E,EAAK6C,KAAK,KAAK+sI,qBAItDC,OAAQ,CACJ7vI,KAAM,CAAC2C,EAA+B3C,IAC3BsyD,OAAO3vD,EAAQu5E,SAASl8E,EAAK6C,KAAK,KAAKitI,qBAItD,KAAM,CACF9vI,KAAM,CAAC2C,EAA+B3C,KAClC,MAAMuhB,EAAO5e,EAAQu5E,SAASl8E,EAAK6C,KAAK,IAClCif,EAAQnf,EAAQu5E,SAASl8E,EAAK6C,KAAK,IACzC,MAAoB,iBAAT0e,GAAsC,iBAAVO,IACH,IAAzBP,EAAK6T,QAAQtT,KAMhC,KAAM,CACF9hB,KAAM,CAAC2C,EAA+B3C,KAClC,MAAMuhB,EAAO5e,EAAQu5E,SAASl8E,EAAK6C,KAAK,IAClCif,EAAQnf,EAAQu5E,SAASl8E,EAAK6C,KAAK,IACzC,MAAoB,iBAAT0e,GAAsC,iBAAVO,GAC5BP,EAAKskC,WAAW/jC,KAMnC,KAAM,CACF9hB,KAAM,CAAC2C,EAA+B3C,KAClC,MAAMuhB,EAAO5e,EAAQu5E,SAASl8E,EAAK6C,KAAK,IAClCif,EAAQnf,EAAQu5E,SAASl8E,EAAK6C,KAAK,IACzC,MAAoB,iBAAT0e,GAAsC,iBAAVO,GAC5BP,EAAKiO,SAAS1N,MAOxB,EAAAgrH,gBAAyCc,G,qGC7CzC,EAAAZ,cARK,CACd+C,OAAQ,CACJ/vI,KAAM,CAAC2C,EAA+B3C,WACpB2C,EAAQu5E,SAASl8E,EAAK6C,KAAK,O,uGCLrD,aAGA,OAMA,SAASmtI,EACLrtI,EACA3C,EACAqS,GAEA,IAAI49H,EACJ,OAAQ59H,GACJ,IAAK,UACD49H,EAAOpuI,EAAMoG,QACb,MACJ,IAAK,UACDgoI,EAAOpuI,EAAMuG,QACb,MACJ,IAAK,UACD6nI,EAAOpuI,EAAMyG,QAGrB,IAAK,MAAMvF,KAAa/C,EAAK6C,KAAM,CAC/B,MAAM/B,EAAQ6B,EAAQu5E,SAASn5E,GAC/B,GAAIjC,aAAiBmvI,EACjB,OAAOnvI,EAGf,MAAM,IAAIoF,MAAM,eAAemM,MAGnC,SAAS69H,EACLvtI,EACA3C,EACAqS,GAEA,IAAI89H,EACAxuG,EAEJ,OAAQtvB,GACJ,IAAK,UACD89H,EAAatuI,EAAMoG,QACnB05B,EAAa,EACb,MACJ,IAAK,UACDwuG,EAAatuI,EAAMuG,QACnBu5B,EAAa,EACb,MACJ,IAAK,UACDwuG,EAAatuI,EAAMyG,QACnBq5B,EAAa,EAIrB,IAAK,MAAM5+B,KAAa/C,EAAK6C,KAAM,CAC/B,MAAM/B,EAAQ6B,EAAQu5E,SAASn5E,GAC/B,GAAIjC,aAAiBqvI,EACjB,OAAOrvI,EACJ,GACH+C,MAAMC,QAAQhD,IACdA,EAAMiD,SAAW49B,GACjB7gC,EAAM0G,MAAM5D,GAAkB,iBAANA,GAExB,OAAO,IAAIusI,GAAa9nD,UAAUvnF,GAG1C,MAAM,IAAIoF,MAAM,eAAemM,MAGnC,MAAMu7H,EAAY,CACd,cAAe,CACX5tI,KAAM,CAAC2C,EAA+B3C,KAClC,QAAoByE,IAAhBzE,EAAKowI,OACL,OAAOpwI,EAAKowI,OAGhB,GAAIpwI,EAAK6C,KAAKkB,OAAS,EACnB,MAAM,IAAImC,MAAM,wBACb,GAAIlG,EAAK6C,KAAKkB,OAAS,EAC1B,MAAM,IAAImC,MAAM,sBAGpB,MAAMy7B,EAAa3hC,EAAK6C,KAAK2F,IAAIiuH,GAAO9zH,EAAQu5E,SAASu6C,IAUzD,IAAI7tH,EAEJ,OAVA+4B,EAAW7+B,QAAQ,CAAC83B,EAASzd,KACzB,GAAuB,iBAAZyd,EACP,MAAM,IAAI10B,MACN,sCAAsCiX,6BAO1CwkB,EAAW59B,QACf,KAAK,EACD6E,GAAS,IAAI/G,EAAMoG,SAAUogF,UAAU1mD,GACvC,MACJ,KAAK,EACD/4B,GAAS,IAAI/G,EAAMuG,SAAUigF,UAAU1mD,GACvC,MACJ,KAAK,EACD/4B,GAAS,IAAI/G,EAAMyG,SAAU+/E,UAAU1mD,GACvC,MACJ,QACI,MAAM,IAAIz7B,MAAM,sBAOxB,OAJIlG,EAAK6C,KAAK2E,MAAMivH,GAAOA,aAAe,EAAA3wH,qBACtC9F,EAAKowI,OAASxnI,GAGXA,IAGfw3D,QAAS,CACLpgE,KAAM,CAAC2C,EAA+B3C,IAAmBgwI,EAASrtI,EAAS3C,EAAM,YAErFiQ,QAAS,CACLjQ,KAAM,CAAC2C,EAA+B3C,IAAmBgwI,EAASrtI,EAAS3C,EAAM,YAErFqwI,QAAS,CACLrwI,KAAM,CAAC2C,EAA+B3C,IAAmBgwI,EAASrtI,EAAS3C,EAAM,YAErF,aAAc,CACVA,KAAM,CAAC2C,EAA+B3C,IAAmBkwI,EAASvtI,EAAS3C,EAAM,YAErF,aAAc,CACVA,KAAM,CAAC2C,EAA+B3C,IAAmBkwI,EAASvtI,EAAS3C,EAAM,YAErF,aAAc,CACVA,KAAM,CAAC2C,EAA+B3C,IAAmBkwI,EAASvtI,EAAS3C,EAAM,aAI5E,EAAAutI,gBAAyCK,G,wGC5ItD,aAkCM0C,EAAW,IAdjB,MAcqBxuG,KAKrB,yBACI,qBAAqBx/B,EAAuBiuI,GACxC,OAAOjuI,EAGX,wBAAwBA,EAA0BiuI,GAC9C,OAAOjuI,EAGX,uBAAuBA,EAAyBiuI,GAC5C,OAAOjuI,EAGX,uBAAuBA,EAAyBiuI,GAC5C,OAAOjuI,EAGX,uBAAuBA,EAAyBiuI,GAC5C,OAAOjuI,EAGX,aAAaA,EAAeK,GACxB,GAAIA,EAAQ6tI,UAAY7tI,EAAQ6tI,SAASxnI,IAAI1G,EAAKlC,MAC9C,OAAOkC,EAEX,MAAMxB,EAAQ6B,EAAQkC,IAAI6qB,OAAOptB,EAAKlC,MACtC,OAAO,EAAAwF,YAAYglI,eAAoBnmI,IAAV3D,EAAsBA,EAAQ,MAG/D,sBAAsBwB,EAAwBK,GAC1C,GAAIA,EAAQ6tI,UAAY7tI,EAAQ6tI,SAASxnI,IAAI1G,EAAKlC,MAC9C,OAAOkC,EAEX,MAAMxB,OAA0C2D,IAAlC9B,EAAQkC,IAAI6qB,OAAOptB,EAAKlC,MACtC,OAAO,EAAAwF,YAAYglI,UAAU9pI,GAGjC,cAAcwB,EAAgBK,GAC1B,MAAME,EAAOP,EAAKO,KAAK2F,IAAIiuH,GAAOA,EAAIj0H,OAAOC,KAAME,IACnD,OAAIE,EAAKqE,KAAK,CAAC+E,EAAGpM,IAAMoM,IAAM3J,EAAKO,KAAKhD,IAC7B,IAAI,EAAAgH,SAASvE,EAAKU,GAAIH,GAE1BP,EAGX,eAAeo+B,EAAkB/9B,GAC7B,MAAM7B,EAAQ4/B,EAAM5/B,MAAM0B,OAAOC,KAAME,GAEvC,GAAI7B,aAAiB,EAAA8E,YAAa,CAC9B,MAAMjF,EAAIG,EAAMA,MAChB,IAAK,MAAO2H,EAAOC,KAASg4B,EAAMv9B,SAAU,CACxC,GAAIU,MAAMC,QAAQ2E,IAAWA,EAAgB8tE,SAAS51E,GAClD,OAAO+H,EAAKlG,OAAOC,KAAME,GACtB,GAAI8F,IAAU9H,EACjB,OAAO+H,EAAKlG,OAAOC,KAAME,GAGjC,OAAO+9B,EAAMp9B,SAASd,OAAOC,KAAME,GAGvC,IAAIojC,EAAUrF,EAAM5/B,QAAUA,EAE9B,MAAMqC,EAAsCu9B,EAAMv9B,SAASqF,IAAI,EAAEC,EAAOpF,MACpE,MAAMotI,EAAYptI,EAAOb,OAAOC,KAAME,GAItC,OAHI8tI,IAAcptI,IACd0iC,GAAU,GAEP,CAACt9B,EAAOgoI,KAGbntI,EAAWo9B,EAAMp9B,SAASd,OAAOC,KAAME,GAM7C,OAJIW,IAAao9B,EAAMp9B,WACnByiC,GAAU,GAGPA,EAAU,IAAI,EAAA1+B,UAAUvG,EAAOqC,EAAUG,GAAYo9B,EAGhE,cAAcp+B,EAAgBK,GAC1B,MAAMQ,EAAgC,GAEtC,IAAI4iC,GAAU,EAEd,IAAK,MAAOxiC,EAAWF,KAAWf,EAAKa,SAAU,CAC7C,MAAMutI,EAAentI,EAAUf,OAAOC,KAAME,GACtCguI,EAAOD,EAAanuI,eAC1B,GAAKgB,EAAU6D,aAAwC,IAAzBupI,EAAKxuI,WAAW0hB,KAKtC6sH,IAAiBntI,IACjBwiC,GAAU,GAEd5iC,EAASwF,KAAK,CAAC+nI,EAAcrtI,SAP7B,GAAIuzE,QAAQ85D,EAAax0D,SAASo0D,EAAU,EAAAtsI,UAAU4sI,YAClD,OAAOvtI,EAAOb,OAAOC,KAAME,GAUvC,GAAwB,IAApBQ,EAASY,OAIT,OAAOzB,EAAKgB,SAASd,OAAOC,KAAME,GAGlCQ,EAASY,SAAWzB,EAAKa,SAASY,SAKlCgiC,GAAU,GAKd5iC,EAASL,QAAQO,IACb,MAAMwtI,EAAqBxtI,EAAO,GAAGb,OAAOC,KAAME,GAE9CkuI,IAAuBxtI,EAAO,KAC9B0iC,GAAU,GAGd1iC,EAAO,GAAKwtI,IAGhB,MAAMvtI,EAAWhB,EAAKgB,SAASd,OAAOC,KAAME,GAM5C,OAJIW,IAAahB,EAAKgB,WAClByiC,GAAU,GAGTA,EAKE,IAAI,EAAAr+B,SAASvE,EAAUG,GAHnBhB,EAMf,cAAcA,EAAgBK,GAC1B,MAAMa,EAAQlB,EAAKkB,MAAMhB,OAAOC,KAAME,GAChCc,EAAenB,EAAKmB,aAAajB,OAAOC,KAAME,GAC9Ce,EAA+BpB,EAAKoB,MAAM8E,IAAI,EAAEpH,EAAKN,KAAW,CAClEM,EACAN,EAAM0B,OAAOC,KAAME,KAEvB,OAAO,IAAI,EAAAkF,SAASrE,EAAOC,EAAcC,GAG7C,qBAAqBpB,EAAuBK,GACxC,MAAMa,EAAQlB,EAAKkB,MAAMhB,OAAOC,KAAME,GAChCe,EAA+BpB,EAAKoB,MAAM8E,IAAI,EAAEpH,EAAKN,KAAW,CAClEM,EACAN,EAAM0B,OAAOC,KAAME,KAEvB,OAAO,IAAI,EAAAoF,gBAAgBzF,EAAKtB,KAAMwC,EAAOE,M,kGCnMrD,aAeA,IAAKotI,EAwFAC,EArDL,SAASC,EAAQC,GACb,OAAQA,GACJ,KAAKH,EAAUI,IACf,KAAKJ,EAAUK,GACf,KAAKL,EAAUM,GACf,KAAKN,EAAUO,MACX,OAAO,EACX,QACI,OAAO,GAOnB,SAASC,EAASL,GACd,OAAOA,GAAaH,EAAUS,IAAMN,GAAaH,EAAUU,GAM/D,SAASC,EAASR,GACd,OACKA,GAAaH,EAAU7kI,GAAKglI,GAAaH,EAAUzoI,GACnD4oI,GAAaH,EAAUY,GAAKT,GAAaH,EAAUa,EAc5D,SAASC,EAAYX,GACjB,OARJ,SAA0BA,GACtB,OAAOQ,EAASR,IAAcK,EAASL,GAQnCY,CAAiBZ,IACjBA,IAAcH,EAAU1tI,GACxB6tI,IAAcH,EAAUgB,QACxBb,IAAcH,EAAUiB,KACxBd,IAAcH,EAAUkB,UACxBf,IAAcH,EAAUmB,SAmChC,SAASC,EAAWC,GAChB,OAAQA,GACJ,KAAKpB,EAAMqB,IACP,MAAO,MACX,KAAKrB,EAAM7qI,MACP,MAAO,QACX,KAAK6qI,EAAMsB,WACP,MAAO,aACX,KAAKtB,EAAMxmH,OACP,MAAO,SACX,KAAKwmH,EAAMz+E,OACP,MAAO,SACX,KAAKy+E,EAAMuB,MACP,MAAO,IACX,KAAKvB,EAAMwB,OACP,MAAO,IACX,KAAKxB,EAAMyB,OACP,MAAO,IACX,KAAKzB,EAAMiB,SACP,MAAO,IACX,KAAKjB,EAAMkB,SACP,MAAO,IACX,KAAKlB,EAAM0B,QACP,MAAO,IACX,KAAK1B,EAAM2B,WACP,MAAO,KACX,KAAK3B,EAAM4B,WACP,MAAO,KACX,KAAK5B,EAAM6B,YACP,MAAO,KACX,KAAK7B,EAAM8B,WACP,MAAO,KACX,KAAK9B,EAAM+B,aACP,MAAO,KACX,KAAK/B,EAAMgC,KACP,MAAO,IACX,KAAKhC,EAAMiC,QACP,MAAO,IACX,KAAKjC,EAAMkC,UACP,MAAO,KACX,KAAKlC,EAAMmC,aACP,MAAO,KACX,KAAKnC,EAAMoC,OACP,MAAO,KACX,KAAKpC,EAAMqC,OACP,MAAO,KACX,QACI,MAAM,IAAIltI,MAAM,iBAAiBisI,OAnK7C,SAAKrB,GACD,iBACA,gBACA,gBACA,sBACA,wBACA,wBACA,sBACA,kBACA,4BACA,8BACA,4BACA,gBACA,gBACA,cACA,cACA,cACA,cACA,eACA,kCACA,kCACA,0BACA,sBACA,sBACA,uBACA,wBACA,oBACA,0BACA,mBACA,kBA7BJ,CAAKA,MAAS,KAwFd,SAAKC,GACD,iBACA,qBACA,+BACA,uBACA,uBACA,qBACA,uBACA,uBACA,2BACA,2BACA,0BACA,gCACA,gCACA,kCACA,gCACA,oCACA,oBACA,0BACA,8BACA,oCACA,wBACA,wBAtBJ,CAAKA,MAAK,KAkFV,MAAMsC,EAMF,YAAqBnvI,GAAA,KAAAA,OALb,KAAAovI,QAAiBvC,EAAM7qI,MACvB,KAAAmkC,QAAU,EACV,KAAAkpG,OAAiBzC,EAAUK,GAQnC,QACI,OAAO1uI,KAAK6wI,QAMhB,OACI,OAAO7wI,KAAK+wI,QAAU,GAM1B,OAEI,GADA/wI,KAAK6wI,QAAU7wI,KAAKgxI,QAChBhxI,KAAK6wI,UAAYvC,EAAM7qI,MACvB,MAAM,IAAIA,MAAM,wBAAwBzD,KAAK8wI,UAEjD,OAAO9wI,KAAK6wI,QAGR,QACJ7wI,KAAK8wI,OAAS9wI,KAAKyB,KAAKwvI,YAAYjxI,KAAK4nC,YAAc,EAGnD,QAEJ,IADA5nC,KAAK+wI,YAAS/uI,EACPusI,EAAQvuI,KAAK8wI,SAChB9wI,KAAKkxI,QAET,GAAoB,IAAhBlxI,KAAK8wI,OACL,OAAOxC,EAAMqB,IAEjB,MAAMwB,EAAKnxI,KAAK8wI,OAEhB,OADA9wI,KAAKkxI,QACGC,GACJ,KAAK9C,EAAUyB,OACX,OAAOxB,EAAMwB,OACjB,KAAKzB,EAAU0B,OACX,OAAOzB,EAAMyB,OACjB,KAAK1B,EAAUkB,SACX,OAAOjB,EAAMiB,SACjB,KAAKlB,EAAUmB,SACX,OAAOlB,EAAMkB,SACjB,KAAKnB,EAAUwB,MACX,OAAOvB,EAAMuB,MACjB,KAAKxB,EAAU+C,YACf,KAAK/C,EAAUgD,YAAa,CACxB,MAAMtnG,EAAQ/pC,KAAK4nC,QAAU,EAC7B,KAAO5nC,KAAK8wI,QAAU9wI,KAAK8wI,SAAWK,GAElCnxI,KAAKkxI,QAET,GAAIlxI,KAAK8wI,SAAWK,EAChB,MAAM,IAAI1tI,MAAM,6BAIpB,OAFAzD,KAAKkxI,QACLlxI,KAAK+wI,OAAS/wI,KAAKyB,KAAKoZ,UAAUkvB,EAAO/pC,KAAK4nC,QAAU,GACjD0mG,EAAMz+E,OAEjB,KAAKw+E,EAAU2B,QACX,OAAIhwI,KAAK8wI,SAAWzC,EAAUiD,OAC1BtxI,KAAKkxI,QACE5C,EAAM+B,cAEV/B,EAAM0B,QACjB,KAAK3B,EAAUkD,MACX,OAAIvxI,KAAK8wI,SAAWzC,EAAUiD,OAC1BtxI,KAAKkxI,QACE5C,EAAM4B,YAEV5B,EAAM7qI,MACjB,KAAK4qI,EAAUmD,MACX,OAAIxxI,KAAK8wI,SAAWzC,EAAUiD,OAC1BtxI,KAAKkxI,QACE5C,EAAM2B,YAEV3B,EAAM7qI,MACjB,KAAK4qI,EAAUiD,MACX,OAAItxI,KAAK8wI,SAAWzC,EAAUiD,OAC1BtxI,KAAKkxI,QACE5C,EAAM8B,YAEV9B,EAAM7qI,MACjB,KAAK4qI,EAAUiC,KACX,OAAItwI,KAAK8wI,SAAWzC,EAAUiD,OAC1BtxI,KAAKkxI,QACE5C,EAAMkC,WAEVlC,EAAMgC,KACjB,KAAKjC,EAAUkC,QACX,OAAIvwI,KAAK8wI,SAAWzC,EAAUiD,OAC1BtxI,KAAKkxI,QACE5C,EAAMmC,cAEVnC,EAAMiC,QACjB,KAAKlC,EAAUoD,IACX,OAAIzxI,KAAK8wI,SAAWzC,EAAUoD,KAC1BzxI,KAAKkxI,QACE5C,EAAMoC,QAEVpC,EAAM7qI,MACjB,KAAK4qI,EAAUqD,IACX,OAAI1xI,KAAK8wI,SAAWzC,EAAUqD,KAC1B1xI,KAAKkxI,QACE5C,EAAMqC,QAEVrC,EAAM7qI,MACjB,QAAS,CACL,MAAMsmC,EAAQ/pC,KAAK4nC,QAAU,EAC7B,GACIonG,EAASmC,IACTA,IAAO9C,EAAU1tI,GAChBwwI,IAAO9C,EAAUgB,QAAUF,EAAYnvI,KAAK8wI,QAC/C,CACE,KAAO3B,EAAYnvI,KAAK8wI,SACpB9wI,KAAKkxI,QAGT,OADAlxI,KAAK+wI,OAAS/wI,KAAKyB,KAAKoZ,UAAUkvB,EAAO/pC,KAAK4nC,QAAU,GACjD0mG,EAAMsB,WACV,GAAIf,EAASsC,GAAK,CACrB,KAAOtC,EAAS7uI,KAAK8wI,SACjB9wI,KAAKkxI,QAET,GAAIlxI,KAAK8wI,SAAWzC,EAAUiB,IAE1B,IADAtvI,KAAKkxI,QACErC,EAAS7uI,KAAK8wI,SACjB9wI,KAAKkxI,QAIb,OADAlxI,KAAK+wI,OAAS/wI,KAAKyB,KAAKoZ,UAAUkvB,EAAO/pC,KAAK4nC,QAAU,GACjD0mG,EAAMxmH,OACV,GAAIqpH,IAAO9C,EAAUgB,OACxB,OAAIrvI,KAAK8wI,SAAWzC,EAAUiD,OAC1BtxI,KAAKkxI,QACE5C,EAAM6B,aAEV7B,EAAM7qI,OAIzB,OAAO6qI,EAAM7qI,OAIrB,SAASkuI,EAAcjC,GACnB,OAAQA,GACJ,KAAKpB,EAAM2B,WACP,MAAO,KACX,KAAK3B,EAAM4B,WACP,MAAO,KACX,KAAK5B,EAAM6B,YACP,MAAO,KACX,KAAK7B,EAAM8B,WACP,MAAO,KACX,KAAK9B,EAAM+B,aACP,MAAO,KACX,QACI,QAIZ,SAASuB,EAAgBlC,GACrB,OAAQA,GACJ,KAAKpB,EAAMgC,KACP,MAAO,IACX,KAAKhC,EAAMiC,QACP,MAAO,IACX,KAAKjC,EAAMkC,UACP,MAAO,KACX,KAAKlC,EAAMmC,aACP,MAAO,KACX,QACI,QAIZ,mBAGI,YAAYhvI,GACRzB,KAAK6xI,IAAM,IAAIjB,EAAMnvI,GACrBzB,KAAK6xI,IAAItqG,OAGb,QACI,OAAOvnC,KAAK8xI,iBAGR,SAASpC,GACb,GAAI1vI,KAAK6xI,IAAInC,UAAYA,EACrB,MAAM,IAAIjsI,MACN,iCAAiCgsI,EAAWC,WACxC,UAAUD,EAAWzvI,KAAK6xI,IAAInC,aAG1C1vI,KAAK6xI,IAAItqG,OAGL,eACJ,OAAQvnC,KAAK6xI,IAAInC,SACb,KAAKpB,EAAMsB,WAAY,CACnB,MAAMpqH,EAAOxlB,KAAK6xI,IAAIrsH,OACtB,OAAQA,GACJ,IAAK,MACDxlB,KAAK6xI,IAAItqG,OACTvnC,KAAK+xI,SAASzD,EAAMwB,QACpB,MAAMkC,EAAehyI,KAAK6xI,IAAIrsH,OAG9B,OAFAxlB,KAAK+xI,SAASzD,EAAMsB,YACpB5vI,KAAK+xI,SAASzD,EAAMyB,QACb,IAAI,EAAA7rI,iBAAiB8tI,GAChC,IAAK,SACDhyI,KAAK6xI,IAAItqG,OACTvnC,KAAK+xI,SAASzD,EAAMwB,QACpB,MAAMzxI,EAAQ2B,KAAK8xI,iBAEnB,OADA9xI,KAAK+xI,SAASzD,EAAMyB,QACb,IAAI,EAAA3rI,SAAS,SAAU,CAAC/F,IACnC,QACI,MAAMwB,EAAO,IAAI,EAAAkD,QAAQyiB,GAEzB,OADAxlB,KAAK6xI,IAAItqG,OACF1nC,GAInB,KAAKyuI,EAAMwB,OAAQ,CACf9vI,KAAK6xI,IAAItqG,OACT,MAAM1nC,EAAOG,KAAK8xI,iBAElB,OADA9xI,KAAK+xI,SAASzD,EAAMyB,QACblwI,EAGX,QACI,OAAOG,KAAKiyI,gBAIhB,eACJ,OAAQjyI,KAAK6xI,IAAInC,SACb,KAAKpB,EAAMxmH,OAAQ,CACf,MAAMjoB,EAAO,IAAI,EAAAwD,kBAAkB2pB,WAAWhtB,KAAK6xI,IAAIrsH,SAEvD,OADAxlB,KAAK6xI,IAAItqG,OACF1nC,EAEX,KAAKyuI,EAAMz+E,OAAQ,CACf,MAAMhwD,EAAO,IAAI,EAAAyD,kBAAkBtD,KAAK6xI,IAAIrsH,QAE5C,OADAxlB,KAAK6xI,IAAItqG,OACF1nC,EAEX,QACI,MAAM,IAAI4D,MAAM,iBAIpB,aACJ,OAAIzD,KAAK6xI,IAAInC,UAAYpB,EAAM0B,SAC3BhwI,KAAK6xI,IAAItqG,OACF,IAAI,EAAAnjC,SAAS,IAAK,CAACpE,KAAKkyI,gBAE5BlyI,KAAKmyI,eAGR,kBACJ,IAAItyI,EAAOG,KAAKkyI,aAChB,OACI,GAAIlyI,KAAK6xI,IAAInC,UAAYpB,EAAMsB,YAAkC,OAApB5vI,KAAK6xI,IAAIrsH,OAAiB,CACnExlB,KAAK6xI,IAAItqG,OACTvnC,KAAK+xI,SAASzD,EAAMiB,UACpB,MAAMxoG,EAAW,CAAC/mC,KAAKiyI,gBACvB,KAAOjyI,KAAK6xI,IAAInC,UAAYpB,EAAMuB,OAC9B7vI,KAAK6xI,IAAItqG,OACTR,EAAS7gC,KAAKlG,KAAKiyI,gBAEvBjyI,KAAK+xI,SAASzD,EAAMkB,UACpB3vI,EAAO,IAAI,EAAAuE,SAAS,KAAM,CACtBvE,EACA,EAAAsD,YAAYglI,UAAUphG,EAAShhC,IAAI,EAAG1H,WAAYA,UAEnD,CACH,MAAMkC,EAAKqxI,EAAgB5xI,KAAK6xI,IAAInC,SACpC,QAAW1tI,IAAPzB,EACA,MAEJP,KAAK6xI,IAAItqG,OACT,MAAMloB,EAAQrf,KAAKkyI,aACnBryI,EAAO,IAAI,EAAAuE,SAAS7D,EAAI,CAACV,EAAMwf,IAGvC,OAAOxf,EAGH,gBACJ,IAAIA,EAAOG,KAAKoyI,kBAChB,OAAa,CACT,IAAI7xI,EAAyBoxI,EAAc3xI,KAAK6xI,IAAInC,SAEpD,QAAW1tI,IAAPzB,EACA,MAGO,OAAPA,IACAA,EAAK,MAGTP,KAAK6xI,IAAItqG,OACT,MAAMloB,EAAQrf,KAAKoyI,kBACnBvyI,EAAO,IAAI,EAAAuE,SAAS7D,EAAI,CAACV,EAAMwf,IAEnC,OAAOxf,EAGH,kBACJ,MAAMA,EAAOG,KAAKqyI,gBAElB,GAAIryI,KAAK6xI,IAAInC,UAAYpB,EAAMqC,OAC3B,OAAO9wI,EAGX,MAAM6mG,EAAsB,CAAC7mG,GAE7B,GACIG,KAAK6xI,IAAItqG,OACTm/D,EAAYxgG,KAAKlG,KAAKqyI,uBACjBryI,KAAK6xI,IAAInC,UAAYpB,EAAMqC,QAEpC,OAAO,IAAI,EAAAvsI,SAAS,MAAOsiG,GAGvB,iBACJ,MAAM7mG,EAAOG,KAAKsyI,kBAElB,GAAItyI,KAAK6xI,IAAInC,UAAYpB,EAAMoC,OAC3B,OAAO7wI,EAGX,MAAM6mG,EAAsB,CAAC7mG,GAE7B,GACIG,KAAK6xI,IAAItqG,OACTm/D,EAAYxgG,KAAKlG,KAAKsyI,yBACjBtyI,KAAK6xI,IAAInC,UAAYpB,EAAMoC,QAEpC,OAAO,IAAI,EAAAtsI,SAAS,MAAOsiG,M,4LCvhBnC,SAAiBrH,GAUb,IAAY8B,EAqCA4C,EA1CC,EAAAD,kCAAoC,yBAKjD,SAAY3C,GACR,4BACA,oBACA,sBAHJ,CAAYA,EAAA,EAAAA,qBAAA,EAAAA,mBAAkB,KAyBd,EAAArB,qBAAhB,SAAqCh1D,GACjC,OACIA,GAC2B,iBAApBA,EAAQm1D,SACS,iBAAjBn1D,EAAQl7B,MACfk7B,EAAQl7B,OAASuxF,EAAmBxpD,aAO5C,SAAYosD,GACR,iCACA,mCAFJ,CAAYA,EAAA,EAAAA,WAAA,EAAAA,SAAQ,KAuCJ,EAAAwuC,sBAAhB,SAAsCh0H,GAClC,MAAO,wCAAwC4kC,KAAK5kC,EAAMusB,UAkC9C,EAAA0nG,iBAAhB,SAAiC1nG,GAC7B,OACIA,GAC2B,iBAApBA,EAAQm1D,SACS,iBAAjBn1D,EAAQl7B,MACfk7B,EAAQl7B,OAASuxF,EAAmBC,SAmB5B,EAAA9B,kBAAhB,SAAkCx0D,GAC9B,OACIA,GAC2B,iBAApBA,EAAQm1D,SACS,iBAAjBn1D,EAAQl7B,MACfk7B,EAAQl7B,OAASuxF,EAAmBsxC,UAtJhD,CAAiB,EAAApzC,wBAAA,EAAAA,sBAAqB,M,2GCGtC,SAAiB6F,GAIb,IAAYnB,GAAZ,SAAYA,GACR,iCACA,6BACA,6BAHJ,CAAYA,EAAA,EAAAA,WAAA,EAAAA,SAAQ,KAkBJ,EAAA2uC,uBAAhB,SAAuC5nG,GACnC,OACIA,GAAmC,iBAAjBA,EAAQl7B,MAAqBk7B,EAAQl7B,OAASm0F,EAASoB,eAgBjE,EAAAwtC,qBAAhB,SAAqC7nG,GACjC,OAAOA,GAAmC,iBAAjBA,EAAQl7B,MAAqBk7B,EAAQl7B,OAASm0F,EAASqB,aAgBpE,EAAAwtC,cAAhB,SAA8B9nG,GAC1B,OAAOA,GAAmC,iBAAjBA,EAAQl7B,MAAqBk7B,EAAQl7B,OAASm0F,EAASsB,aA1DxF,CAAiB,EAAAH,sBAAA,EAAAA,oBAAmB,M,iICYpC,0BAQI,YACWv/E,EAAmB,EACnBktH,EAAmC,IAAIvb,iBADvC,KAAA3xG,WACA,KAAAktH,kBAGX,aACI,OAAO7yI,KAAK6yI,gBAAgBrxC,OAOhC,QACIxhG,KAAK6yI,gBAAgBnb,UAO7B,SAAiBpzB,GAIb,IAAYK,EAuCAZ,GAvCZ,SAAYY,GACR,gCADJ,CAAYA,EAAA,EAAAA,qBAAA,EAAAA,mBAAkB,KA2Bd,EAAAmuC,uBAAhB,SAAuChoG,GACnC,OACIA,GAC2B,iBAApBA,EAAQm1D,SACS,iBAAjBn1D,EAAQl7B,MACfk7B,EAAQl7B,OAAS+0F,EAAmBC,eAO5C,SAAYb,GACR,0CACA,sCAFJ,CAAYA,EAAA,EAAAA,WAAA,EAAAA,SAAQ,KAmBJ,EAAAgvC,oBAAhB,SAAoCjoG,GAChC,OACIA,GACwB,iBAAjBA,EAAQl7B,MACfk7B,EAAQl7B,OAASm0F,EAASQ,mBAkBlB,EAAAyuC,kBAAhB,SAAkCloG,GAC9B,OACIA,GAAmC,iBAAjBA,EAAQl7B,MAAqBk7B,EAAQl7B,OAASm0F,EAASW,iBAtFrF,CAAiB,EAAAJ,wBAAA,EAAAA,sBAAqB,M,2QC/CtC,aACA,QAqCA,iCACIpkG,EACA+yI,EACAjyI,GAEA,QAAkBgB,IAAdixI,EACA,OAAOjyI,EAGX,MAAMmF,EAAS,EAAAk5B,IAAI0sG,MAAM7rI,GACnB,EAAAgtB,iBAAiB+lH,EAAW/yI,GAC5B,EAAAgtB,iBAAiB+lH,EAAW/yI,EAAQkC,IAAKlC,EAAQgzI,mBAEvD,OAAO/sI,UAAUnF,I,mLCnDrB,aAMA,qBACI,YAAqB09D,GAAA,KAAAA,QAQrB,YAAYy0E,GACR,MAAMC,EAASrtH,IACP,EAAA7kB,WAAW6kB,MAGXotH,EAAUptH,GAKlB,QAA0B/jB,IAAtBhC,KAAK0+D,MAAMgL,OACX,IAAK,MAAMnD,KAAgBvmE,KAAK0+D,MAAMgL,OAClC,QAAwC1nE,IAApChC,KAAK0+D,MAAMgL,OAAOnD,GAClB,IAAK,MAAMxgD,KAAS/lB,KAAK0+D,MAAMgL,OAAOnD,GAClC,GAAI6sE,EAAMrtH,GACN,OAAO,EAM3B,OAAO,K,+cCpCf,aACA,OAmDA,kBAAa6G,UAA6BxtB,EAAM0Y,eAW5C,YAAYytH,EAA6C,IACrD,MAAM,KAAEnkH,EAAI,MAAE6J,EAAK,QAAEC,GAA6Bq6G,EAAjB8N,EAAY,EAAK9N,EAA5C,4BACN8N,EAAa11I,KAAO,uBACpB01I,EAAaj6G,aA/DQ,qOAgErBi6G,EAAah6G,eApDU,8XAqDvBg6G,EAAar7H,SAAW,CACpBoJ,KAAM,IAAIhiB,EAAMgsD,QAAQx+B,EAAqB0mH,qBAC7C9e,QAAS,IAAIp1H,EAAMgsD,QAAQ,IAAIhsD,EAAMsqB,OACrCwB,QAAS,IAAI9rB,EAAMgsD,QAAQ,IAE/BioF,EAAankH,WAAY,EACzBmkH,EAAaz2C,WAAa,OAAH,wBAChBy2C,EAAaz2C,YAAU,CAC1BC,aAAa,IAGjB75F,MAAMqwI,GAEN,EAAA/mC,gBAAgBtsG,MAEhBA,KAAK4P,KAAO,uBACZ5P,KAAKuzI,QAAUvzI,KAAKgY,SAASw8G,QAAQn2H,MACrC2B,KAAKwzI,UAAYxzI,KAAKgY,SAASkT,QAAQ7sB,WAE1B2D,IAATof,IACAphB,KAAKohB,KAAOA,QAEFpf,IAAVipB,IACAjrB,KAAKirB,MAAQA,QAEDjpB,IAAZkpB,IACAlrB,KAAKkrB,QAAUA,GAOvB,WACI,OAAOlrB,KAAKgY,SAASoJ,KAAK/iB,MAM9B,SAAS+iB,GACLphB,KAAKgY,SAASoJ,KAAK/iB,MAAQ+iB,EAM/B,cACI,OAAOphB,KAAKwzI,UAMhB,YAAYtoH,GACRlrB,KAAKwzI,UAAYtoH,EAGblrB,KAAKgY,UAAYhY,KAAKgY,SAASkT,UAC/BlrB,KAAKgY,SAASkT,QAAQ7sB,MAAQ6sB,GAOtC,YACI,OAAOlrB,KAAKuzI,QAMhB,UAAUtoH,GACNjrB,KAAKuzI,QAAQvsI,IAAIikB,IAEzB,OA3FoB,EAAAqoH,oBAAsB,EA2F1C,GA5FA,GAAa,EAAA1mH,wB,8GC3Bb,kCAAuCniB,GACnC,MAAO,oBAAqBA,I,oGC1BhC,aAGA,QAMA,QACA,OAoHA,kBAAak2E,UAAqBvhF,EAAMyY,kBAUpC,YAAYwF,GACR,MAAM7R,EAAkC,GAClCioI,OAAgCzxI,IAAXqb,QAAmDrb,IAA3Bqb,EAAOrE,gBACpD06H,OACS1xI,IAAXqb,QAC0Brb,IAA1Bqb,EAAOwvC,gBACPxvC,EAAOwvC,gBAAkB,EAAA1sB,qBAAqBC,mBAC9C/iB,EAAOwvC,eAAiB,EAAA1sB,qBAAqBE,kBAC7CozG,GACA,EAAA/nI,gBAAgBF,EAAS,uBAAuB,GAEhDkoI,GACA,EAAAhoI,gBAAgBF,EAAS,iBAAiB,GAoB9CxI,MAjBqB,CACjBrF,KAAM,eACNy7B,aA7IiB,2nDA8IjBC,eA5EmB,0bA6EnBrhB,SAAU,CACN27H,UAAW,IAAIv0I,EAAMgsD,QAAQ,IAAIhsD,EAAMsqB,MAAMi3D,EAAal3D,gBAC1DmqH,aAAc,IAAIx0I,EAAMgsD,QAAQu1B,EAAa6D,mBAC7Cx+D,SAAU,IAAI5mB,EAAMgsD,QAAQ,EAAAX,cAAce,mBAC1CvlC,QAAS,IAAI7mB,EAAMgsD,QAAQ,EAAAX,cAAcgB,kBACzCoB,eAAgB,IAAIztD,EAAMgsD,QAAQ,EAAAjrB,qBAAqBE,mBACvDrnB,gBAAiB,IAAI5Z,EAAMgsD,QACvBqoF,EAAqBp2H,EAAQrE,gBAAkB,IAAI5Z,EAAM8Y,UAGjEyhC,YAAY,EACZnuC,YAGJ,EAAA8gG,gBAAgBtsG,MAEhB,EAAAyqD,cAAckB,0BACd,EAAAjB,iBAAiBiB,+BAGF3pD,IAAXqb,SACqBrb,IAAjBqb,EAAO4N,OAIPjrB,KAAKirB,MAAMjkB,IAAIqW,EAAO4N,YAEFjpB,IAApBqb,EAAOojE,WACPzgF,KAAKygF,SAAWpjE,EAAOojE,eAEHz+E,IAApBqb,EAAO2I,WACPhmB,KAAKgmB,SAAW3I,EAAO2I,eAEJhkB,IAAnBqb,EAAO4I,UACPjmB,KAAKimB,QAAU5I,EAAO4I,cAEKjkB,IAA3Bqb,EAAOrE,kBACPhZ,KAAKgZ,gBAAkBqE,EAAOrE,sBAEJhX,IAA1Bqb,EAAOwvC,iBACP7sD,KAAK6sD,eAAiBxvC,EAAOwvC,iBAQzC,YACI,OAAO7sD,KAAKgY,SAAS27H,UAAUt1I,MAEnC,UAAUA,GACN2B,KAAKgY,SAAS27H,UAAUt1I,MAAMiR,KAAKjR,GAMvC,eACI,OAAO2B,KAAKgY,SAAS47H,aAAav1I,MAEtC,aAAaA,GACL2B,KAAKgY,SAAS47H,aAAav1I,QAAUA,IAGzC2B,KAAKgY,SAAS47H,aAAav1I,MAAQA,EACnC,EAAAsgF,wBAAwB3+E,KAAM,YAAa3B,EAAQ,IAGvD,eACI,OAAO2B,KAAKgY,SAASgO,SAAS3nB,MAElC,aAAaA,GACT2B,KAAKgY,SAASgO,SAAS3nB,MAAQA,EAGnC,cACI,OAAO2B,KAAKgY,SAASiO,QAAQ5nB,MAEjC,YAAYA,GACJ2B,KAAKgY,SAASiO,QAAQ5nB,QAAUA,IAGpC2B,KAAKgY,SAASiO,QAAQ5nB,MAAQA,EAC9B,EAAAsgF,wBAAwB3+E,KAAM,aAAc3B,EAAQ,IAGxD,qBACI,OAAO2B,KAAKgY,SAAS60C,eAAexuD,MAExC,mBAAmBA,GACf,GAAI2B,KAAKgY,SAAS60C,eAAexuD,QAAUA,EACvC,OAEJ2B,KAAKgY,SAAS60C,eAAexuD,MAAQA,EAGrC,MAAM2uD,EAAe3uD,GAAS,EAAA8hC,qBAAqBC,kBACnD,EAAAu+C,wBAAwB3+E,KAAM,gBAAiBgtD,GAGnD,sBACI,OAAOhtD,KAAKgY,SAASgB,gBAAgB3a,MAGzC,oBAAoB0H,GAChB,GAAI/F,KAAKgY,SAASgB,gBAAgB3a,QAAU0H,EACxC,OAEJ/F,KAAKgY,SAASgB,gBAAgB3a,MAAQ0H,EACtC,MAAM+kD,EAA6B,OAAR/kD,EACvB+kD,IACA9qD,KAAKgY,SAASgB,gBAAgB3a,MAAMkO,aAAc,GAEtD,EAAAoyE,wBAAwB3+E,KAAM,sBAAuB8qD,IAE7D,OA/IW,EAAArhC,cAAwB,EACxB,EAAA+6D,kBAA4B,EA8IvC,GAjJA,GAAa,EAAA7D,gB,8EC9Hb,cAEMkzD,EACF,EAAA1zG,qBAAqBG,oBAAsB,EAAAH,qBAAqBG,oBAEpE,UAAe,CACXwsB,sBAAuB,gWAavBgnF,iBAAkB,qMAIsBD,+ZAcxCE,gCAAiC,0qCA+BjCC,wBAAyB,8IAQzBC,mBAAoB,mJ,8ECtExB,UAAe,CACXpoF,mBAAoB,iCAIpBqoF,cAAe,mCAIfC,qBAAsB,kFAMtBC,gBAAiB,+V,iHCdR,EAAAhmF,0BAA4B,y0D,yICRzC,aACA,QACA,OASa,EAAAimF,uBAAuC,CAChDr8H,SAAU,CACNs8H,mBAAoB,IAAIl1I,EAAMgsD,QAAQ,IAAIhsD,EAAMuG,SAChD4uI,sBAAuB,IAAIn1I,EAAMgsD,QAAQ,IAAIhsD,EAAMuG,QAAQ,EAAG,EAAG,IACjE6uI,sBAAuB,IAAIp1I,EAAMgsD,QAAQ,IAAIhsD,EAAMsO,SAGnD+mI,gBAAiB,IAAIr1I,EAAMgsD,QACvB,IAAIhsD,EAAMyG,QAfY,QAiBE,MAEpBoH,YAEA,EAIA,IAGRynI,gBAAiB,IAAIt1I,EAAMgsD,QAAQ,IAAIhsD,EAAMuG,QAAQ,EAAG,EAAG,IAE3DgvI,SAAU,IAAIv1I,EAAMgsD,QAAQ,IAAIhsD,EAAMsqB,MAAM,QAC5CkrH,YAAa,IAAIx1I,EAAMgsD,QAAQ,IAAIhsD,EAAMsqB,MAAM,WAC/C7F,OAAQ,IAAIzkB,EAAMgsD,QAAQ,IAC1BrrB,SAAU,IAAI3gC,EAAMgsD,QAAQ,IAC5BypF,SAAU,IAAIz1I,EAAMgsD,QAAQ,IAAIhsD,EAAMsqB,MAAM,QAC5CorH,QAAS,IAAI11I,EAAMgsD,QAAQ,IAAIhsD,EAAMsqB,MAAM,QAC3CqrH,OAAQ,IAAI31I,EAAMgsD,QAAQ,IAAIhsD,EAAMsqB,MAAM,YAG9C0P,aAAc,8mCAuCZ,UAAuBmgE,gCACvB,UAAuBC,8iKAiIzBngE,eAAgB,isBA0Bd,UAAuBkgE,gCACvB,UAAuBE,m/GA+F7B,MAAau7C,UAAiC51I,EAAMyY,kBAChD,YAAYwF,GAgBRra,MAZqB,CACjBrF,KAAM,2BACNy7B,aAAc,EAAAi7G,uBAAuBj7G,aACrCC,eAAgB,EAAAg7G,uBAAuBh7G,eACvCrhB,SAAU,EAAAq8H,uBAAuBr8H,SACjCtN,aAAa,EACbwkB,WAAW,EACXyqB,YAAY,EACZ+iD,KAAMt9F,EAAM61I,UACZrqI,SAAUxL,EAAMiN,eAChBwiB,KAAK,IAKb,mBAAmBqmH,GACfl1I,KAAKgY,SAASy8H,gBAAgBp2I,MAAMyH,EAAIovI,EAAiB,EAAM,EAQnE,gBAAgBxlI,GACZ1P,KAAKgY,SAASy8H,gBAAgBp2I,MAAMqH,EAAIgK,EAG5C,kBACI,OAAO1P,KAAKgY,SAASy8H,gBAAgBp2I,MAAMqH,EAQ/C,gBAAgBgK,GACZ1P,KAAKgY,SAASy8H,gBAAgBp2I,MAAMoH,EAAIiK,EAG5C,kBACI,OAAO1P,KAAKgY,SAASy8H,gBAAgBp2I,MAAMoH,EAc/C,eACIslF,EACAjsF,EACA4P,EACA4hE,GAEA,MAAM6kE,EAAan1I,KAAKo1I,cAAct2I,EAAQ4P,GAE9C,QAAuB1M,IAAnB+oF,IAAgCA,EAAeE,WAmC/C,MAAMxnF,MAAM,0DAlCZ,KACIsnF,EAAe/yE,UACf+yE,EAAe/yE,SAASy8H,iBACxB1pD,EAAe/yE,SAAS08H,iBACxB3pD,EAAe/yE,SAASs8H,oBACxBvpD,EAAe/yE,SAASw8H,uBACxBzpD,EAAe/yE,SAASu8H,uBAyBxB,MAAM9wI,MAAM,4CAxBd,CACE,MAAM0lF,EAASgsD,EAAWhsD,OACpBD,EAAMisD,EAAWE,oBACjBlkI,EAAegkI,EAAWG,UAEhCvqD,EAAe/yE,SAASs8H,mBAAmBj2I,MAAMiR,KAAK65E,GACtD4B,EAAe/yE,SAASw8H,sBAAsBn2I,MAAMiR,KAAK45E,GAEzD6B,EAAe/yE,SAASy8H,gBAAgBp2I,MAAMuH,EAAIuL,EAClD45E,EAAe/yE,SAASu8H,sBAAsBl2I,MAAQiyE,EAAezjE,QAErE,MAAM0oI,EAAgBpkI,EAAenR,KAAKw1I,YACpCC,EAAe,EAAA/pI,gBACjBq/E,EAAev/E,QACf,kBACA+pI,GAEEG,EAAe,EAAAhqI,gBACjBq/E,EAAev/E,QACf,wBACC+pI,GAELxqD,EAAex+E,YAAckpI,GAAgBC,GAejD,cACJ52I,EACA4P,EACAinI,GAAmB,GAEnB,GAAIA,EAAS,CACT,MAAMC,GAAc,IAAIx2I,EAAMsO,SAAUmoI,WAClCC,GAAa,IAAI12I,EAAMsO,SAAUwG,WAAWpV,EAAOiT,aAAagkI,YAChE5hI,EAAmBzF,EAAOyF,iBAE1B6hI,EAAY,IAAI52I,EAAMsO,QAE5BsoI,EAAU/hI,iBAAiB6hI,EAAYF,GACvCI,EAAU/hI,iBAAiBE,EAAkB6hI,GAE7C,MAAM7sD,EAAS,IAAI/pF,EAAMuG,QACzB7G,EAAOwiD,iBAAiB6nC,GACxB,MAAM8sD,EAAY,IAAI72I,EAAMuG,QAI5B,OAHA+I,EAAO4yC,iBAAiB20F,GAGjB,CACHZ,oBAAqBW,EACrB7sD,SACAmsD,UALcW,EAAUv6H,WAAWytE,IAOpC,CACH,MAAMysD,EAAc92I,EAAOiT,YACrB+jI,EAAapnI,EAAOuhE,mBACpB97D,EAAmBzF,EAAOyF,iBAE1B6hI,EAAY,IAAI52I,EAAMsO,QAE5BsoI,EAAU/hI,iBAAiB6hI,EAAYF,GACvCI,EAAU/hI,iBAAiBE,EAAkB6hI,GAE7C,MAAM7sD,EAAS,IAAI/pF,EAAMuG,QACzB+I,EAAO4yC,iBAAiB6nC,GACxB,MAAM8sD,EAAY,IAAI72I,EAAMuG,QAC5B7G,EAAOwiD,iBAAiB20F,GACxB,MAAMX,EAAYW,EAAUv6H,WAAWytE,GAIvC,OADAA,EAAOr2E,IAAImjI,GACJ,CACHZ,oBAAqBW,EACrB7sD,SACAmsD,eAjKhB,8B,+IC7UA,aACA,QAgEA,kBAAa1mH,UAAkCxvB,EAAMyY,kBAWjD,YAAYwF,GACRvf,OAAOysD,OAAOnrD,EAAMwsD,YAAa,WAEjC,MAAMynF,EAAe,CACjB11I,KAAM,4BACNy7B,aA9EiB,wpBA+EjBC,eArDmB,yTAsDnBrhB,SAAU,CACNw8G,QAAS,IAAIp1H,EAAMgsD,QACf,IAAIhsD,EAAMsqB,MAAMkF,EAA0BnF,gBAE9CyB,QAAS,IAAI9rB,EAAMgsD,QAAQx8B,EAA0BjF,iBACrDuhE,MAAO,IAAI9rF,EAAMgsD,QAAQ,IAAIhsD,EAAMsO,SACnCy9E,SAAU,IAAI/rF,EAAMgsD,QAAQ,IAAIhsD,EAAMuG,SACtCylF,iBAAkB,IAAIhsF,EAAMgsD,QAAQ,IAAIhsD,EAAMuG,WAGtD7H,OAAOysD,OAAO8oF,EAAch2H,GAC5Bra,MAAMqwI,GAENrzI,KAAK4P,KAAO,4BACZ5P,KAAKw+E,6BAA8B,OAGpBx8E,IAAXqb,SACqBrb,IAAjBqb,EAAO4N,OACPjrB,KAAKirB,MAAMjkB,IAAIqW,EAAO4N,YAEHjpB,IAAnBqb,EAAO6N,UACPlrB,KAAKkrB,QAAU7N,EAAO6N,UAI9BlrB,KAAKk2I,4BAMT,YACI,OAAOl2I,KAAKgY,SAASw8G,QAAQn2H,MAEjC,UAAUA,GACN2B,KAAKgY,SAASw8G,QAAQn2H,MAAMiR,KAAKjR,GAG7B,4BACJ2B,KAAK0K,YAAc1K,KAAKkrB,QAAU,GAE1C,OA3DW,EAAAzB,cAAwB,GACxB,EAAAE,gBAA0B,EA0DrC,GA5DA,GAAa,EAAAiF,4BA8Db,uCACInkB,GAEA,YACiBzI,IAAbyI,IACwE,IAAvEA,EAAuC+zE,8B,iJCpIhD,aACA,QAwDA,kBAAaqO,UAAmCztF,EAAMutB,eAgBlD,YAAYtP,GACRvf,OAAOysD,OAAOnrD,EAAMwsD,YAAa,WAGjC5oD,MADqBqa,GAGrBrd,KAAK4P,KAAO,6BACZ5P,KAAKo5B,aA7EgB,8qBA8ErBp5B,KAAKq5B,eAAiBj6B,EAAMwsD,YAAYuqF,YACxCn2I,KAAK6uB,KAAM,EAEX7uB,KAAKgY,SAAW,CACZw8G,QAAS,IAAIp1H,EAAMgsD,QAAQ,IAAIhsD,EAAMsqB,MAAMmjE,EAA2BpjE,gBACtEyB,QAAS,IAAI9rB,EAAMgsD,QAAQyhC,EAA2BljE,iBACtDvI,KAAM,IAAIhiB,EAAMgsD,QAAQyhC,EAA2BupD,cACnDt1F,MAAO,IAAI1hD,EAAMgsD,QAAQyhC,EAA2BwpD,eACpDtwI,IAAK,IAAI3G,EAAMgsD,QAAQ,IAAIhsD,EAAM8Y,SACjCo+H,YAAa,IAAIl3I,EAAMgsD,QAAQ,IAAIhsD,EAAMm3I,SACzCrrD,MAAO,IAAI9rF,EAAMgsD,QAAQ,IAAIhsD,EAAMsO,SACnCy9E,SAAU,IAAI/rF,EAAMgsD,QAAQ,IAAIhsD,EAAMuG,SACtCylF,iBAAkB,IAAIhsF,EAAMgsD,QAAQ,IAAIhsD,EAAMuG,UAGlD3F,KAAK4sF,8BAA+B,OAGrB5qF,IAAXqb,SACqBrb,IAAjBqb,EAAO4N,OACPjrB,KAAKirB,MAAMjkB,IAAIqW,EAAO4N,YAEHjpB,IAAnBqb,EAAO6N,UACPlrB,KAAKkrB,QAAU7N,EAAO6N,cAENlpB,IAAhBqb,EAAO+D,OACPphB,KAAKohB,KAAO/D,EAAO+D,WAEFpf,IAAjBqb,EAAOyjC,QACP9gD,KAAK8gD,MAAQzjC,EAAOyjC,YAEG9+C,IAAvBqb,EAAOi5H,cACPt2I,KAAKs2I,YAAcj5H,EAAOi5H,kBAEXt0I,IAAfqb,EAAOtX,MACP/F,KAAK+F,IAAMsX,EAAOtX,MAQ9B,YACI,OAAO/F,KAAKgY,SAAS8oC,MAAMziD,MAG/B,UAAUA,GACN2B,KAAKgY,SAAS8oC,MAAMziD,MAAQA,EAMhC,kBACI,OAAO2B,KAAKgY,SAASs+H,YAAYj4I,MAErC,gBAAgBA,GACZ2B,KAAKgY,SAASs+H,YAAYj4I,MAAQA,GAE1C,OAnFW,EAAAorB,cAAwB,GACxB,EAAAE,gBAA0B,EAC1B,EAAAysH,aAAuB,EACvB,EAAAC,cAAwB,EAgFnC,GApFA,GAAa,EAAAxpD,6BAsFb,wCACIpiF,GAEA,YACiBzI,IAAbyI,IAC0E,IAAzEA,EAAwCmiF,+B,oGCpJjD,aAoDA,MAAaipB,UAAqBz2G,EAAMyY,kBAMpC,YAAYwF,GAiBRra,MAfqD,CACjDrF,KAAM,eACNy7B,aA5DiB,6TA6DjBC,eA5CmB,2RA6CnBrhB,SAAU,CACNjS,IAAK,IAAI3G,EAAMgsD,QAAQ/tC,EAAOtX,MAElCmpB,WAAW,EACXyqB,YAAY,EACZjvC,aAAa,EAEb6oB,cAAc,EACdzoB,oBAAoB,EACpBF,SAAUxL,EAAMiN,iBAQxB,UACI,OAAOrM,KAAKgY,SAASjS,IAAI1H,OA9BjC,kB,gHCpDA,aAKa,EAAAm4I,yBAAyC,CAClDx+H,SAAU,CACNohF,SAAU,CAAE/6F,MAAO,MACnBo4I,oBAAqB,CAAEp4I,MAAO,GAC9Bq4I,YAAa,CAAEr4I,MAAO,GACtBqqD,aAAc,CAAErqD,MAAO,IAAIe,EAAMsqB,MAAM,IACvC61F,eAAgB,CAAElhH,MAAO,IAE7B+6B,aAAc,0JAMdC,eAAgB,ilB,oGCpBpB,aAEA,QAMA,MAAamkE,UAAqBp+F,EAAM0Y,eAMpC,YAAYE,GACRhV,MAAM,CACFgV,WACAohB,aAAc,EAAA+/D,WAAW//D,aACzBC,eAAgB,EAAA8/D,WAAW9/D,eAC3BvuB,oBAAoB,EACpBJ,aAAa,EACbE,SAAUxL,EAAMu3I,iBAChBznH,WAAW,EACXyqB,YAAY,KAfxB,kB,mGCHa,EAAAi9F,YAA4B,CACrC5+H,SAAU,CACNohF,SAAU,CAAE/6F,MAAO,MACnBw4I,OAAQ,CAAEx4I,MAAO,IAErB+6B,aAAc,4KAMdC,eAAgB,skB,mIChBpB,aACA,QACA,OASa,EAAAy9G,oBAAoC,CAC7C9+H,SAAU,CACNs8H,mBAAoB,IAAIl1I,EAAMgsD,QAAQ,IAAIhsD,EAAMuG,SAChD4uI,sBAAuB,IAAIn1I,EAAMgsD,QAAQ,IAAIhsD,EAAMuG,QAAQ,EAAG,EAAG,IACjE6uI,sBAAuB,IAAIp1I,EAAMgsD,QAAQ,IAAIhsD,EAAMsO,SAGnD+mI,gBAAiB,IAAIr1I,EAAMgsD,QACvB,IAAIhsD,EAAMyG,QAfY,QAmBlBoH,YAEA,EAIA,IAGRynI,gBAAiB,IAAIt1I,EAAMgsD,QAAQ,IAAIhsD,EAAMuG,QAAQ,EAAG,EAAG,IAE3DgvI,SAAU,IAAIv1I,EAAMgsD,QAAQ,IAAIhsD,EAAMsqB,MAAM,QAC5CkrH,YAAa,IAAIx1I,EAAMgsD,QAAQ,IAAIhsD,EAAMsqB,MAAM,WAC/C7F,OAAQ,IAAIzkB,EAAMgsD,QAAQ,IAC1BrrB,SAAU,IAAI3gC,EAAMgsD,QAAQ,IAC5BypF,SAAU,IAAIz1I,EAAMgsD,QAAQ,IAAIhsD,EAAMsqB,MAAM,QAC5CorH,QAAS,IAAI11I,EAAMgsD,QAAQ,IAAIhsD,EAAMsqB,MAAM,QAC3CqrH,OAAQ,IAAI31I,EAAMgsD,QAAQ,IAAIhsD,EAAMsqB,MAAM,YAG9C0P,aAAc,oiCAiCZ,UAAuBmgE,gCACvB,UAAuBC,kuIA2GzBngE,eAAgB,ooBAsBd,UAAuBkgE,gCACvB,UAAuBE,sjEAkD7B,MAAas9C,UAA8B33I,EAAMyY,kBAC7C,YAAYwF,GAiBRra,MAZqB,CACjBrF,KAAM,wBACNy7B,aAAc,EAAA09G,oBAAoB19G,aAClCC,eAAgB,EAAAy9G,oBAAoBz9G,eACpCrhB,SAAU,EAAA8+H,oBAAoB9+H,SAC9BtN,aAAa,EACbwkB,WAAW,EACXyqB,YAAY,EACZ+iD,KAAMt9F,EAAM43I,SACZpsI,SAAUxL,EAAMiN,eAChBwiB,KAAK,IAKb,mBAAmBqmH,GACfl1I,KAAKgY,SAASy8H,gBAAgBp2I,MAAMyH,EAAIovI,EAAiB,EAAM,EAQnE,gBAAgBxlI,GACZ1P,KAAKgY,SAASy8H,gBAAgBp2I,MAAMqH,EAAIgK,EAG5C,kBACI,OAAO1P,KAAKgY,SAASy8H,gBAAgBp2I,MAAMqH,EAQ/C,gBAAgBgK,GACZ1P,KAAKgY,SAASy8H,gBAAgBp2I,MAAMoH,EAAIiK,EAG5C,kBACI,OAAO1P,KAAKgY,SAASy8H,gBAAgBp2I,MAAMoH,EAc/C,eACIslF,EACAjsF,EACA4P,EACA4hE,GAEA,MAAM6kE,EAAan1I,KAAKo1I,cAAct2I,EAAQ4P,GAE9C,QAAuB1M,IAAnB+oF,IAAgCA,EAAeE,WAmC/C,MAAMxnF,MAAM,0DAlCZ,KACIsnF,EAAe/yE,UACf+yE,EAAe/yE,SAASy8H,iBACxB1pD,EAAe/yE,SAAS08H,iBACxB3pD,EAAe/yE,SAASs8H,oBACxBvpD,EAAe/yE,SAASw8H,uBACxBzpD,EAAe/yE,SAASu8H,uBAyBxB,MAAM9wI,MAAM,4CAxBd,CACE,MAAM0lF,EAASgsD,EAAWhsD,OACpBD,EAAMisD,EAAWE,oBACjBlkI,EAAegkI,EAAWG,UAEhCvqD,EAAe/yE,SAASs8H,mBAAmBj2I,MAAMiR,KAAK65E,GACtD4B,EAAe/yE,SAASw8H,sBAAsBn2I,MAAMiR,KAAK45E,GAEzD6B,EAAe/yE,SAASy8H,gBAAgBp2I,MAAMuH,EAAIuL,EAClD45E,EAAe/yE,SAASu8H,sBAAsBl2I,MAAQiyE,EAAezjE,QAErE,MAAM0oI,EAAgBpkI,EAAenR,KAAKw1I,YACpCC,EAAe,EAAA/pI,gBACjBq/E,EAAev/E,QACf,kBACA+pI,GAEEG,EAAe,EAAAhqI,gBACjBq/E,EAAev/E,QACf,wBACC+pI,GAELxqD,EAAex+E,YAAckpI,GAAgBC,GAejD,cACJ52I,EACA4P,EACAinI,GAAmB,GAEnB,GAAIA,EAAS,CACT,MAAMC,GAAc,IAAIx2I,EAAMsO,SAAUmoI,WAClCC,GAAa,IAAI12I,EAAMsO,SAAUwG,WAAWpV,EAAOiT,aAAagkI,YAChE5hI,EAAmBzF,EAAOyF,iBAE1B6hI,EAAY,IAAI52I,EAAMsO,QAE5BsoI,EAAU/hI,iBAAiB6hI,EAAYF,GACvCI,EAAU/hI,iBAAiBE,EAAkB6hI,GAE7C,MAAM7sD,EAAS,IAAI/pF,EAAMuG,QACzB7G,EAAOwiD,iBAAiB6nC,GACxB,MAAM8sD,EAAY,IAAI72I,EAAMuG,QAG5B,OAFA+I,EAAO4yC,iBAAiB20F,GAEjB,CACHZ,oBAAqBW,EACrB7sD,SACAmsD,UAJcW,EAAUv6H,WAAWytE,IAMpC,CACH,MAAMysD,EAAc92I,EAAOiT,YACrB+jI,EAAapnI,EAAOuhE,mBACpB97D,EAAmBzF,EAAOyF,iBAE1B6hI,EAAY,IAAI52I,EAAMsO,QAE5BsoI,EAAU/hI,iBAAiB6hI,EAAYF,GACvCI,EAAU/hI,iBAAiBE,EAAkB6hI,GAE7C,MAAM7sD,EAAS,IAAI/pF,EAAMuG,QACzB+I,EAAO4yC,iBAAiB6nC,GACxB,MAAM8sD,EAAY,IAAI72I,EAAMuG,QAC5B7G,EAAOwiD,iBAAiB20F,GACxB,MAAMX,EAAYW,EAAUv6H,WAAWytE,GAIvC,OADAA,EAAOr2E,IAAImjI,GACJ,CACHZ,oBAAqBW,EACrB7sD,SACAmsD,eAjKhB,2B,2HC/PA,aAEA,QACA,QACA,OAOM2B,EAAwD,CAC1DhiD,KAAM,EAAA3mC,cAAcG,UACpByoF,OAAQ,EAAA5oF,cAAcI,YACtByoF,MAAO,EAAA7oF,cAAcK,WACrByoF,WAAY,EAAA9oF,cAAcM,iBAC1ByoF,YAAa,EAAA/oF,cAAcO,mBAGzByoF,EAAsDx5I,OAAO89D,KAC/Dq7E,GACFz4G,OAAO,CAACtgC,EAAGq5I,KACT,MAAMC,EAAYD,EAGlB,OADAr5I,EAD4B+4I,EAAuBO,IAClCA,EACVt5I,GACP,IAEJ,IAAYu5I,GAAZ,SAAYA,GACR,qCACA,mCACA,uCAHJ,CAAYA,EAAA,EAAAA,kBAAA,EAAAA,gBAAe,KAM3B,MAAMC,EAA4D,CAC9DR,OAAQO,EAAgBE,cACxBR,MAAOM,EAAgBG,aACvBC,QAASJ,EAAgBK,gBAGvBC,EAA0Dj6I,OAAO89D,KACnE87E,GACFl5G,OAAO,CAACtgC,EAAG85I,KACT,MAAMR,EAAYQ,EAGlB,OADA95I,EAD4Bw5I,EAAyBF,IACpCA,EACVt5I,GACP,IAaEo4B,EAAW,IAAIl3B,EAAMsqB,MA0GrBwyE,EAAyB,yWAiBPu7C,EAAgBE,uCACjBF,EAAgBG,wCACdH,EAAgBK,06GA2MzC,kBAAaprH,UAA0BttB,EAAMyY,kBAwBzC,YAAYwF,G,MACRvf,OAAOysD,OAAOnrD,EAAMwsD,YAAa,WAEjC,EAAAnB,cAAckB,0BAGd,MAAMngD,EAAkC,CACpCysI,UAAW,EAAA3pF,cAAcK,WACzBupF,YAAaT,EAAgBE,eAKjC,IAEI3+H,EAFAm/H,GAAW,EACXC,EAAe,EAEnB,QAAep2I,IAAXqb,EAAsB,CACtB86H,GAA0B,IAAf96H,EAAOwR,IACdspH,GACA,EAAAzsI,gBAAgBF,EAAS,WAAW,GAExC4sI,OAAkCp2I,IAAnBqb,EAAO6N,QAAwB7N,EAAO6N,QAAUktH,EAC/Dp/H,EAAkBqE,EAAOrE,qBACDhX,IAApBgX,GACA,EAAAtN,gBAAgBF,EAAS,uBAAuB,QAETxJ,IAAxBqb,EAAO+V,cAA8B/V,EAAO+V,aAAe,GAE1E,EAAA1nB,gBAAgBF,EAAS,eAAe,GA4ChDxI,MAxCqD,CACjDrF,KAAM,oBACNy7B,aAjYiB,+0GAkYjBC,eAAgB6iE,EAChBlkF,SAAU5Y,EAAM+5B,cAAck/G,MAAM,CAChC,CACI7jB,QAAS,IAAIp1H,EAAMgsD,QAAQ,IAAIhsD,EAAMsqB,MAAMgD,EAAkBjD,gBAC7D6uH,UAAW,IAAIl5I,EAAMgsD,QAAQ,IAAIhsD,EAAMsqB,MAAMgD,EAAkBjD,gBAC/D8uH,aAAc,IAAIn5I,EAAMgsD,QACpB,IAAIhsD,EAAMsqB,MAAMgD,EAAkBjD,gBAEtC+uH,eAAgB,IAAIp5I,EAAMgsD,QAAQ1+B,EAAkB+rH,eACpDrlH,aAAc,IAAIh0B,EAAMgsD,QAAQ1+B,EAAkBgsH,uBAClD70H,OAAQ,IAAIzkB,EAAMgsD,QAAQ1+B,EAAkBisH,gBAC5CztH,QAAS,IAAI9rB,EAAMgsD,QAAQ1+B,EAAkB/C,iBAC7C7S,SAAU,IAAI1X,EAAMgsD,QAAQ,IAAIhsD,EAAMoG,SACtCwgB,SAAU,IAAI5mB,EAAMgsD,QAAQ,EAAAX,cAAce,mBAC1CvlC,QAAS,IAAI7mB,EAAMgsD,QAAQ,EAAAX,cAAcgB,kBACzCzyC,gBAAiB,IAAI5Z,EAAMgsD,aACHppD,IAApBgX,EAAgCA,EAAkB,IAAI5Z,EAAM8Y,SAEhEyyF,UAAW,IAAIvrG,EAAMgsD,QACjB,IAAIhsD,EAAMoG,QACNknB,EAAkBksH,yBAClBlsH,EAAkBmsH,yBAG1BxlH,SAAU,IAAIj0B,EAAMgsD,QAAQ1+B,EAAkBosH,mBAC9CxlH,QAAS,IAAIl0B,EAAMgsD,QAAQ1+B,EAAkBqsH,mBAIjD35I,EAAM45I,YAAYnqH,MAEtBrjB,UAGAqjB,IAAKspH,EACLjtH,QAASktH,IAMbp4I,KAAKigE,MAAQk4E,EACbn4I,KAAKwzI,UAAY4E,EAEjB,EAAA9rC,gBAAgBtsG,MAChBA,KAAK48F,WAAWC,aAAc,OAGf76F,IAAXqb,SACqBrb,IAAjBqb,EAAO4N,QACPqL,EAAStvB,IAAIqW,EAAO4N,OACpBjrB,KAAKirB,MAAQqL,QAEWt0B,IAAxBqb,EAAOk7H,eACPjiH,EAAStvB,IAAIqW,EAAOk7H,cACpBv4I,KAAKu4I,aAAejiH,QAECt0B,IAArBqb,EAAOwO,YACP7rB,KAAK6rB,UAAYxO,EAAOwO,gBAEA7pB,IAAxBqb,EAAO+V,eACPpzB,KAAKozB,aAAe/V,EAAO+V,mBAERpxB,IAAnBqb,EAAO6N,UACPlrB,KAAKkrB,QAAU7N,EAAO6N,cAEDlpB,IAArBqb,EAAO6R,YACPlvB,KAAKkvB,UAAY7R,EAAO6R,gBAEFltB,IAAtBqb,EAAOs8B,aACP35C,KAAK25C,WAAat8B,EAAOs8B,iBAEL33C,IAApBqb,EAAO2I,WACPhmB,KAAKgmB,SAAW3I,EAAO2I,eAEJhkB,IAAnBqb,EAAO4I,UACPjmB,KAAKimB,QAAU5I,EAAO4I,cAEKjkB,IAA3Bqb,EAAOrE,kBACPhZ,KAAKgZ,gBAAkBqE,EAAOrE,sBAEdhX,IAAhBqb,EAAOikE,OACPthF,KAAKshF,KAAOjkE,EAAOikE,WAEOt/E,IAA1Bqb,EAAO47H,iBACPj5I,KAAKi5I,eAAiB57H,EAAO47H,qBAELj3I,IAAxBqb,EAAO67H,eACPl5I,KAAKk5I,aAAe77H,EAAO67H,mBAETl3I,IAAlBqb,EAAOmsC,SACPxpD,KAAKwpD,OAASnsC,EAAOmsC,aAEAxnD,IAArBqb,EAAOi7H,YACPhiH,EAAStvB,IAAIqW,EAAOi7H,WACpBt4I,KAAKs4I,UAAYhiH,QAEGt0B,IAApBqb,EAAOgW,WACPrzB,KAAKqzB,SAAWhW,EAAOgW,eAEJrxB,IAAnBqb,EAAOiW,UACPtzB,KAAKszB,QAAUjW,EAAOiW,cAEPtxB,IAAfqb,EAAOwR,MACP7uB,KAAK6uB,IAAMxR,EAAOwR,KAEtB7uB,KAAK6jB,OAAsB,QAAhB,EAAGxG,EAAOwG,cAAM,QAAI,GAInC7jB,KAAKm5I,gBACLn5I,KAAKo5I,oBAQT,QAAQliE,GACJl3E,KAAKigE,MAAQiX,OAIQl1E,IAAjBhC,KAAKwL,SACL,EAAAmzE,wBAAwB3+E,KAAM,UAAWk3E,GAOjD,UACI,OAAOl3E,KAAKigE,QAAsD,IAA7C,EAAA30D,wBAAwBtL,KAAM,WAMvD,WAAW6jB,GACP7jB,KAAKgY,SAAS6L,OAAOxlB,MAAQwlB,EAMjC,aACI,OAAO7jB,KAAKgY,SAAS6L,OAAOxlB,MAQhC,YAAY64E,GACR,EAAAyH,wBAAwB3+E,KAAM,cAAek3E,GAMjD,cACI,OAAwD,IAAjD,EAAA5rE,wBAAwBtL,KAAM,eAMzC,cACI,OAAOA,KAAKwzI,UAEhB,YAAYn1I,GACR2B,KAAKwzI,UAAYn1I,OAGK2D,IAAlBhC,KAAKgY,WACLhY,KAAKgY,SAASkT,QAAQ7sB,MAAQA,GAOtC,YACI,OAAO2B,KAAKgY,SAASw8G,QAAQn2H,MAEjC,UAAUA,GACN2B,KAAKgY,SAASw8G,QAAQn2H,MAAMiR,KAAKjR,GAQrC,mBACI,OAAO2B,KAAKgY,SAASugI,aAAal6I,MAEtC,iBAAiBA,GACb2B,KAAKgY,SAASugI,aAAal6I,MAAMiR,KAAKjR,GAQ1C,gBACI,OAAO2B,KAAKgY,SAASsgI,UAAUj6I,MAEnC,cAAcA,GACV2B,KAAKgY,SAASsgI,UAAUj6I,MAAMiR,KAAKjR,GACnC,EAAAsgF,wBAAwB3+E,KAAM,kBAAkB,GAMpD,gBACI,OAAwD,EAAhDA,KAAKgY,SAASwgI,eAAen6I,MAEzC,cAAcA,GACV2B,KAAKgY,SAASwgI,eAAen6I,MAAQA,EAAQ,EAMjD,mBACI,OAAO2B,KAAKgY,SAASob,aAAa/0B,MAEtC,iBAAiBA,GACb2B,KAAKgY,SAASob,aAAa/0B,MAAQA,EACnC2B,KAAKouE,QAAU/vE,EAAQ,EAS3B,eACI,OAAO2B,KAAKgY,SAASqb,SAASh1B,MAElC,aAAaA,GACT2B,KAAKgY,SAASqb,SAASh1B,MAAQA,EASnC,cACI,OAAO2B,KAAKgY,SAASsb,QAAQj1B,MAEjC,YAAYA,GACR2B,KAAKgY,SAASsb,QAAQj1B,MAAQA,EAC9B,EAAAsgF,wBAAwB3+E,KAAM,kBAAmB3B,EAAQ,GAM7D,WACI,IAAI8H,EAAmB,QACvB,MAAMkzI,EAAW,EAAA/tI,wBAAwBtL,KAAM,aAK/C,MAHwB,iBAAbq5I,GAAyB/B,EAAuBr4I,eAAeo6I,KACtElzI,EAASmxI,EAAuB+B,IAE7BlzI,EAEX,SAAS9H,GAGD44I,EAAuBh4I,eAAeZ,IACtC,EAAAsgF,wBAAwB3+E,KAAM,YAAai3I,EAAuB54I,IAO1E,aACI,IAAI8H,EAAqB,SACzB,MAAMmzI,EAAa,EAAAhuI,wBAAwBtL,KAAM,eAKjD,MAH0B,iBAAfs5I,GAA2BvB,EAAyB94I,eAAeq6I,KAC1EnzI,EAAS4xI,EAAyBuB,IAE/BnzI,EAEX,WAAW9H,GAGHq5I,EAAyBz4I,eAAeZ,IACxC,EAAAsgF,wBAAwB3+E,KAAM,cAAe03I,EAAyBr5I,IAI9E,eACI,OAAO2B,KAAKgY,SAASgO,SAAS3nB,MAElC,aAAaA,GACT2B,KAAKgY,SAASgO,SAAS3nB,MAAQA,EAGnC,cACI,OAAO2B,KAAKgY,SAASiO,QAAQ5nB,MAEjC,YAAYA,GACR2B,KAAKgY,SAASiO,QAAQ5nB,MAAQA,EAC9B,EAAAsgF,wBAAwB3+E,KAAM,aAAc3B,EAAQ,GAGxD,sBACI,OAAO2B,KAAKgY,SAASgB,gBAAgB3a,MAEzC,oBAAoB0H,GAChB,GAAI/F,KAAKgY,SAASgB,gBAAgB3a,QAAU0H,EACxC,OAEJ/F,KAAKgY,SAASgB,gBAAgB3a,MAAQ0H,EACtC,MAAM+kD,EAA6B,OAAR/kD,EACvB+kD,IACA9qD,KAAKgY,SAASgB,gBAAgB3a,MAAMkO,aAAc,GAEtD,EAAAoyE,wBAAwB3+E,KAAM,sBAAuB8qD,GAGzD,qBACI,OAAO9qD,KAAKgY,SAAS2yF,UAAUtsG,MAAMoH,EAEzC,mBAAmBpH,GACf2B,KAAKgY,SAAS2yF,UAAUtsG,MAAMoH,EAAIpH,EAGtC,mBACI,OAAO2B,KAAKgY,SAAS2yF,UAAUtsG,MAAMqH,EAEzC,iBAAiBrH,GACb2B,KAAKgY,SAAS2yF,UAAUtsG,MAAMqH,EAAIrH,EAGtC,iBAAiByY,GACb9W,KAAKgY,SAASlB,SAASzY,MAAMiR,KAAKwH,GAClC,MAAMyiI,EAAcziI,EAASrR,EAAI,GAAKqR,EAASpR,EAAI,EACnD,EAAAi5E,wBAAwB3+E,KAAM,gBAAiBu5I,GAEnD,mBACI,OAAOv5I,KAAKgY,SAASlB,SAASzY,MAG1B,gBACA2B,KAAKigE,QAAU,EAAA30D,wBAAwBtL,KAAM,YAC7C,EAAA2+E,wBAAwB3+E,KAAM,UAAWA,KAAKigE,OAI9C,oBACAjgE,KAAKwzI,YAAcxzI,KAAKgY,SAASkT,QAAQ7sB,QACzC2B,KAAKgY,SAASkT,QAAQ7sB,MAAQ2B,KAAKwzI,YAG/C,OAzaW,EAAA/pH,cAAwB,SACxB,EAAAgvH,cAAwB,EACxB,EAAAC,sBAAgC,EAChC,EAAA/uH,gBAA0B,EAC1B,EAAAivH,yBAAmC,EACnC,EAAAC,uBAAiC,EACjC,EAAAC,kBAA4B,EAC5B,EAAAC,iBAA2B,EAC3B,EAAAJ,eAAyB,EAiapC,GA3aA,GAAa,EAAAjsH,qB,sGCjYA,EAAA8sH,eAA+B,CACxCxhI,SAAU,CACNohF,SAAU,CAAE/6F,MAAO,MACnBwlB,OAAQ,CAAExlB,MAAO,GACjBo7I,SAAU,CAAEp7I,MAAO,IAEvB+6B,aAAc,4KAMdC,eAAgB,kY,mGChBpB,aAGA,QACA,SACA,QAqEA,MAAaqgH,EAuGT,YACaj2F,EACA9lD,EACAiS,EACAwR,EACAq4B,EACAC,EACA2iD,EACAs9C,EACAC,EACAC,EACDC,GAVC,KAAAr2F,MACA,KAAA9lD,OACA,KAAAiS,OACA,KAAAwR,OACA,KAAAq4B,WACA,KAAAC,YACA,KAAA2iD,gBACA,KAAAs9C,QACA,KAAAC,gBACA,KAAAC,oBACD,KAAAC,qBAER95I,KAAK+5I,oBAAsB,IAAI,EAAAC,kBAC3BH,EACA75I,KAAKy5C,SAAW,EAChBz5C,KAAK05C,UAAY,GAGrB15C,KAAKi6I,cAAgB,IAAI93I,IACzBnC,KAAKk6I,eAAiB,IAAI/3I,IAC1BnC,KAAKm6I,gBAAkB,IAAIh4I,IAC3BnC,KAAKo6I,aAAe,IAAIj4I,IACxBnC,KAAKq6I,cAAgB,IAAIl4I,IACzBnC,KAAKs6I,eAAiB,IAAIn4I,IArH9B,kBAAkB+kB,EAAc2yH,GAC5B,MAAMp2F,EAAM,IAAIzxB,IAAI9K,EAAM+kB,OAAOx1B,SAAS4rF,MACpCtqD,QAAoB2hG,EAAYa,SAAS92F,EAAI4+C,MAE7Cm4C,EAAoB,IAAIxoH,IAAI,GAAG+lB,EAAYp6C,qBAA2B8lD,GACtEg3F,QAAwBf,EAAYa,SACtCC,EAAkBn4C,KAAO,iBAEvBq4C,QAA2BhB,EAAYiB,YACzCH,EAAkBn4C,KAAO,gBAE7Bq4C,EAAmBjrH,MAAQrwB,EAAMgsG,oBACjCsvC,EAAmB/qH,MAAQvwB,EAAMgsG,oBACjCsvC,EAAmB5qH,UAAY1wB,EAAMmsG,cACrCmvC,EAAmBnuI,aAAc,EAEjC,MAAMquI,EAAkB7iG,EAAY4hG,MAAMzhH,KAAMo3B,GAA6B,UAAdA,EAAK3xD,MAC9Dk9I,EAAmB,IAAI,EAAA7rF,UACzB,MACA,WACAyrF,EAAgBK,MAAM,GAAGrjI,MACzBgjI,EAAgBK,MAAM,GAAG5pI,OACzBupI,EAAgBK,MAAM,GAAGC,SACzBN,EAAgBK,MAAM,GAAGE,QACzBP,EAAgBK,MAAM,GAAGG,QACzB,EACA,EACA,EACA,EACAP,EACAE,GAgBJ,OAbwB,IAAIlB,EACxBj2F,EAAI4+C,KAAK/+C,OAAO,EAAGG,EAAI4+C,KAAK1+C,YAAY,MACxC5L,EAAYp6C,KACZo6C,EAAYnoC,KACZmoC,EAAY32B,KACZ22B,EAAY0B,SACZ1B,EAAY2B,UACZ3B,EAAYskD,cACZtkD,EAAY4hG,MACZ5hG,EAAYmjG,gBACZrB,EACAgB,GAKR,yBAAyBp3F,GACrB,OAAO,IAAIxL,QAAQqzB,KACf,IAAIlsE,EAAM8yB,eAAgBC,KAAKsxB,EAAK6nB,KAI5C,sBAAsB7nB,GAClB,MAAM8kB,QAAiBD,MAAM7kB,GAC7B,IAAK8kB,EAASq7C,GACV,MAAM,IAAIngH,MAAM,GAAGggD,mBAAqB8kB,EAASs7C,cAErD,MAAMs3B,QAAgB5yE,EAAS/iD,OAC/B,OAAO/d,KAAK9F,MAAMw5I,GA8DtB,UACIn7I,KAAK25I,MAAMr4I,OAAS,EACpBtB,KAAK45I,cAAct4I,OAAS,EAC5BtB,KAAK+5I,oBAAoBt0G,UACzBzlC,KAAKi6I,cAAcj0G,QACnBhmC,KAAKk6I,eAAel0G,QACpBhmC,KAAKm6I,gBAAgBn0G,QACrBhmC,KAAKo6I,aAAap0G,QAClBhmC,KAAKq6I,cAAcr0G,QACnBhmC,KAAKs6I,eAAet0G,QAMxB,QACIhmC,KAAK+5I,oBAAoB/zG,QACzBhmC,KAAKi6I,cAAcj0G,QACnBhmC,KAAKk6I,eAAel0G,QACpBhmC,KAAKm6I,gBAAgBn0G,QACrBhmC,KAAKo6I,aAAap0G,QAClBhmC,KAAKq6I,cAAcr0G,QACnBhmC,KAAKs6I,eAAet0G,QASxB,OAAOtN,GACH14B,KAAK+5I,oBAAoB1nG,OAAO3Z,GAMpC,cACI,OAAO14B,KAAK+5I,oBAAoB5iI,QAMpC,kBACI,OAAOnX,KAAK+5I,oBAAoBvgG,YAMpC,gBACI,OACIx5C,KAAKi6I,cAAc74H,KAAO,GAC1BphB,KAAKk6I,eAAe94H,KAAO,GAC3BphB,KAAKm6I,gBAAgB/4H,KAAO,EAepC,gBACIyW,EACAy3B,EACAxkC,EACAswH,GAEA,MAAMC,EAAar7I,KAAKs7I,cAAcxwH,EAAWwkC,GAC3CisF,EAAW,GAAGF,KAAcxjH,EAAMl6B,KAAKyO,QAAQ,KAAM,YAC3D,IAAIxK,EAAO5B,KAAKo6I,aAAan8I,IAAIs9I,GACjC,QAAav5I,IAATJ,EAAoB,CACpB,IAAI45I,EAAcx7I,KAAKi6I,cAAch8I,IAAIs9I,GACzC,QAAoBv5I,IAAhBw5I,EACA,IACIA,EAAc9B,EAAYa,SAASgB,GACnCv7I,KAAKi6I,cAAcjzI,IAAIu0I,EAAUC,GACjC55I,QAAa45I,EACbx7I,KAAKi6I,cAAclzI,OAAOw0I,GAC1Bv7I,KAAKo6I,aAAapzI,IAAIu0I,EAAU35I,GAClC,MAAO8C,GAELyyF,QAAQ54E,MAAM7Z,GACd1E,KAAKi6I,cAAclzI,OAAOw0I,QAG9B35I,QAAa45I,EAIrB,MAAMC,EAA8C,GACpD,IAAkB,IAAdL,EACA,IAAK,MAAMM,KAAQ95I,EAAK+5I,MACpBF,EAAav1I,KAAKlG,KAAK47I,SAAS,GAAGP,KAAcK,MAKzD,aAFMzjG,QAAQC,IAAIujG,GAEX75I,EAWX,YAAYi2B,EAAqBy3B,EAAYxkC,GACzC,MAAMuwH,EAAar7I,KAAKs7I,cAAcxwH,EAAWwkC,GAC3CisF,EAAW,GAAGF,KAAcxjH,EAAMl6B,KAAKyO,QAAQ,KAAM,YACrDxK,EAAO5B,KAAKo6I,aAAan8I,IAAIs9I,GACnC,QAAav5I,IAATJ,EAAoB,CACpB,IAAK,MAAM85I,KAAQ95I,EAAK+5I,MAAO,CAC3B,MAAME,EAAW,GAAGR,KAAcK,IAClC17I,KAAKk6I,eAAenzI,OAAO80I,GAC3B77I,KAAKq6I,cAActzI,OAAO80I,GAE9B77I,KAAKi6I,cAAclzI,OAAOw0I,GAC1Bv7I,KAAKo6I,aAAarzI,OAAOw0I,IAcjC,kBAAkBx6I,EAAeglB,GAC7B,MAAM6E,EAAW7E,EAAM6E,SACjBE,EAAY/E,EAAM+E,UAKlBgxH,GAHF/1H,EAAMgF,cAAgB,EAAA7C,YAAY6zH,SAClCh2H,EAAMgF,cAAgB,EAAA7C,YAAYktC,UAEHr0D,EAAMq9G,cAAgBr9G,GAAOqL,QAC5D,uBACA,CAAC3O,EAAG0B,IACOA,EAAEwzB,QAAQl1B,GAAK,EAAI,GAAKA,GAGjCu+I,EAA2C,GACjD,IAAK,MAAMC,KAAQH,EAAS,CACxB,MAAM3kH,EAAY8kH,EAAKhL,YAAY,GAC7B3hF,EAAOtvD,KAAKk8I,QAAQ/kH,EAAWvM,GAC/BuxH,EAAW,GAAG7sF,EAAK3xD,QAAQmtB,IAC3BsxH,EAAY,GAAGD,KAAYhlH,IAEjC,IAAIklH,EAAer8I,KAAKs6I,eAAer8I,IAAIk+I,QACtBn6I,IAAjBq6I,IACAA,EAAe,IAAIl6I,IACnBnC,KAAKs6I,eAAetzI,IAAIm1I,EAAUE,IAGtC,MAAMxoF,EAAQwoF,EAAap+I,IAAIk5B,GAC/B,QAAcn1B,IAAV6xD,EAAqB,CACrB,IAAIyoF,EAAet8I,KAAKm6I,gBAAgBl8I,IAAIm+I,GAC5C,QAAqBp6I,IAAjBs6I,EAA4B,CAC5B,IAA+D,IAA3DhtF,EAAKwsF,QAAQnpH,QAAQk9B,OAAOC,cAAc34B,IAAoB,CAC9D,MAAM0jH,EAAmB76I,KAAKu8I,uBAAuBplH,EAAW8kH,EAAM3sF,GACtE+sF,EAAcr1I,IAAImwB,EAAW0jH,GAC7B76I,KAAK+5I,oBAAoB55I,IAAIi8I,EAAWvB,GACxC,SAGJ,IAAI2B,EACJ,IAAK,MAAM3kH,KAAS73B,KAAK45I,cACrB,GAAIziH,GAAaU,EAAMjuB,KAAOutB,GAAaU,EAAM/tB,IAAK,CAClD0yI,EAAmB3kH,EACnB,MAIRykH,EAAet8I,KAAKy8I,WAAWtlH,EAAWrM,EAAW0xH,EAAmBltF,GACxEtvD,KAAKm6I,gBAAgBnzI,IAAIo1I,EAAWE,GACpCA,EAAat3G,KAAM03G,IACf18I,KAAKm6I,gBAAgBpzI,OAAOq1I,GAC5BC,EAAcr1I,IAAImwB,EAAWulH,GAC7B18I,KAAK+5I,oBAAoB55I,IAAIi8I,EAAWM,KAGhDV,EAAc91I,KAAKo2I,QACXt8I,KAAK+5I,oBAAoBxzI,IAAI61I,KACrCJ,EAAc91I,KAAK+xC,QAAQqzB,QAAQzX,IACnC7zD,KAAK+5I,oBAAoB55I,IAAIi8I,EAAWvoF,IAIhD,OAAO5b,QAAQC,IAAI8jG,GAavB,SAAS7kH,EAAmBm4B,EAAYxkC,GACpC,MAAMuxH,EAAer8I,KAAKs6I,eAAer8I,IAAI,GAAGqxD,EAAK3xD,QAAQmtB,KAC7D,QAAqB9oB,IAAjBq6I,EAGJ,OAAOA,EAAap+I,IAAIk5B,GAa5B,UACIp2B,EACAglB,EACA6oB,GAEA,MAAMzoC,EAAS,GACTykB,EAAW7E,EAAM6E,SACjBE,EAAY/E,EAAM+E,UAClBC,EAAchF,EAAMgF,YACpB4xH,EACF5xH,IAAgB,EAAA7C,YAAY6zH,SAAWhxH,IAAgB,EAAA7C,YAAYktC,UACvE,IAAK,MAAMxF,KAAa7uD,EAAO,CAC3B,MAAM67I,EAAuBD,EAAkB/sF,EAAUwuD,cAAgBxuD,EACzE,IAAK,MAAMqsF,KAAQW,EAAsB,CACrC,MAAMzlH,EAAY8kH,EAAKhL,YAAY,GAC7B3hF,EAAOtvD,KAAKk8I,QAAQ/kH,EAAWvM,GAC/BonC,EAAYhyD,KAAK68I,SAAS1lH,EAAWm4B,EAAMxkC,GACjD,QAAkB9oB,IAAdgwD,EAMA,OALA7rD,EAAOD,KAAK8rD,QACYhwD,IAApB4sC,GACAA,EAAgB1oC,KAAK+1I,IAASrsF,IAO9C,OAAOzpD,EAWX,QAAQgxB,EAAmBvM,GACvB,IAAIkyH,EAA2B98I,KAAK25I,MAAM,GAAGh8I,KAC7C,IAAK,MAAMk6B,KAAS73B,KAAK45I,cACrB,GAAIziH,GAAaU,EAAMjuB,KAAOutB,GAAaU,EAAM/tB,IAAK,CAClDgzI,OACiB96I,IAAb4oB,QAGO5oB,IAFP61B,EAAM8hH,MAAMzhH,KAAKC,GACNA,IAAYvN,GAEjBA,EACAiN,EAAM8hH,MAAM,GACtB,MAIR,OAAO35I,KAAK25I,MAAMzhH,KAAKC,GACZA,EAAQx6B,OAASm/I,GAShC,kBAAkBzoF,GACd,IAAI7zB,EAAW,EAEf,IAAK,MAAM3I,KAAS73B,KAAK45I,cACrBp5G,GAAsC,GAAzB3I,EAAM/tB,IAAM+tB,EAAMjuB,KAInC,IAAImzI,EACA/8I,KAAK+5I,oBAAoBvgG,YAAY/zC,EAAIzF,KAAK+5I,oBAAoBvgG,YAAY9zC,EAAI,EAEtF,IAAK,MAAMg2I,KAAQ17I,KAAKq6I,cAAc/6G,QAClC,QAAqCt9B,IAAjChC,KAAKq6I,cAAcp8I,IAAIy9I,GAAqB,CAC5C,MAAMsB,EAAah9I,KAAKq6I,cAAcp8I,IAAIy9I,QACvB15I,IAAfg7I,IACAD,GAAgBC,EAAW1lI,MAAMG,MAAQulI,EAAW1lI,MAAMpG,OAAS,GAK/EmjD,EAAK38C,UAAY8oB,EAAWu8G,EAC5B1oF,EAAK18C,SAAWolI,EAGZ,uBAAuB5lH,EAAmB8kH,EAAc3sF,GAC5D,MAAMurF,EAAmB76I,KAAK85I,mBAAmBjtI,QAIjD,OAHCguI,EAAyB1jH,UAAYA,EACrC0jH,EAAyBjrF,UAAYqsF,EACrCpB,EAAyBvrF,KAAOA,EAC1BurF,EAGH,iBACJ1jH,EACArM,EACA+M,EACAy3B,GAEA,MAAM1tD,QAAa5B,KAAKi9I,UAAUplH,EAAOy3B,EAAMxkC,GAC/C,QAAa9oB,IAATJ,EACA,OAAO5B,KAAK85I,mBAGhB,MAAMoD,EAAmBt7I,EAAKk5I,MAAyB5iH,KAAK+jH,GAAQA,EAAKltH,KAAOoI,GAE1EgmH,EAAc,GADDn9I,KAAKs7I,cAAcxwH,EAAWwkC,MACZ1tD,EAAK+5I,MAAMuB,EAAiBxB,QAC3DvkI,QAAgBnX,KAAK47I,SAASuB,GAkBpC,OAhBkB,IAAI,EAAAnuF,UAClBkuF,EAAiBnuH,GACjB8I,EAAMl6B,KACNu/I,EAAiBzlI,MACjBylI,EAAiBhsI,OACjBgsI,EAAiBnC,SACjBmC,EAAiBlC,QACjBkC,EAAiBjC,QACjBiC,EAAiBz3I,EAAI0R,EAASG,MAAMG,MACpC,GAAOylI,EAAiBx3I,EAAIw3I,EAAiBhsI,QAAUiG,EAASG,MAAMpG,QACrEgsI,EAAiBz3I,EAAIy3I,EAAiBzlI,OAASN,EAASG,MAAMG,MAC/D,EAAMylI,EAAiBx3I,EAAIyR,EAASG,MAAMpG,OAC1CiG,EACAm4C,GAMA,eAAeusF,GACnB,IAAIH,EAAO17I,KAAKq6I,cAAcp8I,IAAI49I,GAClC,QAAa75I,IAAT05I,EAAoB,CACpB,IAAI0B,EAAcp9I,KAAKk6I,eAAej8I,IAAI49I,QACtB75I,IAAhBo7I,GACAA,EAAc1D,EAAYiB,YAAYkB,GACtC77I,KAAKk6I,eAAelzI,IAAI60I,EAAUuB,GAClC1B,QAAa0B,EACb1B,EAAKjsH,MAAQrwB,EAAMgsG,oBACnBswC,EAAK/rH,MAAQvwB,EAAMgsG,oBACnBswC,EAAK5rH,UAAY1wB,EAAMmsG,cACvBmwC,EAAKnvI,aAAc,EACfvM,KAAKk6I,eAAenzI,OAAO80I,IAC3B77I,KAAKq6I,cAAcrzI,IAAI60I,EAAUH,GAErC17I,KAAKk6I,eAAenzI,OAAO80I,IAE3BH,QAAa0B,EAGrB,OAAO1B,EAGH,cAAc5wH,EAAsBwkC,GACxC,IAAI+tF,EA5kBQ,WA6kBZ,OAAQvyH,GACJ,KAAK,EAAA7C,UAAUq1H,UACOt7I,IAAdstD,EAAKiuF,OACLF,EA/kBK,gBAilBT,MACJ,KAAK,EAAAp1H,UAAUu1H,YACSx7I,IAAhBstD,EAAKmuF,SACLJ,EAnlBO,kBAqlBX,MACJ,KAAK,EAAAp1H,UAAUy1H,gBACa17I,IAApBstD,EAAKquF,WACLN,EAvlBY,0BAwlBWr7I,IAAhBstD,EAAKmuF,OACZJ,EA1lBO,sBA2lBcr7I,IAAdstD,EAAKiuF,OACZF,EA7lBK,gBAimBjB,MAAO,GAAGr9I,KAAKyjD,OAAOzjD,KAAKrC,OAAO0/I,IAAgB/tF,EAAK3xD,QA/hB/D,iB,yGC1EA,cACA,OAGA,QACA,QA8BA,0BAoCI,YACawpC,EACAy2G,EACAC,GAFA,KAAA12G,WACA,KAAAy2G,aACA,KAAAC,cAET,MAAMC,EAAQz0I,KAAKmtB,MAAMntB,KAAK+H,KAAK+1B,IACnCnnC,KAAK+9I,cAAgBD,EAAQA,EAAQ32G,EAAW22G,EAAQ,EAAIA,EAC5D99I,KAAKg+I,aAAeF,EAAQ99I,KAAK+9I,cAAgB52G,EAAW22G,EAAQ,EAAIA,EAExE99I,KAAKi+I,cAAgB,IAAI7+I,EAAMoG,QAC3BxF,KAAKg+I,aAAeJ,EACpB59I,KAAK+9I,cAAgBF,IAErB79I,KAAKi+I,cAAcv4I,EAjEN,MAiE8B1F,KAAKi+I,cAAcx4I,EAjEjD,OAmEb0xF,QAAQphF,KACJ,mCACI/V,KAAKi+I,cAAcx4I,EACnB,KACAzF,KAAKi+I,cAAcv4I,EACnB,oLAQZ1F,KAAKk+I,aAAe,IAAI,EAAArwB,SAAkC1mF,GAC1DnnC,KAAKm+I,mBAELn+I,KAAK+/D,QAAU,IAAI3gE,EAAMkiB,MACzBthB,KAAKw5B,SAAW,IAAIp6B,EAAMq6B,mBACtB,EACAz5B,KAAKi+I,cAAcx4I,EACnBzF,KAAKi+I,cAAcv4I,EACnB,GAEJ1F,KAAKw5B,SAASzrB,SAASnI,EAAI,EAC3B5F,KAAKw5B,SAASzkB,mBAAkB,GAChC/U,KAAKo+I,KAAO,IAAIh/I,EAAMs+F,kBAAkB19F,KAAKi+I,cAAcx4I,EAAGzF,KAAKi+I,cAAcv4I,EAAG,CAChF+pB,MAAOrwB,EAAMgsG,oBACbz7E,MAAOvwB,EAAMgsG,oBACbizC,aAAa,EACbC,eAAe,IAGnBt+I,KAAKu+I,iBAAmB,IAAI5+I,IAC5BK,KAAKw+I,gBAAkB,IAAIp/I,EAAMm3I,QACjCv2I,KAAKy+I,gBAAkB,GACvBz+I,KAAKy+I,gBAAgBv4I,KACjB,IAAI9G,EAAMoG,QACV,IAAIpG,EAAMoG,QACV,IAAIpG,EAAMoG,QACV,IAAIpG,EAAMoG,SAGdxF,KAAK0+I,eAAiB,IAAI,EAAArjD,kBAC1Br7F,KAAK2+I,mBAAqB,IAAIv/I,EAAM4xD,kBAAkB,IAAIx/B,aAAwB,GAAX2V,GAAgB,GACvFnnC,KAAK2+I,mBAAmB1tF,SAAS7xD,EAAM8xD,kBAEvClxD,KAAK4+I,wBAA0B,IAAIx/I,EAAMya,2BACrC7Z,KAAK2+I,mBACL,EACA,GAEJ3+I,KAAK6+I,kBAAoB,IAAIz/I,EAAMya,2BAC/B7Z,KAAK2+I,mBACL,EACA,GAEJ3+I,KAAK8+I,eAAiB,IAAI1/I,EAAMob,eAChCxa,KAAK8+I,eAAertF,aAAa,WAAYzxD,KAAK4+I,yBAClD5+I,KAAK8+I,eAAertF,aAAa,KAAMzxD,KAAK6+I,mBAE5C,MAAME,EAAkB,IAAI3/I,EAAM0a,gBAAgB,IAAIwX,YAAuB,EAAX6V,GAAe,GACjF43G,EAAgB9tF,SAAS7xD,EAAM8xD,kBAC/BlxD,KAAK8+I,eAAeptF,SAASqtF,GAC7B/+I,KAAKg/I,WAAa,IAAI5/I,EAAM40B,KAAKh0B,KAAK8+I,eAAgB9+I,KAAK0+I,gBAC3D1+I,KAAKg/I,WAAWntF,eAAgB,EAChC7xD,KAAKi/I,wBAA0B,EAE/Bj/I,KAAKk/I,gBAAkB,IAAI,EAAA9jD,mBAC3Bp7F,KAAKm/I,yBAA2B,IAAI//I,EAAM0a,gBACtC,IAAI0X,aAAwB,EAAX2V,GACjB,GAEJnnC,KAAKm/I,yBAAyBluF,SAAS7xD,EAAM8xD,kBAC7ClxD,KAAKo/I,gBAAkB,IAAIhgJ,EAAMob,eACjCxa,KAAKo/I,gBAAgB3tF,aAAa,WAAYzxD,KAAKm/I,0BACnD,MAAME,EAAmB,IAAIjgJ,EAAM0a,gBAAgB,IAAIwX,YAAuB,EAAX6V,GAAe,GAClFk4G,EAAiBpuF,SAAS7xD,EAAM8xD,kBAEhClxD,KAAKo/I,gBAAgB1tF,SAAS2tF,GAC9Br/I,KAAKs/I,YAAc,IAAIlgJ,EAAM40B,KAAKh0B,KAAKo/I,gBAAiBp/I,KAAKk/I,iBAC7Dl/I,KAAKs/I,YAAYztF,eAAgB,EACjC7xD,KAAKu/I,yBAA2B,EAEhCv/I,KAAK+/D,QAAQ5/D,IAAIH,KAAKs/I,YAAat/I,KAAKg/I,YAM5C,UACIh/I,KAAKk+I,aAAal4G,QAClBhmC,KAAK+/D,QAAQ18B,OAAOrjC,KAAKs/I,YAAat/I,KAAKg/I,YAC3Ch/I,KAAKo+I,KAAK34G,UACVzlC,KAAKk/I,gBAAgBz5G,UACrBzlC,KAAK0+I,eAAej5G,UACpBzlC,KAAKu+I,iBAAiBv4G,QACtBhmC,KAAKo/I,gBAAgB35G,UACrBzlC,KAAK8+I,eAAer5G,UAMxB,cACI,OAAOzlC,KAAKo+I,KAAKjnI,QAMrB,kBACI,OAAOnX,KAAKi+I,cAUhB,IAAI3iB,EAAcznE,GAEd,QAAc7xD,IADAhC,KAAKk+I,aAAajgJ,IAAIq9H,GAEhC,OAGJ,MAAMkkB,EAAcx/I,KAAKk+I,aAAauB,OACtC,GAAoB,OAAhBD,EACA,MAAM,IAAI/7I,MAAM,uCAEpBzD,KAAK0/I,gBAAgBF,EAAYnhJ,OACjC2B,KAAK2/I,iBAAiBrkB,EAAMznE,EAAO2rF,EAAYnhJ,MAAMoY,UAUzD,IAAI6kH,GACA,OAAOt7H,KAAKk+I,aAAa33I,IAAI+0H,GAUjC,IAAIA,GACA,OAAOt7H,KAAKk+I,aAAajgJ,IAAIq9H,GAMjC,QACIt7H,KAAKi/I,wBAA0B,EAC/Bj/I,KAAKu/I,yBAA2B,EAChCv/I,KAAKk+I,aAAal4G,QAClBhmC,KAAKu+I,iBAAiBv4G,QACtBhmC,KAAKm+I,mBAST,OAAOzlH,GACH,IAAIulE,EAA6C,KAEjD,MAAM2hD,EAAoB5/I,KAAKu/I,yBAA2B,EACpDM,EAAmB7/I,KAAKi/I,wBAA0B,EAOxD,IALIW,GAAqBC,KACrB5hD,EAAkBvlE,EAASwlE,kBAC3BxlE,EAASK,gBAAgB/4B,KAAKo+I,OAG9BwB,EAAmB,CACnB,GAAmC,OAA/B5/I,KAAKo/I,gBAAgB1kI,MACrB,MAAM,IAAIjX,MAAM,4DAEpBzD,KAAKm/I,yBAAyB5yI,aAAc,EAC5CvM,KAAKm/I,yBAAyBrtF,YAAYjuC,OAAS,EACnD7jB,KAAKm/I,yBAAyBrtF,YAAY/3C,MAAwC,EAAhC/Z,KAAKu/I,yBACvDv/I,KAAKo/I,gBAAgB1kI,MAAMnO,aAAc,EACzCvM,KAAKo/I,gBAAgB1kI,MAAMo3C,YAAYjuC,OAAS,EAChD7jB,KAAKo/I,gBAAgB1kI,MAAMo3C,YAAY/3C,MAAwC,EAAhC/Z,KAAKu/I,yBACpDv/I,KAAKo/I,gBAAgBrtF,aAAa,EAAmC,EAAhC/xD,KAAKu/I,0BAE1Cv/I,KAAKs/I,YAAYl5H,SAAU,EAC3BpmB,KAAKg/I,WAAW54H,SAAU,EAE1BsS,EAASM,OAAOh5B,KAAK+/D,QAAS//D,KAAKw5B,UACnCx5B,KAAKu/I,yBAA2B,EAChCv/I,KAAKs/I,YAAYl5H,SAAU,EAG/B,GAAIy5H,EAAkB,CAClB,GAAkC,OAA9B7/I,KAAK8+I,eAAepkI,MACpB,MAAM,IAAIjX,MAAM,2DAEpBzD,KAAK2+I,mBAAmBpyI,aAAc,EACtCvM,KAAK2+I,mBAAmB7sF,YAAYjuC,OAAS,EAC7C7jB,KAAK2+I,mBAAmB7sF,YAAY/3C,MAAuC,GAA/B/Z,KAAKi/I,wBACjDj/I,KAAK8+I,eAAepkI,MAAMnO,aAAc,EACxCvM,KAAK8+I,eAAepkI,MAAMo3C,YAAYjuC,OAAS,EAC/C7jB,KAAK8+I,eAAepkI,MAAMo3C,YAAY/3C,MAAuC,EAA/B/Z,KAAKi/I,wBACnDj/I,KAAK8+I,eAAe/sF,aAAa,EAAkC,EAA/B/xD,KAAKi/I,yBAEzCj/I,KAAKg/I,WAAW54H,SAAU,EAC1B,MAAM05H,EAAW1+I,MAAM6I,KAAKjK,KAAKu+I,kBAC3BwB,EAAU12I,KAAKuW,KAAK5f,KAAKu+I,iBAAiBn9H,KArSjC,GAsSf,IAAK,IAAIsuC,EAAY,EAAGA,EAAYqwF,EAASrwF,IAAa,CACtD,MAAM4rC,EAvSK,EAuSQ5rC,EACnB1vD,KAAK0+I,eAAe1mI,SAASsjF,WAAWj9F,MAAQi9F,EAChD,IAAK,IAAIl+F,EAAI,EAAGA,EAzSL,EAyS6BA,IAAK,CACzC,MAAM4iJ,EAAY1kD,EAAal+F,EAC3B4iJ,EAAYhgJ,KAAKu+I,iBAAiBn9H,OAClCphB,KAAK0+I,eAAe1mI,SAAS,OAAS5a,GAAGiB,MAAQyhJ,EAASE,IAIlEtnH,EAASM,OAAOh5B,KAAK+/D,QAAS//D,KAAKw5B,UAEvCx5B,KAAKu+I,iBAAiBv4G,QACtBhmC,KAAKi/I,wBAA0B,GAE/BW,GAAqBC,IACrBnnH,EAASK,gBAAgBklE,GAIzB,mBACJ,MASMgiD,EAAkB,CACpBtiJ,KAAM,GACNqyD,QAX8B,CAC9B5uC,KAAM,EACNi7E,cAAe,EACf2tC,KAAM,EACN/5E,WAAY,EACZiwF,QAAS,EACT5qF,UAAW,EACXD,QAAS,GAKTymF,QAAS,IAGPqE,EAAiB,IAAI,EAAAnxF,UACvB,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA5vD,EAAM8Y,QAAQsjF,cACdykD,GAGJ,IAAK,IAAI7iJ,EAAI,EAAGA,EAAI4C,KAAK+9I,cAAe3gJ,IACpC,IAAK,IAAI4kD,EAAI,EAAGA,EAAIhiD,KAAKg+I,aAAch8F,IAAK,CACxC,MAAMo+F,EAA8B,CAChCpuF,UAAWmuF,EACX1pI,SAAU,IAAIrX,EAAMoG,QAAQw8C,EAAG5kD,IAEnC4C,KAAKk+I,aAAal3I,IAAI,SAAS5J,EAAI4C,KAAK+9I,cAAgB/7F,IAAKo+F,IAKjE,iBAAiB9kB,EAAcznE,EAAkBwsF,GACrDrgJ,KAAKu+I,iBAAiBp+I,IAAI0zD,EAAM18C,SAChC,IAAImpI,EAAmB,EACvB,IAAK,MAAMjiJ,KAAS2B,KAAKu+I,iBAAiB5+G,SAAU,CAChD,GAAIthC,IAAUw1D,EAAM18C,QAChB,MAEJmpI,IAEJzsF,EAAMnE,UAAY4wF,EAElBtgJ,KAAKw+I,gBAAgBx3I,IACjB,EACA,EACAq5I,EAAc56I,EAAIzF,KAAK49I,WAAa/pF,EAAMt/C,QAC1C,EACA,EACA8rI,EAAc36I,EAAI1F,KAAK69I,YAAchqF,EAAMtE,UAAU,GAAG7pD,EACxD,EACA,EACA,GAEJ,IAAK,IAAItI,EAAI,EAAGA,EAAI,IAAKA,EACrB4C,KAAKy+I,gBAAgBrhJ,GAAG4J,IAAI6sD,EAAMtE,UAAUnyD,GAAGqI,EAAGouD,EAAMtE,UAAUnyD,GAAGsI,GACrE1F,KAAKy+I,gBAAgBrhJ,GAAGmjJ,aAAavgJ,KAAKw+I,iBAG9C,GAAIx+I,KAAKi/I,yBAA2Bj/I,KAAKmnC,SACrC,OAEJ,MAAMorB,EAA4C,EAA/BvyD,KAAKi/I,wBAClBzsF,EAA2C,EAA/BxyD,KAAKi/I,wBAEvB,IAAK,IAAI7hJ,EAAI,EAAGA,EAAI,IAAKA,EACrB4C,KAAK4+I,wBAAwB4B,OACzBjuF,EAAan1D,EACb4C,KAAKy+I,gBAAgBrhJ,GAAGqI,EACxBzF,KAAKy+I,gBAAgBrhJ,GAAGsI,EACxBmuD,EAAMnE,WAEV1vD,KAAK6+I,kBAAkB4B,MACnBluF,EAAan1D,EACby2D,EAAMrE,yBAAyBpyD,GAAGqI,EAClCouD,EAAMrE,yBAAyBpyD,GAAGsI,GAI1C,GAAkC,OAA9B1F,KAAK8+I,eAAepkI,MACpB,MAAM,IAAIjX,MAAM,2DAEpBzD,KAAK8+I,eAAepkI,MAAMi4C,KAAKH,EAAWD,GAC1CvyD,KAAK8+I,eAAepkI,MAAMi4C,KAAKH,EAAY,EAAGD,EAAa,GAC3DvyD,KAAK8+I,eAAepkI,MAAMi4C,KAAKH,EAAY,EAAGD,EAAa,GAC3DvyD,KAAK8+I,eAAepkI,MAAMi4C,KAAKH,EAAY,EAAGD,EAAa,GAC3DvyD,KAAK8+I,eAAepkI,MAAMi4C,KAAKH,EAAY,EAAGD,EAAa,GAC3DvyD,KAAK8+I,eAAepkI,MAAMi4C,KAAKH,EAAY,EAAGD,EAAa,KAEzDvyD,KAAKi/I,wBAEP,MAAM/vF,EAAKlvD,KAAKy+I,gBAAgB,GAAGh5I,EAAIzF,KAAKi+I,cAAcx4I,EACpD0pD,EAAKnvD,KAAKy+I,gBAAgB,GAAG/4I,EAAI1F,KAAKi+I,cAAcv4I,EACpD0pD,EAAKpvD,KAAKy+I,gBAAgB,GAAGh5I,EAAIzF,KAAKi+I,cAAcx4I,EACpD4pD,EAAKrvD,KAAKy+I,gBAAgB,GAAG/4I,EAAI1F,KAAKi+I,cAAcv4I,EAC1DmuD,EAAMpE,0BAA0B,GAAGzoD,IAAIkoD,EAAIC,GAC3C0E,EAAMpE,0BAA0B,GAAGzoD,IAAIooD,EAAID,GAC3C0E,EAAMpE,0BAA0B,GAAGzoD,IAAIkoD,EAAIG,GAC3CwE,EAAMpE,0BAA0B,GAAGzoD,IAAIooD,EAAIC,GAE3CwE,EAAMlE,WAAY,EAClB3vD,KAAKk+I,aAAal3I,IAAIs0H,EAAM,CACxBtpE,UAAW6B,EACXp9C,SAAU4pI,IAIV,gBAAgBr8D,GAmBpB,GAlBAA,EAAMhyB,UAAUrC,WAAY,EAC5B3vD,KAAKy+I,gBAAgB,GAAGz3I,IACpBg9E,EAAMvtE,SAAShR,EAAIzF,KAAK49I,WACxB55D,EAAMvtE,SAAS/Q,EAAI1F,KAAK69I,aAE5B79I,KAAKy+I,gBAAgB,GAAGz3I,KACnBg9E,EAAMvtE,SAAShR,EAAI,GAAKzF,KAAK49I,WAC9B55D,EAAMvtE,SAAS/Q,EAAI1F,KAAK69I,aAE5B79I,KAAKy+I,gBAAgB,GAAGz3I,IACpBg9E,EAAMvtE,SAAShR,EAAIzF,KAAK49I,YACvB55D,EAAMvtE,SAAS/Q,EAAI,GAAK1F,KAAK69I,aAElC79I,KAAKy+I,gBAAgB,GAAGz3I,KACnBg9E,EAAMvtE,SAAShR,EAAI,GAAKzF,KAAK49I,YAC7B55D,EAAMvtE,SAAS/Q,EAAI,GAAK1F,KAAK69I,aAG9B79I,KAAKu/I,0BAA4Bv/I,KAAKmnC,SACtC,OAEJ,MAAMorB,EAA6C,EAAhCvyD,KAAKu/I,yBAClB/sF,EAA4C,EAAhCxyD,KAAKu/I,yBAEvB,IAAK,IAAIniJ,EAAI,EAAGA,EAAI,IAAKA,EACrB4C,KAAKm/I,yBAAyBsB,MAC1BluF,EAAan1D,EACb4C,KAAKy+I,gBAAgBrhJ,GAAGqI,EACxBzF,KAAKy+I,gBAAgBrhJ,GAAGsI,GAIhC,GAAmC,OAA/B1F,KAAKo/I,gBAAgB1kI,MACrB,MAAM,IAAIjX,MAAM,4DAEpBzD,KAAKo/I,gBAAgB1kI,MAAMi4C,KAAKH,EAAWD,GAC3CvyD,KAAKo/I,gBAAgB1kI,MAAMi4C,KAAKH,EAAY,EAAGD,EAAa,GAC5DvyD,KAAKo/I,gBAAgB1kI,MAAMi4C,KAAKH,EAAY,EAAGD,EAAa,GAC5DvyD,KAAKo/I,gBAAgB1kI,MAAMi4C,KAAKH,EAAY,EAAGD,EAAa,GAC5DvyD,KAAKo/I,gBAAgB1kI,MAAMi4C,KAAKH,EAAY,EAAGD,EAAa,GAC5DvyD,KAAKo/I,gBAAgB1kI,MAAMi4C,KAAKH,EAAY,EAAGD,EAAa,KAE1DvyD,KAAKu/I,4B,wGCvef,aAGA,MAAamB,EACT,YACW/hJ,EACAN,EACA+iB,EACAu/H,EACAC,GAJA,KAAAjiJ,MACA,KAAAN,QACA,KAAA+iB,OACA,KAAAu/H,QACA,KAAAC,SANf,UAcA,iBAwDI,YAAYC,EAAuBC,EAAqC,KAAM,IAlCtE,KAAAC,OAAS,EAKT,KAAAlmF,MAAQ,IAAI14D,IAKZ,KAAA6+I,SAAqC,KAKrC,KAAAC,SAAqC,KAoBzCjhJ,KAAKkhJ,WAAaL,EAClB7gJ,KAAKmhJ,eAAiBL,EAY1B,QACIM,EACAC,GAEA,IAAIr9D,EAAQhkF,KAAKghJ,SACjB,KAAiB,OAAVh9D,GAAgB,CACnB,MAAM48D,EAAQ58D,EAAM48D,MACpBQ,EAAW7jJ,KAAK8jJ,EAASr9D,EAAM3lF,MAAO2lF,EAAMrlF,IAAKqB,MACjDgkF,EAAQ48D,GAShB,WACI,OAAO5gJ,KAAK+gJ,OAUhB,eACI,OAAO/gJ,KAAKkhJ,WAUhB,UAGI,OAAOlhJ,KAAK66D,MAQhB,aACI,OAAO76D,KAAKghJ,SAUhB,aACI,OAAOhhJ,KAAKihJ,SAShB,YAAYK,GACRthJ,KAAKkhJ,WAAaI,EAClBthJ,KAAKuhJ,QAWT,sBAAsBD,EAAqBE,EAAoC,KAAM,IACjFxhJ,KAAKkhJ,WAAaI,EAClBthJ,KAAKmhJ,eAAiBK,EACtBxhJ,KAAKouH,mBAOT,mBACI,IAAIhtG,EAAO,EACX,MAAM0/H,EAAe9gJ,KAAKmhJ,eAE1B,IAAIn9D,EAAQhkF,KAAKghJ,SACjB,KAAiB,OAAVh9D,GAAgB,CACnB,MAAMy9D,EAAYX,EAAa98D,EAAM3lF,OACrC2lF,EAAM5iE,KAAOqgI,EACbrgI,GAAQqgI,EACRz9D,EAAQA,EAAM48D,MAGlB5gJ,KAAK+gJ,OAAS3/H,EACdphB,KAAKuhJ,QAeT,IAAI5iJ,EAAUN,GACV,MAAMqjJ,EAAY1hJ,KAAKmhJ,eAAe9iJ,GACtC,IAAI2lF,EAAQhkF,KAAK66D,MAAM58D,IAAIU,GAC3B,QAAcqD,IAAVgiF,EACAhkF,KAAK+gJ,OAAS/gJ,KAAK+gJ,OAAS/8D,EAAM5iE,KAAOsgI,EACzC19D,EAAM3lF,MAAQA,EACd2lF,EAAM5iE,KAAOsgI,EACb1hJ,KAAK2hJ,aAAa39D,GAClBhkF,KAAKuhJ,YACF,CACH,GAAIG,EAAY1hJ,KAAKkhJ,WACjB,OAIJ,GADAl9D,EAAQ,IAAI08D,EAAkB/hJ,EAAKN,EAAOqjJ,EAAW,KAAM,MACnC,IAApB1hJ,KAAK66D,MAAMz5C,KACXphB,KAAKghJ,SAAWhhJ,KAAKihJ,SAAWj9D,MAC7B,CACH,EAAA13E,OAAyB,OAAlBtM,KAAKghJ,UACZ,MAAMY,EAA4B5hJ,KAAKghJ,SACvCh9D,EAAM48D,MAAQ5gJ,KAAKghJ,SACnBY,EAAOjB,MAAQ38D,EACfhkF,KAAKghJ,SAAWh9D,EAEpBhkF,KAAK66D,MAAM7zD,IAAIrI,EAAKqlF,GACpBhkF,KAAK+gJ,QAAUW,EACf1hJ,KAAKuhJ,SAUb,IAAI5iJ,GACA,MAAMqlF,EAAQhkF,KAAK66D,MAAM58D,IAAIU,GAC7B,QAAcqD,IAAVgiF,EAKJ,OADAhkF,KAAK2hJ,aAAa39D,GACXA,EAAM3lF,MASjB,IAAIM,GACA,OAAOqB,KAAK66D,MAAMt0D,IAAI5H,GAS1B,QACIqB,KAAKghJ,SAAWhhJ,KAAKihJ,SAAW,KAChCjhJ,KAAK+gJ,OAAS,EACd/gJ,KAAK66D,MAAM70B,QAQf,WACI,MAAM67G,EAAK7hJ,KAAK8tH,sBACL9rH,IAAP6/I,GACA7hJ,KAAKK,QAAQ,CAAChC,EAAOM,IAAQkjJ,EAAGljJ,EAAKN,IAEzC2B,KAAKgmC,QAST,cAAcsoF,EAA+C+yB,GACzD,MAAMQ,EAAK7hJ,KAAK8tH,iBAChB,IAAI9pC,EAAQhkF,KAAKghJ,SACjB,KAAiB,OAAVh9D,GAAgB,CACnB,MAAM89D,EAAa99D,EAAM48D,MACrBtyB,EAAS/wH,KAAK8jJ,EAASr9D,EAAM3lF,MAAO2lF,EAAMrlF,YAC/BqD,IAAP6/I,GACAA,EAAG79D,EAAMrlF,IAAKqlF,EAAM3lF,OAExB2B,KAAK+hJ,YAAY/9D,GACjBhkF,KAAK66D,MAAM9zD,OAAOi9E,EAAMrlF,MAE5BqlF,EAAQ89D,GAYhB,OAAOnjJ,GACH,MAAMqlF,EAAQhkF,KAAK66D,MAAM58D,IAAIU,GAC7B,YAAcqD,IAAVgiF,IAGJhkF,KAAK+hJ,YAAY/9D,GACVhkF,KAAK66D,MAAM9zD,OAAOpI,IAGnB,QACN,KAAyB,OAAlBqB,KAAKihJ,UAAqBjhJ,KAAK+gJ,OAAS/gJ,KAAKkhJ,YAAY,CAE5D,QAAgBl/I,IADAhC,KAAKgiJ,cAEjB,QAKF,cACN,EAAA11I,OAAyB,OAAlBtM,KAAKihJ,UACZ,MAAMxB,EAASz/I,KAAKihJ,SACpB,EAAA30I,OAAwB,OAAjBmzI,EAAOmB,OACd,IAAIqB,EAAexC,EAEnB,QAAsBz9I,IAAlBhC,KAAK+tH,SACL,MAAQ/tH,KAAK+tH,SAASk0B,EAAatjJ,IAAKsjJ,EAAa5jJ,QAAQ,CACzD,GAA2B,OAAvB4jJ,EAAatB,MACb,OAEJsB,EAAeA,EAAatB,MAIpC,GAAIsB,IAAiBxC,EACjBz/I,KAAKihJ,SAAWgB,EAAatB,MACF,OAAvBsB,EAAatB,QACb,EAAAr0I,OAAO21I,EAAatB,MAAMC,QAAUqB,GACpCA,EAAatB,MAAMC,MAAQ,UAE5B,CACH,GAA2B,OAAvBqB,EAAatB,MAOb,OANA,EAAAr0I,OAAO21I,EAAatB,MAAMC,QAAUqB,GACpCA,EAAatB,MAAMC,MAAQqB,EAAarB,MACb,OAAvBqB,EAAarB,QACbqB,EAAarB,MAAMD,MAAQsB,EAAatB,OAOpD,MAAMuB,EAAOliJ,KAAK66D,MAAM9zD,OAAOk7I,EAAatjJ,KAM5C,OALA,EAAA2N,QAAgB,IAAT41I,GACHA,QAAkClgJ,IAA1BhC,KAAK8tH,kBACb9tH,KAAK8tH,iBAAiBm0B,EAAatjJ,IAAKsjJ,EAAa5jJ,OAEzD2B,KAAK+gJ,QAAUkB,EAAa7gI,KACrB6gI,EAGH,YAAYj+D,GACZA,IAAUhkF,KAAKghJ,SACfhhJ,KAAKghJ,SAAWh9D,EAAM48D,MACf58D,EAAM28D,MACb38D,EAAM28D,MAAMC,MAAQ58D,EAAM48D,MAE1B,EAAAt0I,QAAO,GAGP03E,IAAUhkF,KAAKihJ,SACfjhJ,KAAKihJ,SAAWj9D,EAAM28D,MACf38D,EAAM48D,MACb58D,EAAM48D,MAAMD,MAAQ38D,EAAM28D,MAE1B,EAAAr0I,QAAO,GAGXtM,KAAK+gJ,QAAU/8D,EAAM5iE,KAGjB,aAAa4iE,GACjB,GAAIA,IAAUhkF,KAAKghJ,SACf,OAIAh9D,EAAM28D,QACN,EAAAr0I,OAAO03E,EAAM28D,MAAMC,QAAU58D,GAC7BA,EAAM28D,MAAMC,MAAQ58D,EAAM48D,OAE1B58D,EAAM48D,QACN,EAAAt0I,OAAO03E,EAAM48D,MAAMD,QAAU38D,GAC7BA,EAAM48D,MAAMD,MAAQ38D,EAAM28D,OAE1B38D,IAAUhkF,KAAKihJ,WACfjhJ,KAAKihJ,SAAWj9D,EAAM28D,OAG1B38D,EAAM28D,MAAQ,KACd38D,EAAM48D,MAAQ5gJ,KAAKghJ,SAGnB,EAAA10I,OAAyB,OAAlBtM,KAAKghJ,UACZ,MAAMY,EAAS5hJ,KAAKghJ,SACpB,EAAA10I,OAAwB,OAAjBs1I,EAAOjB,OACdiB,EAAOjB,MAAQ38D,EACfhkF,KAAKghJ,SAAWh9D,K,8HC1axB,aAIA,QACA,QAEA,QACA,SACA,SAEA,QAEMm+D,EAAmB,IAAI/iJ,EAAMuG,QAC7By8I,EAAiB,CACnBzoI,MAAO,CAAC,IAAIva,EAAM42D,MAClBnyC,OAAQ,GAEZ,IAAIw+H,EAAmB,IAAI7wH,aAmId,EAAAylB,0BAA4B,EAyDzC,kBAAaqrG,EAqCT,YAAYjlI,GACRrd,KAAKmiE,WAAa9kD,EAAOqb,SACzB14B,KAAKuiJ,cAAgBllI,EAAO06B,YAC5B/3C,KAAKwiJ,cAAgBnlI,EAAOmlI,cAC5BxiJ,KAAKyiJ,cAAgBplI,EAAOolI,mBAEJzgJ,IAApBqb,EAAO5S,UACPzK,KAAK0iJ,gBAAiB,EACtB1iJ,KAAK41G,WAAa,EAAA+sC,sBAAsB,CAAE5qG,YAAa16B,EAAO06B,gBAE9D/3C,KAAK0iJ,gBAAiB,EACtB1iJ,KAAK41G,WAAav4F,EAAO5S,eAEKzI,IAA9Bqb,EAAOozC,oBACPzwD,KAAK4iJ,kBAAmB,EACxB5iJ,KAAK6iJ,aAAe,EAAAF,sBAAsB,CACtC5qG,YAAa16B,EAAO06B,YACpB0kD,cAAc,MAGlBz8F,KAAK4iJ,kBAAmB,EACxB5iJ,KAAK6iJ,aAAexlI,EAAOozC,oBAG/BzwD,KAAK8iJ,eAAiB,CAClB/zH,GAAI,EAAAkoB,0BACJC,QAAS,IAAI,EAAA6rG,aACT,IAAI3jJ,EAAMkiB,MACVthB,KAAK41G,WACL51G,KAAK6iJ,aACL7iJ,KAAKwiJ,cACLxiJ,KAAKyiJ,gBAGbziJ,KAAKgjJ,SAAW,CAAChjJ,KAAK8iJ,gBAEtB9iJ,KAAKijJ,0BAA2B,IAAI,EAAAz8H,iBAAkBlX,KAClDgzI,EAAWxkC,wBAEf99G,KAAKkjJ,0BAA2B,IAAI,EAAAx8H,iBAAkBpX,KAClDgzI,EAAWtkC,wBAGfh+G,KAAKmjJ,iBAAmB,IAAI,EAAAC,eAC5BpjJ,KAAKqjJ,iBAAmB,IAAI,EAAAC,eAMhC,kBACI,OAAOtjJ,KAAKuiJ,cAEhB,gBAAgBlkJ,GACZ2B,KAAKuiJ,cAAgBlkJ,EAErB,MAAMoM,EAAWzK,KAAK41G,WACtBnrG,EAASuN,SAASmkF,WAAW99F,MAAQ2B,KAAKuiJ,cAAcprI,QACxD1M,EAASuN,SAASokF,UAAU/9F,MAAQ,IAAIe,EAAMyG,QAC1C7F,KAAKuiJ,cAAc/oG,YAAY/zC,EAC/BzF,KAAKuiJ,cAAc/oG,YAAY9zC,EAC/B1F,KAAKuiJ,cAAcnhI,KACnBphB,KAAKuiJ,cAAclmD,eAEvB5xF,EAASe,QAAQ8wF,KAAmC,SAA5Bt8F,KAAKuiJ,cAAc3yI,KAAkB,EAAM,EAEnE,MAAM2zI,EAAavjJ,KAAK6iJ,aACxBU,EAAWvrI,SAASmkF,WAAW99F,MAAQ2B,KAAKuiJ,cAAcprI,QAC1DosI,EAAWvrI,SAASokF,UAAU/9F,MAAQ,IAAIe,EAAMyG,QAC5C7F,KAAKuiJ,cAAc/oG,YAAY/zC,EAC/BzF,KAAKuiJ,cAAc/oG,YAAY9zC,EAC/B1F,KAAKuiJ,cAAcnhI,KACnBphB,KAAKuiJ,cAAclmD,eAEvBknD,EAAW/3I,QAAQ8wF,KAAmC,SAA5Bt8F,KAAKuiJ,cAAc3yI,KAAkB,EAAM,EAMzE,eACI,OAAO5P,KAAK41G,WAEhB,aAAav3G,GACL2B,KAAK0iJ,iBACL1iJ,KAAK41G,WAAWnwE,UAChBzlC,KAAK0iJ,gBAAiB,GAG1B1iJ,KAAK41G,WAAav3G,EAClB,IAAK,MAAMswC,KAAS3uC,KAAKgjJ,SACrBr0G,EAAMuI,QAAQx1B,KAAKjX,SAAWzK,KAAK41G,WAO3C,yBACI,OAAO51G,KAAK6iJ,aAEhB,uBAAuBxkJ,GACf2B,KAAK4iJ,mBACL5iJ,KAAK6iJ,aAAap9G,UAClBzlC,KAAK4iJ,kBAAmB,GAG5B5iJ,KAAK6iJ,aAAexkJ,EACpB,IAAK,MAAMswC,KAAS3uC,KAAKgjJ,SACrBr0G,EAAMuI,QAAQssG,eAAe/4I,SAAWzK,KAAK6iJ,aAOrD,sBACI,OAAO7iJ,KAAKijJ,yBAEhB,oBAAoBl9H,GAChB/lB,KAAKijJ,yBAAyB3zI,KAAKyW,GAMvC,sBACI,OAAO/lB,KAAKkjJ,yBAEhB,oBAAoBn9H,GAChB/lB,KAAKkjJ,yBAAyB5zI,KAAKyW,GAMvC,QACI,IAAK,MAAM4oB,KAAS3uC,KAAKgjJ,SACrBr0G,EAAMuI,QAAQlR,QAElBhmC,KAAKijJ,yBAAyB3zI,KAAKgzI,EAAWxkC,wBAC9C99G,KAAKkjJ,yBAAyB5zI,KAAKgzI,EAAWtkC,wBAUlD,OAAOtvG,EAAkCH,EAAkCy3B,GACvEhmC,KAAKuiJ,cAAclwG,OAAOryC,KAAKmiE,YAC/B,IAAIshF,EAAuC,UAC5BzhJ,IAAXuM,IACAk1I,EAAYzjJ,KAAKmiE,WAAW+7B,kBAC5Bl+F,KAAKmiE,WAAWppC,gBAAgBxqB,KAEtB,IAAVy3B,GACAhmC,KAAKmiE,WAAWn8B,OAAM,GAE1B,IAAK,MAAM2I,KAAS3uC,KAAKgjJ,SACrBr0G,EAAMuI,QAAQ7E,SACdryC,KAAKmiE,WAAWnpC,OAAO2V,EAAMuI,QAAQve,MAAOjqB,QAEjC1M,IAAXuM,GACAvO,KAAKmiE,WAAWppC,gBAAgB0qH,GAYxC,SAASC,GACL,IAAIv9I,EAASnG,KAAKg3C,SAAS0sG,GAkB3B,YAjBe1hJ,IAAXmE,IACAA,EAAS,CACL4oB,GAAI20H,EACJxsG,QAAS,IAAI,EAAA6rG,aACT,IAAI3jJ,EAAMkiB,MACVthB,KAAK41G,WACL51G,KAAK6iJ,aACL7iJ,KAAKwiJ,cACLxiJ,KAAKyiJ,gBAIbziJ,KAAKgjJ,SAAS98I,KAAKC,GACnBnG,KAAKgjJ,SAASp6G,KAAK,CAACp/B,EAAoBE,IAC7BF,EAAEulB,GAAKrlB,EAAEqlB,KAGjB5oB,EAUX,SAASu9I,GACL,OAAO1jJ,KAAKgjJ,SAAS9qH,KAAKyW,GAASA,EAAM5f,KAAO20H,GAQpD,eACI,OAAO1jJ,KAAKgjJ,SAchB,YACIx9H,EACAm+H,EACAtmI,GAIA,IAAI6J,EACAwnB,EACAk1G,EACA9yC,EACJ,GANAqxC,EAAiBn7I,IAAI,EAAG,EAAG,QAMZhF,IAAXqb,EAAsB,CAItB,GAHA6J,EAAO7J,EAAO6J,KACdwnB,EAAerxB,EAAOqxB,aACtBoiE,EAAwBzzF,EAAOyzF,2BACX9uG,IAAhBqb,EAAO6J,KAAoB,CAC3B,MAAM28H,EAAaxmI,EAAO6J,KAAKq7B,SAAS,GACxC,GAAmB,OAAfshG,EACA,OAAO,EAEX1B,EAAiBn7I,IAAI68I,EAAWp+I,EAAGo+I,EAAWn+I,EAAG,GAEjD2X,EAAOuxB,kBACPg1G,EAAiBvmI,EAAOuxB,iBAIhC,OAAO5uC,KAAK80E,UAAU,CAClB/zE,MAAOykB,EACPmpB,MAAO3uC,KAAK8iJ,eACZ1lG,SAAUl2B,EACV48H,iBAAkBp1G,EAClByJ,OAAQwrG,EACR5tF,iBAAkB+6C,EAClBliE,gBAAiBg1G,IAezB,QACIp+H,EACAzX,EACAsP,GAIA,IAAI6J,EACAwnB,EACAk1G,EAJJzB,EAAiB7yI,KAAKvB,GAKtB,IAAIg2I,EAAc/jJ,KAAK8iJ,eACvB,QAAe9gJ,IAAXqb,EAAsB,CAGtB,GAFA6J,EAAO7J,EAAO6J,KACdwnB,EAAerxB,EAAOqxB,kBACD1sC,IAAjBqb,EAAOsxB,MAAqB,CAC5B,IAAIq1G,EAAYhkJ,KAAKg3C,SAAS35B,EAAOsxB,YACnB3sC,IAAdgiJ,IACAA,EAAYhkJ,KAAKikJ,SAAS5mI,EAAOsxB,QAErCo1G,EAAcC,OAEEhiJ,IAAhBqb,EAAO6J,MACPi7H,EAAiBn7I,IAAI,EAAG,EAAGm7I,EAAiBv8I,GAE5CyX,EAAOuxB,kBACPg1G,EAAiBvmI,EAAOuxB,iBAGhC,MAAMs1G,EAAgBH,EAAY7sG,QAAQC,UAEpChxC,EAASnG,KAAK80E,UAAU,CAC1B/zE,MAAOykB,EACP43B,SAAUl2B,EACV48H,iBAAkBp1G,EAClBC,MAAOo1G,EACPn1G,gBAAiBg1G,IAgBrB,OAdIz9I,QAAqBnE,IAAXqb,IACoB,IAA1BA,EAAO8mI,gBACPp2I,EAASuB,KAAK6yI,QAESngJ,IAAvBqb,EAAOyxB,aACPi1G,EAAY7sG,QAAQktG,eAChBF,EACAH,EAAY7sG,QAAQC,UACpB95B,EAAOyxB,cAGP3oC,IACP49I,EAAY7sG,QAAgB0Z,YAAcszF,GAExC/9I,EAaX,uBACIqf,EACAnI,GAIA,IAAIgnI,EACAT,EAHJzB,EAAiBn7I,IAAI,EAAG,EAAG,GAI3B,MAAMs9I,EACFtkJ,KAAKijJ,yBAAyBl4H,cAAgB,EAAA7C,YAAYktC,UAC9D,GAAoB,iBAAT5vC,EACP6+H,EAAa7+H,OACExjB,IAAXqb,GAAwBA,EAAOuxB,kBAC/Bg1G,EAAiBvmI,EAAOuxB,sBAS5B,GANAg1G,EAAiB,GACjBS,EAAarkJ,KAAKuiJ,cAAcnqG,UAC5B5yB,EACAxlB,KAAKijJ,yBACLqB,EAAmBV,OAAiB5hJ,QAErBA,IAAfqiJ,EACA,OAIR,IAAIn9H,EACAwnB,EACA61G,EACAznD,EACAr2E,EACAE,EA2BJ,YA1Be3kB,IAAXqb,IACA6J,EAAO7J,EAAO6J,KACdwnB,EAAerxB,EAAOqxB,cACM,IAAxBrxB,EAAOsmI,eACPY,EAAa,IAAInlJ,EAAM42D,OAEU,IAAjC34C,EAAOyzF,wBACPhU,EAAkB,KAEK,IAAvBz/E,EAAOmnI,cACP/9H,EAAczmB,KAAKijJ,yBAAyBp2I,QAC5C8Z,EAAc3mB,KAAKkjJ,yBAAyBr2I,UAIpD7M,KAAK80E,UAAU,CACX/zE,MAAOykB,EACPmpB,MAAO3uC,KAAK8iJ,eACZ2B,mBAAmB,EACnBrnG,SAAUl2B,EACV48H,iBAAkBp1G,EAClByJ,OAAQosG,EACRxuF,iBAAkB+mC,EAClBluD,gBAAiBg1G,IAGd,IAAI,EAAAc,iBACPL,EACA,IAAI7yH,aAAa6wH,GACjBkC,EACAznD,EACAr2E,EACAE,GAcR,oBACIg6B,EACAtjC,G,MAEA,IACItP,EACA+yC,EACA91B,EACAC,EACAC,EACA2nC,EACAC,EAPAixF,EAAc/jJ,KAAK8iJ,eASvB,QAAe9gJ,IAAXqb,EAAsB,CACtB,QAAqBrb,IAAjBqb,EAAOsxB,MAAqB,CAC5B,IAAIq1G,EAAYhkJ,KAAKg3C,SAAS35B,EAAOsxB,YACnB3sC,IAAdgiJ,IACAA,EAAYhkJ,KAAKikJ,SAAS5mI,EAAOsxB,QAErCo1G,EAAcC,EAElBj2I,EAA0B,QAAlB,EAAGsP,EAAOtP,gBAAQ,eAAElB,QAC5Bi0C,EAAQzjC,EAAOyjC,MACf91B,EAAW3N,EAAO2N,SAClBC,EAAQ5N,EAAO4N,MACfC,EAAU7N,EAAO6N,QACjB2nC,EAAUx1C,EAAO8N,gBACjB2nC,EAAYz1C,EAAO+N,kBAEvB,MAAM84H,EAAgBH,EAAY7sG,QAAQC,UAEpChxC,EAAS49I,EAAY7sG,QAAQ6J,oBAC/BJ,EACA5yC,EACA+yC,EACA91B,EACAC,EACAC,EACA2nC,EACAC,GAaJ,OAXI3sD,QAAqBnE,IAAXqb,OACiBrb,IAAvBqb,EAAOyxB,aACPi1G,EAAY7sG,QAAQktG,eAChBF,EACAH,EAAY7sG,QAAQC,UACpB95B,EAAOyxB,aAGP3oC,IACP49I,EAAY7sG,QAAgB0Z,YAAcszF,GAExC/9I,EAUX,SAAS4H,EAAyBq4B,GAC9B,IAAK,MAAMuI,KAAS3uC,KAAKgjJ,SACrBr0G,EAAMuI,QAAQ/jB,KAAKplB,EAAUq4B,GASrC,eAAeiuB,GACXr0D,KAAKuiJ,cAAcltC,kBAAkBhhD,GAErC,IAAK,MAAM1lB,KAAS3uC,KAAKgjJ,SACrBr0G,EAAMuI,QAAQm+D,kBAAkBhhD,GAOhC,UAAUh3C,GACd,GAA4B,IAAxBA,EAAOtc,MAAMO,QAA4D,IAA5CtB,KAAKkjJ,yBAAyBt3H,SAQ3D,YAPsB5pB,IAAlBqb,EAAO86B,SACP96B,EAAO86B,OAAOvuC,IAAI5C,IAAI,EAAG,GACzBqW,EAAO86B,OAAOruC,IAAI9C,IAAI,EAAG,SAEGhF,IAA5Bqb,EAAO04C,mBACP14C,EAAO04C,iBAAiBz0D,OAAS,IAE9B,EAGX,IAAI+iJ,EACAlvF,EACJ,MAAMmvF,EACFtkJ,KAAKijJ,yBAAyBl4H,cAAgB,EAAA7C,YAAYktC,UAC9D,GAA4B,iBAAjB/3C,EAAOtc,MACdsjJ,EAAahnI,EAAOtc,MAChBsc,EAAOuxB,kBACPumB,EAA2B93C,EAAOuxB,sBAStC,GANAumB,EAA2B,GAC3BkvF,EAAarkJ,KAAKuiJ,cAAcnqG,UAC5B/6B,EAAOtc,MACPf,KAAKijJ,yBACLqB,EAAmBnvF,OAA2BnzD,QAE/BA,IAAfqiJ,EACA,OAAO,EAIf,IAAIM,OAC4B3iJ,IAA5Bqb,EAAO04C,mBACPqsF,EAAezoI,MAAQ0D,EAAO04C,iBAC9BqsF,EAAev+H,OAAS,EACxB8gI,EAAcvC,QAEIpgJ,IAAlBqb,EAAO86B,SACP96B,EAAO86B,OAAOvuC,IAAI5C,IAAI6C,IAAUA,KAChCwT,EAAO86B,OAAOruC,IAAI9C,KAAK6C,KAAWA,OAEL,IAA7BwT,EAAOonI,oBACPpC,EAAmB,IAAI7wH,aAAa6yH,EAAW/iJ,OAAS,EAAAivD,+BAG5D,MAAMq0F,OAA6B5iJ,IAApBqb,EAAO+/B,SAChBynG,EAAuE,CACzE71G,OAAQq1G,EACRtsG,YAAa/3C,KAAKuiJ,cAClBlrG,gBAAiBr3C,KAAKijJ,yBACtB3rG,gBAAiBt3C,KAAKkjJ,yBACtBn1I,SAAUo0I,EACVjoI,SAAUmD,EAAOsxB,MAAMuI,QACvB4tG,eAAgBR,EAAmBnvF,OAA2BnzD,EAC9D8zD,aAAcz4C,EAAO86B,OACrB4d,iBAAkB4uF,EAClBI,cAA2C,IAA7B1nI,EAAOonI,kBAA6BpC,OAAmBrgJ,GAGzE,IAAImE,GAAS,EAgBb,OAfIy+I,GACA9mJ,OAAOysD,OAAOs6F,EAAgD,CAC1D39H,KAAM7J,EAAO+/B,SACb1O,cAA0C,IAA5BrxB,EAAOymI,mBAEzB39I,EAASnG,KAAKqjJ,iBAAiB2B,cAC3BH,IAGJ1+I,EAASnG,KAAKmjJ,iBAAiB6B,cAAcH,QAE7B7iJ,IAAhB2iJ,IACAA,EAAYhrI,MAAMrY,OAASqjJ,EAAY9gI,QAGpC1d,GAEf,OA9mBmB,EAAA23G,uBAA0C,IAAI,EAAAt3F,gBAC9C,EAAAw3F,uBAA0C,IAAI,EAAAt3F,gBA6mBjE,GA/mBA,GAAa,EAAA47H,c,sGC9Mb,aAEA,QACA,QACA,QACA,QAMA,uBAiBI,cACItiJ,KAAKilJ,gBAAkB,IAAI7lJ,EAAMm3I,QACjCv2I,KAAKklJ,cAAgB,CACjB,IAAI9lJ,EAAMuG,QACV,IAAIvG,EAAMuG,QACV,IAAIvG,EAAMuG,QACV,IAAIvG,EAAMuG,SAEd3F,KAAKmlJ,oBAAsB,EAAApuH,aAAaC,UAAUqB,IAClDr4B,KAAKolJ,mBAAqB,EAAAruH,aAAaC,UAAUqB,IACjDr4B,KAAKqlJ,gBAAkB,EACvBrlJ,KAAKslJ,kBAAoB,EACzBtlJ,KAAKulJ,YAAc,EACnBvlJ,KAAKwlJ,iBAAkB,EAiB3B,cAAcnoI,GAEVrd,KAAKylJ,gBAAkBpoI,EACvBrd,KAAKmlJ,oBAAsB,EAAA3wF,iBAAiB58B,aAAa53B,KAAKylJ,gBAAgBz2G,OAAQ,GACtFhvC,KAAKolJ,mBAAqBplJ,KAAKmlJ,oBAC/BnlJ,KAAKqlJ,gBAAkB,EAAA7wF,iBAAiBK,aACpC70D,KAAKylJ,gBAAgBpuG,gBAAgBxsB,SAASzJ,KAC9CphB,KAAKylJ,gBAAgBpuG,gBAAgBxsB,SAAS5B,KAC9CjpB,KAAKylJ,gBAAgB1tG,YAAY32B,MAErCphB,KAAKulJ,YAAcvlJ,KAAKqlJ,gBAAkBrlJ,KAAKylJ,gBAAgB1tG,YAAY32B,KAC3EphB,KAAKslJ,kBAAoBj8I,KAAKO,IAC1B,EAAA4qD,iBAAiBK,aACb70D,KAAKylJ,gBAAgBpuG,gBAAgBxsB,SAASzB,eAC9CppB,KAAKylJ,gBAAgBpuG,gBAAgBxsB,SAAS5B,KAC9CjpB,KAAKylJ,gBAAgB1tG,YAAY32B,MAErCphB,KAAKylJ,gBAAiB1tG,YAAYskD,cAAgBr8F,KAAKulJ,aAE3DvlJ,KAAKwlJ,qBAA2DxjJ,IAAzChC,KAAKylJ,gBAAiBX,eAE7C9kJ,KAAKylJ,gBAAgB13I,SAASrI,GAC1B1F,KAAKylJ,gBAAgBnuG,gBAAgB/rB,kBACrCvrB,KAAKylJ,gBAAgBz2G,OAAO,GAAGsgB,KAAKU,QAAQsF,UAC5Ct1D,KAAKulJ,YAET,MAAMG,OACoC1jJ,IAAtChC,KAAKylJ,gBAAgB3vF,mBACiB9zD,IAAtChC,KAAKylJ,gBAAgBV,aAGnBv/D,EAASxlF,KAAKylJ,gBAAgB13I,SAAStI,EACvCwqD,EACFjwD,KAAKylJ,gBAAgBz2G,OAAO,GAAGsgB,KAAKU,QAAQC,WAC5CjwD,KAAKylJ,gBAAgBnuG,gBAAgB3rB,QAGzC,IAAIg6H,EAAe,EACfC,EAAe,EACfC,EAAc,EACdC,EAAa,EACbC,EAAY,EACZC,EAAa,EACbC,EAAY,EAEZC,EAAY,EACZC,GAAsB,EAC1B,IAAK,IAAI/oJ,EAAI,EAAGA,EAAI4C,KAAKylJ,gBAAgBz2G,OAAO1tC,UACxC4kJ,EAAYlmJ,KAAKylJ,gBAAgBnuG,gBAAgB1rB,SAAW,KADVxuB,EAAG,CAIzD,MAAM40D,EAAYhyD,KAAKylJ,gBAAgBz2G,OAAO5xC,GAC9C,IAAK40D,EAAUrC,YAAc+1F,EACzB,OAAO,EAGX,MAAMpuH,EAAY,EAAAP,aAAaO,UAAU06B,EAAU76B,WAC7CD,EAAe,EAAAH,aAAaG,aAAa86B,EAAU76B,WA6BzD,GA1BKgvH,GAAuBn0F,EAAUjC,aAAe/vD,KAAKmlJ,sBACtDgB,GAAsB,GAGtB,EAAApvH,aAAaS,YAAYw6B,EAAU76B,aACnC4uH,IACK/zF,EAAU/C,SAAWjvD,KAAKylJ,gBAAgBnuG,gBAAgB5rB,UAC3D1rB,KAAKulJ,aACJvlJ,KAAKwlJ,gBACA,EAAAhxF,iBAAiBU,kBACbl1D,KAAKylJ,gBAAgBz2G,OACrBhvC,KAAKylJ,gBAAgBX,eACrB1nJ,EACA4C,KAAKylJ,gBAAgBpuG,gBAAgBtsB,aAEzC,IAIV3tB,IAAMuoJ,IACNG,EAAaC,EACbC,EAAaD,EACbE,EAAYF,GAKZzuH,GACCt3B,KAAKylJ,gBAAgBnuG,gBAAgBtrB,eAAiB,EAAA3D,aAAagmH,WAChE0X,EAAY/lJ,KAAKylJ,gBAAgBnuG,gBAAgBzrB,WACpD7rB,KAAKylJ,gBAAgBnuG,gBAAgBtrB,eAAiB,EAAA3D,aAAagC,MAChE07H,EAAY/lJ,KAAKylJ,gBAAgBnuG,gBAAgBzrB,WACjDo6H,IAAcH,EACpB,CAEE,GAAI9lJ,KAAKylJ,gBAAgBnuG,gBAAgBtrB,eAAiB,EAAA3D,aAAa4sE,KAAM,CACzE,IAAImxD,EAAeR,EACfS,EAAaL,EAGbhmJ,KAAKylJ,gBAAgBnuG,gBAAgBtrB,eAAiB,EAAA3D,aAAagC,MACnE47H,IAAcH,IAEdM,EAAeP,EACfQ,EAAaJ,GAGjBF,EAAYM,EACZjpJ,EAAIiM,KAAKO,IACL0tB,EAAaquH,IAAiBvoJ,EAAIgpJ,EAAehpJ,EAAKgpJ,EACtDpmJ,KAAKylJ,gBAAgBz2G,OAAO1tC,OAAS,GAM7C,MAAMglJ,EACFtmJ,KAAKmlJ,sBAAwB,EAAApuH,aAAaC,UAAUoB,KAAO+tH,EACrD,EAAMnmJ,KAAKylJ,gBAAgBnuG,gBAAgBhsB,oBAC3CtrB,KAAKylJ,gBAAgBnuG,gBAAgBhsB,oBAG/C,GAFAtrB,KAAKylJ,gBAAgB13I,SAAStI,EAC1BzF,KAAKylJ,gBAAgB13I,SAAStI,EAAIsgJ,EAAYO,GAE7CtmJ,KAAKumJ,UAAUZ,EAAcvoJ,EAAG4C,KAAKmlJ,oBAAqBgB,GAE3D,OAAO,EAQX,IAJAnmJ,KAAKylJ,gBAAgB13I,SAASrI,GAAKuqD,EAAajwD,KAAKulJ,YACrDvlJ,KAAKylJ,gBAAgB13I,SAAStI,EAAI+/E,EAI9BpoF,IAAMuoJ,GACNvoJ,EAAI,EAAI4C,KAAKylJ,gBAAgBz2G,OAAO1tC,QACpC,EAAAy1B,aAAaG,aAAal3B,KAAKylJ,gBAAgBz2G,OAAO5xC,EAAI,GAAG+5B,cAE3D/5B,EAGN,GADAuoJ,EAAevoJ,EAAI,EACfuoJ,IAAiB3lJ,KAAKylJ,gBAAgBz2G,OAAO1tC,OAC7C,MAMAg2B,IACAt3B,KAAKmlJ,oBAAsB,EAAA3wF,iBAAiB58B,aACxC53B,KAAKylJ,gBAAgBz2G,OACrB22G,GAEJ3lJ,KAAKolJ,mBAAqBplJ,KAAKmlJ,qBAInCW,EAAa,EACbC,EAAY,EACZH,EAAeD,EACfK,EAAa,EACbH,EAAcF,EACdM,EAAY,EACZE,GAAsB,EACtBD,SAIAlmJ,KAAKylJ,gBAAgBnuG,gBAAgBtrB,eAAiB,EAAA3D,aAAa4sE,MAClE/9D,IAGD0uH,EAAexoJ,EACf4oJ,EAAaD,EAKT/lJ,KAAKylJ,gBAAgBnuG,gBAAgBtrB,eAAiB,EAAA3D,aAAagC,MACnEjtB,EAAI,EAAI4C,KAAKylJ,gBAAgBz2G,OAAO1tC,SACnC,EAAAy1B,aAAaG,aAAal3B,KAAKylJ,gBAAgBz2G,OAAO5xC,EAAI,GAAG+5B,YAC1D,EAAAJ,aAAaO,UAAUt3B,KAAKylJ,gBAAgBz2G,OAAO5xC,EAAI,GAAG+5B,cAE9D0uH,EAAczoJ,EACd6oJ,EAAYF,IAMxB,GACIG,GAAalmJ,KAAKylJ,gBAAgBnuG,gBAAgB1rB,SAAW,GAC7D+5H,GAAgB3lJ,KAAKylJ,gBAAgBz2G,OAAO1tC,OAAS,EACvD,CACE,MAAMuiB,EACF7jB,KAAKmlJ,sBAAwB,EAAApuH,aAAaC,UAAUoB,KAAO+tH,EACrD,EAAMnmJ,KAAKylJ,gBAAgBnuG,gBAAgBhsB,oBAC3CtrB,KAAKylJ,gBAAgBnuG,gBAAgBhsB,oBAI/C,GAHAtrB,KAAKylJ,gBAAgB13I,SAAS4kD,KAC1B3yD,KAAKylJ,gBAAgB13I,SAAStI,EAAIsgJ,EAAYliI,IAG7C7jB,KAAKumJ,UACFZ,EACA3lJ,KAAKylJ,gBAAgBz2G,OAAO1tC,OAAS,EACrCtB,KAAKmlJ,oBACLgB,GAGJ,OAAO,EAIf,OAAO,EAKH,UACJpyF,EACAC,EACAjE,EACAy2F,GAGA,IAAKA,EACD,OAAOxmJ,KAAKymJ,SAAS1yF,EAAUC,EAAQjE,GAI3C,MAAM22F,EAAiB1mJ,KAAKylJ,gBAAiBz2G,OACvC81G,EAAiB9kJ,KAAKylJ,gBAAiBX,eACvCztG,EAAkBr3C,KAAKylJ,gBAAiBpuG,gBACxCC,EAAkBt3C,KAAKylJ,gBAAiBnuG,gBACxCvpC,EAAW/N,KAAKylJ,gBAAiB13I,SAGjC44I,EAAQ52F,IAAc,EAAAh5B,aAAaC,UAAUoB,IAC7CotD,EAASz3E,EAAStI,EACxB,IAAIoe,EAAS,EACT+iI,EAAW7yF,EAEf,IAAK,IAAI32D,EAAI22D,EAAU32D,GAAK42D,IAAU52D,EAAG,CACrC,MAAM40D,EAAY00F,EAAetpJ,GAGjC,GAAI40D,EAAUjC,aAAe/vD,KAAKolJ,mBAAoB,CAIlD,GAHIuB,IACA54I,EAAStI,EAAI+/E,EAAS3hE,IAErB7jB,KAAKymJ,SAASG,EAAUxpJ,EAAI,EAAG4C,KAAKolJ,oBACrC,OAAO,EAENuB,IACD54I,EAAStI,EAAI+/E,EAAS3hE,GAG1B+iI,EAAWxpJ,EACX4C,KAAKolJ,qBAAuB,OAK3B,GACDpzF,EAAUjC,YAAc,EAAAh5B,aAAaC,UAAUiB,SAC/Cj4B,KAAKolJ,sBAAwBr1F,EAC/B,CACE,IAAI82F,EAAazpJ,EACjB,KACIypJ,EAAa,EAAIH,EAAeplJ,QACmB,IAAnD+H,KAAK2S,IAAI0qI,EAAeG,GAAY92F,cAElC82F,EAKN,GAAIH,EAAeG,GAAY92F,YAAc/vD,KAAKolJ,mBAAoB,CAIlE,GAHIuB,IACA54I,EAAStI,EAAI+/E,EAAS3hE,IAErB7jB,KAAKymJ,SAASG,EAAUxpJ,EAAI,EAAG4C,KAAKolJ,oBACrC,OAAO,EAENuB,IACD54I,EAAStI,EAAI+/E,EAAS3hE,GAG1B+iI,EAAWxpJ,EACX4C,KAAKolJ,qBAAuB,GAKpCvhI,IACKmuC,EAAU/C,SAAW3X,EAAgB5rB,UACtC1rB,KAAKulJ,aACJvlJ,KAAKwlJ,gBACA,EAAAhxF,iBAAiBU,kBACbwxF,EACA5B,EACA1nJ,EACAi6C,EAAgBtsB,aAEpB,GACNglC,EAIR,GAAI62F,GAAY5yF,EAAQ,CAIpB,GAHI2yF,IACA54I,EAAStI,EAAI+/E,EAAS3hE,IAErB7jB,KAAKymJ,SAASG,EAAU5yF,EAAQh0D,KAAKolJ,oBACtC,OAAO,EAENuB,IACD54I,EAAStI,EAAI+/E,EAAS3hE,GAI9B,OAAO,EAIH,SAASkwC,EAAkBC,EAAgBjE,GAE/C,MAAM22F,EAAiB1mJ,KAAKylJ,gBAAiBz2G,OACvC81G,EAAiB9kJ,KAAKylJ,gBAAiBX,eACvC/sG,EAAc/3C,KAAKylJ,gBAAiB1tG,YACpCV,EAAkBr3C,KAAKylJ,gBAAiBpuG,gBACxCC,EAAkBt3C,KAAKylJ,gBAAiBnuG,gBACxCvpC,EAAW/N,KAAKylJ,gBAAiB13I,SACjCmM,EAAWla,KAAKylJ,gBAAiBvrI,SACjC47C,EAAe91D,KAAKylJ,gBAAiB3vF,aACrCC,EAAmB/1D,KAAKylJ,gBAAiB1vF,iBACzCgvF,EAAe/kJ,KAAKylJ,gBAAiBV,aAIrCh7G,EAAQgmB,IAAc,EAAAh5B,aAAaC,UAAUqB,IAAM07B,EAAWC,EAC9Dpf,EAAMmb,IAAc,EAAAh5B,aAAaC,UAAUqB,IAAM27B,EAASD,EAChE,IACI,IAAI32D,EAAI2sC,EACRgmB,IAAc,EAAAh5B,aAAaC,UAAUoB,IAAMh7B,GAAKw3C,EAAMx3C,GAAKw3C,EAC3Dx3C,GAAK2yD,EACP,CAEE,MAAMiC,EAAY00F,EAAetpJ,GACjC,IAAK,EAAA25B,aAAaS,YAAYw6B,EAAU76B,WACpC,SAMJ,GACI48B,IAAaC,GACP,IAAN52D,GACA2yD,IAAc,EAAAh5B,aAAaC,UAAUoB,KACrC45B,EAAUjC,YAAc,EAAAh5B,aAAaC,UAAUe,KACjD,CACE,IAAI+uH,EAAe1pJ,EACf2pJ,EAAYL,EAAeI,EAAe,GAC9C,KACIA,IAAiB/yF,IAChBgzF,EAAUh3F,YAAc,EAAAh5B,aAAaC,UAAUe,MAC3CgvH,EAAUh3F,YAAc,EAAAh5B,aAAaC,UAAUiB,UAC3C,EAAAlB,aAAaG,aAAa6vH,EAAU5vH,eAE3C2vH,EACFC,EAAYL,EAAeI,EAAe,GAG9C9mJ,KAAKymJ,SAASp9I,KAAKS,IAAIg9I,EAAc/yF,GAAW32D,EAAG,EAAA25B,aAAaC,UAAUqB,KAE1Ej7B,EAAI0pJ,EACJ,SAIJ,MAAME,EAAYh1F,EAAU1C,KACtB23F,EAAmBD,EAAUh3F,QAC7BllC,EAAYusB,EAAgBvsB,UAE5Bo8H,EACDp8H,IAAc,EAAA7C,UAAUq1H,WAA2Bt7I,IAAnBglJ,EAAUzJ,MAC1CzyH,IAAc,EAAA7C,UAAUy1H,iBACF17I,IAAnBglJ,EAAUzJ,WACev7I,IAAzBglJ,EAAUrJ,WACZwJ,EACDr8H,IAAc,EAAA7C,UAAUu1H,aAA+Bx7I,IAArBglJ,EAAUvJ,QAC5C3yH,IAAc,EAAA7C,UAAUy1H,iBACA17I,IAArBglJ,EAAUvJ,aACez7I,IAAzBglJ,EAAUrJ,WAEZyJ,IAAcpnJ,KAAKwlJ,kBACnBV,EAAgB1nJ,IAAMi6C,EAAgBtsB,cAAgB,EAAA7C,YAAYktC,WAElEiyF,EAAiBD,EACjBH,EAAiB5xF,QAAU4xF,EAAiB3xF,UAC5C,EACAgyF,EAAatnJ,KAAKulJ,YAAc8B,EAEhCE,IACAL,EAAiB,IAAO,IAAQE,EAAc,IAAO,KACtDrvG,EAAY32B,KAAO22B,EAAYskD,eAC9BlqC,EACD,GAAMnyD,KAAKslJ,mBACXvtG,EAAYskD,cAAgBhzF,KAAKS,IAAIw9I,EAAY,IAChDE,EACF,EAAAzwH,aAAawB,cAAcy5B,EAAU76B,YACrC44B,IAAc,EAAAh5B,aAAaC,UAAUoB,IACnCqvH,EACFR,EAAiBh3F,WACjBg3F,EAAiBjd,KACgB,GAAjCid,EAAiB5qD,cAGrB,EAAA7nC,iBAAiBe,sBACbv1D,KAAKilJ,gBACLl3I,EACAu5I,EACAhwG,EAAgBxrB,eAChBurB,EAAgBrsB,UAEpB,IAAK,IAAIg3B,EAAI,EAAGA,EAAI,IAAKA,EAAG,CACxB,MAAM0lG,EAAsB11F,EAAUzC,UAAUvN,GAC1C2lG,EACFR,GAAoBnlG,EAAI,EAClB,EAAAwS,iBAAiBI,eAAiBqyF,EAAiB7lI,KACnD,EACVphB,KAAKklJ,cAAcljG,GAAGh7C,IAClB0gJ,EAAoBjiJ,EAAIkiJ,EACxBD,EAAoBhiJ,EAAI+hJ,EACxBC,EAAoB9hJ,GAExB5F,KAAKklJ,cAAcljG,GAAGu+F,aAAavgJ,KAAKilJ,iBAK5C,QAAqBjjJ,IAAjB8zD,QAA+C9zD,IAAjB+iJ,GAC9B,IACK7qI,EAAS/Z,IACN6xD,EACAhyD,KAAKklJ,cACLqC,EACAA,EAAkBp1F,EAClBq1F,EACAnwG,GAGJ,OAAO,YAGUr1C,IAAjB8zD,GACA,EAAAtB,iBAAiBqB,aACb71D,KAAKklJ,cACLpvF,EACAC,QAGa/zD,IAAjB+iJ,GACA7qI,EAAS0tI,YACL7C,EACA3nJ,EAAI,EAAAmzD,6BACJyB,EACAhyD,KAAKklJ,cACLqC,EACAA,EAAkBp1F,EAClBq1F,EACAnwG,GAMZtpC,EAAS/G,IACL+G,EAAStI,GACJusD,EAAU/C,SAAW3X,EAAgB5rB,UAClC47H,EACAj+I,KAAKkH,IAAI+mC,EAAgBvrB,cACjChe,EAASrI,GACJssD,EAAU/C,SAAW3X,EAAgB5rB,UAClC47H,EACAj+I,KAAKsH,IAAI2mC,EAAgBvrB,cACjChe,EAASnI,GAIjB,OAAO,K,sGCriBf,aAEA,QACA,QACA,QACA,QAsBA,uBAqBI,cACI5F,KAAKilJ,gBAAkB,IAAI7lJ,EAAMm3I,QACjCv2I,KAAKklJ,cAAgB,CACjB,IAAI9lJ,EAAMuG,QACV,IAAIvG,EAAMuG,QACV,IAAIvG,EAAMuG,QACV,IAAIvG,EAAMuG,SAEd3F,KAAKmlJ,oBAAsB,EAAApuH,aAAaC,UAAUqB,IAClDr4B,KAAKolJ,mBAAqB,EAAAruH,aAAaC,UAAUqB,IACjDr4B,KAAKqlJ,gBAAkB,EACvBrlJ,KAAKslJ,kBAAoB,EACzBtlJ,KAAKulJ,YAAc,EACnBvlJ,KAAKwlJ,iBAAkB,EAEvBxlJ,KAAK6nJ,mBAAqB,IAAIzoJ,EAAMuG,QACpC3F,KAAK8nJ,iBAAmB,EACxB9nJ,KAAK+nJ,iBAAmB,EAa5B,cAAc1qI,GAEVrd,KAAKylJ,gBAAkBpoI,EACvBrd,KAAKmlJ,oBAAsB,EAAA3wF,iBAAiB58B,aAAa53B,KAAKylJ,gBAAgBz2G,OAAQ,GACtFhvC,KAAKolJ,mBAAqBplJ,KAAKmlJ,oBAC/BnlJ,KAAKqlJ,gBAAkB,EAAA7wF,iBAAiBK,aACpC70D,KAAKylJ,gBAAgBpuG,gBAAgBxsB,SAASzJ,KAC9CphB,KAAKylJ,gBAAgBpuG,gBAAgBxsB,SAAS5B,KAC9CjpB,KAAKylJ,gBAAgB1tG,YAAY32B,MAErCphB,KAAKulJ,YAAcvlJ,KAAKqlJ,gBAAkBrlJ,KAAKylJ,gBAAgB1tG,YAAY32B,KAC3EphB,KAAKslJ,kBAAoBj8I,KAAKO,IAC1B,EAAA4qD,iBAAiBK,aACb70D,KAAKylJ,gBAAgBpuG,gBAAgBxsB,SAASzB,eAC9CppB,KAAKylJ,gBAAgBpuG,gBAAgBxsB,SAAS5B,KAC9CjpB,KAAKylJ,gBAAgB1tG,YAAY32B,MAErCphB,KAAKylJ,gBAAiB1tG,YAAYskD,cAAgBr8F,KAAKulJ,aAE3DvlJ,KAAKwlJ,qBAA2DxjJ,IAAzChC,KAAKylJ,gBAAiBX,eAE7C9kJ,KAAK8nJ,iBAAmB9nJ,KAAKylJ,gBAAgBv+H,KAAK8gI,YAClDhoJ,KAAK+nJ,iBAAmB,EAExB,MAAMrC,OACoC1jJ,IAAtChC,KAAKylJ,gBAAgB3vF,mBACiB9zD,IAAtChC,KAAKylJ,gBAAgBV,aAKzB,IAAIyB,GAAkB,EAClByB,EAAY,EAChB,IAAK,IAAI7qJ,EAAI,EAAGA,EAAI4C,KAAKylJ,gBAAgBz2G,OAAO1tC,SAAUlE,EAAG,CACzD,MAAM40D,EAAYhyD,KAAKylJ,gBAAgBz2G,OAAO5xC,GAC9C,IAAK40D,EAAUrC,YAAc+1F,EACzB,OAAO,EAGN,EAAA3uH,aAAaS,YAAYw6B,EAAU76B,aAGnCqvH,GAAmBx0F,EAAUjC,aAAe/vD,KAAKmlJ,sBAClDqB,GAAkB,GAGtByB,IACKj2F,EAAU/C,SAAWjvD,KAAKylJ,gBAAgBnuG,gBAAgB5rB,UAC3D1rB,KAAKulJ,aACJvlJ,KAAKwlJ,gBACA,EAAAhxF,iBAAiBU,kBACbl1D,KAAKylJ,gBAAgBz2G,OACrBhvC,KAAKylJ,gBAAgBX,eACrB1nJ,EACA4C,KAAKylJ,gBAAgBpuG,gBAAgBtsB,aAEzC,IAad,OAXA/qB,KAAK+nJ,iBAAmB1+I,KAAKO,IACzBP,KAAKS,KACA9J,KAAKylJ,gBAAgBnuG,gBAAgBhsB,oBACjCtrB,KAAKylJ,gBAAgBnuG,gBAAgBhsB,oBAAsB28H,EACxDjoJ,KAAK8nJ,iBACb,GAEJ,GAIG9nJ,KAAKumJ,UAAUvmJ,KAAKmlJ,oBAAqBqB,GAK5C,UAAUz2F,EAAmCy2F,GAEjD,IAAKA,EACD,OAAOxmJ,KAAKymJ,SAAS,EAAGzmJ,KAAKylJ,gBAAiBz2G,OAAO1tC,OAAS,EAAGyuD,GAIrE,MAAM22F,EAAiB1mJ,KAAKylJ,gBAAiBz2G,OAG7C,IAAI43G,EAAW,EACf,IAAK,IAAIxpJ,EAAIwpJ,EAAUxpJ,EAAIspJ,EAAeplJ,SAAUlE,EAAG,CACnD,MAAM40D,EAAY00F,EAAetpJ,GAGjC,GAAI40D,EAAUjC,aAAe/vD,KAAKolJ,mBAAoB,CAClD,IAAKplJ,KAAKymJ,SAASG,EAAUxpJ,EAAI,EAAG4C,KAAKolJ,oBACrC,OAAO,EAGXwB,EAAWxpJ,EACX4C,KAAKolJ,qBAAuB,OAK3B,GACDpzF,EAAUjC,YAAc,EAAAh5B,aAAaC,UAAUiB,SAC/Cj4B,KAAKolJ,sBAAwBr1F,EAC/B,CACE,IAAI82F,EAAazpJ,EACjB,KACIypJ,EAAa,EAAIH,EAAeplJ,QACmB,IAAnD+H,KAAK2S,IAAI0qI,EAAeG,GAAY92F,cAElC82F,EAKN,GAAIH,EAAeG,GAAY92F,YAAc/vD,KAAKolJ,mBAAoB,CAClE,IAAKplJ,KAAKymJ,SAASG,EAAUxpJ,EAAI,EAAG4C,KAAKolJ,oBACrC,OAAO,EAGXwB,EAAWxpJ,EACX4C,KAAKolJ,qBAAuB,IAMxC,QAAIwB,EAAWF,EAAeplJ,SACrBtB,KAAKymJ,SAASG,EAAUF,EAAeplJ,OAAS,EAAGtB,KAAKolJ,qBAS7D,SAASrxF,EAAkBC,EAAgBjE,GAE/C,MAAM22F,EAAiB1mJ,KAAKylJ,gBAAiBz2G,OACvC81G,EAAiB9kJ,KAAKylJ,gBAAiBX,eACvC/sG,EAAc/3C,KAAKylJ,gBAAiB1tG,YACpCV,EAAkBr3C,KAAKylJ,gBAAiBpuG,gBACxCC,EAAkBt3C,KAAKylJ,gBAAiBnuG,gBACxCvpC,EAAW/N,KAAKylJ,gBAAiB13I,SACjCmM,EAAWla,KAAKylJ,gBAAiBvrI,SACjC47C,EAAe91D,KAAKylJ,gBAAiB3vF,aACrCC,EAAmB/1D,KAAKylJ,gBAAiB1vF,iBACzCgvF,EAAe/kJ,KAAKylJ,gBAAiBV,aACrC79H,EAAOlnB,KAAKylJ,gBAAiBv+H,KAE7BghI,EAAuB7wG,EAAgBrsB,SACvCm9H,EACF7wG,EAAgB/rB,kBAChBm7H,EAAe,GAAGp3F,KAAKU,QAAQsF,UAC/Bt1D,KAAKulJ,YAIHx7G,EAAQgmB,IAAc,EAAAh5B,aAAaC,UAAUqB,IAAM07B,EAAWC,EAC9Dpf,EAAMmb,IAAc,EAAAh5B,aAAaC,UAAUqB,IAAM27B,EAASD,EAChE,IACI,IAAI32D,EAAI2sC,EACRgmB,IAAc,EAAAh5B,aAAaC,UAAUoB,IAAMh7B,GAAKw3C,EAAMx3C,GAAKw3C,EAC3Dx3C,GAAK2yD,EACP,CAEE,MAAMiC,EAAY00F,EAAetpJ,GACjC,IAAK,EAAA25B,aAAaS,YAAYw6B,EAAU76B,WACpC,SAMJ,GACI48B,IAAaC,GACP,IAAN52D,GACA2yD,IAAc,EAAAh5B,aAAaC,UAAUoB,KACrC45B,EAAUjC,YAAc,EAAAh5B,aAAaC,UAAUe,KACjD,CACE,IAAI+uH,EAAe1pJ,EACf2pJ,EAAYL,EAAeI,EAAe,GAC9C,KACIA,IAAiB/yF,IAChBgzF,EAAUh3F,YAAc,EAAAh5B,aAAaC,UAAUe,MAC3CgvH,EAAUh3F,YAAc,EAAAh5B,aAAaC,UAAUiB,UAC3C,EAAAlB,aAAaG,aAAa6vH,EAAU5vH,eAE3C2vH,EACFC,EAAYL,EAAeI,EAAe,GAG9C9mJ,KAAKymJ,SAASp9I,KAAKS,IAAIg9I,EAAc/yF,GAAW32D,EAAG,EAAA25B,aAAaC,UAAUqB,KAE1Ej7B,EAAI0pJ,EACJ,SAIJ,MAAME,EAAYh1F,EAAU1C,KACtB23F,EAAmBD,EAAUh3F,QAC7BllC,EAAYusB,EAAgBvsB,UAE5Bo8H,EACDp8H,IAAc,EAAA7C,UAAUq1H,WAA2Bt7I,IAAnBglJ,EAAUzJ,MAC1CzyH,IAAc,EAAA7C,UAAUy1H,iBACF17I,IAAnBglJ,EAAUzJ,WACev7I,IAAzBglJ,EAAUrJ,WACZwJ,EACDr8H,IAAc,EAAA7C,UAAUu1H,aAA+Bx7I,IAArBglJ,EAAUvJ,QAC5C3yH,IAAc,EAAA7C,UAAUy1H,iBACA17I,IAArBglJ,EAAUvJ,aACez7I,IAAzBglJ,EAAUrJ,WAEZyJ,IAAcpnJ,KAAKwlJ,kBACnBV,EAAgB1nJ,IAAMi6C,EAAgBtsB,cAAgB,EAAA7C,YAAYktC,WAElEiyF,EAAiBD,EACjBH,EAAiB5xF,QAAU4xF,EAAiB3xF,UAC5C,EACAgyF,EAAatnJ,KAAKulJ,YAAc8B,EAEhCE,IACAL,EAAiB,IAAO,IAAQE,EAAc,IAAO,KACtDrvG,EAAY32B,KAAO22B,EAAYskD,eAC9BlqC,EACD,GAAMnyD,KAAKslJ,mBACXvtG,EAAYskD,cAAgBhzF,KAAKS,IAAIw9I,EAAY,IAChDE,EACF,EAAAzwH,aAAawB,cAAcy5B,EAAU76B,YACrC44B,IAAc,EAAAh5B,aAAaC,UAAUoB,IAEnCqvH,EACFR,EAAiBh3F,WACjBg3F,EAAiBjd,KACgB,GAAjCid,EAAiB5qD,cAGf+rD,EAAYlhI,EAAKq7B,SAASviD,KAAK+nJ,kBACrC,GAAkB,OAAdK,EACA,OAAOpoJ,KAAKylJ,gBAAiB/2G,aAEjC,MAAM25G,EAAUnhI,EAAKohI,WAAWtoJ,KAAK+nJ,kBAC/BxyI,EAAS,IAAInW,EAAMoG,SAAS6iJ,EAAQ3iJ,EAAG2iJ,EAAQ5iJ,GAAGmO,eACpDu0I,GAEE3yB,EAAQnsH,KAAKmN,MAAM6xI,EAAQ3iJ,EAAG2iJ,EAAQ5iJ,GAC5CzF,KAAK6nJ,mBAAmB7gJ,IAAIuO,EAAO9P,EAAI2iJ,EAAU3iJ,EAAG8P,EAAO7P,EAAI0iJ,EAAU1iJ,EAAGqI,EAASnI,GACrFyxC,EAAgBrsB,SAAWk9H,EAAuB1yB,EAGlD,EAAAhhE,iBAAiBe,sBACbv1D,KAAKilJ,gBACLjlJ,KAAK6nJ,mBACLP,EACA,EACAjwG,EAAgBrsB,UAEpB,IAAK,IAAIg3B,EAAI,EAAGA,EAAI,IAAKA,EAAG,CACxB,MAAM0lG,EAAsB11F,EAAUzC,UAAUvN,GAC1C2lG,EACFR,GAAoBnlG,EAAI,EAClB,EAAAwS,iBAAiBI,eAAiBqyF,EAAiB7lI,KACnD,EACVphB,KAAKklJ,cAAcljG,GAAGh7C,IAClB0gJ,EAAoBjiJ,EAAIkiJ,EACxBD,EAAoBhiJ,EAAI+hJ,EACxBC,EAAoB9hJ,GAExB5F,KAAKklJ,cAAcljG,GAAGu+F,aAAavgJ,KAAKilJ,iBAExCjlJ,KAAKklJ,cAAcljG,GAAGv8C,GAAKsI,EAAStI,EACpCzF,KAAKklJ,cAAcljG,GAAGt8C,GAAKqI,EAASrI,EAKxC,QAAqB1D,IAAjB8zD,QAA+C9zD,IAAjB+iJ,GAC9B,IACK7qI,EAAS/Z,IACN6xD,EACAhyD,KAAKklJ,cACLqC,EACAA,EAAkBp1F,EAClBq1F,EACAnwG,GAGJ,OAAO,YAGUr1C,IAAjB8zD,GACA,EAAAtB,iBAAiBqB,aACb71D,KAAKklJ,cACLpvF,EACAC,QAGa/zD,IAAjB+iJ,GACA7qI,EAAS0tI,YACL7C,EACA3nJ,EAAI,EAAAmzD,6BACJyB,EACAhyD,KAAKklJ,cACLqC,EACAA,EAAkBp1F,EAClBq1F,EACAnwG,GAMZA,EAAgBrsB,SAAWk9H,EAG3BloJ,KAAK+nJ,mBACC/1F,EAAU/C,SAAW3X,EAAgB5rB,UAAY47H,EACnDtnJ,KAAK8nJ,iBAGb,OAAO,K,6BC/Yf,IAAKS,EAMAC,E,oFANL,SAAKD,GACD,yBACA,uBACA,qBAHJ,CAAKA,MAAc,KAMnB,SAAKC,GACD,2BACA,6BAFJ,CAAKA,MAAY,KASjB,MAAapsE,EAgBT,cAPQ,KAAAqsE,sBAAwE,IAAItmJ,IAC5E,KAAAumJ,wBAGJ,IAAIvmJ,IAKJnC,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,MAAChF,OAAWA,OAAWA,IAC9DhC,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,MAAChF,OAAWA,EAAW,QAC9DhC,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,MAAChF,OAAWA,EAAW,QAC9DhC,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,MAAChF,OAAWA,EAAW,QAC9DhC,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,MAAChF,OAAWA,EAAW,QAC9DhC,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,CAAC,MAAQ,MAAQ,QACxDhH,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,MAAChF,OAAWA,EAAW,QAC9DhC,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,CAAC,MAAQ,MAAQ,QACxDhH,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,MAAChF,OAAWA,EAAW,QAC9DhC,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,CAAC,MAAQ,MAAQ,QACxDhH,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,CAAC,MAAQ,MAAQ,QACxDhH,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,CAAC,MAAQ,MAAQ,QACxDhH,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,CAAC,MAAQ,MAAQ,QACxDhH,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,CAAC,MAAQ,MAAQ,QACxDhH,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,MAAChF,OAAWA,EAAW,QAC9DhC,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,MAAChF,OAAWA,EAAW,QAC9DhC,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,MAAChF,OAAWA,EAAW,QAC9DhC,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,MAAChF,OAAWA,EAAW,QAC9DhC,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,CAAC,MAAQ,MAAQ,QACxDhH,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,CAAC,MAAQ,MAAQ,QACxDhH,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,CAAC,MAAQ,MAAQ,QACxDhH,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,CAAC,MAAQ,MAAQ,QACxDhH,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,CAAC,MAAQ,MAAQ,QACxDhH,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,CAAC,MAAQ,MAAQ,QACxDhH,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,CAAC,MAAQ,MAAQ,QACxDhH,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,CAAC,MAAQ,MAAQ,QACxDhH,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,CAAC,KAAQ,KAAQ,OACxDhH,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,CAAC,MAAQ,MAAQ,QACxDhH,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,CAAC,MAAQ,MAAQ,QACxDhH,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,CAAC,MAAQ,MAAQ,QACxDhH,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,CAAC,MAAQ,MAAQ,QACxDhH,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,CAAC,MAAQ,MAAQ,QACxDhH,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,CAAC,MAAQ,MAAQ,QACxDhH,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,CAAC,MAAQ,MAAQ,QACxDhH,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,MAAChF,OAAWA,EAAW,QAC9DhC,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,MAAChF,OAAWA,EAAW,QAC9DhC,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,CAAC,MAAQ,MAAQ,QACxDhH,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,CAAC,MAAQ,MAAQ,QACxDhH,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,CAAC,MAAQ,MAAQ,QACxDhH,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,CAAC,MAAQ,MAAQ,QACxDhH,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,CAAC,MAAQ,MAAQ,QACxDhH,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,CAAC,MAAQ,MAAQ,QACxDhH,KAAKyoJ,sBAAsBzhJ,IAAI,KAAQ,MAAChF,OAAWA,EAAW,QAG9DhC,KAAK0oJ,wBAAwB1hJ,IAAI,KAAQ,IAAI7E,KAE7CnC,KAAK0oJ,wBAAwBzqJ,IAAI,MAAS+I,IAAI,KAAQ,CAAC,MAAQ,QAE/DhH,KAAK0oJ,wBAAwBzqJ,IAAI,MAAS+I,IAAI,KAAQ,CAAC,MAAQ,QAE/DhH,KAAK0oJ,wBAAwBzqJ,IAAI,MAAS+I,IAAI,KAAQ,CAAC,MAAQ,QAE/DhH,KAAK0oJ,wBAAwBzqJ,IAAI,MAAS+I,IAAI,KAAQ,CAAC,MAAQ,QAG/DhH,KAAK2oJ,oBAAsB,CACvB,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,MA/GR,sBAII,YAHwB3mJ,IAApBhC,KAAKurC,aACLvrC,KAAKurC,WAAa,IAAI6wC,GAEnBp8E,KAAKurC,WAoHhB,QAAQxqC,GACJ,IAAI6nJ,EAAS,GACb,IAAK,IAAIxrJ,EAAI,EAAGA,EAAI2D,EAAMO,SAAUlE,EAAG,CACnC,MAAMyrJ,EAAmB9nJ,EAAM+nJ,WAAW1rJ,GAG1C,GAAI4C,KAAK+oJ,kBAAkBF,GAAmB,CAE1C,IAAIG,EAAY5rJ,EAAI,EACpB,KAAO4rJ,GAAa,GACXhpJ,KAAKipJ,UAAUloJ,EAAM+nJ,WAAWE,MADhBA,GAOzB,IAAIE,EAAgBF,GAAa,EAAIjoJ,EAAM+nJ,WAAWE,QAAahnJ,EACnE,QAAsBA,IAAlBknJ,EAA6B,CAC7B,MAAMC,EAAUnpJ,KAAKopJ,gBAAgBF,SAErBlnJ,IAAZmnJ,QACqCnnJ,IAApCmnJ,EAAQZ,EAAec,eACernJ,IAAnCmnJ,EAAQZ,EAAee,WAE3BJ,OAAgBlnJ,GAKxB,IAAIunJ,EAAYnsJ,EAAI,EACpB,KAAOmsJ,EAAYxoJ,EAAMO,QAChBtB,KAAKipJ,UAAUloJ,EAAM+nJ,WAAWS,MADNA,GAOnC,IAAIC,EACAD,EAAYxoJ,EAAMO,OAASP,EAAM+nJ,WAAWS,QAAavnJ,EAC7D,QAAsBA,IAAlBwnJ,EAA6B,CAC7B,MAAMC,EAAUzpJ,KAAKopJ,gBAAgBI,SAErBxnJ,IAAZynJ,QACoCznJ,IAAnCynJ,EAAQlB,EAAee,cACctnJ,IAAlCynJ,EAAQlB,EAAemB,UAE3BF,OAAgBxnJ,GAKxB,GACyB,OAArB6mJ,QACkB7mJ,IAAlBwnJ,IACmB,OAAlBA,GACqB,OAAlBA,GACkB,OAAlBA,GACkB,OAAlBA,GACN,CACE,MAAMG,EAAc3pJ,KAAK4pJ,wBACrBf,EACAW,GAGAZ,QADkB5mJ,IAAlBknJ,EACUr5F,OAAOg6F,aAAaF,EAAYnB,EAAasB,YAE7Cj6F,OAAOg6F,aAAaF,EAAYnB,EAAauB,aAIzD3sJ,EACF,SAIJ,MAAM2I,EAAM/F,KAAKopJ,gBAAgBP,QAGX7mJ,IAAlBknJ,QACkBlnJ,IAAlBwnJ,QAC+BxnJ,IAA/B+D,EAAIwiJ,EAAee,QAEnBV,GAAU/4F,OAAOg6F,aAAa9jJ,EAAIwiJ,EAAee,cAG1BtnJ,IAAlBknJ,QAA6DlnJ,IAA9B+D,EAAIwiJ,EAAemB,OACvDd,GAAU/4F,OAAOg6F,aAAa9jJ,EAAIwiJ,EAAemB,aAG1B1nJ,IAAlBwnJ,QAA+DxnJ,IAAhC+D,EAAIwiJ,EAAec,SACvDT,GAAU/4F,OAAOg6F,aAAa9jJ,EAAIwiJ,EAAec,UAIjDT,GAAU/4F,OAAOg6F,aAAahB,QAGlCD,GAAU/4F,OAAOg6F,aAAahB,GAItC,OAAOD,EAGH,kBAAkBzxH,GACtB,OAAOn3B,KAAKyoJ,sBAAsBliJ,IAAI4wB,GAGlC,gBAAgBA,GACpB,OAAOn3B,KAAKyoJ,sBAAsBxqJ,IAAIk5B,GAGlC,wBACJA,EACAqyH,GAEA,MAAMzjJ,EAAM/F,KAAK0oJ,wBAAwBzqJ,IAAIk5B,GAC7C,QAAYn1B,IAAR+D,EACA,OAAOA,EAAI9H,IAAIurJ,GAKf,UAAUryH,GACd,IAAK,MAAMy4B,KAAa5vD,KAAK2oJ,oBACzB,GAAI/4F,IAAcz4B,EACd,OAAO,EAGf,OAAO,GA3Pf,+B,wGCfA,aAMA,MAAa0L,UAAyB,EAAA0+F,mBAAtC,sB,oHCNA,aAMA,MAAa7/F,UAAqC,EAAA+/F,qBAAlD,kC,0GCGA,2BAKI,YAAYh/G,GAJJ,KAAAunI,iBAAsC,GACtC,KAAAC,iBAAsC,GAI1CjqJ,KAAKyiB,KAAOA,EAGhB,QACIziB,KAAKgqJ,iBAAiB1oJ,OAAS,EAC/BtB,KAAKiqJ,iBAAiB3oJ,OAAS,EAGnC,eACIgrB,GAEA,IAAIvG,EAAQ/lB,KAAKgqJ,iBAAiB19H,EAAU49H,QAS5C,YARcloJ,IAAV+jB,IACAA,EAAQ/lB,KAAKgqJ,iBACT19H,EAAU49H,QACVlqJ,KAAKyiB,KAAKvU,QAAQ6U,qBAAqBonI,WAAWC,kBAClDpqJ,KAAKyiB,KACL6J,IAGDvG,EAGX,eACIuG,GAEA,IAAIvG,EAAQ/lB,KAAKiqJ,iBAAiB39H,EAAU49H,QAS5C,YARcloJ,IAAV+jB,IACAA,EAAQ/lB,KAAKiqJ,iBACT39H,EAAU49H,QACVlqJ,KAAKyiB,KAAKvU,QAAQ6U,qBAAqBonI,WAAWE,kBAClDrqJ,KAAKyiB,KACL6J,IAGDvG,K,2GCnDf,aAQA,OAEA,SACA,QACA,SACA,QACA,SAEMukI,EAAsC,EAAAttD,aAAaE,QACnDqtD,EAAqC,EAAAvtD,aAAawtD,QA+HxD,4BAmDI,YACI/yI,EACAvG,EACA07D,EACA69E,EAAuD,CAAEC,aAAa,IAtD1E,KAAAv8E,MAAQ,CACJnvD,SAAS,EACT2rI,SAAU,IACVj7I,OAAQ,GACRk7I,UAAW,KAEf,KAAAx8E,QAAU,CACNpvD,SAAS,EACT6rI,UAAW,KACX5/H,MAAO,UACP6/H,uBAAuB,EACvBv+I,aAAa,GAEjB,KAAA8hE,SAAW,CACPrvD,SAAS,EACT6E,OAAQ,EACR41H,SAAU,GAEd,KAAAnrE,MAAQ,CACJtvD,SAAS,EACT63H,OAAQ,IAGJ,KAAAkU,QAAkB,EAClB,KAAAC,SAAmB,EAInB,KAAAC,aAA2B,IAAI,EAAAC,WAC/B,KAAAC,UAAqC,IAAI/rJ,EAAMs+F,kBAAkB,EAAG,GACpE,KAAA0tD,UAAqC,IAAIhsJ,EAAMs+F,kBAAkB,EAAG,GAEpE,KAAA2tD,YAA0B,IAAI,EAAAC,WAAW,EAAA1U,aACzC,KAAA2U,eAA6B,IAAI,EAAAD,WAAW,EAAA9R,gBAuBhDx5I,KAAKwrJ,aAAe,IAAIpsJ,EAAMs+F,kBAAkBjmF,EAAOvG,GACvDlR,KAAKyrJ,WAAa,IAAI,EAAA1uD,eACtB/8F,KAAKyrJ,WAAWzsI,aACUhd,IAAtByoJ,IAAoE,IAAlCA,EAAkBC,YACxD1qJ,KAAK0rJ,gCAC8C1pJ,IAA/CyoJ,EAAkBkB,yBACZrB,EACAG,EAAkBkB,yBAC5B3rJ,KAAK4rJ,+BAC6C5pJ,IAA9CyoJ,EAAkBoB,wBACZtB,EACAE,EAAkBoB,wBAC5B7rJ,KAAK8rJ,aAAe,IAAI,EAAAC,iBAAiBn/E,GACzC5sE,KAAK8rJ,aAAa9sI,aAA+Bhd,IAArB4qE,EAGhC,cAAc32D,GACVjW,KAAKouE,QAAQnjD,MAAQhV,EAAQgV,MAC7BjrB,KAAKouE,QAAQy8E,UAAY50I,EAAQ40I,UACjC7qJ,KAAKouE,QAAQ08E,sBAAwB70I,EAAQ60I,sBAC7C9qJ,KAAKouE,QAAQ7hE,aAAc,EAc/B,OACImsB,EACAC,EACAjqB,EACAs9I,GAGA,IAAKA,QAAkDhqJ,IAAjChC,KAAK8rJ,aAAattF,WAIpC,OAFAx+D,KAAK8rJ,aAAarzH,gBAAiB,OACnCz4B,KAAK8rJ,aAAa9yH,OAAON,EAAUC,EAAOjqB,EAJ/B,KAI+C1O,KAAKwrJ,cAInE,MAAMS,EACFjsJ,KAAKmuE,MAAMnvD,SACXhf,KAAKouE,QAAQpvD,SACbhf,KAAKquE,SAASrvD,SACdhf,KAAKsuE,MAAMtvD,QAEf,IAAIktI,EAA+C,KA6BnD,IA1BIlsJ,KAAKmuE,MAAMnvD,SAAWhf,KAAKquE,SAASrvD,SAAWhf,KAAKsuE,MAAMtvD,WAC1D0Z,EAASK,gBAAgB/4B,KAAKmrJ,WAC9BzyH,EAASyzH,cAKTnsJ,KAAKyrJ,WAAWzsI,SAEhBhf,KAAKyrJ,WAAWxuD,cAAgB+uD,EAC1BhsJ,KAAK4rJ,0BACL5rJ,KAAK0rJ,2BAEX1rJ,KAAKyrJ,WAAWhzH,gBAAkBwzH,EAElCjsJ,KAAKyrJ,WAAWzyH,OAAON,EAAUC,EAAOjqB,EAhC7B,KAgC6C1O,KAAKwrJ,eAEzDxrJ,KAAKmuE,MAAMnvD,SAAWhf,KAAKquE,SAASrvD,SAAWhf,KAAKsuE,MAAMtvD,SAC1DktI,EAAelsJ,KAAKmrJ,UACpBnrJ,KAAKirJ,aAAajyH,OAAON,EAAUC,EAAOjqB,EAAQ1O,KAAKmrJ,UAAW,SAC1DnrJ,KAAKouE,QAAQpvD,SAAYhf,KAAKouE,QAAQpvD,UAAYhf,KAAKmuE,MAAMnvD,UACrE0Z,EAASM,OAAOL,EAAOjqB,GAK3B1O,KAAKouE,QAAQpvD,QAAS,MACOhd,IAAzBhC,KAAKosJ,kBACLpsJ,KAAKosJ,gBAAkB,IAAI,EAAAC,cAAc3zH,IAEzC14B,KAAKouE,QAAQ7hE,cACbvM,KAAKosJ,gBAAgBnhI,MAAQjrB,KAAKouE,QAAQnjD,MAC1CjrB,KAAKosJ,gBAAgBvB,UAAY7qJ,KAAKouE,QAAQy8E,UAC9C7qJ,KAAKosJ,gBAAgBtB,sBAAwB9qJ,KAAKouE,QAAQ08E,sBAC1D9qJ,KAAKouE,QAAQ7hE,aAAc,GAE/B,MAAM+/I,EACFtsJ,KAAKmuE,MAAMnvD,SAAWhf,KAAKquE,SAASrvD,SAAWhf,KAAKsuE,MAAMtvD,QAC1DstI,IACAJ,EAAelsJ,KAAKmrJ,WAExBzyH,EAASK,gBAAgBuzH,EAAoBJ,EAAe,MAC5DlsJ,KAAKosJ,gBAAgBpzH,OAAOL,EAAOjqB,GAGvC,GAAI1O,KAAKmuE,MAAMnvD,QAAS,MACKhd,IAArBhC,KAAKusJ,cACLvsJ,KAAKusJ,YAAc,IAAI,EAAAC,UACnB,IAAIptJ,EAAMoG,QAAQxF,KAAK+qJ,QAAS/qJ,KAAKgrJ,UACrChrJ,KAAKmuE,MAAMw8E,SACX3qJ,KAAKmuE,MAAMz+D,OACX1P,KAAKmuE,MAAMy8E,YAGnB,MAAM0B,EAAoBtsJ,KAAKquE,SAASrvD,SAAWhf,KAAKsuE,MAAMtvD,QAC9Dhf,KAAKusJ,YAAY9zH,gBAAkB6zH,EACnCtsJ,KAAKusJ,YAAY78I,OAAS1P,KAAKmuE,MAAMz+D,OACrC1P,KAAKusJ,YAAY5B,SAAW3qJ,KAAKmuE,MAAMw8E,SACvC3qJ,KAAKusJ,YAAY3B,UAAY5qJ,KAAKmuE,MAAMy8E,UACxC5qJ,KAAKusJ,YAAYvzH,OAAON,EAAUC,EAAOjqB,EAAQ,KAAOw9I,aAC5BlqJ,IAArBhC,KAAKusJ,cACZvsJ,KAAKusJ,YAAY9mH,UACjBzlC,KAAKusJ,iBAAcvqJ,GAGvB,GAAIhC,KAAKquE,SAASrvD,QAAS,CACvB,MAAMykI,EAAYyI,EACZI,EAAoBtsJ,KAAKsuE,MAAMtvD,QACrChf,KAAKurJ,eAAevzI,SAAS6L,OAAOxlB,MAAQ2B,KAAKquE,SAASxqD,OAC1D7jB,KAAKurJ,eAAevzI,SAASyhI,SAASp7I,MAAQ2B,KAAKquE,SAASorE,SAC5Dz5I,KAAKurJ,eAAe9yH,gBAAkB6zH,EAClCA,IACAJ,EAAeA,IAAiBlsJ,KAAKmrJ,UAAYnrJ,KAAKorJ,UAAYprJ,KAAKmrJ,WAE3EnrJ,KAAKurJ,eAAevyH,OAAON,EAAUC,EAAOjqB,EAAQw9I,EAAezI,GAGnEzjJ,KAAKsuE,MAAMtvD,UACXhf,KAAKqrJ,YAAY5yH,gBAAiB,EAClCz4B,KAAKqrJ,YAAYrzI,SAAS6+H,OAAOx4I,MAAQ2B,KAAKsuE,MAAMuoE,OACpD72I,KAAKqrJ,YAAYryH,OAAON,EAAUC,EAAOjqB,EAAQ,KAAOw9I,IAWhE,QAAQz0I,EAAevG,GACnBlR,KAAKwrJ,aAAar+E,QAAQ11D,EAAOvG,GACjClR,KAAKyrJ,WAAWt+E,QAAQ11D,EAAOvG,QACNlP,IAArBhC,KAAKusJ,aACLvsJ,KAAKusJ,YAAYp/E,QAAQ11D,EAAOvG,GAEpClR,KAAK8rJ,aAAa3+E,QAAQ11D,EAAOvG,GACjClR,KAAKmrJ,UAAUh+E,QAAQ11D,EAAOvG,GAC9BlR,KAAKorJ,UAAUj+E,QAAQ11D,EAAOvG,GAC9BlR,KAAK+qJ,QAAUtzI,EACfzX,KAAKgrJ,SAAW95I,EASpB,uBACI,OAAOlR,KAAK8rJ,aAAattF,WAG7B,qBAAqBA,GACjBx+D,KAAK8rJ,aAAattF,WAAaA,EAC/Bx+D,KAAK8rJ,aAAa9sI,aAAyBhd,IAAfw8D,EAQhC,6BAA6By+B,GACzBj9F,KAAK0rJ,2BAA6BzuD,EAMtC,+BACI,OAAOj9F,KAAK0rJ,2BAShB,gBAAgBrtJ,GACZ2B,KAAKyrJ,WAAWzsI,QAAU3gB,EAM9B,kBACI,OAAO2B,KAAKyrJ,WAAWzsI,QAQ3B,4BAA4Bi+E,GACxBj9F,KAAK4rJ,0BAA4B3uD,EAOrC,8BACI,OAAOj9F,KAAK4rJ,6B,wGCxapB,aACA,OAEA,QAUA,MAAaG,UAAyB,EAAAvzH,KA+BlC,YAAmBo0C,GACf5pE,QADe,KAAA4pE,mBA9BX,KAAAuwB,eAAiD,KACxC,KAAAC,cAA0C,IAAIh+F,EAAMq6B,oBAChE,EACD,EACA,GACC,EACD,EACA,GAEa,KAAA4jE,YAA2B,IAAIj+F,EAAMkiB,MACrC,KAAAg8E,eACb,EAAAnE,WAAWnhF,SACE,KAAAulF,eAAuC,IAAI,EAAAlE,aAAar5F,KAAKs9F,gBAC7D,KAAAG,OAAqB,IAAIr+F,EAAM40B,KAC5C,IAAI50B,EAAMs6B,oBAAoB,EAAG,GACjC15B,KAAKu9F,gBAGD,KAAAkvD,aAAe,EACf,KAAAC,cAAgB,EAapB1sJ,KAAKy9F,OAAO5rC,eAAgB,EAC5B7xD,KAAKq9F,YAAYl9F,IAAIH,KAAKy9F,QAC1Bz9F,KAAK+iE,aAAe6J,EAMxB,UACI5sE,KAAKu9F,eAAe93D,UACpBzlC,KAAKy9F,OAAOvjF,SAASurB,UACO,OAAxBzlC,KAAKm9F,iBACLn9F,KAAKm9F,eAAe13D,UACpBzlC,KAAKm9F,eAAiB,MAa9B,eAAexwB,GACX3sE,KAAK+iE,aAAe4J,EAChB3sE,KAAKm9F,qBAAsCn7F,IAApBhC,KAAKw+D,YAC5Bx+D,KAAKm9F,eAAehwB,QAChB9jE,KAAKmtB,MAAMx2B,KAAKysJ,aAAezsJ,KAAKw+D,YACpCn1D,KAAKmtB,MAAMx2B,KAAK0sJ,cAAgB1sJ,KAAKw+D,aAKjD,iBACI,OAAOx+D,KAAK+iE,aAgBhB,OACIrqC,EACAC,EACAjqB,EACAkqB,EACAC,GAEA,IAAK74B,KAAKgf,cAA+Bhd,IAApBhC,KAAKw+D,WACtB,OAIwB,OAAxBx+D,KAAKm9F,iBACLn9F,KAAKysJ,aAAe5zH,EAAWphB,MAC/BzX,KAAK0sJ,cAAgB7zH,EAAW3nB,OAChClR,KAAKm9F,eAAiB,IAAI/9F,EAAMs+F,kBAC5Br0F,KAAKmtB,MAAMx2B,KAAKysJ,aAAezsJ,KAAKw+D,YACpCn1D,KAAKmtB,MAAMx2B,KAAK0sJ,cAAgB1sJ,KAAKw+D,YACrC,CACI1uC,UAAW1wB,EAAMu+F,aACjB/tE,UAAWxwB,EAAMu+F,aACjB/rE,OAAQxyB,EAAMw+F,WACdygD,aAAa,EACbC,eAAe,IAGvBt+I,KAAKm9F,eAAehmF,QAAQxZ,KAAO,2BAGvCqC,KAAKs9F,eAAelE,SAAS/6F,MAAQ2B,KAAKm9F,eAAehmF,QACzDnX,KAAKs9F,eAAepyE,QAAQ7sB,MAAQ,EAEpC,MAAM4/F,EAAkBvlE,EAASwlE,kBACjCxlE,EAASK,gBAAgB/4B,KAAKm9F,gBAC9BzkE,EAASsN,QAETtN,EAASM,OAAOL,EAAOjqB,GAIvBgqB,EAASK,gBAAgB/4B,KAAKy4B,eAAiB,KAAOG,GACtDF,EAASsN,QACTtN,EAASM,OAAOh5B,KAAKq9F,YAAar9F,KAAKo9F,eACvC1kE,EAASK,gBAAgBklE,GAW7B,QAAQxmF,EAAevG,GACnBlR,KAAKysJ,aAAeh1I,EACpBzX,KAAK0sJ,cAAgBx7I,EACjBlR,KAAKm9F,qBAAsCn7F,IAApBhC,KAAKw+D,YAC5Bx+D,KAAKm9F,eAAehwB,QAChB9jE,KAAKmtB,MAAM/e,EAAQzX,KAAKw+D,YACxBn1D,KAAKmtB,MAAMtlB,EAASlR,KAAKw+D,cAlJzC,sB,qGCbA,aAOA,OACA,OA+FA,sBAgCI,YAAoB2D,GAAA,KAAAA,aA/BpB,KAAAnjD,SAAmB,EAMX,KAAA2tI,mBAA6B,IAC7B,KAAAC,eAA8B,IAAIxtJ,EAAMsqB,MAAM,EAAG,EAAG,GACpD,KAAAmjI,eAAyB,EACzB,KAAAC,oBAA8B,EAC9B,KAAAC,yBAAmC,EAEnC,KAAA5kD,QAAe,GACf,KAAA6kD,uBAAiC,GACjC,KAAAC,oBAA2B,GAC3B,KAAAC,0BAAiC,GAEjC,KAAAC,YAAyC,CAC7Ch1I,kBAAmB,QACnBi1I,oBAAqB,UACrBC,kBAAmB,QACnBC,iBAAkB,QAClBp/F,qBAAsB,WACtBq/F,qBAAsB,YAElB,KAAAC,gBAAkB,CACtBC,iBAAkB,CAAEpvJ,MAAO2B,KAAK2sJ,oBAChCpU,aAAc,CAAEl6I,MAAO2B,KAAK4sJ,gBAC5Bc,aAAc,CAAErvJ,MAAO2B,KAAK6sJ,iBAI5B7sJ,KAAKukE,UAAYpC,EAAWoC,UAC5BvkE,KAAK2tJ,WAAaxrF,EAAWwrF,WAC7B3tJ,KAAKyuE,UAAYtM,EAAWsM,UAGhC,cAAco8E,GACV7qJ,KAAK2sJ,mBAAqB9B,EAC1B7qJ,KAAKwtJ,gBAAgBC,iBAAiBpvJ,MAAQwsJ,EAC9C7qJ,KAAKmoG,QAAU,GAGnB,UAAUl9E,GACNjrB,KAAK4sJ,eAAe5lJ,IAAIikB,GACxBjrB,KAAKmoG,QAAU,GAGnB,0BAA0BylD,GACtB5tJ,KAAK+sJ,wBAA0Ba,EAGnC,MAAM3iI,EAAgB4iI,EAAgBC,GAClC9tJ,KAAKmiE,WAAWn8B,MAAM/a,EAAO4iI,EAAOC,GAGxC,gBACI,OAAO9tJ,KAAKmiE,WAAWsK,gBAG3B,cAAcpuE,GACV2B,KAAKmiE,WAAWuK,cAAcruE,GAGlC,QAAQkQ,GACJ,OAAOvO,KAAKmiE,WAAWuI,QAAQn8D,GAGnC,QAAQkJ,EAAevG,EAAgB68I,GACnC/tJ,KAAKmiE,WAAWgL,QAAQ11D,EAAOvG,EAAQ68I,GAG3C,YAAYtoJ,EAAWC,EAAW+R,EAAevG,GAC7ClR,KAAKmiE,WAAW6rF,YAAYvoJ,EAAGC,EAAG+R,EAAOvG,GAG7C,WAAWzL,EAAWC,EAAW+R,EAAevG,GAC5ClR,KAAKmiE,WAAW8rF,WAAWxoJ,EAAGC,EAAG+R,EAAOvG,GAG5C,eAAei7H,GACXnsI,KAAKmiE,WAAW+rF,eAAe/hB,GAGnC,gBAAgBgiB,GACZnuJ,KAAKmiE,WAAWppC,gBAAgBo1H,GAGpC,OAAOx1H,EAAoBjqB,GAIvB,GAAI1O,KAAK+sJ,wBAAyB,CAC9B,IAAK/sJ,KAAKgf,QAEN,YADAhf,KAAKmiE,WAAWnpC,OAAOL,EAAOjqB,GAIlC,MAAM0/I,EAAmBpuJ,KAAKmiE,WAAWoC,UACzCvkE,KAAKmiE,WAAWoC,UAAYvkE,KAAKukE,UAEjCvkE,KAAKmiE,WAAWnpC,OAAOL,EAAOjqB,GAE9B1O,KAAKmiE,WAAWoC,UAAY6pF,EAGhCpuJ,KAAKquJ,cAAc11H,EAAOjqB,GAG9B,cAAciqB,EAAoBjqB,GAC9B,MAAM0/I,EAAmBpuJ,KAAKmiE,WAAWoC,UACnC+pF,EAAyB31H,EAAM41H,WAC/BC,EAAyB71H,EAAM88C,WAC/Bg5E,EAA0BzuJ,KAAKmiE,WAAWsM,UAAUzvD,QAE1D2Z,EAAM41H,YAAa,EACnB51H,EAAM88C,WAAa,KACnBz1E,KAAKmiE,WAAWoC,WAAY,EAC5BvkE,KAAKmiE,WAAWsM,UAAUzvD,SAAU,EAEpC2Z,EAAMmN,SAAS9lC,KAAK0uJ,mBAAmB9vJ,KAAKoB,OAE5CA,KAAKmiE,WAAWnpC,OAAOL,EAAOjqB,GAE9BiqB,EAAMmN,SAAS9lC,KAAK2uJ,wBAAwB/vJ,KAAKoB,OAEjDA,KAAK4uJ,eAELj2H,EAAM41H,WAAaD,EACnB31H,EAAM88C,WAAa+4E,EACnBxuJ,KAAKmiE,WAAWoC,UAAY6pF,EAC5BpuJ,KAAKmiE,WAAWsM,UAAUzvD,QAAUyvI,EAGhC,0BACJ,OAAO,IAAIrvJ,EAAM0Y,eAAe,CAAEna,KAAM,YAAayoB,SAAS,IAG1D,eAAeyoI,GAEnB,GACIA,aAA4B,EAAAluE,eAC4C,IAAvEkuE,EAA4CriD,uBAE7C,OAAOxsG,KAAK8uJ,0BAGhB,MAAMC,EAAW/uJ,KAAKmtJ,YAAY0B,EAAiBj/I,MACnD,IAAIo/I,EAEAC,OAC+DjtJ,IAA9D6sJ,EAA2CxkG,eACrCwkG,EAA2CxkG,eAC3CwkG,EAA0C72I,SAErD,QAAiBhW,IAAb+sJ,EAAwB,CACxB,MAAM91H,EAAS75B,EAAM8vJ,UAAUH,GAC/BE,EAAmBh2H,EAAOjhB,SAC1Bg3I,EAAuB/1H,EAAOG,kBAC3B,IAAsD,IAAjDy1H,EAAyBM,qBAGjC,GAFAH,EAAwBH,EAAyBz1H,cAG5C,kCAAkC+pB,KAAK6rG,KACvC,gCAAgC7rG,KAAK6rG,GAEtC,OAAOhvJ,KAAK8uJ,8BAEb,KAAmD,IAA9CD,EAAyBO,iBAGjC,OAAOpvJ,KAAK8uJ,0BAFZE,EAAwBH,EAAyBz1H,aAKrD,MAAMi2H,OAC6DrtJ,IAA9D6sJ,EAA2CxkG,qBACgBroD,IAA3D6sJ,EAAyBxkG,eAAewC,eAEvCyiG,EAAmB,EAAA7kG,cAAciB,UAAUmjG,GAE3C72I,EAAQ,+BAAsBi3I,GAAqBjvJ,KAAKwtJ,iBAExDp0H,EAAe41H,EAEhB5iJ,QAAQ,wBAAyBmjJ,ojBAGjCnjJ,QAAQ,SAAUojJ,gyBAIlBpjJ,QAAQ,kCAAmC,IAE1CZ,EAAe,GAuDrB,MApDK,yBAAyB23C,KAAK6rG,IAC9B,4BAA4B7rG,KAAK6rG,KAEjCxjJ,EAAgBikJ,qBAAsB,GAGvCJ,IAGAr3I,EAAS60C,eAAiB,CAAExuD,MAAO,EAAA8hC,qBAAqBC,mBACxD50B,EAAQkkJ,cAAgB,GAGxBJ,IACAt3I,EAASgO,SAAW,CAChB3nB,WACmC2D,IAA/BitJ,EAAkBjpI,SACZipI,EAAkBjpI,SAAS3nB,MAC3B,EAAAosD,cAAce,mBAE5BxzC,EAASiO,QAAU,CACf5nB,WACkC2D,IAA9BitJ,EAAkBhpI,QACZgpI,EAAkBhpI,QAAQ5nB,MAC1B,EAAAosD,cAAcgB,kBAE5BjgD,EAAQmkJ,WAAa,GAGD,IAAIvwJ,EAAM0Y,eAAe,CAC7CtM,UACAwM,WACAohB,eACAC,eA1QW,sfA2QXqjE,KAAMt9F,EAAM43I,SAEZ4Y,UAAU,EACVC,cAAc,EACdC,cAAc,EACdjhI,KAAK,EACLjkB,SAAUxL,EAAMyL,eAChBE,SAAU3L,EAAMiM,eAChBJ,SAAU7L,EAAM8L,uBAChBC,cAAe/L,EAAM4L,UACrBI,cAAehM,EAAM8L,uBACrBR,aAAa,EACbg8C,eAAe,EAEfC,oBAAqB,GACrBC,mBAAoB,KAMpB,4BAA4BioG,GAChC,IAAIvnH,EAAOtnC,KAAKmoG,QAAQ0mD,EAAiBt3I,MAezC,YAbavV,IAATslC,IACAA,EAAO,CACH78B,SAAUzK,KAAK09E,eAAemxE,GAC9BkB,MAAM,EACNC,UAAWhwJ,KAAK8sJ,mBAChB/yI,MAAO,GAGX/Z,KAAKmoG,QAAQ0mD,EAAiBt3I,MAAQ+vB,GAG1CA,EAAKyoH,MAAO,EAELzoH,EAAK78B,SAGR,mBAAmBokJ,GACvB,MAAM3tE,EAAkBlhF,KAAKiwJ,4BAA4BpB,GAMzD,OAJA7uJ,KAAKitJ,oBAAoB/rE,EAAgB3pE,MAAQs3I,EAEjD7uJ,KAAKkwJ,sBAAsBhvE,EAAiB2tE,GAErC3tE,EAGH,mBAAmBpiF,GACvB,QAAwCkD,IAAnClD,EAAsB2L,SAA3B,CAIA,GAAIrJ,MAAMC,QAASvC,EAAsB2L,UACrC,IACI,IAAIrN,EAAI,EAAGuoF,EAAO7mF,EAAsB2L,SAA8BnJ,OACtElE,EAAIuoF,EACJvoF,IAEE0B,EAAsB2L,SAA8BrN,GAAK4C,KAAKmwJ,mBAC1DrxJ,EAAsB2L,SAA8BrN,SAI7D0B,EAAsB2L,SAAWzK,KAAKmwJ,mBAClCrxJ,EAAsB2L,UAI/BzK,KAAKktJ,0BAA0BpuJ,EAAOyY,MAAQzY,EAAOstD,eACrDttD,EAAOstD,eAAiB,EAAA9lB,eACpBxnC,EAAOstD,eACPpsD,KAAKosD,eAAextD,KAAKoB,QAIzB,wBAAwBlB,GAC5B,QAAwCkD,IAAnClD,EAAsB2L,SAA3B,CAIA,GAAIrJ,MAAMC,QAASvC,EAAsB2L,UACrC,IACI,IAAIrN,EAAI,EAAGuoF,EAAO7mF,EAAsB2L,SAA8BnJ,OACtElE,EAAIuoF,EACJvoF,IAEE0B,EAAsB2L,SAA8BrN,GAAK4C,KAAKitJ,oBAC1DnuJ,EAAsB2L,SAA8BrN,GAAGma,WAIhEzY,EAAsB2L,SAAWzK,KAAKitJ,oBACjCnuJ,EAAsB2L,SAA4B8M,MAI5DzY,EAAOstD,eAAiBpsD,KAAKktJ,0BAA0BpuJ,EAAOyY,OAG1D,eACJmhB,EACAC,EACAjqB,EACAwL,EACAzP,EACAk4B,GAEA,MAAMksH,EAAmB7uJ,KAAKitJ,oBAAoBxiJ,EAAS8M,WAGlCvV,IAArB6sJ,GAIJ7uJ,KAAKksD,eAAezhD,EAAUokJ,GAG1B,eAAepkJ,EAA0BokJ,GAC7C,MAAMuB,EAAoBvB,EAAiB/sI,SAASsuI,kBAE9CC,EAAmB5lJ,EAAkCuN,SAC3Dq4I,EAAgB3C,aAAarvJ,MAAQwwJ,EAAiB3jI,QAEtD,MAAM+jI,OAC2CjtJ,IAA5C6sJ,EAAyBxkG,eACnBwkG,EAAyBxkG,eACzBwkG,EAAyB72I,SAgBpC,QAd0BhW,IAAtBouJ,SACoCpuJ,IAAhCouJ,EAAkBvF,YAClBwF,EAAgB5C,iBAAiBpvJ,MAAQ+xJ,EAAkBvF,gBAE/B7oJ,IAA5BouJ,EAAkBnlI,OAClBolI,EAAgB9X,aAAal6I,MAAMunF,UAAUwqE,EAAkBnlI,YAEnCjpB,IAA5BouJ,EAAkB98F,QAClB+8F,EAAgB3C,aAAarvJ,MAAQ+xJ,EAAkB98F,aAMtCtxD,IAArBitJ,QAAsEjtJ,IAApCitJ,EAAiBpiG,eAA8B,CACjF,MAAMxuD,EAASwwJ,EAAyBxkG,eAAewC,eAAexuD,MACrEoM,EAAiBoiD,eAAiBxuD,EAClCoM,EAAiBuN,SAAS60C,eAAexuD,WAC5B2D,IAAV3D,EAAsBA,EAAQ,EAAA8hC,qBAAqBC,uBAKvBp+B,IAAhCyI,EAASe,QAAQmkJ,iBACa3tJ,IAA9BitJ,EAAiBjpI,eACYhkB,IAA7BitJ,EAAiBhpI,SACjBgpI,EAAiBhpI,QAAQ5nB,OAAS,IAElCgyJ,EAAgBrqI,SAAS3nB,MAAQ4wJ,EAAiBjpI,SAAS3nB,MAC3DgyJ,EAAgBpqI,QAAQ5nB,MAAQ4wJ,EAAiBhpI,QAAQ5nB,OAIzD,sBAAsBoM,EAA0BokJ,GACpD,GAAsB,cAAlBpkJ,EAAS9M,KACT,OAGJ,MAAMyyJ,EAAoBvB,EAAiB/sI,SAASsuI,kBAEnD3lJ,EAAiBmlJ,SAAYf,EAAyBe,SACtDnlJ,EAAiBolJ,aAAgBhB,EAAyBgB,aAC1DplJ,EAAiBqlJ,aAAgBjB,EAAyBiB,aAC3DrlJ,EAASokB,IAAMggI,EAAiBhgI,SAEN7sB,IAAtBouJ,GACA3lJ,EAAS2b,SACwB,IAA7ByoI,EAAiBzoI,eAEmBpkB,IAA9BouJ,EAAkBhqI,SAClBgqI,EAAkBhqI,cAGQpkB,IAAhCouJ,EAAkBJ,YAClBhwJ,KAAKmoG,QAAQ0mD,EAAiBt3I,MAAMy4I,UAAYI,EAAkBJ,YAGtEvlJ,EAAS2b,QAAUyoI,EAAiBzoI,SAGI,IAAvCyoI,EAAyBj1G,YAAqD,IAA/Bi1G,EAAiB3/H,YACjEzkB,EAAS2b,SAAU,GAInB,eACJ,IAAIw1C,EAGJA,EAAO99D,OAAO89D,KAAK57D,KAAKitJ,qBAExB,IAAK,IAAI7vJ,EAAI,EAAGuoF,EAAK/pB,EAAKt6D,OAAQlE,EAAIuoF,EAAIvoF,IACtC4C,KAAKitJ,oBAAoBrxF,EAAKx+D,SAAM4E,EAIxC45D,EAAO99D,OAAO89D,KAAK57D,KAAKktJ,2BAExB,IAAK,IAAI9vJ,EAAI,EAAGuoF,EAAK/pB,EAAKt6D,OAAQlE,EAAIuoF,EAAIvoF,IACtC4C,KAAKktJ,0BAA0BtxF,EAAKx+D,SAAM4E,EAI9C45D,EAAO99D,OAAO89D,KAAK57D,KAAKmoG,SAExB,IAAK,MAAMxpG,KAAOi9D,GACiB,IAA3B57D,KAAKmoG,QAAQxpG,GAAKoxJ,MAClB/vJ,KAAKmoG,QAAQxpG,GAAKob,SAGkB,IAAhC/Z,KAAKmoG,QAAQxpG,GAAKqxJ,WAClBhwJ,KAAKmoG,QAAQxpG,GAAKob,MAAQ/Z,KAAKgtJ,+BAExBhtJ,KAAKmoG,QAAQxpG,KAGxBqB,KAAKmoG,QAAQxpG,GAAKoxJ,MAAO,EACzB/vJ,KAAKmoG,QAAQxpG,GAAKob,MAAQ,M,iGCjjB1C,aACA,OACA,QAEMu2I,EAAiB,IAAIlxJ,EAAMoG,QAAQ,EAAK,GACxC+qJ,EAAiB,IAAInxJ,EAAMoG,QAAQ,EAAK,GAK9C,MAAagnJ,UAAkB,EAAAh0H,KA8B3B,YAAYg4H,EAA2B7F,EAAkBj7I,EAAgBk7I,GACrE5nJ,QA3BJ,KAAAwtJ,WAA4B,IAAIpxJ,EAAMoG,QAAQ,IAAK,KAC3C,KAAAirJ,0BAAuD,GACvD,KAAAC,wBAAqD,GACrD,KAAAC,QAAkB,EAGlB,KAAAC,yBAAmD,GAKnD,KAAAp3H,SAAqC,IAAIp6B,EAAMq6B,oBAAoB,EAAG,EAAG,GAAI,EAAG,EAAG,GACnF,KAAAsmC,QAAuB,IAAI3gE,EAAMkiB,MACjC,KAAAuvI,QAAU,IAAIzxJ,EAAM+Y,kBACpB,KAAAslF,OAAS,IAAIr+F,EAAM40B,KAAK,IAAI50B,EAAMs6B,oBAAoB,EAAG,IAEzD,KAAAo3H,kBAAqC,CACzC,IAAI1xJ,EAAMuG,QAAQ,EAAG,EAAG,GACxB,IAAIvG,EAAMuG,QAAQ,EAAG,EAAG,GACxB,IAAIvG,EAAMuG,QAAQ,EAAG,EAAG,GACxB,IAAIvG,EAAMuG,QAAQ,EAAG,EAAG,GACxB,IAAIvG,EAAMuG,QAAQ,EAAG,EAAG,IAQxB3F,KAAK2qJ,SAAWA,EAChB3qJ,KAAK0P,OAASA,EACd1P,KAAK4qJ,UAAYA,EACjB5qJ,KAAKwwJ,WAAaA,EAElBxwJ,KAAKy9F,OAAO5rC,eAAgB,EAC5B7xD,KAAK+/D,QAAQ5/D,IAAIH,KAAKy9F,QAEtB,MAAMszD,EAAO,CACTjhI,UAAW1wB,EAAMu+F,aACjB/tE,UAAWxwB,EAAMu+F,aACjB/rE,OAAQxyB,EAAMw+F,YAGlB,IAAIozD,EAAO3nJ,KAAKggC,MAAMrpC,KAAKwwJ,WAAW/qJ,EAAI,GACtCwrJ,EAAO5nJ,KAAKggC,MAAMrpC,KAAKwwJ,WAAW9qJ,EAAI,GAE1C1F,KAAKkxJ,qBAAuB,IAAI9xJ,EAAMs+F,kBAAkBszD,EAAMC,EAAMF,GACpE/wJ,KAAKkxJ,qBAAqB/5I,QAAQxZ,KAAO,yBACzCqC,KAAKkxJ,qBAAqB/5I,QAAQg6I,iBAAkB,EAEpD,IAAK,IAAI/zJ,EAAI,EAAGA,EAAI4C,KAAK2wJ,QAASvzJ,IAAK,CACnC,MAAMg0J,EAAwB,IAAIhyJ,EAAMs+F,kBAAkBszD,EAAMC,EAAMF,GACtEK,EAAsBj6I,QAAQxZ,KAAO,oBAAsBP,EAC3Dg0J,EAAsBj6I,QAAQg6I,iBAAkB,EAChDnxJ,KAAKywJ,0BAA0BvqJ,KAAKkrJ,GAEpC,MAAMC,EAAuB,IAAIjyJ,EAAMs+F,kBAAkBszD,EAAMC,EAAMF,GACrEM,EAAqBl6I,QAAQxZ,KAAO,oBAAsBP,EAC1Di0J,EAAqBl6I,QAAQg6I,iBAAkB,EAC/CnxJ,KAAK0wJ,wBAAwBxqJ,KAAKmrJ,GAElCL,EAAO3nJ,KAAKggC,MAAM2nH,EAAO,GACzBC,EAAO5nJ,KAAKggC,MAAM4nH,EAAO,GAG7BjxJ,KAAKsxJ,mBAAqBlyJ,EAAM+5B,cAActsB,MAAM,EAAA2pI,yBAAyBx+H,UAG7EhY,KAAKsxJ,mBAAwC,oBAAEjzJ,MAAQusJ,EACvD5qJ,KAAKsxJ,mBAAgC,YAAEjzJ,MAAQ,IAE/C2B,KAAKuxJ,yBAA2B,IAAInyJ,EAAM0Y,eAAe,CACrDE,SAAUhY,KAAKsxJ,mBACfl4H,aAAc,EAAAo9G,yBAAyBp9G,aACvCC,eAAgB,EAAAm9G,yBAAyBn9G,eACzC7tB,QAAS,KAIb,MAAMgmJ,EAAkB,CAAC,EAAG,EAAG,EAAG,EAAG,IACrCR,EAAO3nJ,KAAKggC,MAAMrpC,KAAKwwJ,WAAW/qJ,EAAI,GACtCwrJ,EAAO5nJ,KAAKggC,MAAMrpC,KAAKwwJ,WAAW9qJ,EAAI,GACtC,IAAK,IAAItI,EAAI,EAAGA,EAAI4C,KAAK2wJ,QAASvzJ,IAC9B4C,KAAK4wJ,yBAAyB1qJ,KAAKlG,KAAKyxJ,yBAAyBD,EAAgBp0J,KACjF4C,KAAK4wJ,yBAAyBxzJ,GAAG4a,SAAkB,QAAE3Z,MAAQ,IAAIe,EAAMoG,QACnEwrJ,EACAC,GAEJD,EAAO3nJ,KAAKggC,MAAM2nH,EAAO,GACzBC,EAAO5nJ,KAAKggC,MAAM4nH,EAAO,GAI7BjxJ,KAAK0xJ,oBAAsB1xJ,KAAK2xJ,qBAAqB3xJ,KAAK2wJ,SAC1D3wJ,KAAK0xJ,oBAAoB15I,SACP,aAChB3Z,MAAQ2B,KAAK0wJ,wBAAwB,GAAGv5I,QAC1CnX,KAAK0xJ,oBAAoB15I,SACP,aAChB3Z,MAAQ2B,KAAK0wJ,wBAAwB,GAAGv5I,QAC1CnX,KAAK0xJ,oBAAoB15I,SACP,aAChB3Z,MAAQ2B,KAAK0wJ,wBAAwB,GAAGv5I,QAC1CnX,KAAK0xJ,oBAAoB15I,SACP,aAChB3Z,MAAQ2B,KAAK0wJ,wBAAwB,GAAGv5I,QAC1CnX,KAAK0xJ,oBAAoB15I,SACP,aAChB3Z,MAAQ2B,KAAK0wJ,wBAAwB,GAAGv5I,QAC1CnX,KAAK0xJ,oBAAoB15I,SAAwB,cAAE3Z,MAAQssJ,EAC3D3qJ,KAAK0xJ,oBAAoB15I,SAAsB,YAAE3Z,MAAQ,GACzD2B,KAAK0xJ,oBAAoBnlJ,aAAc,EAGvCvM,KAAK0xJ,oBAAoB15I,SAAuB,aAAE3Z,MAD7B,CAAC,EAAK,GAAK,GAAK,GAAK,IAE1C2B,KAAK0xJ,oBAAoB15I,SAA0B,gBAAE3Z,MAAQ2B,KAAK8wJ,kBAElE9wJ,KAAK4xJ,eAAiBxyJ,EAAM+5B,cAActsB,MAAM,EAAAssF,WAAWnhF,UAC3DhY,KAAK4xJ,eAAwB,QAAEvzJ,MAAQ,EAGvC2B,KAAK6xJ,eAAiB,IAAIzyJ,EAAM0Y,eAAe,CAC3CE,SAAUhY,KAAK4xJ,eACfx4H,aAAc,EAAA+/D,WAAW//D,aACzBC,eAAgB,EAAA8/D,WAAW9/D,eAC3BzuB,SAAUxL,EAAMu3I,iBAChBznH,WAAW,EACXyqB,YAAY,EACZjvC,aAAa,IAGrB,UACI,IAAK,MAAMonJ,KAAM9xJ,KAAKywJ,0BAClBqB,EAAGrsH,UAEP,IAAK,MAAMqsH,KAAM9xJ,KAAK0wJ,wBAClBoB,EAAGrsH,UAEPzlC,KAAKkxJ,qBAAqBzrH,UAG9B,QAAQhuB,EAAevG,GACnB,IAAI8/I,EAAO3nJ,KAAKggC,MAAM5xB,EAAQ,GAC1Bw5I,EAAO5nJ,KAAKggC,MAAMn4B,EAAS,GAC/BlR,KAAKkxJ,qBAAqB/jF,QAAQ6jF,EAAMC,GACxC,IAAK,IAAI7zJ,EAAI,EAAGA,EAAI4C,KAAK2wJ,QAASvzJ,IAC9B4C,KAAKywJ,0BAA0BrzJ,GAAG+vE,QAAQ6jF,EAAMC,GAChDjxJ,KAAK0wJ,wBAAwBtzJ,GAAG+vE,QAAQ6jF,EAAMC,GAE9CjxJ,KAAK4wJ,yBAAyBxzJ,GAAG4a,SAAkB,QAAE3Z,MAAQ,IAAIe,EAAMoG,QACnEwrJ,EACAC,GAEJD,EAAO3nJ,KAAKggC,MAAM2nH,EAAO,GACzBC,EAAO5nJ,KAAKggC,MAAM4nH,EAAO,GAIjC,OACIv4H,EACAC,EACAjqB,EACAkqB,EACAC,GAKI74B,KAAKy4B,iBACLz4B,KAAKy9F,OAAOhzF,SAAWzK,KAAK6wJ,QAC5B7wJ,KAAK6wJ,QAAQ9qJ,IAAM8yB,EAAW1hB,QAC9BuhB,EAASK,gBAAgB,MACzBL,EAASsN,QACTtN,EAASM,OAAOh5B,KAAK+/D,QAAS//D,KAAKw5B,WAIvCx5B,KAAKsxJ,mBAA6B,SAAEjzJ,MAAQw6B,EAAW1hB,QACvDnX,KAAKsxJ,mBAAwC,oBAAEjzJ,MAAQ2B,KAAK4qJ,UAC5D5qJ,KAAKy9F,OAAOhzF,SAAWzK,KAAKuxJ,yBAE5B74H,EAASK,gBAAgB/4B,KAAKkxJ,sBAC9Bx4H,EAASsN,QACTtN,EAASM,OAAOh5B,KAAK+/D,QAAS//D,KAAKw5B,UAGnC,IAAIu4H,EAAoB/xJ,KAAKkxJ,qBAE7B,IAAK,IAAI9zJ,EAAI,EAAGA,EAAI4C,KAAK2wJ,QAASvzJ,IAC9B4C,KAAKy9F,OAAOhzF,SAAWzK,KAAK4wJ,yBAAyBxzJ,GAErD4C,KAAK4wJ,yBAAyBxzJ,GAAG4a,SAAuB,aAAE3Z,MACtD0zJ,EAAkB56I,QACtBnX,KAAK4wJ,yBAAyBxzJ,GAAG4a,SAAoB,UAAE3Z,MAAQiyJ,EAC/D53H,EAASK,gBAAgB/4B,KAAKywJ,0BAA0BrzJ,IACxDs7B,EAASsN,QACTtN,EAASM,OAAOh5B,KAAK+/D,QAAS//D,KAAKw5B,UAEnCx5B,KAAK4wJ,yBAAyBxzJ,GAAG4a,SACf,aAChB3Z,MAAQ2B,KAAKywJ,0BAA0BrzJ,GAAG+Z,QAC5CnX,KAAK4wJ,yBAAyBxzJ,GAAG4a,SAAoB,UAAE3Z,MAAQkyJ,EAC/D73H,EAASK,gBAAgB/4B,KAAK0wJ,wBAAwBtzJ,IACtDs7B,EAASsN,QACTtN,EAASM,OAAOh5B,KAAK+/D,QAAS//D,KAAKw5B,UAEnCu4H,EAAoB/xJ,KAAK0wJ,wBAAwBtzJ,GAIrD4C,KAAKy9F,OAAOhzF,SAAWzK,KAAK0xJ,oBAC5B1xJ,KAAK0xJ,oBAAoB15I,SAAwB,cAAE3Z,MAAQ2B,KAAK2qJ,SAChE3qJ,KAAK0xJ,oBAAoB15I,SAAsB,YAAE3Z,MAAQ2B,KAAK0P,OAC9D1P,KAAK0xJ,oBAAoB15I,SAA0B,gBAAE3Z,MAAQ2B,KAAK8wJ,kBAElEp4H,EAASK,gBAAgB/4B,KAAKywJ,0BAA0B,IACxD/3H,EAASsN,QACTtN,EAASM,OAAOh5B,KAAK+/D,QAAS//D,KAAKw5B,UAGnCx5B,KAAKy9F,OAAOhzF,SAAWzK,KAAK6xJ,eAC5B7xJ,KAAK4xJ,eAAyB,SAAEvzJ,MAAQ2B,KAAKywJ,0BAA0B,GAAGt5I,QAEtEnX,KAAKy4B,gBACLC,EAASK,gBAAgB,MACzBL,EAASM,OAAOh5B,KAAK+/D,QAAS//D,KAAKw5B,YAEnCd,EAASK,gBAAgBF,GACzBH,EAASM,OAAOh5B,KAAK+/D,QAAS//D,KAAKw5B,WAK3C,yBAAyBw4H,GACrB,OAAO,IAAI5yJ,EAAM0Y,eAAe,CAC5BtM,QAAS,CACLymJ,cAAeD,EACfE,MAAOF,GAGXh6I,SAAU,CACNm6I,aAAc,CAAE9zJ,MAAO,MACvB+zJ,QAAS,CAAE/zJ,MAAO,IAAIe,EAAMoG,QAAQ,GAAK,KACzCuqD,UAAW,CAAE1xD,MAAO,IAAIe,EAAMoG,QAAQ,GAAK,MAG/C4zB,aAAc,oLAMdC,eAAgB,qpCA4BxB,qBAAqBg5H,GACjB,OAAO,IAAIjzJ,EAAM0Y,eAAe,CAC5BtM,QAAS,CACL8mJ,SAAUD,GAGdr6I,SAAU,CACNu6I,aAAc,CAAEl0J,MAAO,MACvBm0J,aAAc,CAAEn0J,MAAO,MACvBo0J,aAAc,CAAEp0J,MAAO,MACvBq0J,aAAc,CAAEr0J,MAAO,MACvBs0J,aAAc,CAAEt0J,MAAO,MACvBu0J,YAAa,CAAEv0J,MAAO,MACtBw0J,cAAe,CAAEx0J,MAAO,GACxBy0J,aAAc,CAAEz0J,MAAO,MACvB00J,gBAAiB,CAAE10J,MAAO,MAC1B20J,YAAa,CAAE30J,MAAO,IAG1B+6B,aAAc,oMAMdC,eAAgB,izCArT5B,e,4ICUA,oCAAyCyR,GACrC,OACIA,GACiB,6BAAjBA,EAAQl7B,MACRxO,MAAMC,QAAQypC,EAAQhrC,eAI9B,qCAA0CgrC,GACtC,OACIA,GACiB,8BAAjBA,EAAQl7B,MACRxO,MAAMC,QAAQypC,EAAQm4D,wB,+GChC9B,aACA,QACA,QAcA,MAAagwD,EAiCT,YAAY96H,EAA+BjqB,GACvC,GAfI,KAAAglJ,WAAyC,IAAI/wJ,IAE7C,KAAAgxJ,WAAwB,GAmGhC,KAAA9gH,OAAS,KACL,MAAM+gH,EAAsBpzJ,KAAKmzJ,WAC5BptJ,IAAImI,GAAWA,EAAQs2B,eACvBhG,OAAO,EAAAk4C,cAAcC,YAAa32E,KAAKqzJ,YAAc,IAI1D,GAAmC,IAA/BD,EAAoB9xJ,OAEpB,YADAtB,KAAKszJ,UAAUvtI,MAAMwtI,QAAU,QAMnC,GAHIvzJ,KAAKszJ,UAAUvtI,MAAMwtI,QAAU,QAGN,IAAzBvzJ,KAAKkzJ,WAAW9xI,KAChB,IAAK,MAAMknE,KAAc8qE,EAAqB,CAC1C,MAAMI,EAAWxzJ,KAAKkzJ,WAAWj1J,IAAIqqF,EAAWv5D,SAC/B/sB,IAAbwxJ,IACAlrE,EAAWG,KAAO,EAAA7Z,eAAe0Z,EAAWG,KAAM+qE,EAAS/qE,MAC3DH,EAAWtiF,MAAQ,EAAA4oE,eAAe0Z,EAAWtiF,MAAOwtJ,EAASxtJ,OAC7DsiF,EAAWI,KAAO,EAAA9Z,eAAe0Z,EAAWI,KAAM8qE,EAAS9qE,OAIvE,MAAM+qE,EAAU,EAAA/8E,cAAcC,YAAYy8E,GAE1CpzJ,KAAKszJ,UAAUI,UAAY,EAAAh9E,cAAciS,aAAa8qE,IAhH/B,iBAAZt7H,EAAsB,CAC7B,MAAMw7H,EAAct6C,SAAS4hB,eAAe9iG,GAC5C,IAAKw7H,EACD,MAAM,IAAIlwJ,MAAM,wDAAwD00B,KAE5En4B,KAAKszJ,UAAYK,OAEjB3zJ,KAAKszJ,UAAYn7H,OAGLn2B,IAAZkM,GACAlO,KAAKirE,OAAO/8D,GArCpB,eAAeiqB,EAA+BjqB,GAC1C,OAAO,IAAI+kJ,EAAwB96H,EAASjqB,GA2ChD,UACI,IAAK,MAAMA,KAAWlO,KAAKmzJ,WACvBjlJ,EAAQu5D,oBAAoB,EAAA5L,kBAAkB6B,iBAAkB19D,KAAKqyC,QAO7E,OAAOnkC,GAMH,OALAlO,KAAKmzJ,WAAWjtJ,KAAKgI,GAErBA,EAAQ61D,iBAAiB,EAAAlI,kBAAkB6B,iBAAkB19D,KAAKqyC,QAClEryC,KAAKqyC,SAEEryC,KAMX,OAAOkO,GAMH,OALAA,EAAQu5D,oBAAoB,EAAA5L,kBAAkB6B,iBAAkB19D,KAAKqyC,QAErEryC,KAAKmzJ,WAAanzJ,KAAKmzJ,WAAW3gI,OAAOqhG,GAAQA,IAAS3lH,GAC1DlO,KAAKqyC,SAEEryC,KAYX,YAAYwzJ,GAER,GADAxzJ,KAAKkzJ,WAAWltH,aACChkC,IAAbwxJ,EACA,IAAK,MAAM3/B,KAAQ2/B,EACfxzJ,KAAKkzJ,WAAWlsJ,IAAI6sH,EAAK9kG,GAAI8kG,GAIrC,OAAO7zH,KAaX,sBAAsBqzJ,GAElB,OADArzJ,KAAKqzJ,WAAaA,EACXrzJ,MAlHf,6B,+IChBA,aACA,OACA,OACA,QAEM4zJ,EAAwB,CAAC,IAAI,EAAAjuJ,QAAW,IAAI,EAAAA,SAElD,IAAYw9E,GAAZ,SAAYA,GAIR,iBAIA,iCARJ,CAAYA,EAAA,EAAAA,kBAAA,EAAAA,gBAAe,KAe3B,MAAaD,UAA8C,EAAA2wE,oBAcvD,YACa7wE,EACA9sD,EACA49H,EAAmC3wE,EAAgBC,IACnDj0E,GAETnM,QALS,KAAAggF,cACA,KAAA9sD,SACA,KAAA49H,kBACA,KAAA3kJ,aAIT,EAAA7C,OACI6C,EAAWS,OAAS,EAAAC,eAAeC,OACnC,0EAGJ,MAAMilB,EAAY5lB,EAAWsB,aAAaylB,EAAOnB,UAAW6+H,EAAsB,IAC5E9+H,EAAY3lB,EAAWsB,aAAaylB,EAAOpB,UAAW8+H,EAAsB,IAClF5zJ,KAAK+zJ,eAAiB,CAClBnqJ,IAAK,CACDnE,EAAG4D,KAAKO,IAAImrB,EAAUtvB,EAAGqvB,EAAUrvB,GACnCC,EAAG2D,KAAKO,IAAImrB,EAAUrvB,EAAGovB,EAAUpvB,GACnCE,EAAGyD,KAAKO,IAAImrB,EAAUnvB,EAAGkvB,EAAUlvB,IAEvCkE,IAAK,CACDrE,EAAG4D,KAAKS,IAAIirB,EAAUtvB,EAAGqvB,EAAUrvB,GACnCC,EAAG2D,KAAKS,IAAIirB,EAAUrvB,EAAGovB,EAAUpvB,GACnCE,EAAGyD,KAAKS,IAAIirB,EAAUnvB,EAAGkvB,EAAUlvB,KAG3C5F,KAAKg0J,cAAgBh0J,KAAK+zJ,eAAejqJ,IAAIrE,EAAIzF,KAAK+zJ,eAAenqJ,IAAInE,GAAKu9E,EAC9EhjF,KAAKi0J,cAAgBj0J,KAAK+zJ,eAAejqJ,IAAIpE,EAAI1F,KAAK+zJ,eAAenqJ,IAAIlE,GAAKs9E,EAG1EhjF,KAAK8zJ,kBAAoB3wE,EAAgBC,MACzCpjF,KAAKg0J,cAAgB,IACrBh0J,KAAKi0J,cAAgB,KAEzBj0J,KAAKk0J,YAAc7qJ,KAAK+H,KACpBpR,KAAKg0J,aAAeh0J,KAAKg0J,aAAeh0J,KAAKi0J,aAAej0J,KAAKi0J,cAOzE,gBACI,OAAOj0J,KAAKk0J,YAMhB,iBACI,OAAOl0J,KAAKg0J,aAMhB,iBACI,OAAOh0J,KAAKi0J,aAIN,oBAAoBzqJ,EAAYE,EAAYjM,GAClD,MAAM02J,EAAgBn0J,KAAKo0J,gBAAgB5qJ,EAAGE,GACxC2qJ,EAAgBr0J,KAAKo0J,gBAAgB1qJ,EAAGjM,GACxC62J,EAAgBt0J,KAAKo0J,gBAAgB32J,EAAG+L,GAG9C,KAFoB2qJ,GAAiBE,GAAiBC,GAGlD,OAGJ,MAAMC,EAAK/qJ,EAAEkS,WAAWhS,GAClB8qJ,EAAK9qJ,EAAEgS,WAAWje,GAClBg3J,EAAKh3J,EAAEie,WAAWlS,GAClBkrJ,EAAcrrJ,KAAKS,IACrBqqJ,EAAgBI,EAAK,EACrBF,EAAgBG,EAAK,EACrBF,EAAgBG,EAAK,GAEzB,GAAIF,IAAOG,EACP,OAAO,EACJ,GAAIF,IAAOE,EACd,OAAO,EACJ,GAAID,IAAOC,EACd,OAAO,EAGX,MAAM,IAAIjxJ,MAAM,6BAGZ,gBAAgB+F,EAAYE,GAChC,OAAQ1J,KAAK8zJ,iBACT,KAAK3wE,EAAgBC,IACjB,OACK55E,EAAE9D,IAAMgE,EAAEhE,GAAK2D,KAAK2S,IAAIxS,EAAE/D,EAAIiE,EAAEjE,GAAKzF,KAAKg0J,cAC1CxqJ,EAAE/D,IAAMiE,EAAEjE,GAAK4D,KAAK2S,IAAIxS,EAAE9D,EAAIgE,EAAEhE,GAAK1F,KAAKi0J,cAC3CzqJ,EAAEkS,WAAWhS,GAAK1J,KAAKk0J,YAE/B,KAAK/wE,EAAgBwxE,YACjB,OACKnrJ,EAAE9D,IAAMgE,EAAEhE,GAAK2D,KAAK2S,IAAIxS,EAAE/D,EAAIiE,EAAEjE,GAAKzF,KAAKg0J,cAC1CxqJ,EAAE/D,IAAMiE,EAAEjE,GAAK4D,KAAK2S,IAAIxS,EAAE9D,EAAIgE,EAAEhE,GAAK1F,KAAKi0J,eApH/D,2C,4HCtBA,aACA,OACA,QAEML,EAAwB,CAAC,IAAI,EAAAjuJ,QAAW,IAAI,EAAAA,QAAW,IAAI,EAAAA,SAMjE,MAAam9E,UAA6C,EAAA+wE,oBAOtD,YAAqBr+B,EAAwBrmH,EAAyB,EAAA4pF,kBAClE/1F,QADiB,KAAAwyH,QAAwB,KAAArmH,aAKnC,oBAAoB3F,EAAYE,EAAYjM,GAClD,MAAMm3J,EAAK,EAAA77D,iBAAiBp9D,eAAe37B,KAAKmP,WAAY3F,EAAGoqJ,EAAsB,IAC/EiB,EAAK,EAAA97D,iBAAiBp9D,eAAe37B,KAAKmP,WAAYzF,EAAGkqJ,EAAsB,IAC/EkB,EAAK,EAAA/7D,iBAAiBp9D,eAAe37B,KAAKmP,WAAY1R,EAAGm2J,EAAsB,IAE/EtgG,EAAQshG,EAAGnjJ,QAAQojJ,GACnBE,EAAOF,EAAGpjJ,QAAQqjJ,GAClBE,EAAQF,EAAGrjJ,QAAQmjJ,GAGnBp3J,EAAI6L,KAAKS,IAAIwpD,EAAOjqD,KAAKS,IAAIirJ,EAAMC,IAGzC,KAAIx3J,EAAIwC,KAAKw1H,OAAb,CAIA,GAAIh4H,IAAM81D,EACN,OAAO,EACJ,GAAI91D,IAAMu3J,EACb,OAAO,EACJ,GAAIv3J,IAAMw3J,EACb,OAAO,EAGX,MAAM,IAAIvxJ,MAAM,8BArCxB,0C,qGCVA,aACA,OACA,OACA,QACA,SAsBA,MAAamwB,UAAsBx0B,EAAM40B,KAsCrC,YACI9Z,EACAzP,EACQwqJ,EACAC,GAMRlyJ,MAAMkX,EAAUzP,GAPR,KAAAwqJ,yBACA,KAAAC,oBAvCJ,qCACJh7I,EACAlB,GAmBA,OAfK4a,EAAcm2E,mBAQfn2E,EAAcm2E,mBAAmBvhE,MAC7BtuB,EAASO,WAAW1M,SACpBmM,EAASO,WAAWlF,OACpB2E,EAASO,WAAWusF,GACpBhuF,GAXJ4a,EAAcm2E,mBAAqB,IAAI,EAAAlC,yBACnC3tF,EAASO,WAAW1M,SACpBmM,EAASO,WAAWlF,OACpB2E,EAASO,WAAWusF,GACpBhuF,GAUD4a,EAAcm2E,mBA6BzB,QAAQ1kB,EAA4BC,GAEhC,MAAM6vE,EAAgBn1J,KAAKm1J,cAI3B,IA/ER,SAAgC1qJ,GAC5B,MAAM2qJ,EAAwB,EAAApnD,uBAAuBvjG,GAErD,OADA,EAAA6B,OAAO8oJ,EAAuB,gDACvBA,EA6EEC,CAAuBF,KA1EpC,SAA0BpvJ,GACtB,IAAKA,EACD,OAAO,EAEX,MAAMuvJ,EAAgBvvJ,aAAe3G,EAAMuyB,YAE3C,OADA,EAAArlB,OAAOgpJ,EAAe,gDACfA,EAqEEC,CAAiBJ,EAAcn8I,iBAGhC,YADAhW,MAAMkxB,QAAQmxD,EAAWC,GAG7B,MAAMtsE,EAAkBm8I,EAAcn8I,gBAChCuwF,EAAoB,OAAH,UAAQvpG,KAAKi1J,0BAEpC,EAAA3oJ,OAAOtM,KAAKka,oBAAoB9a,EAAMob,eAAgB,8BACtD,MAAMN,EAAWla,KAAKka,SAClBla,KAAKw1J,kBACLx1J,KAAKw1J,kBAAkBhtH,MAAMtuB,EAAUlB,EAAiBuwF,GAExDvpG,KAAKw1J,kBAAoB,IAAI,EAAA3rD,wBACzB3vF,EACAlB,EACAuwF,EACA31E,EAAc6hI,8BAA8Bv7I,EAAUlB,IAK9DhZ,KAAKka,SAAWla,KAAKw1J,kBACjBx1J,KAAKk1J,kBACLl1J,KAAKk1J,kBAAkBl1J,KAAMqlF,EAAWC,GAExCtiF,MAAMkxB,QAAQmxD,EAAWC,GAE7BtiF,MAAMkX,SAAWla,KAAKw1J,kBAAkB1rD,iBAG5C,oBACI,OAAO1oG,MAAMC,QAAQrB,KAAKyK,UAAYzK,KAAKyK,SAAS,GAAKzK,KAAKyK,UA7FtE,mB,mGCzBA,aAGA,IAAKirJ,GAAL,SAAKA,GACD,2BACA,2BACA,2BACA,aACA,aACA,aACA,qBAPJ,CAAKA,MAAK,KAgBV,oBAUI,YAAqBC,GAAA,KAAAA,iBATb,KAAAxtD,QAAoB,GACpB,KAAAytD,cAAwB,EACxB,KAAAC,YAAsB,EACtB,KAAAC,YAAsB,EAO1B91J,KAAKmoG,QAAQ7mG,OAAStB,KAAK21J,eAAiBD,EAAMK,MAClD/1J,KAAKgmC,QAMT,QACIhmC,KAAKmoG,QAAQ5gD,MAzBG,GA0BhBvnD,KAAK41J,cAAgB,EASzB,IAAII,EAAkBC,GAClB,MAAMC,EAAYl2J,KAAKk4B,KAAK89H,GAC5B,YAAkBh0J,IAAdk0J,IAGJl2J,KAAK2hJ,aAAauU,GAClBl2J,KAAKm2J,UAAUD,EAAWD,IACnB,GAQX,IAAID,EAAkBC,GAClB,IAAIC,GAnDY,EAoDZl2J,KAAK41J,cAAgB51J,KAAK21J,gBAC1BO,EAAYl2J,KAAK41J,cAAgBF,EAAMK,MACvC/1J,KAAK41J,iBAELM,EAAYl2J,KAAK61J,YAEM,IAAvB71J,KAAK41J,cACL51J,KAAK61J,YAAc71J,KAAK81J,YAAcI,EAEtCl2J,KAAK2hJ,aAAauU,GAEtBl2J,KAAKo2J,UAAUF,EAAWF,EAAUC,GAGhC,KAAKD,GACT,MAAM50I,EAAOphB,KAAKmoG,QAAQ7mG,OAC1B,IAAK,IAAIlE,EAAI,EAAGA,EAAIgkB,EAAMhkB,GAAKs4J,EAAMK,MACjC,GAAI/1J,KAAKmoG,QAAQ/qG,KAAO44J,EACpB,OAAO54J,EAKX,aAAa84J,GACjB,GAAIA,IAAcl2J,KAAK81J,YACnB,OAGJ,MAAMO,EAAWr2J,KAAKs2J,YAAYJ,GAC5BK,EAAWv2J,KAAKw2J,YAAYN,IAjFlB,IAkFZG,IACA,EAAA/pJ,OAAOtM,KAAKw2J,YAAYH,KAAcH,GACtCl2J,KAAKy2J,YAAYJ,EAAUE,KApFf,IAsFZA,IACA,EAAAjqJ,OAAOtM,KAAKs2J,YAAYC,KAAcL,GACtCl2J,KAAK02J,YAAYH,EAAUF,IAE3BH,IAAcl2J,KAAK61J,cACnB71J,KAAK61J,YAAcQ,GAGvBr2J,KAAK02J,YAAYR,GA9FD,GA+FhBl2J,KAAKy2J,YAAYP,EAAWl2J,KAAK81J,aAEjC,EAAAxpJ,QAjGgB,IAiGTtM,KAAK81J,aACZ,EAAAxpJ,QAlGgB,IAkGTtM,KAAKs2J,YAAYt2J,KAAK81J,cAC7B91J,KAAK02J,YAAY12J,KAAK81J,YAAaI,GACnCl2J,KAAK81J,YAAcI,EAEf,YAAYA,GAChB,OAAOl2J,KAAKmoG,QAAQ+tD,EAAYR,EAAMiB,UAElC,YAAYT,EAAmBK,GACnCv2J,KAAKmoG,QAAQ+tD,EAAYR,EAAMiB,UAAYJ,EAEvC,YAAYL,GAChB,OAAOl2J,KAAKmoG,QAAQ+tD,EAAYR,EAAMkB,UAElC,YAAYV,EAAmBG,GACnCr2J,KAAKmoG,QAAQ+tD,EAAYR,EAAMkB,UAAYP,EAEvC,UAAUH,EAAmBD,GACjCA,EAAOxwJ,EAAIzF,KAAKmoG,QAAQ+tD,EAAYR,EAAMmB,GAC1CZ,EAAOvwJ,EAAI1F,KAAKmoG,QAAQ+tD,EAAYR,EAAMoB,GAC1Cb,EAAOrwJ,EAAI5F,KAAKmoG,QAAQ+tD,EAAYR,EAAMxmB,GAEtC,UAAUgnB,EAAmBF,EAAkBC,GACnDj2J,KAAKmoG,QAAQ+tD,GAAaF,EAC1Bh2J,KAAKmoG,QAAQ+tD,EAAYR,EAAMmB,GAAKZ,EAAOxwJ,EAC3CzF,KAAKmoG,QAAQ+tD,EAAYR,EAAMoB,GAAKb,EAAOvwJ,EAC3C1F,KAAKmoG,QAAQ+tD,EAAYR,EAAMxmB,GAAK+mB,EAAOrwJ,K,qGCzInD,aACA,OACA,OACA,OACA,SAEMmxJ,EAAY,IAAI33J,EAAM2N,OACtBiqJ,EAAmB,IAAI53J,EAAMsO,QAC7BupJ,EAAS,IAAI73J,EAAM83J,IACnBC,EAAW,IAAI/3J,EAAMg4J,MACrB/tD,EAAS,IAAIjqG,EAAMm7B,KACnBysD,EAAS,IAAI,EAAA3lD,aACbg2H,EAAW,IAAIj4J,EAAMwN,MACrBu8F,EAAQ,IAAI/pG,EAAMuG,QAClByjG,EAAQ,IAAIhqG,EAAMuG,QAClB2xJ,EAAQ,IAAIl4J,EAAMuG,QAClB4xJ,EAAQ,IAAIn4J,EAAMuG,QAuBxB,SAAS6xJ,EACLt9I,EACAu9I,EACAC,GAEA,IAAInuD,EAEArvF,aAAoB,EAAA2vF,0BACpBN,EAAoBrvF,EAASqvF,kBAC7BrvF,EAAWA,EAAS4vF,kBAGxB,MACMj9B,EADa3yD,EAASO,WACL1M,SACjB23E,EAAUxrE,EAASQ,MAAOf,MAC1Bg+I,EAAS,IAAIv4J,EAAM2N,OACnB6tG,EAAOvR,EAAOuuD,YACd3B,EAAS9sD,EAGf,IAAK,IAAI/rG,EAAIq6J,EAAmBr6J,EAAIs6J,EAAiBt6J,GAvClC,EAwCfw9G,EAAKhqC,cAAcqlF,EAAOjtD,oBAAoBn8B,EAAK6Y,EAAQtoF,KAC3Dw9G,EAAKhqC,cAAcqlF,EAAOjtD,oBAAoBn8B,EAAK6Y,EAAQtoF,EAtC7C,KAyClB,GAAImsG,EAAmB,CAanB,MAAMh0F,EAAS6zF,EAEf,OADA7zF,EAAOyzF,oBAAoB9uF,EAASO,WAAWlF,OAAiC,GACzE,EAAA+zF,YAAYsR,EAAMrR,EAAmBh0F,GAAQi1F,kBAAkBmtD,GAG1E,OAAO/8C,EAAKpQ,kBAAkBmtD,GAmElC,SAASE,EACL9nJ,EACA2kC,EACAojH,EACAC,EACAC,EACAj3B,EACAk3B,EACAC,GAEA,GAAID,EAAW19D,OAAOxqF,EAAIy1E,SAA+C,IAApCz1E,EAAIggD,UAAUr6C,IAAIqrH,EAAMxrH,QAAe,CAGxE,MAAM4iJ,EApEd,SACIpoJ,EACA2kC,EACAojH,EACAviJ,EACAwiJ,G,MAEA,MAAMhzI,EAAMiiE,EAOZ,OANAtyC,EAAKu6B,UAAUlqD,EAAIhX,UACnB2mC,EAAK5b,MAAM/T,EAAInX,OAAOiD,YACtBkU,EAAIlX,MAAMyB,KAAKwoJ,GACf/yI,EAAIjX,MAAMwB,KAAKiG,GACfwP,EAAIC,QAAQhe,IAAI0tC,EAAK1lC,WAAa,EAAG+oJ,EAAQA,GAEzChzI,EAAIqpF,SAASr+F,EAAIy1E,QACV,EAEkB,QAA7B,EAAOzgE,EAAIsiE,cAAct3E,UAAI,QAAIlG,IAmDXuuJ,CAAsBroJ,EAAK2kC,EAAMojH,EAAY/2B,EAAMxrH,OAAQwiJ,GACvEM,EA1Cd,SAAgCtoJ,EAAgB2kC,EAAmBqjH,GAC/D,MAAMJ,EAAS,IAAIv4J,EAAM2N,OAAO2nC,EAAK3K,MAAOguH,GACtCO,EAAYX,EAAOY,cAAcxoJ,EAAIy1E,QACrC,EACAz1E,EAAIE,gBAAgB0nJ,EAAQJ,GAC5BA,EAAMzkJ,IAAI/C,EAAIy1E,QAAQlkF,SACtBuI,IACN8tJ,EAAO16I,OAAO3N,KAAKolC,EAAKE,KACxB,MAAMyjH,EAAUV,EAAOY,cAAcxoJ,EAAIy1E,QACnC,EACAz1E,EAAIE,gBAAgB0nJ,EAAQJ,GAC5BA,EAAMzkJ,IAAI/C,EAAIy1E,QAAQlkF,SACtBuI,IACN,OAAOR,KAAKO,IAAI0uJ,EAAWD,GA6BPG,CAAuBzoJ,EAAK2kC,EAAMqjH,GAE5Cn/C,EAAOvvG,KAAKO,IAAIuuJ,EAAWE,GACjC,OAAIz/C,IAAS/uG,MAGbkG,EAAIs7H,GAAGzyB,EAAMs/C,IACN,GAOX,QAFeD,EAAWQ,kBAAkB/jH,EAAKgkH,oBAAoBT,GAAY,EAAMV,IAE1ES,KAGbE,EAAa5oJ,KAAK2oJ,IACX,GAiBX,SAASU,EACLj3I,EACA2jE,EACAuzE,EACAC,EACAC,EACAC,EACAC,EACAhlG,EACAilG,EACAC,GAEA,MAAMC,EAAOhwD,EACP43B,EAAQs2B,EACRY,EAAa7uD,EACb10D,EAAOyiH,EAEPj9I,EAAWwH,EAAKxH,SAChBO,EAAaP,EAASO,WACtB1M,EAAW0M,EAAW1M,SACtBqrJ,EAAY3+I,EAAW2+I,UACvB1zE,EAAUxrE,EAASQ,MAAOf,MAMhC,GAJAo9I,EAAUznJ,KAAK2pJ,GACflC,EAAU9kJ,aAAayP,EAAK3P,aAC5BglJ,EAAUrnJ,QAAUmpJ,EAEfxzE,EAAUt1E,IAAIspJ,iBAAiBtC,GAIpC,IAAK,IAAI35J,EAAI47J,EAAU57J,EAAI42D,EAAQ52D,GAjNhB,EAiNqC,CACpD,MAAMoM,EAAIk8E,EAAQtoF,GACZsM,EAAIg8E,EAAQtoF,EAhNJ,GAwNd,GAJAs3C,EAAK3K,MAAMi/D,oBAAoBj7F,EAAUvE,GACzCkrC,EAAKE,IAAIo0D,oBAAoBj7F,EAAUrE,GACvCyvJ,EAAKnyJ,IAAIoyJ,EAAUjlG,KAAK3qD,GAAI4vJ,EAAUhlG,KAAK5qD,GAAI4vJ,EAAUx8E,KAAKpzE,IAAIqH,YAClEkwH,EAAM3uH,sBAAsBsiC,EAAK3K,MAAOutH,EAAMhoJ,KAAKolC,EAAK3K,OAAO5pC,IAAIg5J,GAAOzkH,EAAKE,KACxC,IAAnCmsF,EAAMxrH,OAAO+jJ,kBAMb,SAIJ,IAAKV,EAAS5oJ,eAAe+wH,EAAOk3B,GAChC,SAGJ,MAAMsB,EAAYjC,EAClB,IACKO,EACGe,EACAlkH,EACAykH,EACAL,EACAC,EACAh4B,EACAk3B,EACAsB,GAGJ,SAIJ,MAAMC,EAAiBD,EAAUtnJ,aAAayP,EAAK3P,aAE7C/C,EAAWq2E,EAAUt1E,IAAIy1E,OAAO9pE,WAAW89I,GAE7CxqJ,EAAWq2E,EAAU3mE,MAAQ1P,EAAWq2E,EAAU1mE,KAItDu6I,EAAchzJ,KAAK,CACf8I,WACAwC,MAAOgoJ,EAAe3sJ,QACtB6N,MAAOtd,EACP0B,OAAQ4iB,KAKpB,MAAM+3I,EAAqB,CAAC,GAc5B,SAASC,EACLh4I,EACAjX,EACA46E,EACAuzE,EACAe,EACAC,EACAV,G,MAEA,MAAMW,EAAWn4I,EAAKI,SAASC,QAAQ+3I,gBACvC,EAAAxtJ,OAAOoV,EAAKxH,oBAAoB9a,EAAMob,eAAgB,8BACtD,MAAMN,EAAWwH,EAAKxH,SACtB,EAAA5N,OAhSJ,SAA6B7B,GACzB,OAAOrJ,MAAMC,QAAQoJ,GACfA,EAAS1F,MAAMgpG,GAAOA,aAAe,EAAArhF,mBACrCjiB,aAAoB,EAAAiiB,kBA6RnBqtI,CAAoBtvJ,GAAW,6BACtC,MAAMuvJ,EAAoBvvJ,EAEpBouJ,GAAamB,EAAkBnuI,UAAYmuI,EAAkB5mI,cAAgB,EAEnF,EAAA9mB,OAAOjD,KAAK2S,IAAI,EAAI0F,EAAKo/B,MAAMr7C,EAAIic,EAAKo/B,MAAMp7C,GA9BrB,KA+BzB,EAAA4G,OAAOjD,KAAK2S,IAAI,EAAI0F,EAAKo/B,MAAMr7C,EAAIic,EAAKo/B,MAAMl7C,GA/BrB,KAgCzB,EAAA0G,OAAOjD,KAAK2S,IAAI,EAAI0F,EAAKo/B,MAAMp7C,EAAIgc,EAAKo/B,MAAMl7C,GAhCrB,KAiCzB,MAAMq0J,EAAiBpB,IAAcn3I,EAAKo/B,MAAMr7C,EAAIic,EAAKo/B,MAAMp7C,EAAIgc,EAAKo/B,MAAMl7C,GAAK,GAC7Es0J,EAAmBD,EAAiBA,EACpCn7E,EAA4C,QAA/B,EAAGp9D,EAAKI,SAASC,QAAQ0e,cAAM,QAAIg5H,EAEtD,IAAIU,EAAaR,EACbX,EAAWl6E,EAAcq7E,GAC7B,MAAMC,EAAiBt7E,EAAcx9E,OAAS,EAE9C,KAAO03J,EAAWY,GAAa,CAC3B,MAAMS,EAAaF,EACbnmG,EAASmmG,EAAaC,EAAiBt7E,IAAgBq7E,GAAcP,EACvES,GAAcR,EAASv4J,QAIvBu4J,EAAS3zJ,KAAKsxJ,EAA6Bt9I,EAAU8+I,EAAUhlG,IAEnE2kG,EACIj3I,EACA2jE,EACAuzE,EACAC,EACAoB,EACAC,EACAlB,EACAhlG,EACA6lG,EAASQ,GACTnB,GAEJF,EAAWhlG,EAEf,OAAOmmG,EAQX,MAAalmI,UAAsB70B,EAAM40B,KASrC,eACItS,EACA2jE,EACA6zE,GAEA,EAAA5sJ,OAAOoV,EAAKxH,oBAAoB9a,EAAMob,eAAgB,6BACtD,MAAMN,EAAWwH,EAAKxH,SACtB,EAAA5N,OAA0B,OAAnB4N,EAASQ,MAAgB,kCAChC,MAAM3I,EAAc2P,EAAK3P,YAEzBilJ,EAAiB9iJ,WAAWnC,GAC5B,MAAM6mJ,EAAW3B,EAAO3nJ,KAAK+1E,EAAUt1E,KAAKkC,aAAa+kJ,GAGpDt1I,EAAKI,SAASC,UACfL,EAAKI,SAASC,QAAU,IAEvBL,EAAKI,SAASC,QAAQ+3I,kBACvBp4I,EAAKI,SAASC,QAAQ+3I,gBAAkB,IAE5C,MAAMp0E,EAAUxrE,EAASQ,MAAOf,MAEhC,GAAIvY,MAAMC,QAAQqgB,EAAKjX,UAAW,CAC9B,IAAI6vJ,EAAiB,EACrB,IAAK,MAAM33H,KAASzoB,EAAS0oB,OAAQ,CAGjC03H,EAAiBZ,EACbh4I,EAHaA,EAAKjX,SAASk4B,EAAMkqE,eAKjCxnB,EACAuzE,EACA0B,EANgB33H,EAAMoH,MAAQpH,EAAM5oB,MAQpCm/I,SAIRQ,EACIh4I,EACAA,EAAKjX,SACL46E,EACAuzE,EACA,EACAlzE,EAAQpkF,OACR43J,GAWZ,YAAYh/I,EAAgCzP,GACxCzH,MAAMkX,EAAUzP,GAKpB,QAAQ46E,EAA4BC,GAChCrxD,EAAcC,QAAQl0B,KAAMqlF,EAAWC,IAxE/C,mB,2GCvWA,aAYA,4BAcI,YAAqBh0E,GAAA,KAAAA,SACjBtR,KAAK20C,iBAAmB,IAAIvzC,MAAmBkQ,EAAOhQ,QAAU,EAAIgQ,EAAOhQ,OAAS,EAAI,GACxF,IAAK,IAAIlE,EAAI,EAAGA,EAAI4C,KAAK20C,iBAAiBrzC,OAAQlE,IAC9C4C,KAAK20C,iBAAiBv3C,GAAK,IAAIgC,EAAMg4J,MAAM,IAAIh4J,EAAMuG,QAAW,IAAIvG,EAAMuG,Y,iHC/BtF,aACA,OAGA,SAmEA,MAAa40J,UAAsBn7J,EAAM40B,KACrC,YAAY9Z,EAAgCzP,GACxCzH,MAAMkX,EAAUzP,GAEhBzK,KAAK4P,KAAO,gBAQhB,cACI,QAAsB5N,IAAlBhC,KAAKka,SACL,OAAO,EACJ,CACH,MAAMC,EAAiBna,KAAKka,SAC5B,OAAgC,OAAzBC,EAAeO,OAAiD,IAA/BP,EAAeO,MAAMX,QAjBzE,kBA0BA,MAAa+7F,EA2CT,YACarrG,EACA6b,EAAsB,EACtBk0I,EA3Ha,EA4HbC,EAvHW,OAoHX,KAAAhwJ,WACA,KAAA6b,cACA,KAAAk0I,oBACA,KAAAC,kBAdL,KAAA1Z,OAAiB,EAgBrB/gJ,KAAK06J,aAAaF,GAClBx6J,KAAK26J,UAAY,IAAIv5J,MAQzB,QACI,OAAO,IAAI00G,EAAU91G,KAAKyK,SAAUzK,KAAKsmB,aAM7C,eAC0BtkB,IAAlBhC,KAAKka,WACLla,KAAKka,SAASurB,UACdzlC,KAAKka,cAAWlY,GAEpBhC,KAAK46J,kBAAe54J,EAMxB,WACI,OAAOhC,KAAK+gJ,OAMhB,aACmC/+I,IAA3BhC,KAAK+rF,oBACL/rF,KAAK+rF,kBAAkBhyE,MAAQ,EAC/B/Z,KAAKkgF,eAAgBnmE,MAAQ,EAC7B/Z,KAAKqgF,YAAatmE,MAAQ,EAC1B/Z,KAAK66J,eAAgB9gJ,MAAQ,EAC7B/Z,KAAK26J,UAAWr5J,OAAS,GAYjC,eAAew5J,EAAa,GACxB,MAAMD,EAAiB76J,KAAK66J,eAC5B,GACIA,EAAe9gJ,MAtKK,EAsKG+gJ,GACvBD,EAAelhJ,MAAMrY,OACvB,CAEE,GAAIu5J,EAAelhJ,MAAMrY,QA1KL,EA0KetB,KAAKy6J,gBACpC,OAAO,EAGX,MAAMpoG,EAAUhpD,KAAKO,IAAI5J,KAAKy6J,gBAA+B,IAAdz6J,KAAKohB,KAAa,IAAkB,EAAZphB,KAAKohB,MAC5EphB,KAAKi1E,OAAO5iB,GAEhB,OAAO,EAMX,YAQI,MAPqB,CACjB0oG,uBAAwB/6J,KAAK+rF,kBAAmBhyE,MAChDihJ,oBAAqBh7J,KAAKkgF,eAAgBnmE,MAC1CkhJ,iBAAkBj7J,KAAKqgF,YAAatmE,MACpCmhJ,oBAAqBl7J,KAAK66J,eAAgB9gJ,MAC1CohJ,cAAen7J,KAAK26J,UAAWr5J,QAUvC,aAAay8C,GACT/9C,KAAK+rF,kBAAmBhyE,MAAQgkC,EAAMg9G,uBACtC/6J,KAAKkgF,eAAgBnmE,MAAQgkC,EAAMi9G,oBACnCh7J,KAAKqgF,YAAatmE,MAAQgkC,EAAMk9G,iBAChCj7J,KAAK66J,eAAgB9gJ,MAAQgkC,EAAMm9G,oBACnCl7J,KAAK26J,UAAWr5J,OAASy8C,EAAMo9G,cAanC,OACI5kD,EACAG,EACAzrF,EACAC,EACAlc,EACAosJ,GAEA,IAAKp7J,KAAKq7J,iBACN,OAAO,EAGX,MAAM,GAAEriD,EAAE,GAAEC,EAAE,GAAEC,EAAE,GAAEC,GAAOzC,GACrB,EAAEjxG,EAAC,EAAEC,EAAC,EAAEI,EAAC,EAAEsmB,GAAMmqF,EAEjBr4G,EAAImL,KAAKggC,MAAgB,IAAVpe,EAAM/sB,GACrB2vB,EAAIxkB,KAAKggC,MAAgB,IAAVpe,EAAM4C,GACrBnkB,EAAIL,KAAKggC,MAAgB,IAAVpe,EAAMvhB,GACrBF,EAAIH,KAAKggC,MAAgB,IAAVne,GAEf6gE,EAAoB/rF,KAAK+rF,kBACzB7L,EAAiBlgF,KAAKkgF,eACtBG,EAAcrgF,KAAKqgF,YACnBw6E,EAAiB76J,KAAK66J,eAEtBtoG,EAAaw5B,EAAkBhyE,MAC/By4C,EAAYqoG,EAAe9gJ,MA+BjC,OA7BAgyE,EAAkBy0D,OAAOjuF,EAAY9sD,EAAGC,EAAGsJ,GAC3C+8E,EAAkBy0D,OAAOjuF,EAAa,EAAG9sD,EAAIK,EAAGJ,EAAGsJ,GACnD+8E,EAAkBy0D,OAAOjuF,EAAa,EAAG9sD,EAAGC,EAAI0mB,EAAGpd,GACnD+8E,EAAkBy0D,OAAOjuF,EAAa,EAAG9sD,EAAIK,EAAGJ,EAAI0mB,EAAGpd,GAEvDkxE,EAAeztB,QAAQF,EAAYr0D,EAAG2vB,EAAGnkB,EAAGF,GAC5C02E,EAAeztB,QAAQF,EAAa,EAAGr0D,EAAG2vB,EAAGnkB,EAAGF,GAChD02E,EAAeztB,QAAQF,EAAa,EAAGr0D,EAAG2vB,EAAGnkB,EAAGF,GAChD02E,EAAeztB,QAAQF,EAAa,EAAGr0D,EAAG2vB,EAAGnkB,EAAGF,GAEhD62E,EAAYogE,MAAMluF,EAAYymD,EAAIC,GAClC54B,EAAYogE,MAAMluF,EAAa,EAAG2mD,EAAID,GACtC54B,EAAYogE,MAAMluF,EAAa,EAAGymD,EAAIG,GACtC94B,EAAYogE,MAAMluF,EAAa,EAAG2mD,EAAIC,GAEtC0hD,EAAeloG,KAAKH,EAAWD,GAC/BsoG,EAAeloG,KAAKH,EAAY,EAAGD,EAAa,GAChDsoG,EAAeloG,KAAKH,EAAY,EAAGD,EAAa,GAChDsoG,EAAeloG,KAAKH,EAAY,EAAGD,EAAa,GAChDsoG,EAAeloG,KAAKH,EAAY,EAAGD,EAAa,GAChDsoG,EAAeloG,KAAKH,EAAY,EAAGD,EAAa,GAEhDw5B,EAAkBhyE,OAhRO,EAiRzBmmE,EAAenmE,OAjRU,EAkRzBsmE,EAAYtmE,OAlRa,EAmRzB8gJ,EAAe9gJ,OA9QS,EAgRxB/Z,KAAK26J,UAAUz0J,KAAKk1J,IAEb,EAOX,uBACI,MAAMrvE,EAAoB/rF,KAAK+rF,kBACzB7L,EAAiBlgF,KAAKkgF,eACtBG,EAAcrgF,KAAKqgF,YACnBw6E,EAAiB76J,KAAK66J,eAExB9uE,EAAkBhyE,MAAQ,IAC1BgyE,EAAkBx/E,aAAc,EAChCw/E,EAAkBj6B,YAAYjuC,OAAS,EACvCkoE,EAAkBj6B,YAAY/3C,MAvST,EAwSjBgyE,EAAkBhyE,OAGtBmmE,EAAenmE,MAAQ,IACvBmmE,EAAe3zE,aAAc,EAC7B2zE,EAAepuB,YAAYjuC,OAAS,EACpCq8D,EAAepuB,YAAY/3C,MA9SN,EA8ScmmE,EAAenmE,OAGlDsmE,EAAYtmE,MAAQ,IACpBsmE,EAAY9zE,aAAc,EAC1B8zE,EAAYvuB,YAAYjuC,OAAS,EACjCw8D,EAAYvuB,YAAY/3C,MApTH,EAoTWsmE,EAAYtmE,OAG5C8gJ,EAAe9gJ,MAAQ,IACvB8gJ,EAAetuJ,aAAc,EAC7BsuJ,EAAe/oG,YAAYjuC,OAAS,EACpCg3I,EAAe/oG,YAAY/3C,MAAQ8gJ,EAAe9gJ,YAGhC/X,IAAlBhC,KAAKka,WACLla,KAAKka,SAASq6D,cACdv0E,KAAKka,SAAS26D,SAAS,EAAG70E,KAAK66J,eAAgB9gJ,QAQvD,UAEuC,IAA/B/Z,KAAK66J,eAAgB9gJ,OAAe/Z,KAAKohB,KAnVvB,GAoVlBphB,KAAKs7J,kBAOb,cACI,OAAOt7J,KAAK46J,aAAcW,QAO9B,WAII,YAH0Bv5J,IAAtBhC,KAAK46J,cACL56J,KAAKi1E,SAEFj1E,KAAK46J,aAWhB,UACInsH,EACAwlB,EACAqhD,GAEA,MAAMz2G,EAAImB,KAAK26J,UAAUr5J,OACnBq5J,EAAY36J,KAAK26J,UACjBprG,EAAYvvD,KAAK+rF,kBACjB7E,EAAUz4C,EAAehpC,EACzB0hF,EAAU14C,EAAe/oC,EAEzB8oC,EAAS6qE,SAASC,cAAc,UACtC,IAAK,IAAIkiD,EAAgB,EAAGA,EAAgB38J,EAAG28J,IAAiB,CAC5D,MAAMtnG,EArXe,EAqXCsnG,EAEhB1mH,EAAOya,EAAU4E,KAAKD,GAC5B,GAAIgzB,EAAUpyC,EACV,SAGJ,MAAMC,EAAOwa,EAAU4E,KAAKD,EAAgB,GAC5C,GAAIgzB,EAAUnyC,EACV,SAGJ,MAAMC,EAAOua,EAAU6E,KAAKF,GAC5B,GAAIizB,EAAUnyC,EACV,SAGJ,MAAMlZ,EAAOyzB,EAAU6E,KAAKF,EAAgB,GAC5C,GAAIizB,EAAUrrD,EACV,SAGJ,MAAM9e,EAAM,IAAI,EAAAilC,OAAOkuD,IAAIr7D,EAAME,EAAMD,EAAOD,EAAMhZ,EAAOkZ,QAEzChzC,IAAdszG,QACqCtzG,IAArC24J,EAAUa,GAAep2I,cACkBpjB,IAA3C24J,EAAUa,GAAep2I,QAAQsxF,OACjC12G,KAAKy7J,mBACDnmD,EACApuB,EACAC,EACAnqE,EACA29I,EAAUa,GAAep2I,QAAQsxF,MACjCloE,SAMyBxsC,IAA7B24J,EAAUa,IACVvnG,EAAa0mG,EAAUa,KAenC,OAAOnpG,EAAkBqpG,GAuBrB,YAtBsB15J,IAAlBhC,KAAKka,UACLla,KAAKka,SAASurB,UAGlBzlC,KAAKka,SAAW,IAAI9a,EAAMob,oBAEVxY,IAAZqwD,KAA0C,IAAhBqpG,GAAwBrpG,EAAUryD,KAAKohB,OACjEphB,KAAK06J,aAAaroG,GAGtBryD,KAAKka,SAASu3C,aAAa,WAAYzxD,KAAK+rF,mBAC5C/rF,KAAKka,SAASu3C,aAAa,QAASzxD,KAAKkgF,gBACzClgF,KAAKka,SAASu3C,aAAa,KAAMzxD,KAAKqgF,aACtCrgF,KAAKka,SAASw3C,SAAS1xD,KAAK66J,gBAC5B76J,KAAKka,SAAS26D,SAAS,EAAG70E,KAAK66J,eAAgB9gJ,YAErB/X,IAAtBhC,KAAK46J,cACL56J,KAAK46J,aAAe,IAAIL,EAAcv6J,KAAKka,SAAUla,KAAKyK,UAC1DzK,KAAK46J,aAAat0I,YAActmB,KAAKsmB,aAErCtmB,KAAK46J,aAAa1gJ,SAAWla,KAAKka,SAE/Bla,KAAK46J,aAQhB,kBAAkBvmG,GACd,MAAM7zB,EAlcyB,EAmc3BxgC,KAAK+rF,kBAAmBhyE,MA/aR,EAfQ,EA+bxB/Z,KAAKkgF,eAAgBnmE,MA1bA,EA2brB/Z,KAAKqgF,YAAatmE,MAjbF,EAKA,EA6ahB/Z,KAAK66J,eAAgB9gJ,MAEzBs6C,EAAK38C,UAAY8oB,EACjB6zB,EAAK18C,SAAW6oB,EAcV,mBACN80E,EACAqmD,EACAC,EACA5+I,EACA05F,EACAloE,GAEA,IAAIqtH,GAAqB,EAEzB,MAAM,EAAE5yD,EAAC,EAAE9nG,GAAM,EAAA26J,sBAAsBH,EAAYC,EAAY5+I,EAAK05F,GAG9DjxG,EADa6vG,EAAU79F,MACNwxF,EAEjBvjG,EADc4vG,EAAUpkG,OACN/P,EAElB46J,EAAQ,EAAAC,kBAAkBv2J,EAAGC,EAAG4vG,EAAW9mE,GAKjD,YAHcxsC,IAAV+5J,GAAoC,IAAbA,EAAM,KAC7BF,GAAqB,GAElBA,EAMD,kBACN77J,KAAK+rF,uBAAoB/pF,EACzBhC,KAAKkgF,oBAAiBl+E,EACtBhC,KAAKqgF,iBAAcr+E,EACnBhC,KAAK66J,oBAAiB74J,EACtBhC,KAAKi1E,OA5gBiB,GA4gBa,GAS7B,aAAa5iB,GACnB,MAAM4pG,EAAmB,IAAIzqI,aA5gBJ,EA6gBrB6gC,EAngB2B,GAsgB/B,QAA+BrwD,IAA3BhC,KAAK+rF,mBAAmC/rF,KAAK+rF,kBAAkBpyE,MAAMrY,OAAS,EAAG,CACjF,MAAMy5J,EAAyB/6J,KAAK+rF,kBAAkBhyE,MACtDkiJ,EAAiBj1J,IAAIhH,KAAK+rF,kBAAkBpyE,OAC5C3Z,KAAK+rF,kBAAkBpyE,MAAQsiJ,EAC/Bj8J,KAAK+rF,kBAAkBhyE,MAAQghJ,OAE/B/6J,KAAK+rF,kBAAoB,IAAI3sF,EAAM0a,gBAC/BmiJ,EA7gBuB,GAghB3Bj8J,KAAK+rF,kBAAkBhyE,MAAQ,EAC/B/Z,KAAK+rF,kBAAkB96B,SAAS7xD,EAAM8xD,kBAG1C,MAAMgrG,EAAgB,IAAIvrI,WA9hBD,EA+hBrB0hC,EAhhBwB,GAmhB5B,QAA4BrwD,IAAxBhC,KAAKkgF,eAA8B,CACnC,MAAM86E,EAAsBh7J,KAAKkgF,eAAenmE,MAChDmiJ,EAAcl1J,IAAIhH,KAAKkgF,eAAevmE,OACtC3Z,KAAKkgF,eAAevmE,MAAQuiJ,EAC5Bl8J,KAAKkgF,eAAenmE,MAAQihJ,OAE5Bh7J,KAAKkgF,eAAiB,IAAI9gF,EAAM0a,gBAC5BoiJ,EA1hBoB,GA4hBpB,GAEJl8J,KAAKkgF,eAAenmE,MAAQ,EAC5B/Z,KAAKkgF,eAAejvB,SAAS7xD,EAAM8xD,kBAGvC,MAAMirG,EAAa,IAAI3qI,aAjjBE,EAkjBrB6gC,EA9hBqB,GAiiBzB,QAAyBrwD,IAArBhC,KAAKqgF,YAA2B,CAChC,MAAM46E,EAAmBj7J,KAAKqgF,YAAYtmE,MAC1CoiJ,EAAWn1J,IAAIhH,KAAKqgF,YAAY1mE,OAChC3Z,KAAKqgF,YAAY1mE,MAAQwiJ,EACzBn8J,KAAKqgF,YAAYtmE,MAAQkhJ,OAEzBj7J,KAAKqgF,YAAc,IAAIjhF,EAAM0a,gBAAgBqiJ,EAviBxB,GAwiBrBn8J,KAAKqgF,YAAYtmE,MAAQ,EACzB/Z,KAAKqgF,YAAYpvB,SAAS7xD,EAAM8xD,kBAGpC,MAAMkrG,EA3jBkB,EA2jBD/pG,EAviBK,EAyiBtBgqG,EACFD,EAAiB,MACX,IAAI9qI,YAAY8qI,GAChB,IAAIlrI,YAAYkrI,GAE1B,QAA4Bp6J,IAAxBhC,KAAK66J,eAA8B,CACnC,MAAMK,EAAsBl7J,KAAK66J,eAAe9gJ,MAChDsiJ,EAAcr1J,IAAIhH,KAAK66J,eAAelhJ,OACtC3Z,KAAK66J,eAAelhJ,MAAQ0iJ,EAC5Br8J,KAAK66J,eAAe9gJ,MAAQmhJ,OAE5Bl7J,KAAK66J,eAAiB,IAAIz7J,EAAM0a,gBAC5BuiJ,EArjBoB,GAwjBxBr8J,KAAK66J,eAAe9gJ,MAAQ,EAC5B/Z,KAAK66J,eAAe5pG,SAAS7xD,EAAM8xD,kBAGvClxD,KAAK+gJ,OAAS1uF,GAlhBtB,e,mLChGA,aAqEA,SAAgBiqG,EACZhlJ,EACAilJ,EACAC,EACAhuH,GAEA,GAAI+tH,EAAOjlJ,EAAMG,OAAS8kJ,EAAO,GAAKC,EAAOllJ,EAAMpG,QAAUsrJ,EAAO,EAChE,OAGJ,IAAIC,EAEJjuH,EAAO/2B,MAAQH,EAAMG,MACrB+2B,EAAOt9B,OAASoG,EAAMpG,OAEtB,MAAMhR,EAAUsuC,EAAOgrE,WAAW,MAelC,OAdgB,OAAZt5G,IACAA,EAAQk6G,UACJ9iG,EACA,EACA,EACAA,EAAMG,MACNH,EAAMpG,OACN,EACA,EACAs9B,EAAO/2B,MACP+2B,EAAOt9B,QAEXurJ,EAAYv8J,EAAQ65G,aAAawiD,EAAMC,EAAM,EAAG,GAAGl1H,MAEhDm1H,EAYX,SAAgBC,EACZC,EACAJ,EACAC,EACAziF,GAWA,KAAIwiF,EAAOI,EAAQllJ,OAAS8kJ,EAAO,GAAKC,EAAOG,EAAQzrJ,QAAUsrJ,EAAO,GAGxE,MAZiB,EAAClnD,EAAsB56F,EAAekiJ,KACnD,MAAMx/J,EAAIsd,EAAQkiJ,EACZl/J,EAAI43G,EAAUhuE,KACdy0H,EAAQ,IAAIc,kBAAkBD,GACpC,IAAK,IAAIz9J,EAAI,EAAGA,EAAIy9J,EAAMz9J,IACtB48J,EAAM,GAAKr+J,EAAEN,EAAI+B,GAErB,OAAO48J,GAKJe,CAASH,EAASH,EAAOG,EAAQllJ,MAAQ8kJ,EAAMxiF,GAtH1D,6BACIwiF,EACAC,EACAlnD,EACA9mE,GAEA,IAAIuuH,EAMJ,QAH8C/6J,IAG5BszG,EAHkB0nD,WAIjBh7J,IAAXwsC,IACAA,EAAS6qE,SAASC,cAAc,WAEpCyjD,EAAcT,EAAwBhnD,EAA0BinD,EAAMC,EAAMhuH,OACzE,CACH,MAAMyuH,EAAa3nD,EAEnBynD,EAAcL,EAAsBO,EAAYV,EAAMC,EADvCS,EAAW31H,KAAKhmC,QAAU27J,EAAW/rJ,OAAS+rJ,EAAWxlJ,QAG5E,OAAOslJ,GAWX,iCACI71E,EACAC,EACAnqE,EACA05F,GAEA,MAAM5hE,EAAO93B,EAAIvX,EACXsvC,EAAO/3B,EAAIvX,EAAIuX,EAAIlX,EACnBkvC,EAAOh4B,EAAItX,EACXo2B,EAAO9e,EAAItX,EAAIsX,EAAIoP,EAIzB,MAAO,CAAE68E,EAHC,EAAA3gG,UAAUvC,IAAImhF,EAASpyC,EAAMC,EAAM2hE,EAAMsC,GAAItC,EAAMwC,IAGjD/3G,EAFF,EAAAmH,UAAUvC,IAAIohF,EAASnyC,EAAMlZ,EAAM46E,EAAMuC,GAAIvC,EAAMyC,MAcjE,4BA0CA,2B,sGC9GA,uBAcI,YAA6BsrB,GAAA,KAAAA,WAb7B,KAAAjpF,YAAsB,EACtB,KAAA0hH,eAAyB,EACzB,KAAApnH,MAAgB,EAChB,KAAAE,cAAwB,EACxB,KAAAE,OAAiB,EACjB,KAAAS,cAAwB,EACxB,KAAAE,gBAA0B,EAC1B,KAAAO,aAAuB,EACvB,KAAAiK,oBAA8B,EAC9B,KAAAJ,oBAA8B,EAC9B,KAAAjB,qBAA+B,EAC/B,KAAAjK,wBAAkC,EAIlC,QACI/1C,KAAKw7C,YAAc,EACnBx7C,KAAKk9J,eAAiB,EACtBl9J,KAAK81C,MAAQ,EACb91C,KAAKg2C,cAAgB,EACrBh2C,KAAKk2C,OAAS,EACdl2C,KAAK22C,cAAgB,EACrB32C,KAAK62C,gBAAkB,EACvB72C,KAAKo3C,aAAe,EACpBp3C,KAAKqhD,oBAAsB,EAC3BrhD,KAAKihD,oBAAsB,EAC3BjhD,KAAKggD,qBAAuB,EAC5BhgD,KAAK+1C,wBAA0B,EAEnC,MACI,MAAMonH,EACFn9J,KAAKg2C,cACLh2C,KAAKggD,qBACLhgD,KAAKk2C,OACLl2C,KAAK22C,cACL32C,KAAKo3C,aACTp3C,KAAKykI,SAASt1F,MAAM,eAAgBnvC,KAAKw7C,aACzCx7C,KAAKykI,SAASt1F,MAAM,kBAAmBnvC,KAAKk9J,gBAC5Cl9J,KAAKykI,SAASt1F,MAAM,eAAgBnvC,KAAK81C,OACzC91C,KAAKykI,SAASt1F,MAAM,kBAAmBnvC,KAAK+1C,yBAC5C/1C,KAAKykI,SAASt1F,MAAM,kBAAmBguH,GACvCn9J,KAAKykI,SAASt1F,MAAM,qBAAsBnvC,KAAKg2C,eAC/Ch2C,KAAKykI,SAASt1F,MAAM,qBAAsBnvC,KAAKqhD,qBAC/CrhD,KAAKykI,SAASt1F,MAAM,qBAAsBnvC,KAAKihD,qBAC/CjhD,KAAKykI,SAASt1F,MAAM,qBAAsBnvC,KAAKggD,sBAC/ChgD,KAAKykI,SAASt1F,MAAM,UAAWnvC,KAAKk2C,QACpCl2C,KAAKykI,SAASt1F,MAAM,cAAenvC,KAAK22C,eACxC32C,KAAKykI,SAASt1F,MAAM,iBAAkBnvC,KAAK62C,iBAC3C72C,KAAKykI,SAASt1F,MAAM,+BAAgCnvC,KAAKo3C,iB,gIClDjE,aAKA,MAAakL,UAAwBljD,EAAMs+C,UAGvC,YAAY2R,EAAmBq4C,GAC3B1kG,MAAMqsD,EAAIq4C,GAGd,aAII,YAHuB1lG,IAAnBhC,KAAKo9J,YACLp9J,KAAKo9J,UAAY,CAAC,EAAGp9J,KAAK0nG,GAAGhsF,WAAW1b,KAAKqvD,MAE1CrvD,KAAKo9J,WAXpB,oBAkBA,MAAaC,EAGT,YAAqBn2I,EAA2BxM,EAAwBpc,GAAnD,KAAA4oB,OAA2B,KAAAxM,QAAwB,KAAApc,IAExE,YACI,OAAO0B,KAAKknB,KAAKo2I,OAAOt9J,KAAK0a,OAGjC,YAII,YAHqB1Y,IAAjBhC,KAAKu9J,UACLv9J,KAAKu9J,QAAUv9J,KAAKw9J,MAAMj7G,SAASviD,KAAK1B,IAErC0B,KAAKu9J,SAbpB,cAoBA,MAAa9/G,UAAmBr+C,EAAMijD,KAGlC,cACIr/C,QAGJ,aACI,GAAIhD,KAAKmoG,QACL,OAAOnoG,KAAKmoG,QAEhB,IAAI7+D,EAAM,EACV,MAAM83F,EAAU,IAAIhgI,MASpB,OARAggI,EAAQl7H,KAAK,GAEblG,KAAKs9J,OAAOj9J,QAAQm9J,IAChB,MAAMC,EAAYD,EAClBl0H,GAAOm0H,EAAUpuG,GAAG3zC,WAAW+hJ,EAAU/1D,IACzC05B,EAAQl7H,KAAKojC,KAEjBtpC,KAAKmoG,QAAUi5B,EACRA,EAGX,WAAW9iI,GACP,MAAM0Q,EAAW1Q,EAAI0B,KAAKgoJ,YACpB0V,EAAe19J,KAAK29J,kBAE1B,IAAK,IAAIjjJ,EAAQ,EAAGA,EAAQgjJ,EAAap8J,SAAUoZ,EAAO,CACtD,GAAIgjJ,EAAahjJ,GAAS1L,EACtB,SAGJ,MAAM4uJ,EAAOF,EAAahjJ,GAAS1L,EAE7B6uJ,EADQ79J,KAAKs9J,OAAO5iJ,GACEstI,YAE5B,OAAO,IAAIqV,EAAUr9J,KAAM0a,EADC,IAAlBmjJ,EAAsB,EAAI,EAAID,EAAOC,GAInD,OAAO,MAxCf,gB,gHCkEA,oCAAyC5nJ,QACTjU,IAAxBiU,EAAQ8hC,cACR9hC,EAAQ8hC,YA/Ga,mDAkHI/1C,IAAzBiU,EAAQ66B,eACR76B,EAAQ66B,aArFQ,WAuFS9uC,IAAzBiU,EAAQ86B,eACR96B,EAAQ86B,aAtFQ,YAwFgB/uC,IAAhCiU,EAAQumC,sBACRvmC,EAAQumC,oBApH+B,UAuHLx6C,IAAlCiU,EAAQ6nJ,wBACR7nJ,EAAQ6nJ,sBAjH+B,UAmHL97J,IAAlCiU,EAAQ4nC,wBACR5nC,EAAQ4nC,sBAzGyB,SA2GC77C,IAAlCiU,EAAQ6nC,wBACR7nC,EAAQ6nC,sBAvGyB,UAyGS97C,IAA1CiU,EAAQ8lC,gCACR9lC,EAAQ8lC,8BApH8B,UAsHG/5C,IAAzCiU,EAAQ+lC,+BACR/lC,EAAQ+lC,6BAvH8B,UA0HZh6C,IAA1BiU,EAAQg7B,gBACRh7B,EAAQg7B,eAAgB,QAGqBjvC,IAA7CiU,EAAQi7B,mCACRj7B,EAAQi7B,kCAAmC,K,6GChJnD,aAGA,SAEA,QAEM1kC,EAAS,EAAAC,cAAcxM,SAASvB,OAAO,yBAA0B,CAAEkd,MAAO,EAAA4xB,SAASC,MAyBzF,MAAMswH,EAAqE,CACvEz+H,QAAS,GACT5kB,OAAQ,GAGZ,SAASsjJ,EAAY7lI,GACjB,OAAOA,EAAQ8lI,eAAiB9lI,EAAQrS,UAAaqS,EAAQ3S,KA8CjE,SAAS04I,EACLC,EACAC,EACAC,EACAC,GAEA,YAAmCt8J,IAA/Bm8J,EAAa3hF,qBAGkBx6E,IAA/Bq8J,EAAa7hF,eAGV2hF,EAAa3hF,cAAgB6hF,EAAa7hF,eAKrD,SAAS+hF,EACLC,EACAC,EACAC,EACAC,GAEA,OAAOF,EAAcE,EAUzB,SAASC,EACLC,EACAC,EACAloJ,GAEA,MAAMuhB,EAAU0mI,EAAa1mI,QACvB4mI,EA7GV,SAAiCnoJ,GAe7B,OAbiB,MAGEvN,KAAKO,IADF,EADA,GAIFP,KAAKO,IAJH,GAIsBP,KAAKmtB,MAAM5f,MAQrB,GA8FXooJ,CAAwBpoJ,GACzCqoJ,EAAaH,EAAWx9J,OACxB49J,EAAkB/mI,EAAQpqB,SAC1BooC,EAAiB0oH,EAAaz4I,QACpC,IACI+4I,EADAC,GAAoB,EAEpBC,EAAyBx1J,IAC7B,MAAMy1J,EACFnnI,EAAQvoB,OAAS,EAAAgX,gBAAgBC,SAAW03I,EAAyBL,EAEzE,IAAK,IAAI9gK,EAAI,EAAGA,EAAI6hK,IAAc7hK,EAAG,CACjC,MAAMmiK,EAAiBT,EAAW1hK,GAC5BoiK,EAAgBD,EAAepnI,QAC/BsnI,EAActnI,EAAQvoB,OAAS4vJ,EAAc5vJ,KAC7C8vJ,EAAiBvpH,GAAkBopH,EAAen5I,QACxD,GAAIq5I,GAAeC,EAGf,SAEJ,MAAMx9G,EAAcg9G,EAAgBzG,kBAAkB+G,EAAczxJ,UAChEm0C,EAAc68G,SAKA/8J,IAAdm9J,GACAG,EAAkBE,EAAet9G,EAAai9G,EAAWE,MAEzDD,EAAWhiK,EACX+hK,EAAYK,EACZH,EAAiBn9G,GAIzB,OAAOk9G,EAOX,4CACqB,KAAAO,eAAiB,IAAIx9J,IAIrB,KAAAy9J,UAAY,IAAIz9J,IAajC,SACI04C,EACAj3B,EACAi8I,GAEA,IAAI3qH,EAAal1C,KAAK/B,IAAI48C,GAE1B,YAAmB74C,IAAfkzC,GACA,EAAA5oC,OAAO4oC,EAAW9zB,OAASy5B,EAAiB9T,SAASzlC,QACrD4zC,EAAW4qH,eAAeD,GACnB,CAAC3qH,GAAY,KAGxBA,EAAa,IAAI,EAAA6qH,sBAAsBllH,EAAkBj3B,EAASi8I,GAClE7/J,KAAKgH,IAAI6zC,EAAkB3F,GAEpB,CAACA,GAAY,IAGxB,WACI,OAAOl1C,KAAK2/J,eAAev+I,KAM/B,wBASI,YARiCpf,IAA7BhC,KAAKggK,sBACLhgK,KAAKggK,oBAAsB5+J,MAAM6I,KAAKjK,KAAK2/J,eAAehgI,UAC1D3/B,KAAKggK,oBAAoBp3H,KAAK,CAACp/B,EAA0BE,IAC9CA,EAAEi5B,MAAMhd,SAAWnc,EAAEm5B,MAAMhd,WAI1C,EAAArZ,OAAOtM,KAAK2/J,eAAev+I,OAASphB,KAAKggK,oBAAoB1+J,QACtDtB,KAAKggK,oBAYhB,OAAOvuH,EAAcR,EAAwBkB,EAA2Bv7B,GACpE,MAAMqpJ,EAAkB9tH,EAClBnyC,KAAKkgK,eAAethK,KAAKoB,KAAM4W,QAC/B5U,EAEN,IAAIm+J,GAAc,EAClB,IAAK,MAAOxhK,EAAKu2C,KAAel1C,KAAK2/J,eAAergI,UAC5C4V,EAAWG,QACXH,EAAWkrH,aAAa3uH,EAAMR,IAE1BkB,GACA+C,EAAWmrH,wBAAwBJ,GAEvCjgK,KAAK2/J,eAAe54J,OAAOpI,GAC3BqB,KAAKggK,yBAAsBh+J,EAC3Bm+J,GAAc,GAGtB,OAAOA,EAMX,eACI,IAAK,MAAMjrH,KAAcl1C,KAAK2/J,eAAehgI,SACzCuV,EAAWG,SAAU,EAI7B,iBACIr1C,KAAK4/J,UAAU55H,QAMnB,QACIhmC,KAAK2/J,eAAe35H,QACpBhmC,KAAKggK,yBAAsBh+J,EAC3BhC,KAAK4/J,UAAU55H,QAWnB,mBAAmBpvB,EAAmBioJ,GAClC,MAAMyB,EAActgK,KAAKugK,cAAc1B,EAAcjoJ,GAErD,QAAoB5U,IAAhBs+J,EAGA,OADAtgK,KAAK4/J,UAAU54J,IAAIg3J,EAAYa,EAAa1mI,SAAU,CAAC0mI,KAChD,EAGX,IAA2B,IAAvByB,EAAY5lJ,MAGZ,OADA4lJ,EAAYhhI,QAAQp5B,KAAK24J,IAClB,EAIX,MAAM2B,EAAkBF,EAAYhhI,QAAQghI,EAAY5lJ,OAExD,QAAK8lJ,EAAgBp6I,UAAWy4I,EAAaz4I,WAEzCk6I,EAAYhhI,QAAQghI,EAAY5lJ,OAASmkJ,EACzC2B,EAAgBh4H,SACT,GAWf,eAAe5xB,EAAmBioJ,GAC9B,EAAAvyJ,OAAOuyJ,EAAaz4I,SACpB,MAAMk6I,EAActgK,KAAKugK,cAAc1B,EAAcjoJ,GAErD,QAAoB5U,IAAhBs+J,IAAoD,IAAvBA,EAAY5lJ,MAEzC,OAGJ,MAAM+lJ,EAAcH,EAAYhhI,QAAQghI,EAAY5lJ,OACpD,EAAApO,QAAQm0J,EAAYr6I,SAEpBq6I,EAAYr0J,QAAQyyJ,GAQhB,IAAIhkH,GACR,MAAM3F,EAAal1C,KAAK2/J,eAAe1hK,IAAI48C,GAK3C,YAHmB74C,IAAfkzC,IACAA,EAAWG,SAAU,GAElBH,EAQH,IAAI2F,EAAoCgC,GAC5C,EAAAvwC,OAAOuuC,EAAiB9T,SAASzlC,OAAS,GAC1CtB,KAAK2/J,eAAe34J,IAAI6zC,EAAkBgC,GAC1C78C,KAAKggK,yBAAsBh+J,EAGvB,cACJ68J,EACAjoJ,GAKA,MAAMuhB,EAAU0mI,EAAa1mI,QACvBuoI,EAAgB1gK,KAAK4/J,UAAU3hK,IAAI+/J,EAAY7lI,IAErD,QAAsBn2B,IAAlB0+J,EAEA,OAGJ3C,EAAmBz+H,QAAUohI,EAC7B,MAAMhmJ,EAAQyd,EAAQ8lI,eAnU9B,SACIY,EACAC,GAGA,MAAM3mI,EAAU0mI,EAAa1mI,QACvBwoI,EAAiB7B,EAAW/6E,UAC9BC,GAASA,EAAM7rD,QAAQjS,aAAeiS,EAAQjS,YAElD,IAAwB,IAApBy6I,EACA,OAAQ,EAEZ,MAAMn6D,EAAYs4D,EAAW6B,GAAgBxoI,QAG7C,GAFA,EAAA7rB,OAAO6rB,EAAQrS,YAAc0gF,EAAU1gF,WAEnC0gF,EAAUhhF,OAAS2S,EAAQ3S,KAW/B,OAAOm7I,EANHn0J,EAAO2iC,MACH,mBAAmBhX,EAAQrS,gCAAgCqS,EAAQ3S,yBAChEghF,EAAUhhF,QA8SXo7I,CAAkB/B,EAAc6B,GAChC9B,EAAoBC,EAAc6B,EAAe9pJ,GAEvD,YAAc5U,IAAV0Y,GAEAyd,EAAQrS,eAAY9jB,EACbhC,KAAKugK,cAAc1B,EAAcjoJ,KAE5CmnJ,EAAmBrjJ,MAAQA,EACpBqjJ,M,6GC5Xf,aAEA,SAaA,8BAUI,YACap7H,EACA/e,EACT4O,GAFS,KAAAmQ,QACA,KAAA/e,UAVL,KAAAi9I,WAAqB,EAazB,EAAAv0J,OAAOq2B,EAAMoE,SAASzlC,OAAS,GAC/B,MAAMA,EAASqhC,EAAMoE,SAASzlC,OAC9BtB,KAAK8gK,oBAAsB,IAAI1/J,MAAME,GACrCtB,KAAK6gK,WAAY,EAOjB,IAAK,IAAIzjK,EAAI,EAAGA,EAAIkE,IAAUlE,EAAG,CAC7B,MAAM0lC,EAAcH,EAAMoE,SAAS3pC,GAC7B2gD,EAAQ,IAAI,EAAAgjH,iBAAiBj+H,GAC7Bob,EAAe1rB,EAAOurB,GAC5BA,EAAM1L,OAAO6L,GACbl+C,KAAK8gK,oBAAoB1jK,GAAK2gD,GAQtC,cACI,OAAO/9C,KAAK6gK,UAGhB,YAAYxrH,GACRr1C,KAAK6gK,UAAYxrH,EAMrB,eACI,OAAOr1C,KAAK2iC,MAAMhd,SAQtB,aAAa8rB,EAAcR,GACvB,IAAK,MAAM4tH,KAAgB7+J,KAAK8gK,yBACP9+J,IAAjB68J,GACAA,EAAauB,aAAa3uH,EAAMR,GAU5C,wBAAwB+vH,GACpB,IAAK,MAAMnC,KAAgB7+J,KAAK8gK,yBACP9+J,IAAjB68J,GAA8BA,EAAaz4I,SAC3C46I,EAAwBnC,GASpC,eAAersI,GACX,IAAK,MAAMqsI,KAAgB7+J,KAAK8gK,oBAAqB,CACjD,MAAM5iH,EAAe1rB,EAAOqsI,GAC5BA,EAAaxsH,OAAO6L,IAI5B,WACI,OAAOl+C,KAAK8gK,oBAAoBx/J,OAOpC,wBACI,OAAOtB,KAAK8gK,uB,wGCnHpB,aAOA,OACA,SACA,SAEA,QAKA,yBA2BI,YAAqB3oI,GAAA,KAAAA,UAErB,kBACI,YAAkCn2B,IAA3BhC,KAAKihK,wBAA+Dj/J,IAA5BhC,KAAKkhK,mBAMxD,cACI,QAA+Bl/J,IAA3BhC,KAAKihK,mBAAmCjhK,KAAKihK,kBAAkBl2F,YAC/D,OAAO,EAGX,MAAMvsB,EAAkBx+C,KAAKw+C,gBAC7B,QAAwBx8C,IAApBw8C,GAAiCA,EAAgBusB,YACjD,OAAO,EAGX,MAAMxsB,EAAmBv+C,KAAKu+C,iBAC9B,QAAyBv8C,IAArBu8C,EACA,OAAO,EAGX,IAAK,MAAMR,KAASQ,EAChB,GAAIR,EAAMgtB,YACN,OAAO,EAGf,OAAO,EAWX,oBACI,MAAMo2F,EAAcnhK,KAAKm4B,QAAQxR,YAC3By6I,EAAcphK,KAAKqhK,kBAUzB,YANoBr/J,IAAhBo/J,EACMA,EAAY7uD,cACZ,CACInmF,EAAG,EAAAslF,wBAAwByvD,EAAY71I,qBACvCnqB,EAAG,EAAAywG,wBAAwBuvD,EAAY51I,oBAYzD,kBAAkBglF,QACiBvuG,IAA3BhC,KAAKqhK,oBAA2E,IAAxCrhK,KAAKshK,oBAAoB/wD,UAItCvuG,IAA3BhC,KAAKqhK,kBAGLrhK,KAAKqhK,kBAAoB,IAAI,EAAAE,YAAYhxD,GAEzCvwG,KAAKqhK,kBAAkB9uD,cAAgBhC,GAY/C,oBAAoBA,GAChB,MAAM4wD,EAAcnhK,KAAKm4B,QAAQxR,YACjC,QAAoB3kB,IAAhBm/J,EACA,OACI,EAAA54I,oBAAoBgoF,EAAUnkF,KAAO+0I,EAAY71I,qBACjD,EAAA7C,oBAAoB8nF,EAAUpvG,KAAOggK,EAAY51I,kBAS7D,QAYI,QAX+BvpB,IAA3BhC,KAAKihK,mBACLjhK,KAAKihK,kBAAkBz4H,aAEIxmC,IAA3BhC,KAAKqhK,yBAC4Br/J,IAA7BhC,KAAKm4B,QAAQxR,YACb3mB,KAAKqhK,kBAAkB74H,MAAMxoC,KAAKm4B,QAAQxR,aAE1C3mB,KAAKqhK,uBAAoBr/J,GAI7BhC,KAAKw+C,gBACJx+C,KAAKkhK,mBAAmC14H,aACtC,QAAgCxmC,IAA5BhC,KAAKkhK,mBACZ,IAAK,MAAMM,KAAexhK,KAAKkhK,mBAC3BM,EAAYh5H,QAGpBxoC,KAAKyhK,oBAAiBz/J,EACtBhC,KAAKm4B,QAAQwoB,sBAAmB3+C,EAQpC,QAAQ0/J,GACJ1hK,KAAKihK,kBAAoBS,EAAYT,kBACrCjhK,KAAKqhK,kBAAoBK,EAAYL,kBACrCrhK,KAAKkhK,mBAAqBQ,EAAYR,mBACtCQ,EAAYT,uBAAoBj/J,EAChC0/J,EAAYL,uBAAoBr/J,EAChC0/J,EAAYR,wBAAqBl/J,OAELA,IAAxBhC,KAAKm4B,QAAQ6W,SAEbhvC,KAAKm4B,QAAQ6W,OAAS0yH,EAAYvpI,QAAQ6W,OAC1ChvC,KAAKm4B,QAAQ0W,eAAiB6yH,EAAYvpI,QAAQ0W,gBAEtD7uC,KAAKm4B,QAAQggB,YAASn2C,EACtBhC,KAAKm4B,QAAQwoB,sBAAmB3+C,EAOpC,mBACI,OAAOhC,KAAKyhK,eAQhB,OAAOxrH,GACEj2C,KAAKoxC,kBAAgCpvC,IAAjBi0C,GACrBj2C,KAAK2hK,yBAGT3hK,KAAK0+C,gBAAgBzI,GAQzB,gBAAgBA,GACZj2C,KAAKyhK,eAAiBxrH,EAU1B,qBACI,OAAoC,IAA7Bj2C,KAAKm4B,QAAQmtB,YACd,OACwBtjD,IAAxBhC,KAAKyhK,gBACJzhK,KAAKyhK,eACN,EAMV,sBACI,OAAOzhK,KAAKihK,kBAOhB,sBACI,QAAgCj/J,IAA5BhC,KAAKkhK,mBAIT,OAAOlhK,KAAKkhK,8BAA8B,EAAAU,YAAc5hK,KAAKkhK,wBAAqBl/J,EAOtF,uBACI,QAAgCA,IAA5BhC,KAAKkhK,mBAIT,OAAOlhK,KAAKkhK,8BAA8B,EAAAU,iBACpC5/J,EACChC,KAAKkhK,mBAShB,aAAazvH,EAAcR,GAKvB,QAJ+BjvC,IAA3BhC,KAAKihK,mBACLjhK,KAAKihK,kBAAkBb,aAAa3uH,EAAMR,QAGjBjvC,IAAzBhC,KAAKw+C,gBAA+B,CACZx+C,KAAKkhK,mBACbd,aAAa3uH,EAAMR,QAChC,QAA8BjvC,IAA1BhC,KAAKu+C,iBACZ,IAAK,MAAMijH,KAAexhK,KAAKkhK,mBAC3BM,EAAYpB,aAAa3uH,EAAMR,GAQnC,yB,MACJ,EAAA3kC,YAAkCtK,IAA3BhC,KAAKihK,mBACZ,EAAA30J,YAAkCtK,IAA3BhC,KAAKqhK,mBACZ,EAAA/0J,YAAmCtK,IAA5BhC,KAAKkhK,oBAEZ,MAAM,aAAEx7G,GAAiB1lD,KAAKm4B,QACxBstB,EAAmC,QAAvB,EAAGzlD,KAAKm4B,QAAQ/S,eAAO,eAAEkH,UAAUm5B,aACrD,GAAIzlD,KAAKm4B,QAAQvoB,OAAS,EAAAgX,gBAAgBO,WAU1CnnB,KAAKihK,kBAAoB,IAAI,EAAAW,YAAYl8G,GAErC1lD,KAAKm4B,QAAQvoB,OAAS,EAAAgX,gBAAgBC,WACtC7mB,KAAKkhK,mBAAqB,IAAI,EAAAU,YAAYn8G,QAb9C,CACIzlD,KAAKkhK,mBAAqB,IAAI9/J,MAC9B,IAAK,MAAMygK,KAAU7hK,KAAKm4B,QAAQ7mB,OAA2B,CACzD,MAAMitC,EAAmBv+C,KAAKkhK,mBACxBM,EAAc,IAAI,EAAAI,YAAYn8G,GACpClH,EAAiBr4C,KAAKs7J,Q,mGC5StC,aAkBA,oBAII,YAAYjxD,GAHJ,KAAAuxD,SAAW,EAAAx5I,iBAAiBkC,6BAC5B,KAAAu3I,SAAW,EAAAz5I,iBAAiBgC,2BAGhCtqB,KAAKuyG,cAAgBhC,EAOzB,kBAAkBA,GACdvwG,KAAK8hK,SAAW,EAAAv5I,oBAAoBgoF,EAAUnkF,GAC9CpsB,KAAK+hK,SAAW,EAAAt5I,oBAAoB8nF,EAAUpvG,GAUlD,oBACI,MAAO,CACHirB,EAAG,EAAAslF,wBAAwB1xG,KAAK8hK,UAChC3gK,EAAG,EAAAywG,wBAAwB5xG,KAAK+hK,WAOxC,MAAMp7I,GACF3mB,KAAK8hK,SAAWn7I,EAAY2E,oBAC5BtrB,KAAK+hK,SAAWp7I,EAAY4E,kBAGhC,0BACI,OAAOvrB,KAAK8hK,SAGhB,wBACI,OAAO9hK,KAAK+hK,Y,qIC9DpB,aACA,OAKA,IAAYC,GAAZ,SAAYA,GACR,6BACA,2BACA,yBACA,8BACA,4BALJ,CAAYA,EAAA,EAAAA,cAAA,EAAAA,YAAW,KAWV,EAAAC,kBAAoB,IAQjC,oBAuBI,YAAmBC,EAAW,EAAAD,mBAAX,KAAAC,WAnBnB,KAAA7jK,MAAgB,EAKhB,KAAA6wC,UAAoB,EAKpB,KAAAhkB,QAAkB,EAEV,KAAA8pE,QAAUgtE,EAAYG,UAY9B,QACIniK,KAAKg1F,QAAUgtE,EAAYG,UAC3BniK,KAAK3B,MAAQ,EACb2B,KAAKkvC,UAAY,EACjBlvC,KAAKkrB,QAAU,EAMnB,cACI,OAAOlrB,KAAKg1F,UAAYgtE,EAAYG,UAMxC,WAGI,OADIniK,KAAKg1F,UAAYgtE,EAAYI,UAAYpiK,KAAKg1F,UAAYgtE,EAAYK,UAO9E,aAEI,OADiBriK,KAAKg1F,UAAYgtE,EAAYI,SAOlD,cAEI,OADkBpiK,KAAKg1F,UAAYgtE,EAAYK,UAOnD,YAEI,OADgBriK,KAAKg1F,UAAYgtE,EAAYM,QAOjD,aAEI,OADiBtiK,KAAKg1F,UAAYgtE,EAAYO,SAOlD,YACI,OAAOviK,KAAKg1F,UAAYgtE,EAAYO,UAAYviK,KAAKg1F,UAAYgtE,EAAYG,UAUjF,YAAY1wH,GACJzxC,KAAKg1F,UAAYgtE,EAAYI,UAAYpiK,KAAKg1F,UAAYgtE,EAAYM,UAItEtiK,KAAKg1F,UAAYgtE,EAAYK,WAG7BriK,KAAK3B,MAAQ,EAAM2B,KAAK3B,MACxB2B,KAAKkvC,UAAYuC,EAAOzxC,KAAK3B,MAAQ2B,KAAKkiK,WAE1CliK,KAAKkvC,UAAYuC,EACjBzxC,KAAK3B,MAAQ,EACb2B,KAAKkrB,QAAU,GAGnBlrB,KAAKg1F,QAAUgtE,EAAYI,UAU/B,aAAa3wH,GACLzxC,KAAKg1F,UAAYgtE,EAAYK,WAAariK,KAAKg1F,UAAYgtE,EAAYO,WAIvEviK,KAAKg1F,UAAYgtE,EAAYI,UAG7BpiK,KAAKkvC,UAAYuC,EAAOzxC,KAAK3B,MAAQ2B,KAAKkiK,SAC1CliK,KAAK3B,MAAQ,EAAM2B,KAAK3B,QAExB2B,KAAKkvC,UAAYuC,EACjBzxC,KAAK3B,MAAQ,EACb2B,KAAKkrB,QAAU,GAGnBlrB,KAAKg1F,QAAUgtE,EAAYK,WAW/B,aAAa5wH,EAAcR,GACvB,GAAIjxC,KAAKg1F,UAAYgtE,EAAYI,UAAYpiK,KAAKg1F,UAAYgtE,EAAYK,UACtE,OAGmB,IAAnBriK,KAAKkvC,YACLlvC,KAAKkvC,UAAYuC,GAGrB,MAAM+wH,EAAa/wH,EAAOzxC,KAAKkvC,UACzBi1F,EAAankI,KAAKg1F,UAAYgtE,EAAYI,SAAW,EAAI,EACzDh+B,EAAWpkI,KAAKg1F,UAAYgtE,EAAYI,SAAW,EAAI,EAEzDnxH,GAAiBuxH,GAAcxiK,KAAKkiK,UACpCliK,KAAK3B,MAAQ,EACb2B,KAAKkrB,QAAUk5G,EACfpkI,KAAKg1F,QACDh1F,KAAKg1F,UAAYgtE,EAAYI,SAAWJ,EAAYM,QAAUN,EAAYO,WAI9EviK,KAAK3B,MAAQmkK,EAAaxiK,KAAKkiK,SAE/BliK,KAAKkrB,QAAU9rB,EAAMkJ,UAAU6B,MAC3B,EAAA7B,UAAUs7H,aAAaO,EAAYC,EAAUpkI,KAAK3B,OAClD,EACA,GAEJ,EAAAiO,OAAOtM,KAAKugD,gB,mGC1MxB,eAEA,oBAOI,YAA6BkkF,GAAA,KAAAA,WAN7B,KAAAnqF,MAAgB,EAChB,KAAAkB,YAAsB,EACtB,KAAAC,UAAoB,EACpB,KAAAH,YAAsB,EACtB,KAAAC,QAAU,IAAIn6C,MAAc,EAAA85C,mBAAmB66G,OAG3C/1J,KAAKu7C,QAAQgM,KAAK,GAGtB,QACIvnD,KAAKs6C,MAAQ,EACbt6C,KAAKw7C,YAAc,EACnBx7C,KAAKy7C,UAAY,EACjBz7C,KAAKs7C,YAAc,EACnBt7C,KAAKu7C,QAAQgM,KAAK,GAEtB,MACIvnD,KAAKykI,SAASt1F,MAAM,QAASnvC,KAAKs6C,OAClCt6C,KAAKykI,SAASt1F,MAAM,eAAgBnvC,KAAKw7C,aACzCx7C,KAAKykI,SAASt1F,MAAM,aAAcnvC,KAAKy7C,WACvCz7C,KAAKykI,SAASt1F,MAAM,eAAgBnvC,KAAKs7C,aACzCt7C,KAAKykI,SAASt1F,MAAM,gBAAiBnvC,KAAKu7C,QAAQ,EAAAL,mBAAmBC,KACrEn7C,KAAKykI,SAASt1F,MAAM,YAAanvC,KAAKu7C,QAAQ,EAAAL,mBAAmBmE,YACjEr/C,KAAKykI,SAASt1F,MAAM,gBAAiBnvC,KAAKu7C,QAAQ,EAAAL,mBAAmBw0D,WACrE1vG,KAAKykI,SAASt1F,MAAM,UAAWnvC,KAAKu7C,QAAQ,EAAAL,mBAAmBu0D,SAC/DzvG,KAAKykI,SAASt1F,MAAM,YAAanvC,KAAKu7C,QAAQ,EAAAL,mBAAmBG,e,0HC9BzE,aAOA,OACA,OAEA,SACA,SAEA,QAEMonH,EAAc,CAAC,IAAIrjK,EAAMuG,QAAW,IAAIvG,EAAMuG,SAC9C+8J,EAAa,IAAItjK,EAAMyG,QAS7B,MAAa88J,EACT,YACW/+I,EACA4f,EACA3f,EAAiB,EACjBiQ,EAAuB,EACvBC,EAAuB,EACvB/kB,EAAmB,GALnB,KAAA4U,UACA,KAAA4f,OACA,KAAA3f,SACA,KAAAiQ,eACA,KAAAC,eACA,KAAA/kB,YAPf,iBAkDA,4BAQI,YACqBwqB,EACRtrB,EACQ00J,EACA5jG,EACA+G,GAJA,KAAAvsC,WACR,KAAAtrB,UACQ,KAAA00J,2BACA,KAAA5jG,wBACA,KAAA+G,mBAZJ,KAAA88F,UAA2B,IAAIzjK,EAAM0jK,QAErC,KAAAC,uBAAyB,IAAI3jK,EAAMsO,QAE5C,KAAAs1J,eAAiC,GACxB,KAAAC,iBAAwC,IAAI9gK,IASzDnC,KAAKkjK,gBAAkB,IAAI,EAAAC,cAAc3pI,GAM7C,aACI,OAAOx5B,KAAKw5B,SAMhB,iBACI,OAAOx5B,KAAKkO,QAAQiB,WAMxB,cAAci0J,GACVpjK,KAAK+iK,uBAAuB9uJ,sBACKjS,IAA7BohK,EACMA,EACApjK,KAAKw5B,SAASrlB,iBACpBnU,KAAKw5B,SAASy2C,oBAGlBjwE,KAAK6iK,UAAUQ,wBAAwBrjK,KAAK+iK,wBAExC/iK,KAAK4iK,0BACL5iK,KAAKkjK,gBAAgBhuD,QAEzBl1G,KAAKsjK,mCAAmCtjK,KAAKw5B,SAASzrB,UAY1D,QACIikF,EACAnkB,EACAjuC,EACAouC,GAEAhuE,KAAKijK,iBAAiBj9H,QAKtB,EAAA15B,OAAuC,IAAhCtM,KAAKkO,QAAQq1J,gBACpB,MAAMC,EAAiBn6J,KAAK2N,IAAI,IAAMhX,KAAKkO,QAAQq1J,eAAgB,GAC7DE,OACuBzhK,IAAzB6rE,GACAA,EAAqB5rC,oBAAsB+vD,EACzC0xE,EACF1jK,KAAKkO,QAAQiB,WAAWS,OAAS,EAAAC,eAAee,WAAa6yJ,EAC3DE,EAAmB,IAAIhkK,IAAIigC,GAE3B19B,EAAQ,CACVgxH,kBAAkB,EAClB0wC,WAAYF,EAAmB,IAAI,EAAAriI,aAAiB,IAAIjiC,EAAMm7B,MAIlE,IAAK,MAAM3jB,KAAa+sJ,EACpB3jK,KAAKijK,iBAAiBj8J,IAAI4P,EAAW,IAAIzU,KAE7C,IAAK,MAAMutH,KAAa1vH,KAAKgjK,eAAgB,CACzC,MAAMp/I,EAAU8rG,EAAU9rG,QACpBC,EAAS6rG,EAAU7rG,OAInBsvG,EAAenzH,KAAK6jK,gBACtBjgJ,EACAC,EACAmuE,EACA9vF,EACAuhK,EAA0B51F,OAAuB7rE,GAGrD,QAAqBA,IAAjBmxH,EACA,IAAK,MAAMv8G,KAAa+sJ,EAAkB,CACf3jK,KAAKijK,iBAAiBhlK,IAAI2Y,GAClC5P,IACX,EAAA0c,gBAAgBC,0BAA0BC,EAASC,GACnDsvG,IAMhB,MAAM2wC,EAAW,IAAI9jK,KAAKgjK,eAAerjI,UACzC,KAAOmkI,EAASxiK,OAAS,GAAG,CACxB,MAAMouH,EAAYo0C,EAAS/nF,MAE3B,QAAkB/5E,IAAd0tH,EACA,MAIJ,MAAM9rG,EAAU8rG,EAAU9rG,QACpBC,EAAS6rG,EAAU7rG,OAIzB,IAHkBmqD,EAAYvpE,KAAK,CAAComE,EAAIztE,IACpCytE,EAAGmX,gBAAgBpiD,EAAWxiC,GAAIwmB,IAGlC,SAIJ,GAAI5jB,KAAK+lE,kBAAoB2pD,EAAUlsF,KAAOggI,EAC1C,SAGJ,MAAMO,EAAmB,EAAArgJ,gBAAgBC,0BAA0BC,EAASC,GAG5E,IAAK,MAAMjN,KAAa+sJ,EAAkB,CACtC,GAAI//I,EAAQhI,OAAShF,EACjB,SAGmB5W,KAAKijK,iBAAiBhlK,IAAI2Y,GAClC7P,OAAOg9J,GAG1B,IAAK,MAAMhkC,KAAc/tC,EAAa6E,eAAejzE,GAAU,CAC3D,MAAMogJ,EAAehkK,KAAK6jK,gBACtB9jC,EACAl8G,EACAmuE,EACA9vF,EACAuhK,EAA0B51F,OAAuB7rE,GAGrD,QAAqBA,IAAjBgiK,EAA4B,CAE5B,IAAK,MAAMptJ,KAAa+sJ,EAAkB,CACtC,GAAIK,EAAapgJ,QAAQhI,MAAQhF,EAC7B,SAGJ,MAAMqtJ,EAAsB,EAAAvgJ,gBAAgBC,0BACxCo8G,EACAl8G,GAEJ7jB,KAAKijK,iBACAhlK,IAAI2Y,GACJ5P,IAAIi9J,EAAqBD,GAGlCF,EAAS59J,KAAK89J,KAI1B,MAAO,CAAE5wC,eAAgBpzH,KAAKijK,iBAAkB/vC,iBAAkBhxH,EAAMgxH,kBAGpE,gBACJtvG,EACAC,EACAmuE,EACA9vF,EACA2rE,GAEA,MAAM33C,EAnOd,SAAmB87D,EAA4B4E,EAAuB/yE,GAClE,MAAMqS,EAAS87D,EAAa57D,UAAUwgE,GAChCstE,EAAkB,IAAQrgJ,EAGhC,OAFAqS,EAAOnB,UAAU3sB,WAAa87J,EAC9BhuI,EAAOpB,UAAU1sB,WAAa87J,EACvBhuI,EA8NYE,CAAU47D,EAAcpuE,EAASC,GAMhD,QAA6B7hB,IAAzB6rE,EAAoC,CACpC,MAAMz2C,EAAQy2C,EAAsBs2F,kBAAkBvgJ,GACtDsS,EAAOpB,UAAUzsB,SAAW+uB,EAAMtD,aAClCoC,EAAOnB,UAAU1sB,SAAW+uB,EAAMrD,aAClC7xB,EAAMgxH,iBACFhxH,EAAMgxH,kBACN97F,EAAMsM,oBAAsB,EAAA28E,kBAAkB+jD,aAGtDpkK,KAAKkO,QAAQiB,WAAW0sB,WAAW3F,EAAQh0B,EAAM0hK,YACjD,MAAM,KAAEpgI,EAAI,SAAEx0B,GAAahP,KAAKqkK,2BAA2BniK,EAAM0hK,YAEjE,GAAIpgI,EAAO,EACP,OAAO,IAAIm/H,EACP/+I,EACA4f,EACA3f,EACAqS,EAAOpB,UAAUzsB,SACjB6tB,EAAOnB,UAAU1sB,SACjB2G,GAWJ,2BACJ40J,GAEA,GAAIA,aAAsBxkK,EAAMm7B,MAC5B,GACKv6B,KAAK4iK,2BACD5iK,KAAKkjK,gBAAgBoB,yBAAyBV,KAClD5jK,KAAK6iK,UAAU0B,cAAcX,GAE9B,MAAO,CACHpgI,KAAM,EACNx0B,SAAUnF,UAGf,IAAK+5J,EAAWt+E,WAAWtlF,KAAK6iK,WACnC,MAAO,CACHr/H,KAAM,EACNx0B,SAAUnF,KAKlB,MAAMoT,EAAS2mJ,EAAW30F,UAAUwzF,EAAY,IAC1C+B,EAAiB9B,EAClB17J,IAAIiW,EAAOxX,EAAGwX,EAAOvX,EAAGuX,EAAOrX,EAAG,GAClCqM,aAAajS,KAAK+iK,wBAKjB3rJ,EAAc,GADPwsJ,EAAWl5F,QAAQ+3F,EAAY,IACbnhK,SAAYkjK,EAAe1+J,EAE1D,MAAO,CACH09B,KAAMpsB,EAAaA,EACnBpI,SAAUw1J,EAAe5+J,EAAI4+J,EAAe1+J,GAe5C,mCAAmC+0B,GACvC76B,KAAKgjK,eAAiB,GACtB,MAAMyB,EAAc,EAAAjgJ,QAAQ8X,mBAAmB,EAAG,EAAG,GAGrD,KAF4Bt8B,KAAKkO,QAAQiB,WAAWS,OAAS,EAAAC,eAAeC,UAE/C9P,KAAKg/D,sBAE9B,YADAh/D,KAAKgjK,eAAe98J,KAAK,IAAIy8J,EAAa8B,EAAa56J,IAAU,EAAG,IAIxE,MAAM66J,EAAgB1kK,KAAKkO,QAAQiB,WAAWgH,eAAe0kB,GACvDw7F,EAAchtH,KAAKggC,MAAMq7H,EAAct8J,UAAY,KAkCnDsG,EAAS1O,KAAKw5B,SACd3iB,EAAc,EAAA7I,aAAagI,gBAAgBhW,KAAKkO,QAASQ,GAAQ4H,MAEjE7D,EAAS/D,EAAO+D,OAAS,EAAI/D,EAAO+D,OAAS,EAAI/D,EAAO+D,OAExDkyJ,EAAgBvlK,EAAMkJ,UAAUW,SAAUyF,EAAO6D,IAAME,EAAU,GAAKoE,EAMtE+tJ,EAJ4Bv7J,KAAKsJ,IAAIgyJ,GAAiBj2J,EAAOX,SAASnI,EAEnCyD,KAAKsJ,IAAIkE,GAAenI,EAAOX,SAASnI,EAG3Ei/J,EAAiB,IAAIzlK,EAAMuG,QAC7Bk1B,EAAYp1B,EAAIm/J,EAChB/pI,EAAYn1B,EACZm1B,EAAYj1B,GAEVk/J,EAAoB9kK,KAAKkO,QAAQiB,WAAWgH,eAAe0uJ,GAG3DE,EAAc3lK,EAAMkJ,UAAU6B,MAChCd,KAAKuW,KACDvW,KAAK2S,KAAK0oJ,EAAct8J,UAAY08J,EAAkB18J,WAAa,KAAOiB,KAAK27J,OAEnF,EAIA,GAEJ,IACI,IAAInhJ,GAAUkhJ,EAAc1uC,EAC5BxyG,GAAUkhJ,EAAc1uC,EACxBxyG,IAEA7jB,KAAKgjK,eAAe98J,KAAK,IAAIy8J,EAAa8B,EAAa56J,IAAUga,EAAQ,EAAG,O,qGC5axF,aAUA,sBAoBI,YAAoB2V,GAAA,KAAAA,WAnBZ,KAAAyrI,mBAAqB,IAAI7lK,EAAMuG,QAC/B,KAAAu/J,mBAAqB,IAAI9lK,EAAMuG,QAE/B,KAAAw/J,iBAAmB,CACvB,IAAI/lK,EAAMuG,QACV,IAAIvG,EAAMuG,QACV,IAAIvG,EAAMuG,QACV,IAAIvG,EAAMuG,QACV,IAAIvG,EAAMuG,QACV,IAAIvG,EAAMuG,QACV,IAAIvG,EAAMuG,QACV,IAAIvG,EAAMuG,SAcd,QACI,MAAMy/J,EAAiBplK,KAAKqlK,oBAEtBzkC,EAAS5gI,KAAKw5B,SAASznB,YAE7B/R,KAAKilK,mBAAmBj+J,IAAI8gB,OAAOw9I,UAAWx9I,OAAOw9I,UAAWx9I,OAAOw9I,WACvEtlK,KAAKklK,mBAAmBl+J,KAAK8gB,OAAOw9I,WAAYx9I,OAAOw9I,WAAYx9I,OAAOw9I,WAE1E,IAAK,MAAMC,KAAiBH,EACxBG,EAActzJ,aAAa2uH,GAE3B5gI,KAAKilK,mBAAmBx/J,EAAI4D,KAAKO,IAAI5J,KAAKilK,mBAAmBx/J,EAAG8/J,EAAc9/J,GAC9EzF,KAAKilK,mBAAmBv/J,EAAI2D,KAAKO,IAAI5J,KAAKilK,mBAAmBv/J,EAAG6/J,EAAc7/J,GAC9E1F,KAAKilK,mBAAmBr/J,EAAIyD,KAAKO,IAAI5J,KAAKilK,mBAAmBr/J,EAAG2/J,EAAc3/J,GAE9E5F,KAAKklK,mBAAmBz/J,EAAI4D,KAAKS,IAAI9J,KAAKklK,mBAAmBz/J,EAAG8/J,EAAc9/J,GAC9EzF,KAAKklK,mBAAmBx/J,EAAI2D,KAAKS,IAAI9J,KAAKklK,mBAAmBx/J,EAAG6/J,EAAc7/J,GAC9E1F,KAAKklK,mBAAmBt/J,EAAIyD,KAAKS,IAAI9J,KAAKklK,mBAAmBt/J,EAAG2/J,EAAc3/J,GAStF,yBAAyBg+J,GACrB,MAAM4B,EAAmBxlK,KAAKilK,mBACxBQ,EAAmBzlK,KAAKklK,mBAE9B,QACIO,EAAiBhgK,EAAIm+J,EAAWh6J,IAAInE,GACpCggK,EAAiB//J,EAAIk+J,EAAWh6J,IAAIlE,GACpC+/J,EAAiB7/J,EAAIg+J,EAAWh6J,IAAIhE,GACpC4/J,EAAiB//J,EAAIm+J,EAAW95J,IAAIrE,GACpC+/J,EAAiB9/J,EAAIk+J,EAAW95J,IAAIpE,GACpC8/J,EAAiB5/J,EAAIg+J,EAAW95J,IAAIlE,GAUpC,oBACJ,MAAMw/J,EAAiBplK,KAAKmlK,iBACtBO,EAAiB1lK,KAAKw5B,SAAiBu2C,wBAE7C,IAAI41F,EAAc,EAElB,SAASC,EAASngK,EAAWC,EAAWE,GACpCw/J,EAAeO,KAAe3+J,IAAIvB,EAAGC,EAAGE,GAAGqM,aAAayzJ,GAoB5D,OAXAE,GANU,GACA,GACA,GAKVA,EAPU,GACA,GACA,GAMVA,GARU,EACA,GACA,GAOVA,EATU,EACA,GACA,GAUVA,GAZU,GACA,EAEA,GAUVA,EAbU,GACA,EAEA,GAWVA,GAdU,EACA,EAEA,GAYVA,EAfU,EACA,EAEA,GAcHR,K,2GC7Gf,aACA,QAGA,SAOA,4BA8DI,YAAsBl3J,GAAA,KAAAA,UArBtB,KAAA23J,oBAA8B,EAMpB,KAAAxrF,aAAgC,IAAI,EAAA2d,gBACpC,KAAA1d,cAAiC,IAAI,EAAA0d,gBACrC,KAAAziD,YAA+B,IAAI,EAAAyiD,gBAQrC,KAAA8tE,oBAA8B,EArDtC,2BACI,OAAO9lK,KAAKq6E,aAGhB,yBAAyB0rF,GACrB/lK,KAAKq6E,aAAe0rF,EAOxB,4BACI,OAAO/lK,KAAKs6E,cAGhB,0BAA0ByrF,GACtB/lK,KAAKs6E,cAAgByrF,EAOzB,0BACI,OAAO/lK,KAAKu1C,YAGhB,wBAAwBwwH,GACpB/lK,KAAKu1C,YAAcwwH,EACnB/lK,KAAKgmK,6BAST,wBACI,OAAOhmK,KAAK8lK,oBAuBhB,SAASrjJ,GACDA,EAAKke,WAAWo3C,oBAChBt1D,EAAKI,mBAAqB,IAAI,EAAAojJ,mBAAmBxjJ,IAOzD,YAAY63B,GACR,IAAK,MAAM73B,KAAQ63B,EAAO,CACtB,MAAM4rH,EAAiBzjJ,EAAKI,wBACL7gB,IAAnBkkK,IACAA,EAAe7zH,OACXryC,KAAK6lK,mBAAqB7lK,KAAKmmK,0BAAuBnkK,EACtDhC,KAAK6lK,mBAAqB7lK,KAAKomK,2BAAwBpkK,GAEvDhC,KAAKqmK,sBACLrmK,KAAKqmK,qBAAqB5jJ,IAOlCziB,KAAKsmK,2BAA2BhsH,IAChCt6C,KAAKkO,QAAQmkC,SAOrB,QACIryC,KAAKq6E,aAAar0C,QAClBhmC,KAAKs6E,cAAct0C,QACnBhmC,KAAKu1C,YAAYvP,QAWrB,WACI+G,EACAw5H,GAAmC,GAEnCvmK,KAAKwmK,mBAAmBxmK,KAAKq6E,aAActtC,EAAMw5H,GAWrD,YACIx5H,EACA05H,GAAoC,GAEpCzmK,KAAKwmK,mBAAmBxmK,KAAKs6E,cAAevtC,EAAM05H,GAWtD,SACI15H,EACA25H,GAAkC,GAElC,IAAIC,GAAuB,EAE3B,GAAIvlK,MAAMC,QAAQ0rC,IAASA,aAAgBptC,IACvC,IAAK,MAAMinK,KAAW75H,EAAM,CACxB,MAAM85H,EAAmB7mK,KAAK8mK,UAC1B9mK,KAAKu1C,YACLqxH,EACAF,GAEJC,EAAuBA,GAAwBE,OAGnDF,EAAuB3mK,KAAK8mK,UAAU9mK,KAAKu1C,YAAaxI,EAAM25H,GAI9DC,GACA3mK,KAAKgmK,6BAUb,kBAAkB1rH,GACd,MAAMysH,EAAgC,IAAI,EAAA/uE,gBAC1C,IAAK,MAAMv1E,KAAQ63B,EAAO,CACtB,MAAM4rH,EAAiBzjJ,EAAKI,mBAC5B,QAAuB7gB,IAAnBkkK,EAA8B,CAC9B,MAAMc,EAAYd,EAAee,uBACjC,QAAkBjlK,IAAdglK,EACA,IAAK,MAAMj6H,KAAQi6H,EACfD,EAAa5mK,IAAI4sC,IAKjC,OAAOg6H,EASX,2BAA2BzsH,GACvB,IAAI4sH,GAAa,EAEjB,IAAK,MAAMzkJ,KAAQ63B,EACf,GAA4B,IAAxB73B,EAAKme,QAAQt/B,QAAgBmhB,EAAKwe,oBAAsBjhC,KAAKihC,kBAAjE,CAGAxe,EAAKwe,kBAAoBjhC,KAAKihC,kBAE9B,IAAK,MAAMniC,KAAU2jB,EAAKme,QAAS,CAC/B,MAAMumI,EAAgB,EAAAv6H,iBAAiB3uC,IAAIa,GACrC08E,EAAe2rF,aAAa,EAAbA,EAAep6H,KACpC,QAAqB/qC,IAAjBw5E,EAA4B,CAC5B,MAAM4rF,GAAc5rF,EAAa/2E,KAAKsoC,GAAQ/sC,KAAKu1C,YAAYhvC,IAAIwmC,IACnEm6H,EAAaA,GAAcpoK,EAAOsnB,UAAYghJ,EAC9CtoK,EAAOsnB,QAAUghJ,IAI7B,OAAOF,EAUX,sBAAsB9gI,GAClBpmC,KAAKqmK,qBAAuBjgI,EAGtB,6BACN,QAASpmC,KAAK8lK,oBAWV,mBACJ9+J,EACA+lC,EACAs6H,GAEA,GAAIjmK,MAAMC,QAAQ0rC,GACd,IAAK,MAAM65H,KAAW75H,EAClB/sC,KAAK8mK,UAAU9/J,EAAK4/J,EAASS,QAE9B,GAAIt6H,aAAgBptC,IAAK,CAC5B,MAAM2nK,EAAUv6H,EAChB,IAAK,MAAM65H,KAAWU,EAClBtnK,KAAK8mK,UAAU9/J,EAAK4/J,EAASS,aAEjBrlK,IAAT+qC,GACP/sC,KAAK8mK,UAAU9/J,EAAK+lC,EAAMs6H,GAY1B,UAAUE,EAA2Bx6H,EAAoBs6H,GAC7D,GAAIA,GACA,IAAKE,EAAShhK,IAAIwmC,GAEd,OADAw6H,EAASpnK,IAAI4sC,IACN,OAGX,GAAIw6H,EAAShhK,IAAIwmC,GAEb,OADAw6H,EAASxgK,OAAOgmC,IACT,EAGf,OAAO,K,0GCrSf,aAeA,OAEA,QAEA,QAKA,MAAak5H,EA6ET,YAAoBuB,GAAA,KAAAA,SANZ,KAAAC,cAAwB,EA7DhC,qCAAqC5jI,GACjC,MAAM6jI,EAA4B,IAAI,EAAA1vE,gBAEtC,IAAK,MAAM1rE,KAAauX,EAAY02C,WAAY,CAC5C,MAAMiB,EAAeyqF,EAAmB0B,oBAAoBr7I,GAE5D,GAAIkvD,aAAwB77E,IACxB,IAAK,MAAMotC,KAAQyuC,EACfksF,EAASvnK,IAAI4sC,QAGjB26H,EAASvnK,IAAIq7E,GAGrB,OAAOksF,EASX,2BAA2Bp7I,GAEvB,IAAIkvD,EAAelvD,EAAUygB,KAgC7B,YA7BqB/qC,IAAjBw5E,GAEIA,EADA,EAAAjyB,gBAAgBj9B,GACD,EAAAynD,aAAakU,KAE5B,EAAA7I,gBAAgB9yD,IAChB,EAAAiyD,qBAAqBjyD,IACrB,EAAA+yD,oBAAoB/yD,IACpB,EAAAE,wBAAwBF,GAET,EAAAynD,aAAax/C,KACrB,EAAAvF,2BAA2B1C,GACnB,EAAAynD,aAAaC,SAE5B,EAAA8G,eAAexuD,IACf,EAAAyuD,sBAAsBzuD,IACtB,EAAA0uD,gBAAgB1uD,GAED,EAAAynD,aAAa6zF,MAEb,EAAA7zF,aAAaqP,IAIhC92D,EAAUygB,KAAOyuC,GACVp6E,MAAMC,QAAQm6E,KAErBA,EAAelvD,EAAUygB,KAAO,IAAI,EAAAirD,gBAAgBxc,IAGjDA,EAeX,WACI,OAAOx7E,KAAKwnK,OAMhB,iBACI,OAAOxnK,KAAKynK,aAMhB,8BAII,OAAQznK,KAAK4iB,iBAAqC5gB,IAAvBhC,KAAK8jC,cAMpC,0BACI,OAAO9jC,KAAKwnK,OAAO7iI,YAMvB,wBACI,OAAO3kC,KAAKynK,aAchB,eAAe5jI,GAQX,OAPA7jC,KAAK8jC,cAAgBD,OAEM7hC,IAAvBhC,KAAK8jC,gBACL9jC,KAAK6nK,yBAA2B5B,EAAmB6B,8BAC/C9nK,KAAK8jC,gBAGN9jC,KAAK8jC,cAMhB,6BACI,OAAO9jC,KAAK6nK,yBAMhB,OACIxtF,EACAC,G,MAEA,MAAM73D,EAAOziB,KAAKyiB,KAGdziB,KAAK4iB,YAQL5iB,KAAK+nK,oBAAoBtlJ,MAKV,QAAf,EAAAA,EAAKE,kBAAU,eAAEC,kBAAmC5gB,IAArBygB,EAAKohB,YACpC7jC,KAAKgoK,UAOLhoK,KAAKioK,0BACJjoK,KAAKkoK,qBAAqB7tF,EAAcC,IAEzCt6E,KAAKwoC,QAKJxoC,KAAKioK,8BAAgDjmK,IAArBygB,EAAKohB,cACtC,EAAAu2C,oBAAoBn6E,SAASkoK,kBAAkB1lJ,EAAM43D,EAAcC,GACnEt6E,KAAKooK,iBAAiB/tF,EAAcC,GACpCt6E,KAAKqoK,eAAe5lJ,EAAKohB,aACzB7jC,KAAKsoK,iBAAiBjuF,EAAcC,MAO5C,UACIt6E,KAAK8jC,mBAAgB9hC,EAOzB,Q,UACiC,QAA7B,EAAAhC,KAAK6nK,gCAAwB,SAAE7hI,QACZ,QAAnB,EAAAhmC,KAAKuoK,sBAAc,SAAEviI,QACD,QAApB,EAAAhmC,KAAKwoK,uBAAe,SAAExiI,QAEtBhmC,KAAK8jC,mBAAgB9hC,EACrBhC,KAAKynK,cAAe,OAEGzlK,IAAnBhC,KAAKyoK,YACLnhG,aAAatnE,KAAKyoK,WAClBzoK,KAAKyoK,eAAYzmK,GAIjB,SACJhC,KAAKwnK,OAAOkB,kBACZ1oK,KAAKwnK,OAAOhiE,oBAEZxlG,KAAK8jC,mBAAgB9hC,EACrBhC,KAAKynK,cAAe,OAEGzlK,IAAnBhC,KAAKyoK,YACLnhG,aAAatnE,KAAKyoK,WAClBzoK,KAAKyoK,eAAYzmK,GAQjB,iBACJq4E,EACAC,GAEA,MAAM73D,EAAOziB,KAAKyiB,KACZohB,EAAc7jC,KAAK8jC,mBAGL9hC,IAAhB6hC,EAKJ7jC,KAAKyoK,UAAYxyF,WAAW,KAIxB,GAFAj2E,KAAKyoK,eAAYzmK,EAEbhC,KAAK+nK,oBAAoBtlJ,GACzB,OAGJ,MAAMyhB,EAAQ,EAAAC,sBAAsBlkC,SACpC,IAAIioC,EAAM,EACNhE,EAAMllB,UACNkpB,EAAM,EAAAD,iBAAiBC,OAG3B,MAAMygI,EAAkB,EAAAvuF,oBAAoBn6E,SAO5C,GALAwiB,EAAKujB,QAEL2iI,EAAgBrtF,gBAAgBz3C,EAAaw2C,EAAcC,GAC3DquF,EAAgBC,oBAAoBnmJ,EAAMohB,GAEtCK,EAAMllB,QAAS,CACf,MAAM6pJ,EAAuB,EAAA5gI,iBAAiBC,MAAQA,EAChD7D,EAAeH,EAAMG,aAG3BA,EAAaC,SAAS,uBAAwBukI,GAC9CxkI,EAAaC,SAAS,8BAA+BukI,GAErDxkI,EAAaC,SAAS,gCAAiCukI,GACvDxkI,EAAaC,SAAS,8BAA+BT,EAAYjiB,WAAWtgB,QAC5E+iC,EAAaC,SAAS,8BAA+BT,EAAY02C,WAAWj5E,QAC5E+iC,EAAaC,SACT,sCAC8BtiC,IAA9B6hC,EAAYg+C,cAA8Bh+C,EAAYg+C,cAAcvgF,OAAS,GAEjF+iC,EAAaC,SACT,uCAC+BtiC,IAA/B6hC,EAAY44C,eAA+B54C,EAAY44C,eAAen7E,OAAS,GAEnF+iC,EAAaC,SACT,2CACmCtiC,IAAnC6hC,EAAY83C,mBACN93C,EAAY83C,mBAAmBr6E,OAC/B,GAEV+iC,EAAaC,SACT,uCAC+BtiC,IAA/B6hC,EAAYq3C,eAA+Br3C,EAAYq3C,eAAe55E,OAAS,GAEnF+iC,EAAaykI,WAET,iBAAiBrmJ,EAAKke,WAAWhjC,cAAc8kB,EAAKmB,QAAQhI,aAAa6G,EAAKmB,QAAQqY,cAAcxZ,EAAKmB,QAAQoY,OAGzHh8B,KAAKgoK,SACLvlJ,EAAKke,WAAW8D,iBACjB,GA7DCzkC,KAAKgoK,SAgEL,oBAAoBvlJ,GAIxB,IAAKA,EAAKsoD,UAAW,CAGjBtoD,EAAKvU,QAAQqU,eAAe2tG,YAAYztG,GAExC,MAAMyhB,EAAQ,EAAAC,sBAAsBlkC,SAQpC,OAPIikC,EAAMllB,SACNklB,EAAMG,aAAaykI,WAEf,iBAAiBrmJ,EAAKke,WAAWhjC,cAAc8kB,EAAKmB,QAAQhI,aAAa6G,EAAKmB,QAAQqY,cAAcxZ,EAAKmB,QAAQoY,6BAGzHh8B,KAAKgoK,UACE,EAGN,GAAIvlJ,EAAKsmJ,SAAU,CACpB,MAAM7kI,EAAQ,EAAAC,sBAAsBlkC,SAQpC,OAPIikC,EAAMllB,SACNklB,EAAMG,aAAaykI,WAEf,iBAAiBrmJ,EAAKke,WAAWhjC,cAAc8kB,EAAKmB,QAAQhI,aAAa6G,EAAKmB,QAAQqY,cAAcxZ,EAAKmB,QAAQoY,4BAGzHh8B,KAAKgoK,UACE,EAEX,OAAO,EAWH,iBACJ3tF,EACAC,G,aAEqBt4E,IAAjBq4E,IACAr6E,KAAKuoK,eAAiBzqK,OAAOysD,OACN,QADY,EAC/BvqD,KAAKuoK,sBAAc,QAAI,IAAI,EAAAvwE,gBAC3B3d,SAGcr4E,IAAlBs4E,IACAt6E,KAAKwoK,gBAAkB1qK,OAAOysD,OACN,QADY,EAChCvqD,KAAKwoK,uBAAe,QAAI,IAAI,EAAAxwE,gBAC5B1d,IAgBJ,qBACJD,EACAC,GAEA,MAAM0uF,EAAchpK,KAAKuoK,iBAAmBluF,EACtC4uF,EAAejpK,KAAKwoK,kBAAoBluF,EAE9C,GAAI0uF,GAAeC,EACf,OAAO,EAEX,MAAMC,SACuBlnK,IAAxBhC,KAAKuoK,gBAA6D,IAA7BvoK,KAAKuoK,eAAennJ,WACxCpf,IAAjBq4E,GAAoD,IAAtBA,EAAaj5D,MAC1C+nJ,SACwBnnK,IAAzBhC,KAAKwoK,iBAA+D,IAA9BxoK,KAAKwoK,gBAAgBpnJ,WACzCpf,IAAlBs4E,GAAsD,IAAvBA,EAAcl5D,MAGlD,GACK8nJ,GAAgBC,GAChBH,GAAeG,GACfF,GAAgBC,EAEjB,OAAO,EAIX,IAAKA,EAAc,CAEf,QAAqBlnK,IAAjBq4E,QAAsDr4E,IAAxBhC,KAAKuoK,eACnC,OAAO,EAGN,IAAKluF,EAAa9zE,IAAIvG,KAAKuoK,gBAC5B,OAAO,EAGf,IAAKY,EAAe,CAEhB,QAAsBnnK,IAAlBs4E,QAAwDt4E,IAAzBhC,KAAKwoK,gBACpC,OAAO,EAGN,IAAKluF,EAAc/zE,IAAIvG,KAAKwoK,iBAC7B,OAAO,EAIf,OAAO,GA3af,wB,wGCvBA,aASA,MAAavjG,UAAyB7lE,EAAM+N,UAOxC,YAAmBsK,EAAsBvG,GACrClO,QADe,KAAAyU,QAAsB,KAAAvG,UAP7C,sB,0GCPA,eAEA,2BAKI,YAA6B2nE,GAAA,KAAAA,YAO7B,kBAAkBtnC,GACd,OAAO,IAAI,EAAAihE,YAAYxyG,KAAK64E,UAAWtnC,M,iYCjB/C,YACA,YACA,YACA,UACA,YACA,Y,gICLA,aAEA,OAsBA,QACA,QAIA,QACA,QACA,QAUM/kC,EAAS,EAAAC,cAAcxM,SAASvB,OAAO,qBAEvC0qK,EAA2B,EAAA3kH,yBAAoC,IAwErE,MAAM4kH,EAGF,SAAStjJ,GACL,GAAIA,EAAMujJ,UAAW,CACjB,MAAMC,EAAavpK,KAAKwpK,YAAYzjJ,GACpCA,EAAMujJ,UAAYvjJ,EAAMujJ,UAAUvpK,OAAOC,UAAMgC,GAC/ChC,KAAKypK,OAASF,GAItB,qBAAqB1pK,EAAuB6pK,GACxC,OAAO7pK,EAGX,wBAAwBA,EAA0B6pK,GAC9C,OAAO7pK,EAGX,uBAAuBA,EAAyB6pK,GAC5C,OAAO7pK,EAGX,uBAAuBA,EAAyB6pK,GAC5C,OAAO7pK,EAGX,uBAAuBA,EAAyB6pK,GAC5C,OAAO7pK,EAGX,aAAaA,EAAe6pK,GACxB,OAAO7pK,EAGX,sBAAsBA,EAAwB6pK,GAC1C,OAAO7pK,EAGX,eAAeA,EAAiB6pK,GAC5B,OAAO7pK,EAGX,cAAcA,EAAgB6pK,GAC1B,OAAO7pK,EAGX,cAActC,EAAgBmsK,GAC1B,GAAgB,QAAZnsK,EAAKgD,GAAc,CAInB,MAAM2hB,EAAW3kB,EAAK6C,KACjB2F,IAAIzF,GAAaA,EAAUP,OAAOC,KAAMzC,IACxCi1B,OAAOlyB,QAA2B0B,IAAd1B,GAEzB,OAAO,IAAI,EAAA8D,SAAS7G,EAAKgD,GAAI2hB,GAC1B,GAAIwnJ,EAAe,CAEtB,MAAMC,EAAU3pK,KAAK4pK,yBAAyBrsK,GAE9C,GAAIosK,EAAS,CACT,QAA0B3nK,IAAtBhC,KAAKypK,OAAO96H,OAAwC,WAAjBg7H,EAAQhsK,KAS3C,YAHAqC,KAAKypK,OAAO96H,MAAQg7H,EAAQtrK,OAIzB,QAC2B2D,IAA9BhC,KAAKypK,OAAOI,eACK,kBAAjBF,EAAQhsK,KAUR,YAHAqC,KAAKypK,OAAOI,cAAgBF,EAAQtrK,QAQhD,OAAOd,EAGX,cAAcsC,EAAgB6pK,GAC1B,MAAM,IAAIjmK,MAAM,QAGpB,qBAAqB5D,EAAuB6pK,GACxC,MAAM,IAAIjmK,MAAM,QASZ,yBAAyBlG,GAC7B,GAAgB,OAAZA,EAAKgD,GAAa,CAClB,MAAMue,EAAOvhB,EAAK6C,KAAK,GACjBif,EAAQ9hB,EAAK6C,KAAK,GAExB,GAAI0e,aAAgB,EAAA/b,SAAWsc,aAAiB,EAAA/b,kBAC5C,MAAO,CAAE3F,KAAMmhB,EAAKnhB,KAAMU,MAAOghB,EAAMhhB,OAG3C,GAAIghB,aAAiB,EAAAtc,SAAW+b,aAAgB,EAAAxb,kBAC5C,MAAO,CAAE3F,KAAM0hB,EAAM1hB,KAAMU,MAAOygB,EAAKzgB,QAY3C,YAAY0nB,GAChB,MAAM+jJ,EAAQ9pK,KAAKypK,OAEnB,OADAzpK,KAAKypK,OAAS1jJ,EACP+jJ,GAIf,MAAMC,EAOF,YAAYp7H,EAA4B41C,GACpCvkF,KAAKrB,IAAM,GACXqB,KAAKgH,IAAI2nC,EAAO41C,GAGpB,IACI51C,EACA41C,EACAniF,GAEA,IAAI4nK,GAA2B,EAC/B,QAAchoK,IAAV2sC,EAAqB,CACrB,MAAMs7H,OAAmBjoK,IAARI,EAAoBA,EAAI6qB,OAAO,eAAYjrB,EAC5D2sC,EAA4B,iBAAbs7H,EAAwBA,OAAWjoK,EAOtD,GALIhC,KAAK2uC,QAAUA,IACf3uC,KAAK2uC,MAAQA,EACbq7H,GAAkB,QAGDhoK,IAAjBuiF,EAA4B,CAC5B,MAAM2lF,OAA0BloK,IAARI,EAAoBA,EAAI6qB,OAAO,sBAAmBjrB,EAC1EuiF,EAA0C,iBAApB2lF,EAA+BA,OAAkBloK,EAU3E,OARIhC,KAAKukF,eAAiBA,IACtBvkF,KAAKukF,aAAeA,EACpBylF,GAAkB,GAGlBA,GACAhqK,KAAKmqK,YAEFnqK,KAGH,iBACegC,IAAfhC,KAAK2uC,WAEqB3sC,IAAtBhC,KAAKukF,aACLvkF,KAAKrB,IAAM,GAAGqB,KAAK2uC,SAAS3uC,KAAKukF,eAEjCvkF,KAAKrB,IAAM,GAAGqB,KAAK2uC,cAGG3sC,IAAtBhC,KAAKukF,aACLvkF,KAAKrB,IAAM,IAAIqB,KAAKukF,eAEpBvkF,KAAKrB,IAAM,MAGnBqB,KAAKoqK,oBAAiBpoK,GAqoB9B,SAAgBqoK,EAAqB/9I,GACjC,MAAMnmB,EAAoC,GAC1C,IAAK,MAAMoT,KAAY+S,EAAW,CAC9B,IAAKA,EAAUrtB,eAAesa,GAC1B,SAGJ,IAAI05H,EAAkB3mH,EAAkB/S,GAGf,iBAAd05H,IACNA,EAAUq3B,WAAar3B,EAAUs3B,WAAat3B,EAAUu3B,aAEzDv3B,EAAY,EAAA9vI,YAAYglI,UAAU8K,IAGlC,EAAAzxI,KAAKuG,OAAOkrI,KACZA,EAAYA,EAAU51B,UAGzBl3G,EAAeoT,GAAY05H,EAEhC,OAAQ9sI,EAppBZ,0BAmBI,YAAY2yE,EAAoBj3E,GAhBf,KAAA4oK,aAAmC,GACnC,KAAAC,WAAa,IAAI,EAAAnyF,SACjB,KAAAoyF,gBAAkB,IAAIxoK,IACtB,KAAAyoK,2BAA6B,IAAIvB,EACjC,KAAAwB,mBAAqB,IAAI1oK,IAEzB,KAAA2oK,sBAAwB,IAAI3oK,IAC5B,KAAA4oK,wBAA8C,IAAIhB,EAClD,KAAAiB,WAAa,IAAI,EAAA3rI,IAC1B,KAAA4rI,sBAAkC,GAQtCjrK,KAAKkrK,cAAgBrpK,EACrB7B,KAAK84E,SAwkBb,SAA2BA,EAA8Bj3E,GACrD,OAAOi3E,EAAS/yE,IAAIggB,GAGxB,SAASolJ,EACLplJ,EACAlkB,GAEA,GAAI,EAAAX,WAAW6kB,GAAQ,CACnB,IAAK,EAAAsmG,oBAAoBtmG,GACrB,MAAM,IAAItiB,MAAM,iEAGpB,MAAMooH,EAAiB9lG,EAAM,GACvBia,EAAMn+B,GAAeA,EAAYgqH,GACvC,IAAK7rF,EACD,MAAM,IAAIv8B,MAAM,sBAAsBooH,kBAE1C,IAAK,EAAAC,2BAA2B9rF,GAC5B,MAAM,IAAIv8B,MAAM,sBAAsBooH,kCAG1C,OAAOs/C,EAAuBnrI,EAAKn+B,GAGvC,OAAO,OAAP,UAAYkkB,GAxBiBolJ,CAAuBplJ,EAAOlkB,IAzkBvCupK,CAAkBtyF,EAAUj3E,GA6jBpD,SAAmCi3E,GAC/B,IAAIuyF,EAAuB,EACvBC,EAAgB,EACpB,IAAK,MAAMvlJ,KAAS+yD,EAChB/yD,EAAMwlJ,eAAiBD,SACCtpK,IAApB+jB,EAAMuG,gBAAiDtqB,IAAtB+jB,EAAMO,cACvCP,EAAMO,YAAc+kJ,KAlkBxBG,CAA0BxrK,KAAK84E,UAC/B94E,KAAKyrK,kBAaT,sBACIrpK,EACAusC,EACA41C,GAEA,GACIvkF,KAAK0rK,kBACL1rK,KAAK2rK,eACL3rK,KAAKirK,sBAAsBlmK,MAAM7F,IAAI,MAAC,OAAkB,QAAlB,EAAAc,KAAK2rK,qBAAa,eAAE1+I,OAAO/tB,MAAOkD,EAAI6qB,OAAO/tB,KAEnF,OAAOc,KAAK0rK,iBAGhB,MAAMvlK,EAA6B,GACnCnG,KAAK2qK,gBAAgB3kI,QAErB,MAAM4lI,EAAqB5rK,KAAK+qK,wBAChCa,EAAmB5kK,IAAI2nC,EAAO41C,EAAcniF,GAG5CpC,KAAK6rK,QAAUD,EAAmBj9H,MAClC3uC,KAAK8rK,eAAiBF,EAAmBrnF,aACzCvkF,KAAKi/D,YAAc78D,EAAI6qB,OAAO,SAE9B,MAAM8+I,EAAmB/rK,KAAKgsK,qBAAqBJ,GAEnD,IAAK,MAAMK,KAAaF,EACpB,GAAI/rK,KAAKksK,aAAa9pK,EAAK6pK,EAAW9lK,GAClC,MAOR,OAHAnG,KAAK0rK,iBAAmBvlK,EACxBnG,KAAK2rK,cAAgBvpK,EAEd+D,EAQX,WAAWwoC,GACP,OACI3uC,KAAKgsK,qBAAqBhsK,KAAK+qK,wBAAwB/jK,IAAI2nC,OAAO3sC,IAAYV,OAAS,EAU/F,aAAaqtC,EAAe41C,GACxB,OACIvkF,KAAKgsK,qBAAqBhsK,KAAK+qK,wBAAwB/jK,IAAI2nC,EAAO41C,IAC7DjjF,OAAS,EAStB,+BACI,OAAOtB,KAAK2qK,gBAQhB,kBACI,IAAK,MAAMwB,KAAansK,KAAKyqK,aACzB0B,EAAUjiB,YAASloJ,EAEvBhC,KAAKyqK,aAAanpK,OAAS,EAC3BtB,KAAK0rK,sBAAmB1pK,EACxBhC,KAAK2rK,mBAAgB3pK,EAMzB,iBACI,OAAOhC,KAAKyqK,aAMhB,wBACI,OAAOzqK,KAAKyqK,aAAa1kK,IAAIskK,GAGzB,qBAAqB+B,GACzB,QAAiCpqK,IAA7BoqK,EAAUhC,eACV,OAAOgC,EAAUhC,eAErB,IAAIiC,EAAoBrsK,KAAK6qK,mBAAmB5sK,IAAImuK,EAAUztK,KAC9D,YAA0BqD,IAAtBqqK,GACAD,EAAUhC,eAAiBiC,EACpBA,IAEXA,EAAoBrsK,KAAKssK,0BAA0BF,GACnDpsK,KAAK6qK,mBAAmB7jK,IAAIolK,EAAUztK,IAAK0tK,GAC3CD,EAAUhC,eAAiBiC,EACpBA,GAGH,0BAA0BD,GAC9B,MAAM,MAAEz9H,EAAK,aAAE41C,GAAiB6nF,EAEhC,OAAOpsK,KAAK84E,SAAStmD,OAAOzM,SACV/jB,IAAV2sC,QAAuC3sC,IAAhB+jB,EAAM4oB,OAAuB5oB,EAAM4oB,QAAUA,UAInD3sC,IAAjBuiF,QACwBviF,IAAxB+jB,EAAM8jJ,eACN9jJ,EAAM8jJ,gBAAkBtlF,IAW5B,kBACJvkF,KAAKirK,sBAAwB,CAAC,SAAU,gBAAiB,SAEzDjrK,KAAK84E,SAASz4E,QAAQ0lB,GAAS/lB,KAAKusK,aAAaxmJ,IAGjD/lB,KAAK84E,SAASz4E,QAAQ0lB,IAClB/lB,KAAKgsK,qBACDhsK,KAAK+qK,wBAAwB/jK,IAAI+e,EAAM4oB,MAAO5oB,EAAM8jJ,kBAUxD,aAAa9jJ,GAGjB,GAFA/lB,KAAKwsK,4BAA4BzmJ,QAEd/jB,IAAf+jB,EAAMwmG,KACN,IACIxmG,EAAMujJ,UAAYloK,MAAMC,QAAQ0kB,EAAMwmG,MAChC,EAAA/qH,KAAKmF,SAASof,EAAMwmG,KAAMvsH,KAAKkrK,cAAelrK,KAAK8qK,uBAEnD,EAAAtpK,KAAKG,MAAMokB,EAAMwmG,MAKvBvsH,KAAK4qK,2BAA2B6B,SAAS1mJ,QAEjB/jB,IAApB+jB,EAAMujJ,YACNvjJ,EAAMujJ,UAAYvjJ,EAAMujJ,UAAU/tF,OAAOv7E,KAAK0qK,aAGlD,MAAMx8B,EAAOnoH,EAAMujJ,UAAUxpK,eAE7BouI,WAAMxuI,WAAWW,QAAQuyB,IAChB5yB,KAAKirK,sBAAsBn3F,SAASlhD,IACrC5yB,KAAKirK,sBAAsB/kK,KAAK0sB,KAIpC,EAAA1xB,WAAW6kB,EAAMhG,gBACjBgG,EAAM2mJ,kBAAoB,EAAAlrK,KAAKmF,SAASof,EAAMhG,cAAcw7D,OACxDv7E,KAAK0qK,aAIT,EAAAxpK,WAAW6kB,EAAM/F,gBACjB+F,EAAM4mJ,kBAAoB,EAAAnrK,KAAKmF,SAASof,EAAM/F,cAAcu7D,OACxDv7E,KAAK0qK,aAGf,MAAOhpE,GACLl1F,EAAOytB,IACH,gCACAxyB,KAAKC,UAAUqe,EAAMwmG,MACrB,QACA18D,OAAO6xC,KAmBf,aAAat/F,EAAU2jB,EAAsB5f,GACjD,IAAKnG,KAAK4sK,eAAexqK,EAAK2jB,GAC1B,OAAO,EAGX,QACqB/jB,IAAjBhC,KAAK6rK,cACW7pK,IAAhB+jB,EAAM4oB,OACN5oB,EAAM4oB,QAAU3uC,KAAK6rK,QAErB,OAAO,EAEX,QAC4B7pK,IAAxBhC,KAAK8rK,qBACmB9pK,IAAxB+jB,EAAM8jJ,eACN9jJ,EAAM8jJ,gBAAkB7pK,KAAK8rK,eAE7B,OAAO,EAGX,GAAI/lJ,EAAMujJ,UACN,IACI,IAAKvjJ,EAAMujJ,UAAU7vF,SAASr3E,EAAK,EAAAb,UAAU4sI,UAAWnuI,KAAK2qK,iBAIzD,OAAO,EAEb,MAAOpsJ,GAIL,OAHA/R,EAAO+R,MACH,kCAAkC9W,KAAKC,UAAUqe,EAAMwmG,WAAWhuG,MAE/D,EAIf,YAAwBvc,IAApB+jB,EAAMuG,YAIc,SAApBvG,EAAMuG,WACNnmB,EAAOD,KAAKlG,KAAK6sK,0BAA0BzqK,EAAK2jB,KAG7B,IAAhBA,EAAM+mJ,OAGT,eAAe1qK,EAAU2jB,GAC7B,QAA2B/jB,IAAvB+jB,EAAMhG,mBAAqD/d,IAAvB+jB,EAAM/F,aAC1C,OAAO,EAGX,MAAMpJ,EAAY5W,KAAKi/D,YACvB,QAAkBj9D,IAAd4U,EACA,OAAO,EAGX,QAA2B5U,IAAvB+jB,EAAMhG,aAA4B,CAClC,IAAIA,EAAsBgG,EAAMhG,aAEhC,GAAIgG,EAAM2mJ,kBAGN,IACI3sJ,EAAegG,EAAM2mJ,kBAAkBjzF,SACnCr3E,EACA,EAAAb,UAAU4sI,UACVnuI,KAAK2qK,iBAEX,MAAOpsJ,GACL/R,EAAO+R,MACH,kCAAkC9W,KAAKC,UACnCqe,EAAM2mJ,wBACHnuJ,KAKnB,GAA4B,iBAAjBwB,GAA6BnJ,EAAYmJ,EAChD,OAAO,EAIf,QAA2B/d,IAAvB+jB,EAAM/F,aAA4B,CAClC,IAAIA,EAAsB+F,EAAM/F,aAEhC,GAAI+F,EAAM4mJ,kBACN,IACI3sJ,EAAe+F,EAAM4mJ,kBAAkBlzF,SACnCr3E,EACA,EAAAb,UAAU4sI,UACVnuI,KAAK2qK,iBAEX,MAAOpsJ,GACL/R,EAAO+R,MACH,kCAAkC9W,KAAKC,UACnCqe,EAAM4mJ,wBACHpuJ,KAKnB,GAA4B,iBAAjByB,GAA6BpJ,EAAYoJ,EAChD,OAAO,EAIf,OAAO,EAGH,0BAA0B5d,EAAU2jB,GACxC,IAAIuG,EACJ,QAAiCtqB,IAA7B+jB,EAAMgnJ,mBAAkC,CACxC,MAAMC,EAAoBhtK,KAAKitK,4BAA4BlnJ,EAAO3jB,GAC5DzD,EAAMqB,KAAKktK,uBAAuBnnJ,EAAOinJ,GAC/C1gJ,EAAYvG,EAAMgnJ,mBAAoB9uK,IAAIU,QACxBqD,IAAdsqB,IACAA,EAAYtsB,KAAKmtK,gBAAgBpnJ,EAAOpnB,EAAKquK,GAC7CjnJ,EAAMgnJ,mBAAoB/lK,IAAIrI,EAAK2tB,SAGvCA,EAAYvG,EAAMqnJ,sBACAprK,IAAdsqB,IACAvG,EAAMqnJ,iBAAmB9gJ,EAAYtsB,KAAKmtK,gBACtCpnJ,EACA,GAAGA,EAAMwlJ,iBACT,KASZ,YAJyBvpK,IAArBsqB,EAAU49H,SACV59H,EAAU49H,OAASlqJ,KAAKyqK,aAAanpK,OACrCtB,KAAKyqK,aAAavkK,KAAKomB,IAEpBA,EAGH,uBACJvG,EACAinJ,GAEA,MAAMK,EAAiBL,EAClBjnK,IAAI,EAAEunK,EAAWr6B,UACIjxI,IAAdixI,EACO,IAEAxrI,KAAKC,UAAUurI,IAG7B78D,KAAK,KACV,MAAO,GAAGrwD,EAAMwlJ,kBAAmB8B,IAG/B,4BAA4BtnJ,G,MAChC,QAA0C/jB,IAAtC+jB,EAAMwnJ,6BAAiE,SAApBxnJ,EAAMuG,UACzD,OAGJvG,EAAMwnJ,4BAA8B,GACpCxnJ,EAAMynJ,0BAA4B,GAClCznJ,EAAM0nJ,4BAA8B,GACpC1nJ,EAAM2nJ,kBAAoB,GAE1B,MAAMC,EAA2B5nJ,EAAMynJ,0BACjCI,EAA6B7nJ,EAAMwnJ,4BACnCM,EAA6B9nJ,EAAM0nJ,4BACnCK,EAAyB/nJ,EAAM2nJ,kBAE/BK,EACF,EAAAx/I,qBAAqBxI,EAAMuG,YAAc88I,EAEvC4E,EAAmB,CAACz0J,EAAkB05H,KACxC,QAAkBjxI,IAAdixI,EAAJ,CAiBA,GAbI,EAAA/xI,WAAW+xI,GACXA,EAAY,EAAAzxI,KAAKmF,SACbssI,EACAjzI,KAAKkrK,cACLlrK,KAAK8qK,uBACPvvF,OAAOv7E,KAAK0qK,YACP,EAAA7jK,iCAAiCosI,KAExCA,EAAY,EAAAzxI,KAAKmF,SACb,EAAAG,yCAAyCmsI,IAC3C13D,OAAOv7E,KAAK0qK,aAGd,EAAAlpK,KAAKuG,OAAOkrI,GAAY,CACxB,MAAM/E,EAAO+E,EAAUnzI,eAEnBouI,EAAKztI,eACY,YAAb8Y,EACA/M,EAAOytB,IAAI,kDAEXlU,EAAMkoJ,mBAAoB,GAIL,IAAzB//B,EAAKxuI,WAAW0hB,MAAe6xH,EAAUtuI,cAEzCsuI,EAAYA,EAAUx5D,SAASz5E,KAAKgrK,aAI5C,GAAI,EAAAxpK,KAAKuG,OAAOkrI,GAAY,CACxB,IAAIi7B,EAAoCH,EAAoB7pH,WACxD3qC,QAGcvX,IAAdksK,IAEAA,EAAY,EAAA/pH,UAAUC,mBAG1B,MAAM8pF,EAAO+E,EAAUnzI,eAQvB,OANAouI,EAAKxuI,WAAWW,QAAQuyB,IACf5yB,KAAKirK,sBAAsBn3F,SAASlhD,IACrC5yB,KAAKirK,sBAAsB/kK,KAAK0sB,KAIhCs7I,GACJ,KAAK,EAAA/pH,UAAUE,gBACXspH,EAAyBznK,KAAK,CAACqT,EAAU05H,IACzC,MACJ,KAAK,EAAA9uF,UAAUC,kBACXwpH,EAA2B1nK,KAAK,CAACqT,EAAU05H,IAC3C,MACJ,KAAK,EAAA9uF,UAAUI,mBACkB,IAAzB2pF,EAAKxuI,WAAW0hB,KAChBysJ,EAA2B3nK,KAAK,CAACqT,EAAU05H,IAE3C26B,EAA2B1nK,KAAK,CAACqT,EAAU05H,UAIhDA,SACP66B,EAAuB5nK,KAAK,CAACqT,EAAU05H,MAIzCwtB,EAAc,IAAIt+J,IAAoB,CACxC,CAAC,WAAY,aACb,CAAC,oBAAqB,wBAG1B,IAAK,MAAMjD,KAAK6mB,EAAO,CACnB,IAAKA,EAAM9mB,eAAeC,GACtB,SAEJ,GAAIA,EAAEkkD,WAAW,KACb,SAEJ,GAAI,CAAC,OAAQ,YAAa,QAAS,OAAQ,eAAe0wB,SAAS50E,GAC/D,SAGJ8uK,EAD6B,QAArB,EAAGvN,EAAYxiK,IAAIiB,UAAE,QAAIA,EACX6mB,EAAc7mB,IAGxC,QAAmB8C,IAAf+jB,EAAMk4D,KACN,IAAK,MAAM1kE,KAAYwM,EAAMk4D,KACpBl4D,EAAMk4D,KAAKh/E,eAAesa,IAG/By0J,EAAiBz0J,EAAWwM,EAAMk4D,KAAa1kE,IAInDq0J,EAA2BtsK,OAAS,IACpCykB,EAAMgnJ,mBAAqB,IAAI5qK,KAI/B,4BAA4B4jB,EAAsB3jB,GACtD,YAA0CJ,IAAtC+jB,EAAMwnJ,4BACC,GAGJxnJ,EAAMwnJ,4BAA4BxnK,IAAI,EAAEwT,EAAU40J,MACrD,IAMI,MAAO,CAAC50J,EALe40J,EAAS10F,SAC5Br3E,EACA,EAAAb,UAAUe,MACVtC,KAAK2qK,kBAGX,MAAOpsJ,GAEL,OADA/R,EAAO+R,MAAM,kCAAkC4vJ,EAAS9wD,cAAc9+F,KAC/D,CAAChF,EAAU,SAKtB,gBACJwM,EACApnB,EACAyvK,GAEA,MAAM9hJ,EAAiB,GAEvB,GADAA,EAAU3uB,KAAOooB,EAAMuG,eACStqB,IAA5B+jB,EAAM2nJ,kBACN,IAAK,MAAOn0J,EAAU05H,KAAcltH,EAAM2nJ,kBACpB,OAAdz6B,IACA3mH,EAAU/S,GAAY05H,GAIlC,IAAK,MAAO15H,EAAU05H,KAAcm7B,EACd,OAAdn7B,IACA3mH,EAAU/S,GAAY05H,GAI9B,QAAwCjxI,IAApC+jB,EAAMynJ,0BACN,IAAK,MAAOj0J,EAAU05H,KAAcltH,EAAMynJ,0BACtClhJ,EAAU/S,GAAY05H,EAI9B,QAA0CjxI,IAAtC+jB,EAAM0nJ,4BACN,IAAK,MAAOl0J,EAAU05H,KAAcltH,EAAM0nJ,4BACtCnhJ,EAAU/S,GAAY05H,EAa9B,OATA3mH,EAAU49H,OAASlqJ,KAAKyqK,aAAanpK,OACrCgrB,EAAUi/I,eAAiBxlJ,EAAMwlJ,oBACVvpK,IAAnB+jB,EAAM+yD,WACNxsD,EAAUs3D,UAAY79D,EAAM+yD,eAEA92E,IAA5B+jB,EAAMkoJ,oBACN3hJ,EAAU2hJ,kBAAoBloJ,EAAMkoJ,mBAExCjuK,KAAKyqK,aAAavkK,KAAKomB,GAChBA,IAgDf,0B,sLCx7BA,aAEM+hJ,EAAgB,IAAIjvK,EAAMoG,QAC1B8oK,EAAe,IAAIlvK,EAAMoG,QACzB+oK,EAAgB,IAAInvK,EAAMoG,QAC1BgpK,EAAe,IAAIpvK,EAAMoG,QAW/B,2BACIipK,EACA77G,EACA87G,EACAC,EACAC,EACAC,EACAC,EACAC,GAEA,IAAK,IAAI3xK,EAAI,EAAGA,EAAIwxK,EAAoBttK,SAAUlE,EAC9C,GAAIwxK,EAAoBxxK,GACpB,IAAmB,IAAfyxK,EAAqB,CACrB,MAAMG,EAAcp8G,EAAmB,EAAJx1D,EAC7B6xK,EAASD,EAAc,EACvBE,EAAct8G,GAAiBx1D,EAAI,GAAKwxK,EAAoBttK,OAAU,EACtE6tK,EAASD,EAAc,GAEH,IAAtBJ,GACAL,EAAYvoK,KAAK8oK,EAAaE,GAElCT,EAAYvoK,KAAK+oK,EAAQE,GAEzB,MAAMC,GAAqB,IAANhyK,EAAUwxK,EAAoBttK,OAASlE,GAAK,EACjE,GAAIwxK,EAAoBQ,GACpB,QAAsBptK,IAAlB+sK,EAA6B,CAC7B,MAAMM,EAAMV,EAAevxK,EAAIsxK,GACzBY,EAAMX,EAAevxK,EAAIsxK,EAAe,GACxCa,EACFZ,GAAiBvxK,EAAI,GAAKwxK,EAAoBttK,OAAUotK,GACtDc,EACFb,GACMvxK,EAAI,GAAKwxK,EAAoBttK,OAAUotK,EAAe,GAGhEL,EAAcrnK,IAAIqoK,EAAKC,GACvBhB,EAAatnK,IAAIuoK,EAAKC,GACtBjB,EAAcvnK,IACV2nK,EAAeS,EAAcV,GAC7BC,EAAeS,EAAcV,EAAe,IAEhDF,EAAaxnK,IAAIqnK,EAAc5oK,EAAG4oK,EAAc3oK,GAG5C8oK,EACK17J,IAAIy7J,GACJ19J,YACA6E,IAAI44J,EAAax7J,IAAIu7J,GAAex9J,cAAgBk+J,GAEzDN,EAAYvoK,KAAK8oK,EAAaC,QAGlCR,EAAYvoK,KAAK8oK,EAAaC,OAGnC,CACH,MAAMQ,EAAS78G,EAAex1D,EACxB6xK,EAASr8G,GAAiBx1D,EAAI,GAAKwxK,EAAoBttK,OAC7DmtK,EAAYvoK,KAAKupK,EAAQR,M,wGCpEzC,eAcA,SAAiBS,GACb,SAAgBC,EAAqBj/I,GACjC,GAAIA,aAAkBI,UAClB,MAAO,OACJ,GAAIJ,aAAkBC,WACzB,MAAO,QACJ,GAAID,aAAkBM,WACzB,MAAO,QACJ,GAAIN,aAAkBQ,YACzB,MAAO,SACJ,GAAIR,aAAkBU,WACzB,MAAO,QACJ,GAAIV,aAAkBY,YACzB,MAAO,SACJ,GAAIZ,aAAkBc,aACzB,MAAO,QAGX,MAAM,IAAI/tB,MAAM,2BAA2B9F,QAG/C,SAAgBiyK,EACZC,GAEA,MAAMn/I,EAAUm/I,EAAgBl2J,MAChC,MAAO,CACHhc,KAAMkyK,EAAgBlyK,KACtB+yB,OAAQA,EAAOA,OACf9gB,KAAM+/J,EAAqBj/I,GAC3B+C,UAAWo8I,EAAgB71J,SAC3B0Z,WAAYm8I,EAAgBn8I,YA7BpB,EAAAi8I,qBAAoB,EAoBpB,EAAAC,yBAAwB,EAaxB,EAAAE,oCAAhB,SACID,GAEA,MAAM,IAAIpsK,MAAM,wBAGJ,EAAAssK,wBAAhB,SACI51J,EACAijE,GAEA,MAAMU,EAAsC,GACtCkyF,EAAiBlyK,OAAOy0B,oBAAoBpY,EAAeM,YACjE,IAAK,MAAM9c,KAAQqyK,EAAgB,CAC/B,MAEMjyF,EAAkB6xF,EAFNz1J,EAAeM,WAAW9c,IAG5CogF,EAAgBpgF,KAAOA,EACvBmgF,EAAiB53E,KAAK63E,GAE1B,MAAMrjE,EACuB,OAAzBP,EAAeO,MACTk1J,EAAyBz1J,EAAeO,YACxC1Y,EAEV,IAAI+X,EAAQ,EACZ,QAAc/X,IAAV0Y,EACAX,EAAiC,OAAzBI,EAAeO,MAAiB,EAAIP,EAAeO,MAAMX,UAC9D,CAEH,MAAM0oE,EAAUtoE,EAAeM,WAAW1M,SAC1C,QAAgB/L,IAAZygF,EACA,MAAM,IAAIh/E,MAAM,kDAEpBsW,EAAQ0oE,EAAQ1oE,MAGpB,MAAO,CACHnK,KAAM,EAAA+3E,aAAaH,YACnB1J,mBACApjE,QACAkoB,OAAQ,CAAC,CAAEmH,MAAO,EAAGhwB,QAAOuS,UAAW8wD,MA1EnD,CAAiB,EAAAsyF,mBAAA,EAAAA,iBAAgB,M,uGCnBjC,aAMA,SAASO,EAAWC,GAChB,OAAOA,EAAItqK,GAAK,GAAKsqK,EAAItqK,EAAI,GAAKsqK,EAAIzqK,IAAM,GAAKyqK,EAAIzqK,GAAK,GAAKyqK,EAAIxqK,IAAM,GAAKwqK,EAAIxqK,GAAK,EAO3F,kBAAao/D,EAYT,YAAoBtrC,GAAA,KAAAA,WARZ,KAAAuxH,QAAkB,EAClB,KAAAC,SAAmB,EAY3B,YACI,OAAOhrJ,KAAK+qJ,QAMhB,aACI,OAAO/qJ,KAAKgrJ,SAYhB,QACI3/H,EACA9c,EAAwB,IAAInP,EAAMoG,SAElC,MAAMtG,EAAIc,KAAKmwK,cAAc9kJ,EAAQy5C,EAAgBsrG,QACrD,GAAIlxK,EAAE0G,GAAK,GAAK1G,EAAE0G,EAAI,EAClB,OAAO5F,KAAKqwK,YAAYnxK,EAAGqP,GAcnC,gBACI8c,EACA9c,EAAwB,IAAInP,EAAMoG,SAElC,MAAMtG,EAAIc,KAAKmwK,cAAc9kJ,EAAQy5C,EAAgBsrG,QACrD,GAAIH,EAAW/wK,GACX,OAAOc,KAAKqwK,YAAYnxK,EAAGqP,GAcnC,SACI8c,EACA9c,EAAwB,IAAInP,EAAMuG,SAElC,MAAMzG,EAAIc,KAAKmwK,cAAc9kJ,EAAQy5C,EAAgBsrG,QACrD,GAAIlxK,EAAE0G,GAAK,GAAK1G,EAAE0G,EAAI,EAElB,OADA2I,EAAOvH,IAAK9H,EAAEuG,EAAIzF,KAAK+qJ,QAAW,EAAI7rJ,EAAEwG,EAAI1F,KAAKgrJ,SAAY,EAAG9rJ,EAAE0G,GAC3D2I,EAaf,cAAc8c,EAAqB9c,GAE/B,OADAA,EAAOvH,IAAIqkB,EAAO5lB,EAAG4lB,EAAO3lB,EAAG2lB,EAAOzlB,GAAG27C,QAAQvhD,KAAKw5B,UAC/CjrB,EAQX,SAAS8c,GAEL,OAAO4kJ,EADGjwK,KAAKmwK,cAAc9kJ,EAAQy5C,EAAgBsrG,SAWzD,OAAO1hK,EAAsB+I,EAAevG,GACxClR,KAAKw5B,SAAW9qB,EAChB1O,KAAK+qJ,QAAUtzI,EACfzX,KAAKgrJ,SAAW95I,EAGZ,YAAYg/J,EAAoB3qF,GACpC,OAAOA,EAAav+E,IAAKkpK,EAAIzqK,EAAIzF,KAAK+qJ,QAAW,EAAImlB,EAAIxqK,EAAI1F,KAAKgrJ,SAAY,IAEtF,OA/HW,EAAAslB,OAAS,IAAIlxK,EAAMoG,QACnB,EAAA4qK,OAAS,IAAIhxK,EAAMuG,QA8H9B,GAhIA,GAAa,EAAAm/D,mB,qGCbb,eACA,SAOA,sBAUI,YACYyrG,EACAC,EACR9hK,GAEA,OAJQ,KAAA6hK,QACA,KAAAC,mBAGAxwK,KAAKuwK,MAAM3gK,MACf,IAAK,WACD5P,KAAKywK,aAAe,IAAI,EAAAC,mBAAmB1wK,KAAKuwK,MAAOvwK,KAAKwwK,kBAC5DxwK,KAAK6yE,aAAankE,GAClB,MACJ,IAAK,UACD1O,KAAKywK,aAAe,IAAI,EAAAE,kBAAkB3wK,KAAKuwK,QAS3D,UACIvwK,KAAKywK,aAAchrI,UAMvB,cACI,OAAOzlC,KAAKywK,aAAct5J,QAQ9B,aAAazI,GACe,aAApB1O,KAAKuwK,MAAM3gK,MACV5P,KAAKywK,aAAqCp+H,OAAO3jC,GAW1D,cAAc2O,EAAkCkyF,GAC5C,MAAMqhE,EACF5wK,KAAKuwK,MAAM3gK,OAASyN,EAAOzN,MAAQ5P,KAAKwwK,mBAAqBjhE,EACjE,OAAQlyF,EAAOzN,MACX,IAAK,WACGghK,EACC5wK,KAAKywK,aAAqC/6F,cAAcr4D,GAEzDrd,KAAKywK,aAAe,IAAI,EAAAC,mBAAmBrzJ,EAAQkyF,GAEvD,MACJ,IAAK,UACGqhE,EACC5wK,KAAKywK,aAAoC/6F,cAAcr4D,GAExDrd,KAAKywK,aAAe,IAAI,EAAAE,kBAAkBtzJ,GAKtDrd,KAAKwwK,iBAAmBjhE,EACxBvvG,KAAKuwK,MAAQlzJ,K,0JCzFrB,aACA,OACA,OAEa,EAAAwzJ,qBAAuB,IACvB,EAAAC,uBAAyB,EAGtC,MAAM50J,EAAY,CACd,IAAI,EAAAvW,QAAQ,EAAG,EAAG,GAClB,IAAI,EAAAA,SAAS,EAAG,EAAG,GACnB,IAAI,EAAAA,QAAQ,GAAI,EAAG,GACnB,IAAI,EAAAA,QAAQ,EAAG,EAAG,GAClB,IAAI,EAAAA,QAAQ,EAAG,EAAG,GAClB,IAAI,EAAAA,QAAQ,EAAG,GAAI,IAEjBorK,EAAc,CAChB,IAAI,EAAAprK,QAAQ,EAAG,GAAI,GACnB,IAAI,EAAAA,QAAQ,EAAG,EAAG,GAClB,IAAI,EAAAA,QAAQ,EAAG,EAAG,GAClB,IAAI,EAAAA,QAAQ,EAAG,EAAG,GAClB,IAAI,EAAAA,QAAQ,EAAG,EAAG,GAClB,IAAI,EAAAA,SAAS,EAAG,EAAG,IAEjBqrK,EAAW,CACb,IAAI,EAAArrK,QAAQ,EAAG,EAAG,GAClB,IAAI,EAAAA,QAAQ,EAAG,EAAG,GAClB,IAAI,EAAAA,QAAQ,EAAG,EAAG,GAClB,IAAI,EAAAA,QAAQ,EAAG,GAAI,GACnB,IAAI,EAAAA,QAAQ,EAAG,EAAG,GAClB,IAAI,EAAAA,QAAQ,EAAG,EAAG,IAUtB,2BAqBI,YACImjE,EACQ0nG,EACAxlB,EAAmB,EAAA6lB,sBADnB,KAAAL,mBACA,KAAAxlB,WAER,MAAMrW,EAAW,IAAI,EAAAjrH,MAAMo/C,EAAI6rE,UACzBC,EAAc,IAAI,EAAAlrH,MAAMo/C,EAAI8rE,aAC5Bp/D,EAAc,IAAI,EAAA9rD,MAAMo/C,EAAI0M,aAElCx1E,KAAK+qJ,QAAU/qJ,KAAKwwK,mBAAqB,EAAA3gK,eAAeC,OAAS,EAAM9P,KAAKgrJ,SAC5EhrJ,KAAKixK,YAAcjxK,KAAKwwK,mBAAqB,EAAA3gK,eAAeC,OAAS,EAAM,EAC3E9P,KAAKkxK,QAAU,GACf,IAAK,IAAI9zK,EAAI,EAAGA,EAAI4C,KAAKixK,cAAe7zK,EAAG,CACvC,MAAMkqC,EAAO,IAAI3W,WAAW,EAAI3wB,KAAK+qJ,QAAU/qJ,KAAKgrJ,UACpDhrJ,KAAKmxK,gBAAgB7pI,EAAMlqC,EAAGu3I,EAAUC,EAAap/D,EAAa1M,EAAIsoG,eAEtE,MAAMj6J,EAAU,IAAI,EAAAwa,YAAY2V,EAAMtnC,KAAK+qJ,QAAS/qJ,KAAKgrJ,SAAU,EAAAngD,WACnE1zF,EAAQ5K,aAAc,EACtB4K,EAAQk6J,gBAAkB,EAC1BrxK,KAAKkxK,QAAQhrK,KAAKiR,GAGlBnX,KAAKwwK,mBAAqB,EAAA3gK,eAAee,WACzC5Q,KAAKkqH,SAAW,IAAI,EAAAE,YAAYpqH,KAAKkxK,SACrClxK,KAAKkqH,SAAS39G,aAAc,IAE5BvM,KAAKsxK,gCAAkC,IAAI,EAAAla,MAC3Cp3J,KAAKuxK,cAAgB,IAAI,EAAA3kK,MAAM,IAAI,EAAAjH,QAAQ,EAAG,EAAG,IACjD3F,KAAKwxK,oBAAsB,IAAI,EAAA7rK,QAC/B3F,KAAKyxK,iBAAmB,IAAI,EAAA9rK,QAC5B3F,KAAK0xK,kBAAoB,IAAI,EAAA/rK,QAC7B3F,KAAK2xK,sBAAwB,CACzB,IAAI,EAAAhsK,QACJ,IAAI,EAAAA,QACJ,IAAI,EAAAA,QACJ,IAAI,EAAAA,UAQhB,UACI,IAAK,IAAIvI,EAAI,EAAGA,EAAI4C,KAAKixK,cAAe7zK,EACpC4C,KAAKkxK,QAAQ9zK,GAAGqoC,UAEhBzlC,KAAKwwK,mBAAqB,EAAA3gK,eAAee,WACzC5Q,KAAKkqH,SAAUzkF,UAQvB,cACI,OAAOzlC,KAAKwwK,mBAAqB,EAAA3gK,eAAeC,OAAS9P,KAAKkxK,QAAQ,GAAKlxK,KAAKkqH,SAQpF,OAAOx7G,GACC1O,KAAKwwK,mBAAqB,EAAA3gK,eAAeC,SACzC9P,KAAK4xK,mBAAmBljK,GACxB1O,KAAK6xK,yBASb,cAAc/oG,GACV,IAAK,IAAI1rE,EAAI,EAAGA,EAAI4C,KAAKixK,cAAe7zK,EACpC4C,KAAKmxK,gBACDnxK,KAAKkxK,QAAQ9zK,GAAGka,MAAMgwB,KACtBlqC,EACA,IAAI,EAAAssB,MAAMo/C,EAAI6rE,UACd,IAAI,EAAAjrH,MAAMo/C,EAAI8rE,aACd,IAAI,EAAAlrH,MAAMo/C,EAAI0M,aACd1M,EAAIsoG,eAERpxK,KAAKkxK,QAAQ9zK,GAAGmP,aAAc,EAE9BvM,KAAKwwK,mBAAqB,EAAA3gK,eAAee,YACzC5Q,KAAKkqH,SAAU39G,aAAc,GAS7B,gBACJ+6B,EACAwqI,EACAn9B,EACAC,EACAp/D,EACA47F,GAEA,MAAMnmJ,EAAQ,IAAI,EAAAvB,MACZ6lE,EAAM,IAAI,EAAA5pF,QACV0Z,EAAQ,IAAI,EAAA1Z,QACZk/D,EAAK,IAAI,EAAAl/D,QAETosK,EAAQ,IAAI,EAAApsK,QAAQ,EAAG,EAAG,GAChC,IAAK,IAAIvI,EAAI,EAAGA,EAAI4C,KAAKgrJ,WAAY5tJ,EACjC,IAAK,IAAI4kD,EAAI,EAAGA,EAAIhiD,KAAK+qJ,UAAW/oG,EAAG,CACnC,GAAIhiD,KAAKwwK,mBAAqB,EAAA3gK,eAAee,UAAW,CACpD,MAAM2D,EAAU8K,EACX/P,KAAKyhK,EAAYe,IACjBl+J,gBAAiBouC,EAAI,IAAOhiD,KAAK+qJ,QAAW,EAAM,GACjDv2I,EAAUqwD,EACXv1D,KAAK0hK,EAASc,IACdl+J,gBAAiBxW,EAAI,IAAO4C,KAAKgrJ,SAAY,EAAM,GACxDz7D,EAAIjgF,KAAK4M,EAAU41J,IACd3xK,IAAIoU,GACJpU,IAAIqU,GACJ3D,YACL,MAAMvS,EAAI+K,KAAKS,IAAIioK,EAAMr8J,IAAI65E,GAAM,GAEnCtkE,EACK3b,KAAKkmE,GACL93C,KAAKk3G,EAAavrI,KAAKO,IAAQ,IAAJtL,EAAS,IACpCo/B,KAAKi3G,EAAUr2I,GAAK,EAAAswE,eAAewiG,EAAe,EAAAN,yBAClDl9J,eAAe,SACjB,CACH,MAAMtV,EAAIlB,EAAI4C,KAAKgrJ,SACT,IAAN5tJ,EACA6tB,EAAM3b,KAAKkmE,GAAa5hE,eAAe,KAEvCqX,EACK3b,KAAKslI,GACLl3G,KACGi3G,EACAr2I,GAAK,EAAAswE,eAAewiG,EAAe,EAAAN,yBAEtCl9J,eAAe,KAI5B0zB,EAAKlqC,EAAI4C,KAAK+qJ,QAAU,EAAQ,EAAJ/oG,GAAS/2B,EAAM/sB,EAC3CopC,EAAKlqC,EAAI4C,KAAK+qJ,QAAU,EAAQ,EAAJ/oG,EAAQ,GAAK/2B,EAAM4C,EAC/CyZ,EAAKlqC,EAAI4C,KAAK+qJ,QAAU,EAAQ,EAAJ/oG,EAAQ,GAAK/2B,EAAMvhB,GAKnD,mBAAmBgF,GACvB1O,KAAK2xK,sBAAuB,GAAG3qK,KAAK,GAAI,EAAG,GAAGgrK,UAAUtjK,GACxD1O,KAAK2xK,sBAAuB,GAAG3qK,IAAI,GAAI,EAAG,GAAGgrK,UAAUtjK,GACvD1O,KAAK2xK,sBAAuB,GAAG3qK,KAAK,EAAG,EAAG,GAAGgrK,UAAUtjK,GACvD1O,KAAK2xK,sBAAuB,GAAG3qK,IAAI,EAAG,EAAG,GAAGgrK,UAAUtjK,GAEtD1O,KAAKwxK,oBAAqBliK,KAAKtP,KAAK2xK,sBAAuB,IACtDxxK,IAAIH,KAAK2xK,sBAAuB,IAChC/9J,eAAe,IACpB5T,KAAKyxK,iBAAkBniK,KAAKtP,KAAK2xK,sBAAuB,IACnDxxK,IAAIH,KAAK2xK,sBAAuB,IAChC/9J,eAAe,IACpB5T,KAAKsxK,gCAAiCtqK,IAAIhH,KAAKwxK,oBAAqBxxK,KAAKyxK,kBAEjDzxK,KAAKuxK,cAAe1Z,cACxC73J,KAAKsxK,gCACLtxK,KAAK0xK,oBAOL1xK,KAAK0xK,kBAAmB1qK,IAAI,EAAK,EAAK,GAItC,wBACJ,MAEMirK,EAFejyK,KAAKwxK,oBAAqB91J,WAAW1b,KAAK0xK,mBACzC1xK,KAAKsxK,gCAAiCtiK,WAStD29D,EAA6C,IAArC3sE,KAAK0xK,kBAAmBpwK,SAAiB,EAAI2wK,EAAW,EAAIjyK,KAAKgrJ,SAK/EhrJ,KAAKkxK,QAAQ,GAAGrtJ,OAAO7c,IAAI,EAAGhH,KAAKwxK,oBAAqB5rK,GAAK,GAAK+mE,EAAQslG,M,qICnQlF,aACA,OAEa,EAAAC,0BAA4B,UAEzC,MAAM1lK,EAAS,EAAAC,cAAcxM,SAASvB,OAAO,qBAI7C,0BAGI,YAA6BmxC,GAAA,KAAAA,UAFrB,KAAAsiI,kBAA4B,EAUpC,WAAWC,GACP,QAAkCpwK,IAA9BhC,KAAK6vC,QAAQ05B,cAAmE,IAArCvpE,KAAK6vC,QAAQ05B,aAAajoE,OAOrE,OANAtB,KAAK6vC,QAAQ05B,aAAe,CACxB,CACI5rE,KAAM,EAAAu0K,0BACNzuH,IAAK2uH,IAGN,EAAAF,0BAIX,OAD+BlyK,KAAK6vC,QAAQ05B,aAAa,GAAG5rE,KAIhE,mBAAmB00K,GACf,EAAA/lK,YAAqCtK,IAA9BhC,KAAK6vC,QAAQ05B,cACpB,EAAAj9D,OAAOtM,KAAK6vC,QAAQ05B,aAAcjoE,OAAS,GAE3C,MAAMggG,EAAiC,GAevC,OAbAthG,KAAK6vC,QAAQ05B,aAAclpE,QAAQiyK,IAC/BtyK,KAAKmyK,mBAAqB,EAC1B,MAAMI,EAAoC,EAAA74B,YAAYvnH,KAAKmgJ,EAAkB7uH,IAAK,MAC7Eze,KAAWqtI,EAAgBzzK,UAAKoD,EAAWswK,EAAkB30K,OAC7DwnC,MAAO5mB,IACJ/R,EAAO+R,MAAM,+BAAgCA,KAEhDqoG,QAAQ,KACL5mH,KAAKmyK,mBAAqB,IAElC7wE,EAASp7F,KAAKqsK,KAGXt6H,QAAQC,IAAIopD,GAGvB,cACI,OAAOthG,KAAKmyK,kBAAoB,K,oGCzDxC,aAQA,qBAEI,YACqBt5F,EACA25F,GADA,KAAA35F,YACA,KAAA25F,6BAHJ,KAAAC,eAAiB,IAAIrzK,EAAMuG,QAM5C,kBACI,OAAO3F,KAAK64E,UAAUh+C,YAE1B,qBACI,OAAO76B,KAAK64E,UAAUz4B,eAE1B,wBACI,OAAOpgD,KAAK64E,UAAU5sB,WAAWhC,QAErC,gBACI,OAAOjqD,KAAK64E,UAAUjiE,UAE1B,UACI,OAAO5W,KAAK64E,UAAUz2E,IAE1B,kBACI,OAAOpC,KAAK64E,UAAUr2C,YAE1B,mBACI,OAAOxiC,KAAK64E,UAAUnqE,OAAOc,kBAAkBxP,KAAKyyK,gBAExD,qBACI,OAAOzyK,KAAK64E,UAAU5pE,eAE1B,gBACI,OAAOjP,KAAK64E,UAAUtG,eAE1B,0BACI,YAA8CvwE,IAAvChC,KAAK64E,UAAUg6C,yBAChB7wH,EACAhC,KAAK64E,UAAUg6C,oBAAoBr9E,oBAG7C,2BACI,OAAOx1C,KAAKwyK,6BAGhB,iBACI,OAAOxyK,KAAK64E,UAAU1pE,WAG1B,wBACI,OAAOnP,KAAK64E,UAAUz9D,qB,yGC3D9B,aACA,OAEA,0BAQI,YAA6B+mD,GAAA,KAAAA,aAPrB,KAAAuwG,gBAA0B,EAC1B,KAAAC,gBAA0B,EAQlC,oBAAoB/oK,EAAaE,GAC7B9J,KAAK0yK,gBAAkB9oK,EACvB5J,KAAK2yK,gBAAkB7oK,EAO3B,iBAAiBiuC,GAGb,OAFA,EAAAzrC,OAAOtM,KAAK2yK,gBAAkB,GAEvB,IAAI,EAAArwB,WAAW,CAClB5pH,SAAU14B,KAAKmiE,WACfpqB,cACAyqG,cAAexiJ,KAAK0yK,gBACpBjwB,cAAeziJ,KAAK2yK,qB,2LC7BhC,eACA,SAaA,MAAaC,UAA6B,EAAAC,0BAUtC,YACYC,EACAC,EACAC,EACAC,EAAsC,EAAAj6C,gBAAgB/4H,YAE9D+C,QALQ,KAAA8vK,aACA,KAAAC,eACA,KAAAC,mBACA,KAAAC,oBASZ,kBAAkB14C,GACdv6H,KAAKgzK,iBAAmBz4C,EAO5B,2BACI,YAAuCv4H,IAAnChC,KAAKkzK,4BAITlzK,KAAKkzK,0BAA4BlzK,KAAKizK,kBACjCt5C,aAAwC35H,KAAK8yK,WAAY,CACtDv4C,QAASv6H,KAAKgzK,mBAEjBhuI,KAAKpjC,GAAQA,EAAK5B,KAAK+yK,eACvB5tI,MAAM5mB,IACHve,KAAKwM,OAAO+R,MAAMA,GACX,MAVJve,KAAKkzK,2BAjCxB,0B,uGCRA,MACA,eA8CA,kBAAal6C,EAuDT,YAAqBm6C,EAAgB7qG,MAAgB8qG,EAAqB,GAArD,KAAAD,gBAAgC,KAAAC,aAT7C,KAAAC,oBAAsB,EACtB,KAAAC,cAAgB,IAAIlyK,MACpB,KAAAmyK,gBAAkB,IAAIpxK,IAlC9B,kBACI,OAAO62H,EAAgBw6C,gBAGnB,6BACJL,EACAM,EACAL,EACA3vH,EACA0xD,GAEA,IACI,MAAM5sC,QAAiB4qG,EAAc1vH,EAAK0xD,GAC1C,GAAwB,MAApB5sC,EAASmrG,QAAkBD,EAAaL,EACxC,OAAO7qG,EAEb,MAAOm5B,GACL,GACIA,EAAIziG,eAAe,gBAClByiG,EAAIziG,eAAe,SAAwB,eAAbyiG,EAAI/jG,MACnC81K,EAAaL,EAEb,MAAM1xE,EAGd,OAAOs3B,EAAgB26C,QAAQ36C,EAAgB46C,aAAeH,GAAYzuI,KAAK,IAC3Eg0F,EAAgB66C,gBAAgBV,EAAeC,EAAYK,EAAa,EAAGhwH,EAAK0xD,IAGhF,eAAe2+D,GACnB,OAAO,IAAI77H,QAAcqzB,GAAW2K,WAAW3K,EAASwoG,IAsB5D,aAAgBrwH,EAAkB0xD,GAC9B,OAAOn1G,KAAK+zK,WAAcxrG,GAAYA,EAAS3mE,OAAQ6hD,EAAK0xD,GAYhE,oBAAoB1xD,EAAkB0xD,GAClC,OAAOn1G,KAAKg0K,SAASvwH,EAAK0xD,GAAMnwE,KAAKujC,GAAYA,EAAS0rG,eAU9D,SAASxwH,EAAkB0xD,GACvB,GAAIn1G,KAAKqzK,qBAAuBr6C,EAAgBk7C,qBAAsB,CAClE,MAAMC,EAAW,IAAI,EAAAC,gBAA0B,IAAMp0K,KAAKq0K,WAAW5wH,EAAK0xD,IAE1E,OADAn1G,KAAKszK,cAAcptK,KAAKiuK,GACjBA,EAASpzE,QAEpB,OAAO/gG,KAAKq0K,WAAW5wH,EAAK0xD,GAExB,iBAAiB1xD,EAAkB0xD,GACvC,MACMn1G,KAAKqzK,oBACP,MAAM9qG,QAAiBywD,EAAgB66C,gBACnC7zK,KAAKmzK,cACL,EACAnzK,KAAKozK,WACL3vH,EACA0xD,GAIJ,OADAn1G,KAAKs0K,iBACE/rG,EACT,MAAOhqD,GAEL,MADAve,KAAKs0K,iBACC/1J,GAGN,mBACFve,KAAKqzK,oBACPrzK,KAAKu0K,uBAED,uBACJ,MAAMC,EAASx0K,KAAKszK,cAAcv3F,WACnB/5E,IAAXwyK,GAGJA,EAAOt2I,OAEH,WACJu2I,EACAhxH,EACA0xD,GAEA,MAAMu/D,EAAWjxH,EACXkxH,EAAe30K,KAAKuzK,gBAAgBt1K,IAAIy2K,GAC9C,QAAqB1yK,IAAjB2yK,EACA,OAAO18H,QAAQqzB,QAAQqpG,GAE3B,MAAMC,EAAW50K,KAAKg0K,SAASvwH,EAAK0xD,GAC/BnwE,KAAKujC,IAEF,GADAvoE,KAAKuzK,gBAAgBxsK,OAAO2tK,GACxBnsG,EAASq7C,GACT,OAAO6wD,EAAUlsG,GAErB,MAAM,IAAI9kE,MAAMgE,KAAKC,UAAU6gE,MAElCpjC,MAAMu8D,IAEH,MADA1hG,KAAKuzK,gBAAgBxsK,OAAO2tK,GACtBhzE,IAGd,OADA1hG,KAAKuzK,gBAAgBvsK,IAAI0tK,EAAUE,GAC5BA,GAEf,OAlJoB,EAAAhB,aAAe,IAIf,EAAAM,qBAAuB,GAOf,EAAAV,gBAAkB,IAAIx6C,EAuIlD,GAxJA,GAAa,EAAAA,mB,uGC9Cb,wBAYI,YAA6B67C,GAAA,KAAAA,WACzB70K,KAAK+gG,QAAU,IAAI9oD,QAAW,CAACqzB,EAAS41B,KACpClhG,KAAK80K,YAAcxpG,EACnBtrE,KAAK+0K,WAAa7zE,IAO1B,OACIlhG,KAAK60K,WACA7vI,KAAK7+B,GAAUnG,KAAK80K,YAAa3uK,IACjCg/B,MAAM5mB,GAASve,KAAK+0K,WAAYx2J,O,+PChB7C,SAAiBy2J,GAIG,EAAAlyJ,UAAhB,SAA0BkyF,GACtB,YAAoChzG,IAA7BgzG,EAAUrS,gBALzB,CAAiB,EAAAqyE,YAAA,EAAAA,UAAS,M,+HCf1B,aAEA,OAGA,OACA,OACA,QAKA,IAAKC,EASAC,EASOC,GAlBZ,SAAKF,GACD,uBACA,iBACA,mCAHJ,CAAKA,MAAiB,KAStB,SAAKC,GACD,2CACA,iCACA,6BAHJ,CAAKA,MAAwB,KAS7B,SAAYC,GACR,qCACA,mCAFJ,CAAYA,EAAA,EAAAA,sBAAA,EAAAA,oBAAmB,KAQ/B,MAUMjzK,EAAQ,CACVkzK,WAAY,CAAE12J,KAAM,EAAGC,IAAK,IAMhC,kBAAa02J,EAiET,YACYh1G,EACAi1G,EACAC,EACAC,EACAC,EAAyCR,EAAkBS,aAC3DC,EAAoBT,EAAyBU,kBAL7C,KAAAv1G,eACA,KAAAi1G,gBACA,KAAAC,eACA,KAAAC,mBACA,KAAAC,sBACA,KAAAE,oBA5CJ,KAAArzD,WAAqB,EAQrB,KAAAuzD,sBAAwB,IAAI,EAAAj9G,4BApDD,KAqD/B,EAAA5rD,eAAeC,kBACf,EACA,EACA,IACA,KAKa,KAAA6oK,iBAAmB,IAAI12K,EAAMuG,QAAQ,EAAK,EAAK,GA6BxD3F,KAAKy1K,oBAAsBR,EAAkBc,KAC7C/1K,KAAKg2K,oBAGLh2K,KAAKy1K,oBAAsBR,EAAkBgB,QAC7Cj2K,KAAKk2K,uBAETl2K,KAAKm2K,gBAAgBn2K,KAAKqgE,cAlE9B,iBAAiB+1G,GACb,IAAK,MAAMr0D,KAAaq0D,EAAWl0J,SAC/B,GACI6/F,EAAUpkH,OAAS03K,EAAkBgB,uBACrCt0D,EAAUpkH,OAAS03K,EAAkBiB,yBAErC,OAAO,EAGf,OAAO,EA4DX,cACI,OAAOt2K,KAAKu2K,UAGhB,iBACI,OAAOv2K,KAAKw2K,aAWhB,YAAYt/F,GAER,GAAIl3E,KAAK+oK,SACL,OAEJ,GAAI/oK,KAAKsiH,YAAcprC,EACnB,OAEJl3E,KAAKsiH,UAAYprC,EACjB,MAAMu/F,EAAUpB,EAAkBqB,UAAU12K,KAAKqgE,cAC7C6W,IAAWu/F,EACXz2K,KAAKm2K,gBAAgBn2K,KAAKqgE,eAClB6W,GAAUu/F,GAClBz2K,KAAK22K,qBAAqB32K,KAAKqgE,cAOvC,cACI,OAAOrgE,KAAKsiH,UAGhB,cAAcs0D,GACV,GAAI52K,KAAK21K,oBAAsBT,EAAyBU,iBACpD,OAEJ,MAAMiB,EAAeD,IAAczB,EAAoB2B,aACvD,QAA8B90K,IAA1BhC,KAAK+2K,iBAAgC,CACnB/2K,KAAK+2K,iBACbC,mBAAmBH,GAEjC,QAA2B70K,IAAvBhC,KAAKi3K,cAA6B,CACnBj3K,KAAKi3K,cACbD,mBAAmBH,IAOlC,U,YAEQ72K,KAAKgf,UACLhf,KAAKgf,SAAU,GAGD,QAAlB,EAAAhf,KAAKi3K,qBAAa,SAAExxI,UACC,QAArB,EAAAzlC,KAAK+2K,wBAAgB,SAAEtxI,UAEL,QAAlB,EAAAzlC,KAAKk3K,qBAAa,SAAEzxI,UACC,QAArB,EAAAzlC,KAAKm3K,wBAAgB,SAAE1xI,UAGvBzlC,KAAKk3K,mBAAgBl1K,EACrBhC,KAAKm3K,sBAAmBn1K,EAExBhC,KAAKi3K,mBAAgBj1K,EACrBhC,KAAK+2K,sBAAmB/0K,EAExBhC,KAAKu2K,eAAYv0K,EACjBhC,KAAKw2K,kBAAex0K,EAaxB,MAAM08D,IAIN,eACI,YAA0B18D,IAAnBhC,KAAKu2K,gBAAiDv0K,IAAtBhC,KAAKw2K,aAMxC,gBAAgBJ,GACpB,EAAA9pK,QAAQ+oK,EAAkBqB,UAAUN,GAAa,iCAC1Bp0K,IAAnBhC,KAAKu2K,WACLH,EAAWj2K,IAAIi3K,EAAgBp3K,KAAKu2K,UAAWzuJ,OAAO29E,wBAEhCzjG,IAAtBhC,KAAKw2K,cACLJ,EAAWj2K,IAAIi3K,EAAgBp3K,KAAKw2K,aAAc1uJ,OAAOC,mBAIzD/nB,KAAKw1K,kBACLx1K,KAAKw1K,mBAOL,qBAAqBY,GACzB,IAAKf,EAAkBqB,UAAUN,GAC7B,OAEJ,IAAI/jI,GAAS,OACUrwC,IAAnBhC,KAAKu2K,YACLH,EAAW/yI,OAAOrjC,KAAKu2K,WACvBlkI,GAAS,QAEarwC,IAAtBhC,KAAKw2K,eACLJ,EAAW/yI,OAAOrjC,KAAKw2K,cACvBnkI,GAAS,GAETA,GAAUryC,KAAKw1K,kBACfx1K,KAAKw1K,mBAIL,oBACJ,IAAI6B,EACJ,OAAQr3K,KAAKu1K,aAAa3lK,MACtB,KAAK,EAAAC,eAAee,UAChBymK,EAAc,IAAIj4K,EAAMk4K,eACe,MAAnC,EAAAtqK,eAAeC,kBACf,IACA,KAEJ,MACJ,QACIoqK,EAAc,IAAIj4K,EAAMm6C,cAAc,IAAK,KAKnD89H,EAAY1tE,UAAU,EAAG,EAAG,GAC5B3pG,KAAKk3K,cAAgB,IAAI93K,EAAMob,eAC/Bxa,KAAKk3K,cAAcrtD,aAAawtD,GAChCA,EAAY5xI,UAERzlC,KAAK21K,oBAAsBT,EAAyBU,iBACpD51K,KAAKi3K,cAAgB,IAAI,EAAAlgC,sBAClB/2I,KAAK21K,oBAAsBT,EAAyBqC,YAC3Dv3K,KAAKi3K,cAAgB,IAAI73K,EAAM+Y,kBAAkB,CAC7C8S,MAAO,IAAI7rB,EAAMsqB,MAAM,UACvBwB,QAAS,GACTxgB,aAAa,EACbwkB,WAAW,EACXyqB,YAAY,EACZ+iD,KAAMt9F,EAAM43I,SACZpsI,SAAUxL,EAAMiN,eAChBwiB,KAAK,IAGT7uB,KAAKi3K,cAAgB,IAAI73K,EAAM8uD,qBAAqB,CAChDjjC,MAAO,QACPiE,WAAW,EACXyqB,YAAY,EACZ69H,YAAa,IAAIp4K,EAAMoG,SAAS,GAAI,GACpCk3F,KAAMt9F,EAAM43I,SACZp9F,WAAW,IAInB55C,KAAKu2K,UAAY,IAAIn3K,EAAM40B,KAAKh0B,KAAKk3K,cAAel3K,KAAKi3K,eAEzDj3K,KAAKu2K,UAAU54K,KAAO03K,EAAkBgB,sBACxCr2K,KAAKy3K,uBAGD,uBACJ,IAAIC,EACJ,OAAQ13K,KAAKu1K,aAAa3lK,MACtB,KAAK,EAAAC,eAAee,UAChB8mK,EAAiB,IAAIt4K,EAAMk4K,eACY,OAAnC,EAAAtqK,eAAeC,kBACf,IACA,KAEJ,MACJ,QACIyqK,EAAiB,IAAIt4K,EAAMm6C,cAAc,IAAK,KAItDm+H,EAAe/tE,UAAU,EAAG,EAAG,GAC/B3pG,KAAKm3K,iBAAmB,IAAI/3K,EAAMob,eAClCxa,KAAKm3K,iBAAiBttD,aAAa6tD,GACnCA,EAAejyI,UAEXzlC,KAAK21K,oBAAsBT,EAAyBU,iBACpD51K,KAAK+2K,iBAAmB,IAAI,EAAA/hC,yBACrBh1I,KAAK21K,oBAAsBT,EAAyBqC,YAC3Dv3K,KAAK+2K,iBAAmB,IAAI33K,EAAM+Y,kBAAkB,CAChD8S,MAAO,IAAI7rB,EAAMsqB,MAAM,OACvBwB,QAAS,GACTxgB,aAAa,EACbwkB,WAAW,EACXyqB,YAAY,EACZ+iD,KAAMt9F,EAAM61I,UACZrqI,SAAUxL,EAAMiN,eAChBwiB,KAAK,IAGT7uB,KAAK+2K,iBAAmB,IAAI33K,EAAM8uD,qBAAqB,CACnDjjC,MAAO,QACPiE,WAAW,EACXyqB,YAAY,EACZ+iD,KAAMt9F,EAAM61I,UACZr7F,WAAW,IAInB55C,KAAKw2K,aAAe,IAAIp3K,EAAM40B,KAAKh0B,KAAKm3K,iBAAkBn3K,KAAK+2K,kBAE/D/2K,KAAKw2K,aAAa74K,KAAO03K,EAAkBiB,yBAE3Ct2K,KAAK23K,0BAGD,uBACJ,QAAuB31K,IAAnBhC,KAAKu2K,UACL,OAKJ,IAAIqB,EAGAA,EAFA53K,KAAK21K,oBAAsBT,EAAyBU,iBAEjC,CAAClnK,EAAsBooH,KACtC92H,KAAK63K,mBAAmBnpK,IAIT,CAACA,EAAsBjE,KACtCzK,KAAK63K,mBAAmBnpK,GAExB,EAAApC,OAAO7B,aAAoB,EAAAssI,uBAC3B,MAAMhpC,EAAM/tG,KAAKi3K,cACjBlpE,EAAI7hD,eAAe6hD,EAAK/tG,KAAKu2K,UAAY7nK,EAAQ1O,KAAK81K,mBAK9D,EAAAxpK,YAA8BtK,IAAvBhC,KAAKi3K,eACZj3K,KAAKu2K,UAAUnqH,eAAiB,CAC5BuqE,EACAC,EACAloH,EACAmoH,EACApsH,EACAssH,KAEA6gD,EAAiBlpK,EAAQjE,IAG7BzK,KAAKu2K,UAAUuB,cAAgB,CAC3BnhD,EACAC,EACAloH,EACAmoH,EACAC,EACAC,KAEA/2H,KAAK+3K,iBAAiBrpK,IAItB,+BACsB1M,IAAtBhC,KAAKw2K,cAGLx2K,KAAK21K,oBAAsBT,EAAyBU,mBAIxD,EAAAtpK,YAAiCtK,IAA1BhC,KAAK+2K,kBAGZ/2K,KAAKw2K,aAAapqH,eAAiB,CAC/BuqE,EACAC,EACAloH,EACAmoH,EACApsH,EACAssH,KAEA,EAAAzqH,OAAO7B,aAAoB,EAAAuqI,0BAC3B,MAAMjnC,EAAM/tG,KAAK+2K,iBACjBhpE,EAAI7hD,eAAe6hD,EAAK/tG,KAAKw2K,aAAe9nK,EAAQ1O,KAAK81K,oBAIzD,mBAAmBkC,GAEvB,MAAMC,EAAWj4K,KAAKs1K,cACtBpzK,EAAMkzK,WAAW12J,KAAOu5J,EAASv5J,KACjCxc,EAAMkzK,WAAWz2J,IAAMs5J,EAASt5J,IAGhC,MAAMstC,EAAajsD,KAAK61K,sBAAsB7mD,mBAC1ChvH,KAAKs1K,cACLt1K,KAAKu1K,cAGT,EAAAjpK,OAAO0rK,aAAqB54K,EAAMq6D,mBAClC,MAAMh8D,EAAIu6K,EACVv6K,EAAEihB,KAAOutC,EAAWvtC,KAGpBjhB,EAAEkhB,IAAMstC,EAAWttC,IAAyC,GAAnC,EAAA3R,eAAeC,kBACxCxP,EAAEgyE,yBAGE,iBAAiBuoG,GACrB,EAAA1rK,OAAO0rK,aAAqB54K,EAAMq6D,mBAClC,MAAMh8D,EAAIu6K,EAEVv6K,EAAEihB,KAAOxc,EAAMkzK,WAAW12J,KAC1BjhB,EAAEkhB,IAAMzc,EAAMkzK,WAAWz2J,IACzBlhB,EAAEgyE,0BAEV,OAtaW,EAAA4mG,sBAAgC,gBAIhC,EAAAC,yBAAmC,mBAka9C,GA1aA,GA4aA,SAASc,EAAgB11J,EAAkB4E,GACvC,MAAM67F,EAASzgG,EAIf,OAHAygG,EAAO77F,YAAcA,EACrB67F,EAAO+1D,UAAW,EAClB/1D,EAAOA,OAAS,IAAI/iH,EAAMuG,QAAQ,EAAG,EAAG,GACjCw8G,EAjbE,EAAAkzD,qB,mGC5Cb,SAAY8C,GACR,yBACA,+BAFJ,CAAY,EAAAA,cAAA,EAAAA,YAAW,M,qGCbvB,aASA,oCACY,KAAAC,gBAAkB,IAAIh5K,EAAM8yB,cAQpC,WACIuxB,EACA40H,EACAC,GAAuB,GAGvB,QAAuBt2K,IAAnBq2K,EACA,OAAOr4K,KAAKu4K,oBAAoB90H,GAIpC,MAAM8kB,QAAiBD,MAAM7kB,EAAK,CAC9B82E,QAAS89C,EACT95K,KAAM+5K,EAAc,OAAS,YAE3Bx1E,QAAav6B,EAASu6B,OAGtB3rF,QAAgBnX,KAAKu4K,oBAAoBvmJ,IAAIC,gBAAgB6wE,IAI7D01E,EACY,gBAAd11E,EAAKlzF,MACL6zC,EAAI8vD,OAAO,kBAAoB,GACM,IAArC9vD,EAAI8vD,OAAO,sBAGf,OAFAp8F,EAAQya,OAAS4mJ,EAASp5K,EAAMyrG,UAAYzrG,EAAMw+F,WAE3CzmF,EAGH,oBAAoBssC,GACxB,OAAO,IAAIxL,QAAuB,CAACqzB,EAAS41B,KACxClhG,KAAKo4K,gBAAgBK,eAAe,IACpCz4K,KAAKo4K,gBAAgBjmJ,KACjBsxB,EACAtsC,GAAWm0D,EAAQn0D,QACnBnV,EACA,IAAMk/F,EAAO,IAAIz9F,MAAM,iC,wGCrDvC,aACA,OAEA,SAWM+I,EAAS,EAAAC,cAAcxM,SAASvB,OAAO,oBA0F7C,yBAaI,YACW+jB,EACCxf,EACRgT,GAFO,KAAAwM,OACC,KAAAxf,UAdJ,KAAAy1K,eAAgB,EAChB,KAAAC,cAAe,EACf,KAAAC,cAAe,EACf,KAAAC,iBAAkB,EActB,MAAMC,GAAgC,IAArB7iK,EAAQ6iK,SACzB94K,KAAK04K,cAAgBI,MAAsC,IAAxB7iK,EAAQ8iK,aAC3C/4K,KAAK24K,aAAeG,MAAqC,IAAvB7iK,EAAQ+iK,YAC1Ch5K,KAAK44K,aAAeE,MAAqC,IAAvB7iK,EAAQgjK,YAC1Cj5K,KAAK64K,gBAAkBC,MAAwC,IAA1B7iK,EAAQijK,eAMjD,WACI,MAAMt4I,EAAU5gC,KAAKyiB,KAAKme,QAE1B,IAAK,MAAM9hC,KAAU8hC,EACjB5gC,KAAKm5K,YAAYr6K,GASf,YAAYA,GAClB,MAAM+iB,OACkB7f,IAApBlD,EAAOgjB,SACAhjB,EAAOgjB,SAASC,aACjB/f,EAIV,QACoBA,IAAhB6f,QAC0B7f,IAAzB6f,EAAY6e,UACuB,IAAhC7e,EAAY6e,SAASp/B,SACpBtB,KAAKiD,QAAQm2K,aAAa,EAAA3kG,aAAa5yD,EAAY6e,SAAS,KAEjE,OAGJ,MAAM6jD,EAAe1iE,EAAY0iE,aACjC,QAAqBviF,IAAjBuiF,EAEA,YADA/3E,EAAOuJ,KAAK,wDAAyDjX,GAczE,OAVA,EAAAwN,YAAgCtK,IAAzB6f,EAAY6e,SAAwB,2BAC3C,EAAAp0B,YAA8BtK,IAAvB6f,EAAY4e,OAAsB,8BACzC,EAAAn0B,OAAOlL,MAAMC,QAAQwgB,EAAY4e,QAAS,2CACbz+B,IAAzB6f,EAAY6e,eAAiD1+B,IAAvB6f,EAAY4e,QAClD,EAAAn0B,OACIuV,EAAY6e,SAASp/B,SAAWugB,EAAY4e,OAAOn/B,OACnD,8DAIAijF,GACJ,KAAK,EAAAoD,aAAa3yB,MAClB,KAAK,EAAA2yB,aAAar0C,KACd,IAAKtzC,KAAK04K,cACN,OAEJ,MACJ,KAAK,EAAA/wF,aAAaE,UAClB,KAAK,EAAAF,aAAaC,aAClB,KAAK,EAAAD,aAAaG,SACd,IAAK9nF,KAAK24K,aACN,OAEJ,MACJ,KAAK,EAAAhxF,aAAaI,QAClB,KAAK,EAAAJ,aAAaK,gBACd,IAAKhoF,KAAK44K,aACN,OAEJ,MACJ,KAAK,EAAAjxF,aAAalzD,SACd,IAAKz0B,KAAK64K,gBACN,OAEJ,MACJ,QACIrsK,EAAOuJ,KAAK,sCAGpB,GAAoB,SAAhBjX,EAAO8Q,KAEP,YADApD,EAAOuJ,KAAK,2DAA4DjX,GAI5E,MAAM4iB,EAAO5iB,EAEbkB,KAAKq5K,UAAU33J,EAAMG,GAUf,kBAAkB/iB,GACxB,MAAMob,EAAWpb,EAAOob,SAExB,GAAsB,mBAAlBA,EAAStK,KAET,YADApD,EAAOuJ,KAAK,qDAIhB,MAAMoE,EAAiBD,EAOvB,GAJwCC,EAAeikE,aACnD,YAQJ,OAAOjkE,EAJH3N,EAAOuJ,KAAK,yDAgBV,oBACNwuE,EACAzlF,EACAqb,GAEA,OAAQoqE,GACJ,KAAK,EAAAoD,aAAa3yB,MAClB,KAAK,EAAA2yB,aAAar0C,KAEd,OACJ,KAAK,EAAAq0C,aAAaE,UAClB,KAAK,EAAAF,aAAaC,aAClB,KAAK,EAAAD,aAAaG,SACd,OAAO,IAAI,EAAAwxF,6BAA6Bx6K,EAAQylF,EAAcpqE,GAClE,KAAK,EAAAwtE,aAAaI,QAClB,KAAK,EAAAJ,aAAaK,gBAEd,OACJ,KAAK,EAAAL,aAAalzD,SACd,OAAO,IAAI,EAAA8kJ,iCAAiCz6K,EAAQylF,EAAcpqE,GACtE,QACI3N,EAAOuJ,KAAK,+CAcd,2BACNwuE,EACAzlF,EACAqb,GAEA,OAAQoqE,GACJ,KAAK,EAAAoD,aAAa3yB,MAClB,KAAK,EAAA2yB,aAAar0C,KAEd,OACJ,KAAK,EAAAq0C,aAAaE,UAClB,KAAK,EAAAF,aAAaC,aAClB,KAAK,EAAAD,aAAaG,SACd,OAAO,IAAI,EAAA0xF,oCACP16K,EACAylF,EACApqE,GAER,KAAK,EAAAwtE,aAAaI,QAClB,KAAK,EAAAJ,aAAaK,gBAGlB,KAAK,EAAAL,aAAalzD,SAEd,OACJ,QACIjoB,EAAOuJ,KAAK,sDAWd,UAAU0jK,EAAwB53J,GACxC,MAAM,SAAE6e,EAAQ,OAAED,GAAW5e,EACvB0iE,EAAe1iE,EAAY0iE,aAGjC,QAAiBviF,IAAb0+B,QAAqC1+B,IAAXy+B,QAAyCz+B,IAAjBuiF,EAClD,OAGJ,IAAIm1F,EAEJ,IAAK,IAAIllG,EAAe,EAAGA,EAAe9zC,EAASp/B,OAAQkzE,IAAgB,CACvE,MAAM1uD,EAAY,EAAA2uD,aAAa/zC,EAAS8zC,IAExC,IAAKx0E,KAAKiD,QAAQm2K,aAAatzJ,GAC3B,SAGJ,MAAM6zJ,EAAel5I,EAAO+zC,GAC5B,IAAIolG,GAAsB,EAG1B,QAAyB53K,IAArB03K,EAAgC,CAChC,MAAMv/J,EAAiBna,KAAK65K,kBAAkBJ,GAC9C,QAAuBz3K,IAAnBmY,EACA,SAiBJ,GAbIu/J,EADyB,OAAzBv/J,EAAeO,MACI1a,KAAK85K,2BACpBv1F,EACAk1F,EACAt/J,GAGena,KAAK+5K,oBACpBx1F,EACAk1F,EACAt/J,QAIiBnY,IAArB03K,EAAgC,CAChCltK,EAAOuJ,KAAK,yCAA0CwuE,GACtD,UAYR,OARAq1F,EACIplG,EAAe/zC,EAAOn/B,OAAS,EACzBm/B,EAAO+zC,EAAe,GACtBklG,EAAiBM,WAG3BN,EAAiBO,SAASN,EAAcC,GAEhCr1F,GACJ,KAAK,EAAAoD,aAAa3yB,MAClB,KAAK,EAAA2yB,aAAar0C,KACdtzC,KAAKiD,QAAQi3K,WAAWp0J,GACxB,MACJ,KAAK,EAAA6hE,aAAaE,UAClB,KAAK,EAAAF,aAAaC,aAClB,KAAK,EAAAD,aAAaG,SACd,EAAAx7E,OAAO,EAAA2nH,eAAeylD,IACtB15K,KAAKiD,QAAQk3K,UAAUr0J,EAAY4zJ,GACnC,MACJ,KAAK,EAAA/xF,aAAaI,QAClB,KAAK,EAAAJ,aAAaK,gBACdhoF,KAAKiD,QAAQm3K,UAAUt0J,GACvB,MACJ,KAAK,EAAA6hE,aAAalzD,SACd,EAAAnoB,OAAO,EAAA4nH,mBAAmBwlD,IAC1B15K,KAAKiD,QAAQo3K,cACTv0J,EACC4zJ,GAEL,MACJ,QACIltK,EAAOuJ,KAAK,2C,iYCzZhC,YACA,YACA,YACA,Y,gKCFA,aACA,OAGMksE,EAAO,IAAI7iF,EAAMuG,QACjB20K,EAAY,IAAIl7K,EAAMuG,QACtB40K,EAAc,IAAIn7K,EAAMuG,QACxB60K,EAAc,IAAIp7K,EAAMuG,QACxB80K,EAAe,IAAIr7K,EAAMuG,QAsBzB+0K,EAA2C,CAC7CjgK,WAAY,CAKR,CAAE9c,KAAM,iBAAkBqc,SAAU,EAAG6J,OAAQ,GAC/C,CAAElmB,KAAM,WAAYqc,SAAU,EAAG6J,OAAQ,GACzC,CAAElmB,KAAM,UAAWqc,SAAU,EAAG6J,OAAQ,GACxC,CAAElmB,KAAM,YAAaqc,SAAU,EAAG6J,OAAQ,IAE9Ck2D,OAAQ,IAIN4gG,EAAgD,CAClDlgK,WAAY,CACR,CAAE9c,KAAM,KAAMqc,SAAU,EAAG6J,OAAQ62J,EAAuB3gG,QAC1D,CAAEp8E,KAAM,SAAUqc,SAAU,EAAG6J,OAAQ62J,EAAuB3gG,OAAS,IAE3EA,OAAQ,GAIN6gG,EAA+C,CACjDngK,WAAY,IAAIigK,EAAuBjgK,cAAekgK,EAA4BlgK,YAClFs/D,OAAQ2gG,EAAuB3gG,OAAS4gG,EAA4B5gG,QAOlE8gG,EAA8C,CAChDpgK,WAAY,CACR,CAAE9c,KAAM,iBAAkBqc,SAAU,EAAG6J,OAAQ,GAC/C,CAAElmB,KAAM,WAAYqc,SAAU,EAAG6J,OAAQ,GACzC,CAAElmB,KAAM,cAAeqc,SAAU,EAAG6J,OAAQ,GAC5C,CAAElmB,KAAM,UAAWqc,SAAU,EAAG6J,OAAQ,GACxC,CAAElmB,KAAM,YAAaqc,SAAU,EAAG6J,OAAQ,KAE9Ck2D,OAAQ,IAIN+gG,EAAkD,CACpDrgK,WAAY,IACLogK,EAA0BpgK,cAC1BkgK,EAA4BlgK,YAEnCs/D,OAAQ8gG,EAA0B9gG,OAAS4gG,EAA4B5gG,QAM3E,MAAaghG,EAAb,cACI,KAAA1gK,SAAqB,GACrB,KAAAkZ,aAAyB,GACzB,KAAAmyD,QAAoB,IAGxB,SAASs1F,EAAoBC,EAA2BC,GACpD,OAAIA,EACOD,EAAmBH,EAAgCD,EAEnDI,EAAmBL,EAA6BF,EAe/D,SAAgBS,EACZl+J,EACAm+J,EACAjsK,EACA0uF,EACA6K,EACA2yE,EACAnhK,EAAW,IAAI6gK,EACfG,GAAyB,GAEzB,GAAwB,IAApBE,EAAS95K,OACT,OAAO4Y,EAGX,MAAM6/D,EAASihG,OAA4Bh5K,IAAR0mG,EAAmBwyE,GAAenhG,OAE/DuhG,EAAaF,EAAS95K,OAAS,EAC/Bi6K,EAAW,IAAIn6K,MAAck6K,GAC7BE,EAAW,IAAIp6K,MAAcg6K,EAAS95K,OAAS,GAC/CixD,EAAar4C,EAASG,SAAS/Y,OAASy4E,EAExC0hG,OAAgCz5K,IAAZ67F,GAAyBA,EAAQv8F,OAAS,EAC9Do6K,OAAuB15K,IAAR0mG,GAAqBA,EAAIpnG,OAAS,EACjDiyB,OAA0BvxB,IAAXq5K,GAAwBA,EAAO/5K,QAAU85K,EAAS95K,OAEvE,EAAAgL,QAAQmvK,GAAqB59E,EAASv8F,SAAWg6K,GACjD,EAAAhvK,QAAQovK,GAAgBhzE,EAAKpnG,OAAS,IAAMg6K,GAC5C,EAAAhvK,QAAQinB,GAAgB8nJ,EAAQ/5K,SAAW85K,EAAS95K,QAGpD,IAAIgoC,EApIe,GAqInBiyI,EAAS,GAAKjyI,EACd,IAAK,IAAIlsC,EAAI,EAAGA,EAAIk+K,EAAa,IAAKl+K,EAAG,CACrC,IAAIu+K,EAAY,EAChB,IAAK,IAAI35H,EAAI,EAAGA,EAAI,IAAKA,EAAG,CACxB,MAAMtkD,EAAI09K,EAAmB,GAATh+K,EAAI,GAAS4kD,GAAKo5H,EAAa,EAAJh+K,EAAQ4kD,GACvDw5H,EAAa,EAAJp+K,EAAQ4kD,GAAKtkD,EACtBi+K,GAAaj+K,EAAIA,EAGrB4rC,GADYjgC,KAAK+H,KAAKuqK,GAEtBJ,EAASn+K,EAAI,GAAKksC,EAGtB,MAAMsyI,EAAeH,EACfpyK,KAAK2S,IAAI6hF,EAASA,EAASv8F,OAAS,GAAKu8F,EAAS,IAClD,EACAg+E,EAAaN,EAASA,EAASj6K,OAAS,GAAKs6K,EAGnD,GAAIH,EACA,IAAK,IAAIr+K,EAAI,EAAGA,EAAIk+K,IAAcl+K,EAC9Bm+K,EAASn+K,GAAKygG,EAASzgG,GAAKy+K,EA1JjB,GA+JnB,IAAIC,GAAW,EACf,IAAK,IAAI95H,EAAI,EAAGA,EAAI,IAAKA,EACrB85H,EAAWA,GAAYV,EAASp5H,KAAOo5H,EAASA,EAAS95K,OAAS,EAAI0gD,GAG1E,MAAM+5H,EAAwB,GAExBC,EAAgB,CAClB5+K,EACA6+K,EACAC,EACAC,EACAC,KAEAL,EAAYz6K,OAAS,EAGrB4Y,EAASG,SAASnU,KAAKi2K,GAA2B,EAAlBC,EAAqBP,GACrDE,EAAY71K,KAAKi2K,EAA0B,EAAjBC,EAAoBP,GAG9C,IAAK,IAAI75H,EAAI,EAAGA,EAAI,IAAKA,EAAG,CACxB,GAAKk5H,EAGE,CACH,MAAMmB,EAAWhzK,KAAK0/E,OAAOqyF,EAAa,EAAJh+K,EAAQ4kD,IACxCs6H,EAAUlB,EAAa,EAAJh+K,EAAQ4kD,GAAKq6H,EACtCniK,EAASG,SAASnU,KAAKm2K,EAAUC,GACjCP,EAAY71K,KAAKm2K,EAAUC,QAN3BpiK,EAASG,SAASnU,KAAKk1K,EAAa,EAAJh+K,EAAQ4kD,IACxC+5H,EAAY71K,KAAKk1K,EAAa,EAAJh+K,EAAQ4kD,IAOtCs4H,EAAUiC,aAAav6H,EAAGo5H,EAAa,EAAJh+K,EAAQ4kD,IAI/C,IAAK,IAAIA,EAAI,EAAGA,EAAI,IAAKA,EACrBu4H,EAAYgC,aAAav6H,EAAGw5H,EAASS,EAAKj6H,IAC1Cw4H,EAAY+B,aAAav6H,EAAGw5H,EAASU,EAAKl6H,IAE9Cu4H,EAAY1pK,YACZqJ,EAASG,SAASnU,KAAKq0K,EAAY90K,EAAG80K,EAAY70K,EAAG60K,EAAY30K,GACjEm2K,EAAY71K,KAAKq0K,EAAY90K,EAAG80K,EAAY70K,EAAG60K,EAAY30K,GAC3D00K,EAAUn6K,IAAI8c,GACd9N,EAAWqG,cAAc8kK,EAAWA,GACpC,MAAM9kD,EA8Qd,SACI32H,EACAo6G,EACAE,EACA0c,GAEA,IAAIL,EAAQ,EACPvc,EAAG1e,OAAO4e,KACXqc,EAAQnsH,KAAKsM,KAAKsjG,EAAGvjG,IAAIyjG,IAAO9vG,KAAKD,KAAKvK,EAAE6W,IAAIusE,EAAK3yE,KAAK2pG,GAAIviG,MAAMyiG,KAChErxF,OAAO5e,MAAMssH,KACbA,EAAQ,IAQhB,OALAK,EAAGvmH,KAAK2pG,GACH94G,IAAIg5G,GACJtoG,YACA6F,MAAM7X,GACNgS,YACE2kH,EAhSWgnD,CACVlC,EACAC,EACAC,EAAY3pK,YACZ4pK,GAEJvgK,EAASG,SAASnU,KAAKu0K,EAAah1K,EAAGg1K,EAAa/0K,EAAG+0K,EAAa70K,EAAG4vH,GACvEumD,EAAY71K,KAAKu0K,EAAah1K,EAAGg1K,EAAa/0K,EAAG+0K,EAAa70K,EAAG4vH,GAE7DkmD,IAEAxhK,EAASG,SAASnU,KAAKwiG,EAAS,EAAJtrG,GAAQsrG,EAAS,EAAJtrG,EAAQ,IACjD2+K,EAAY71K,KAAKwiG,EAAS,EAAJtrG,GAAQsrG,EAAS,EAAJtrG,EAAQ,IAE3C8c,EAASG,SAASnU,KAAKo0K,EAAU70K,EAAG60K,EAAU50K,EAAG40K,EAAU10K,GAC3Dm2K,EAAY71K,KAAKo0K,EAAU70K,EAAG60K,EAAU50K,EAAG40K,EAAU10K,IAGzDsU,EAASG,SAASnU,QAAQ61K,GAGtBxoJ,IACArZ,EAASqZ,aAAartB,KAAKm1K,EAAY,EAAJj+K,GAAQi+K,EAAY,EAAJj+K,EAAQ,GAAIi+K,EAAY,EAAJj+K,EAAQ,IAC/E8c,EAASqZ,aAAartB,KAAKm1K,EAAY,EAAJj+K,GAAQi+K,EAAY,EAAJj+K,EAAQ,GAAIi+K,EAAY,EAAJj+K,EAAQ,MAIvF,IAAK,IAAIA,EAAI,EAAGA,EAAIk+K,IAAcl+K,EAAG,CAEjC,MAAM6+K,EAAKH,GAAkB,IAAN1+K,EAAUo+K,EAASl6K,OAAS,EAAyB,EAArB+H,KAAKS,IAAI,EAAG1M,EAAI,GACjE8+K,EAAKJ,GAAY1+K,IAAMk+K,EAAa,EAAI,EAAIjyK,KAAKO,IAAQ,EAAJxM,EAAOo+K,EAASl6K,OAAS,GAGhFlE,EAAI,GACJ4+K,EAAc5+K,EAAG6+K,EAAIC,EAAIX,EAASn+K,EAAI,GAAIm+K,EAASn+K,IAInDA,EAAI,EAAIk+K,GACRU,EACI5+K,EACA6+K,EACAC,GAC8C,EAA9CX,EAASlyK,KAAKO,IAAIxM,EAAGm+K,EAASj6K,OAAS,IACvCi6K,EAASlyK,KAAKO,IAAIxM,EAAI,EAAGm+K,EAASj6K,OAAS,KAMvD,IAAK,IAAIlE,EAAI,EAAGA,EAAIk+K,EAAa,IAAKl+K,EAAG,CACrC,MAAM4sI,EAAOz3E,EAAiB,EAAJn1D,EAC1B8c,EAASwrE,QAAQx/E,KAAK8jI,EAAMA,EAAO,EAAGA,EAAO,EAAGA,EAAO,EAAGA,EAAO,EAAGA,EAAO,GAG/E,OAAO9vH,EAUX,SAAgBuiK,EACZrB,EACAC,EACAnhK,EAAW,IAAI6gK,GAEf,GAAwB,IAApBK,EAAS95K,OACT,OAAO4Y,EAGX,MAAMohK,EAAaF,EAAS95K,OAAS,EACrC,IAAIoZ,EAAQR,EAASG,SAAS/Y,OAAS,EAEvC,MAAMiyB,OAA0BvxB,IAAXq5K,GAAwBA,EAAO/5K,QAAU85K,EAAS95K,OAEvE,IAAK,IAAIlE,EAAI,EAAGA,EAAIk+K,IAAcl+K,EAAGsd,IAAS,CACtCtd,EAAI,GACJ8c,EAASwrE,QAAQx/E,KAAKwU,GAEtBtd,EAAIk+K,EAAa,GACjBphK,EAASwrE,QAAQx/E,KAAKwU,GAE1B,IAAK,IAAIsnC,EAAI,EAAGA,EAAI,IAAKA,EACrB9nC,EAASG,SAASnU,KAAKk1K,EAAa,EAAJh+K,EAAQ4kD,IACpCzuB,GACArZ,EAASqZ,aAAartB,KAAKm1K,EAAY,EAAJj+K,EAAQ4kD,IAKvD,OAAO9nC,EA5NX,iBAyBA,uBAsKA,6BAmCA,MAAawiK,EAiET,YACazB,GAA4B,EAC5BC,GAAyB,EACzByB,GAAoB,GAFpB,KAAA1B,mBACA,KAAAC,gBACA,KAAAyB,WAET38K,KAAKwxD,WAAa,IAAIupH,EA1D1B,sBACI1gK,EACAghK,EACA31F,EACAxrE,EACA+gK,GAA4B,EAC5BC,GAAgB,EAChByB,GAAW,GAEX,GAAIA,EAYA,OAXAziK,EAASu3C,aACL,WACA,IAAIryD,EAAM0a,gBAAgB,IAAI0X,aAAanX,GAAW,IAEtDghK,EAAO/5K,SAAW+Y,EAAS/Y,QAC3B4Y,EAASu3C,aACL,QACA,IAAIryD,EAAM0a,gBAAgB,IAAI0X,aAAa6pJ,GAAS,IAG5DnhK,EAASw3C,SAAS,IAAItyD,EAAM0a,gBAAgB,IAAIwX,YAAYo0D,GAAU,IAC/DxrE,EACJ,CACH,MAAM0iK,EAAmB5B,EAAoBC,EAAkBC,GAEzDxqJ,EAAS,IAAItxB,EAAM4xD,kBACrB,IAAIx/B,aAAanX,GACjBuiK,EAAiB7iG,QAoBrB,OAlBA6iG,EAAiBniK,WAAWpa,QAAQw8K,IAChC,MAAMvjK,EAAY,IAAIla,EAAMya,2BACxB6W,EACAmsJ,EAAM7iK,SACN6iK,EAAMh5J,QACN,GAEJ3J,EAASu3C,aAAaorH,EAAMl/K,KAAM2b,KAElC+hK,EAAO/5K,SAAW+Y,EAAS/Y,QAC3B4Y,EAASu3C,aACL,QACA,IAAIryD,EAAM0a,gBAAgB,IAAI0X,aAAa6pJ,GAAS,IAI5DnhK,EAASw3C,SAAS,IAAItyD,EAAM0a,gBAAgB,IAAIwX,YAAYo0D,GAAU,IAE/DxrE,GAiBf,QACIla,KAAKwxD,WAAWn3C,SAAW,GAC3Bra,KAAKwxD,WAAWj+B,aAAe,GAC/BvzB,KAAKwxD,WAAWk0B,QAAU,GAY9B,IACIzoE,EACA3L,EACAnC,EACA0uF,EACA6K,EACA2yE,GAiBA,OAfKr7K,KAAK28K,SAaNF,EAAyBnrK,EAAQ+pK,EAAQr7K,KAAKwxD,aAZ9C,EAAAllD,QAAQtM,KAAKi7K,uBAA4Bj5K,IAAR0mG,GACjCyyE,EACIl+J,EACA3L,EACAnC,EACA0uF,EACA6K,EACA2yE,EACAr7K,KAAKwxD,WACLxxD,KAAKk7K,gBAKNl7K,KAMX,eACI,OAAOA,KAAKwxD,WAAWn3C,SAM3B,mBACI,OAAOra,KAAKwxD,WAAWj+B,aAM3B,cACI,OAAOvzB,KAAKwxD,WAAWk0B,QAM3B,uBACI,OAAOs1F,EAAoBh7K,KAAKi7K,iBAAkBj7K,KAAKk7K,eAAezgK,WAM1E,aACI,OAAOugK,EAAoBh7K,KAAKi7K,iBAAkBj7K,KAAKk7K,eAAenhG,OAM1E,eAAe7/D,GAIX,YAHiBlY,IAAbkY,IACAA,EAAW,IAAI9a,EAAMob,gBAElBkiK,EAAUI,eACb98K,KAAKwxD,WAAWn3C,SAChBra,KAAKwxD,WAAWj+B,aAChBvzB,KAAKwxD,WAAWk0B,QAChBxrE,EACAla,KAAKi7K,iBACLj7K,KAAKk7K,gBArKjB,e,2GCzTA,aAEA,OAGA,QAKA,MAAaluF,UAA4B5tF,EAAMo1B,OAkB3C,YACIta,EACAzP,EACA8kD,EACAtkC,EACAC,QAEiBlpB,IAAbyI,IACAA,EAAW,IAAI,EAAAoiF,2BAA2B,CACtC5hE,MAAOA,GAAgB,EAAA4hE,2BAA2BpjE,cAClDyB,aAAqBlpB,IAAZkpB,EAAwBA,EAAU,KAInDloB,WAAmBhB,IAAbkY,EAAyB,IAAI9a,EAAMob,eAAmBN,EAAUzP,GAEtEzK,KAAKiwE,mBAAqB,IAAI7wE,EAAMsO,QAEhC6hD,GACAvvD,KAAK2qF,aAAap7B,GAI1B,qBACI,OAAOvvD,KAAKka,SAMhB,gBACI,OAAQla,KAAKka,SAAW,IAAI9a,EAAMob,eAGtC,qBACI,OAAOxa,KAAKyK,SAGhB,aAAa8kD,GACT,EAAAs5B,mBAAmB8B,aAAa3qF,KAAMuvD,GAG1C,oBAESvvD,KAAKyK,SAAiBsyK,oCACC/6K,IAAxBhC,KAAKg9K,gBAEJh9K,KAAKyK,SAAiBwyK,kBAAkBj9K,KAAKg9K,gBAElDh9K,KAAKosD,eAAiB,CAClBuqE,EACAC,EACAloH,EACAmoH,EACAC,EACAC,KAEA,EAAAluC,mBAAmBiC,iBAAiB9qF,KAAM0O,EAAQ1O,KAAK+qF,iBAI/D,kBAAkBoK,GACd,MAAM6hC,EAA6Bh3H,KAAKi3H,wBAA0B9hC,EAElEnyF,MAAM+R,kBAAkBogF,GAEpB6hC,GACAh3H,KAAKiwE,mBAAmB/7D,WAAWlU,KAAK+R,cArFpD,yB,iYCFA,YACA,YACA,WACA,WACA,YACA,YACA,a,qMCfA,aAEA,QAsHA,2CA+BI,YACIkE,GA/BI,KAAAinK,wBAAkC,EAClC,KAAAC,wBAAkC,EAClC,KAAAC,uBAAiC,EACjC,KAAAC,0BAAoC,EAE3B,KAAAC,kBAAoB,IAAIl8K,MACxB,KAAAm8K,iBAAmB,IAAIn8K,MACvB,KAAAo8K,kBAAoB,IAAIp8K,MACxB,KAAAq8K,gBAAkB,IAAIr8K,MACtB,KAAAs8K,iBAAmB,IAAIt8K,MACvB,KAAAu8K,gBAAkB,IAAIv8K,MACtB,KAAAw8K,oBAAsB,IAAIx8K,MAC1B,KAAAy8K,mBAAqB,IAAIz8K,MAElC,KAAA08K,iBAA6B,GAC7B,KAAAC,gBAA4B,GAkB5B9nK,IACAjW,KAAKk9K,4BACgCl7K,IAAjCiU,EAAQ+nK,sBAAqC/nK,EAAQ+nK,qBACzDh+K,KAAKm9K,4BACgCn7K,IAAjCiU,EAAQgoK,sBAAqChoK,EAAQgoK,qBACzDj+K,KAAKo9K,2BAC+Bp7K,IAAhCiU,EAAQioK,qBAAoCjoK,EAAQioK,oBACxDl+K,KAAKq9K,8BACkCr7K,IAAnCiU,EAAQkoK,wBACFloK,EAAQkoK,wBAW1B,aACIxvI,EACA1Q,EAAQ,EAAAivD,gBAAgBC,YAAYK,MACpCyI,EAAmB,EACnB29B,EAAmB/pH,KAEnB7J,KAAKs9K,kBAAkBp3K,KAAK,CACxBvI,KAAM,CAAEU,MAAOswC,EAAO1Q,SACtBg4D,WACA29B,aAUR,YACIjlF,EACA1Q,EAAQ,EAAAivD,gBAAgBC,YAAYK,MACpCyI,EAAmB,EACnB29B,EAAmB/pH,KAEnB7J,KAAKu9K,iBAAiBr3K,KAAK,CACvBvI,KAAM,CAAEU,MAAOswC,EAAO1Q,SACtBg4D,WACA29B,aASR,aAAa39G,GACTjW,KAAKo+K,QAAQp+K,KAAKw9K,kBAAmBvnK,GAQzC,cAAcA,GACVjW,KAAKq+K,SAASr+K,KAAKw9K,kBAAmBvnK,GAQ1C,YAAYA,GACRjW,KAAKo+K,QAAQp+K,KAAKy9K,gBAAiBxnK,GAQvC,aAAaA,GACTjW,KAAKq+K,SAASr+K,KAAKy9K,gBAAiBxnK,GAQxC,YAAYA,GACRjW,KAAKo+K,QAAQp+K,KAAK09K,iBAAkBznK,GAQxC,aAAaA,GACTjW,KAAKq+K,SAASr+K,KAAK09K,iBAAkBznK,GAQzC,WAAWA,GACPjW,KAAKo+K,QAAQp+K,KAAK29K,gBAAiB1nK,GAQvC,YAAYA,GACRjW,KAAKq+K,SAASr+K,KAAK29K,gBAAiB1nK,GAQxC,eAAeA,GACXjW,KAAKo+K,QAAQp+K,KAAK49K,oBAAqB3nK,GAQ3C,gBAAgBA,GACZjW,KAAKq+K,SAASr+K,KAAK49K,oBAAqB3nK,GAQ5C,cAAcA,GACVjW,KAAKo+K,QAAQp+K,KAAK69K,mBAAoB5nK,GAQ1C,eAAeA,GACXjW,KAAKq+K,SAASr+K,KAAK69K,mBAAoB5nK,GAQ3C,aAAaokE,GACTr6E,KAAK89K,iBAAmB99K,KAAK89K,iBAAiBjrI,OAAOwnC,GAQzD,YAAYC,GACRt6E,KAAK+9K,gBAAkB/9K,KAAK+9K,gBAAgBlrI,OAAOynC,GAMvD,oBACI,MAAO,CACH0jG,qBAAsBh+K,KAAKk9K,uBAC3Be,qBAAsBj+K,KAAKm9K,uBAC3Be,oBAAqBl+K,KAAKo9K,sBAC1Be,uBAAwBn+K,KAAKq9K,yBAE7BiB,gBAAiBt+K,KAAKs9K,kBACtBiB,eAAgBv+K,KAAKu9K,iBACrBiB,gBAAiBx+K,KAAKw9K,kBACtBiB,eAAgBz+K,KAAKy9K,gBACrBiB,eAAgB1+K,KAAK09K,iBACrBiB,cAAe3+K,KAAK29K,gBACpBiB,kBAAmB5+K,KAAK49K,oBACxBiB,iBAAkB7+K,KAAK69K,mBAEvBiB,eAAgB9+K,KAAK89K,iBACrBiB,cAAe/+K,KAAK+9K,iBAIpB,QACJiB,EACA/oK,SAEyBjU,IAArBiU,EAAQggF,UAA0B/sF,MAAM+M,EAAQggF,aAChDhgF,EAAQggF,SAAW,SAEEj0F,IAArBiU,EAAQ29G,UAA0B1qH,MAAM+M,EAAQ29G,aAChD39G,EAAQ29G,SAAW/pH,KAGvB,MAAMgqH,EAA6B,CAC/BorD,UAAW,CACP5gL,MAAO4X,EAAQ04B,MACf1Q,WAC2Bj8B,IAAvBiU,EAAQipK,WACF,EAAAhyF,gBAAgBC,YAAYK,MAC5Bv3E,EAAQipK,YAEtBC,mBACyBn9K,IAArBiU,EAAQmpK,SACFh+K,MAAMC,QAAQ4U,EAAQmpK,UAClBnpK,EAAQmpK,SACR,CAACnpK,EAAQmpK,eACbp9K,EACVq9K,QAAS,CACL,CACIhhL,MAAO4X,EAAQqpK,aACfrhJ,WAC2Bj8B,IAAvBiU,EAAQspK,WACF,EAAAryF,gBAAgBC,YAAYK,MAC5Bv3E,EAAQspK,aAG1BtpF,SAAUhgF,EAAQggF,SAClB29B,SAAU39G,EAAQ29G,SAClB4rD,iBAAkBvpK,EAAQupK,kBAG9BR,EAAM94K,KAAK2tH,GAGP,SACJmrD,EACA/oK,SAEyBjU,IAArBiU,EAAQggF,UAA0B/sF,MAAM+M,EAAQggF,aAChDhgF,EAAQggF,SAAW,SAEEj0F,IAArBiU,EAAQ29G,UAA0B1qH,MAAM+M,EAAQ29G,aAChD39G,EAAQ29G,SAAW/pH,KAGvB,MAAMgqH,EAA6B,CAC/BorD,UAAW,CACP5gL,MAAO4X,EAAQ04B,MACf1Q,WAC2Bj8B,IAAvBiU,EAAQipK,WACF,EAAAhyF,gBAAgBC,YAAYK,MAC5Bv3E,EAAQipK,YAEtBC,mBAC0Bn9K,IAAtBiU,EAAQwpK,UACFr+K,MAAMC,QAAQ4U,EAAQwpK,WAClBxpK,EAAQwpK,UACR,CAACxpK,EAAQwpK,gBACbz9K,EACVq9K,QAASppK,EAAQypK,eACjBzpF,SAAUhgF,EAAQggF,SAClB29B,SAAU39G,EAAQ29G,SAClB4rD,iBAAkBvpK,EAAQupK,kBAG9BR,EAAM94K,KAAK2tH,KAiHnB,MAAa8rD,EAqBT,YAAoBhmG,GAAA,KAAAA,cACZ35E,KAAK25E,YAAYmlG,eAAex9K,OAAS,IACzCtB,KAAKq6E,aAAe,IAAI,EAAA2d,gBACpBh4F,KAAK25E,YAAYmlG,iBAGrB9+K,KAAK25E,YAAYolG,cAAcz9K,OAAS,IACxCtB,KAAKs6E,cAAgB,IAAI,EAAA0d,gBACrBh4F,KAAK25E,YAAYolG,gBA5BrB,kBACJpwI,EACAixI,EACAhkK,GAEA,IAAK,MAAMikK,KAAaD,EACpB,KAAIhkK,EAAQikK,EAAU5pF,UAAYr6E,EAAQikK,EAAUjsD,WAIhD,EAAA1mC,gBAAgBE,YAAYz+C,EAAOkxI,EAAUliL,MAC7C,OAAO,EAGf,OAAO,EAmBX,WAAWgxC,EAAe/yB,GACtB,QAAI+jK,EAAwBT,WAAWvwI,EAAO3uC,KAAK25E,YAAY2kG,gBAAiB1iK,KAI5E+jK,EAAwBT,WAAWvwI,EAAO3uC,KAAK25E,YAAY4kG,eAAgB3iK,IAIxE5b,KAAK25E,YAAYqkG,qBAG5B,kBAAkBrvI,EAAe41C,EAA+B3oE,GAC5D,OAAO5b,KAAKo5K,aACRp5K,KAAK25E,YAAY6kG,gBACjBx+K,KAAK25E,YAAY8kG,eACjB9vI,EACA41C,EACA3oE,EACA5b,KAAK25E,YAAYskG,sBAIzB,iBAAiBtvI,EAAe41C,EAA+B3oE,GAC3D,OAAO5b,KAAKo5K,aACRp5K,KAAK25E,YAAY+kG,eACjB1+K,KAAK25E,YAAYglG,cACjBhwI,EACA41C,EACA3oE,EACA5b,KAAK25E,YAAYukG,qBAIzB,oBAAoBvvI,EAAe41C,EAA+B3oE,GAC9D,OAAO5b,KAAKo5K,aACRp5K,KAAK25E,YAAYilG,kBACjB5+K,KAAK25E,YAAYklG,iBACjBlwI,EACA41C,EACA3oE,EACA5b,KAAK25E,YAAYwkG,wBAIzB,UAAUpxI,GAEN,YAAa/qC,IAAT+qC,WAM2B/qC,IAAvBhC,KAAKs6E,eACLt6E,KAAKs6E,cAAc/jC,gBAAgBxJ,UAEhB/qC,IAAtBhC,KAAKq6E,cACFr6E,KAAKq6E,aAAa9jC,gBAAgBxJ,IAI9C,oBACI,YAA6B/qC,IAAtBhC,KAAKq6E,mBAAqDr4E,IAAvBhC,KAAKs6E,cAG3C,aACJwlG,EACAC,EACApxI,EACA41C,EACA3oE,EACAokK,GAEA,IAAK,MAAMnsD,KAAQisD,EACf,KAAIlkK,EAAQi4G,EAAK59B,UAAYr6E,EAAQi4G,EAAKD,WAIrC,EAAA1mC,gBAAgBE,YAAYz+C,EAAOklF,EAAKorD,iBAKlBj9K,IAAvB6xH,EAAKsrD,eAA+BtrD,EAAKsrD,cAAcxsJ,QAAQ4xD,IAAiB,EAChF,OAAO,EAIf,IAAK,MAAMsvC,KAAQksD,EACf,GAAK,EAAA7yF,gBAAgBE,YAAYz+C,EAAOklF,EAAKorD,iBAKlBj9K,IAAvB6xH,EAAKsrD,eAA+BtrD,EAAKsrD,cAAcxsJ,QAAQ4xD,IAAiB,EAChF,OAAO,EAIf,OAAOy7F,GArIf,4BA6IA,2BACI,YAAqBC,GAAA,KAAAA,UAErB,oBACI,OAAOjgL,KAAKigL,QAAQzhJ,OAChB,CAACr4B,EAAQqsB,IAAWrsB,GAAUqsB,EAAO0tJ,eACrC,GAIR,WAAWvxI,EAAe/yB,GACtB,OAAO5b,KAAKigL,QAAQzhJ,OAChB,CAACr4B,EAAQqsB,IAAWrsB,GAAUqsB,EAAO2tJ,WAAWxxI,EAAO/yB,IACvD,GAGR,kBAAkB+yB,EAAe41C,EAA+B3oE,GAC5D,OAAO5b,KAAKigL,QAAQzhJ,OAChB,CAACr4B,EAAQqsB,IAAWrsB,GAAUqsB,EAAO4tJ,kBAAkBzxI,EAAO41C,EAAc3oE,IAC5E,GAGR,iBAAiB+yB,EAAe41C,EAA+B3oE,GAC3D,OAAO5b,KAAKigL,QAAQzhJ,OAChB,CAACr4B,EAAQqsB,IAAWrsB,GAAUqsB,EAAO6tJ,iBAAiB1xI,EAAO41C,EAAc3oE,IAC3E,GAGR,oBAAoB+yB,EAAe41C,EAA+B3oE,GAC9D,OAAO5b,KAAKigL,QAAQzhJ,OAChB,CAACr4B,EAAQqsB,IAAWrsB,GAAUqsB,EAAO8tJ,oBAAoB3xI,EAAO41C,EAAc3oE,IAC9E,GAGR,UAAUmxB,GACN,OAAO/sC,KAAKigL,QAAQzhJ,OAChB,CAACr4B,EAAQqsB,IAAWrsB,GAAUqsB,EAAO+tJ,UAAUxzI,IAC/C,KAUZ,MAAayzI,EAmCT,YAAoB7mG,GAAA,KAAAA,cAlCpB,kBACIslG,EACAK,EACAN,GAEA,IAAK,MAAMnrD,KAAQmrD,EACf,QAAqBh9K,IAAjB6xH,EAAKwrD,QAAuB,CAC5B,IAAK,EAAAnyF,gBAAgBE,YAAY6xF,EAAWprD,EAAKorD,WAC7C,SAEJ,IAAK,MAAMM,KAAc1rD,EAAKwrD,QAC1B,GAAI,EAAAnyF,gBAAgBE,YAAYkyF,EAAcC,GAC1C,OAAO,EAKvB,OAAO,EAGX,sBAAsBN,EAAmB78K,EAAa48K,GAClD,IAAK,MAAMnrD,KAAQmrD,EACf,QAA8Bh9K,IAA1B6xH,EAAK2rD,kBAED,EAAAtyF,gBAAgBE,YAAY6xF,EAAWprD,EAAKorD,YAC5C78K,EAAI6qB,OAAO4mG,EAAK2rD,iBAAiB7gL,OAASk1H,EAAK2rD,iBAAiBnhL,MAEhE,OAAO,EAInB,OAAO,EAKX,sBAAsBswC,EAAevsC,GACjC,OAAOpC,KAAKygL,iBACRzgL,KAAK25E,YAAY6kG,gBACjBx+K,KAAK25E,YAAY8kG,eACjB9vI,EACAvsC,EACApC,KAAK25E,YAAYskG,sBAIzB,qBAAqBtvI,EAAevsC,GAChC,OAAOpC,KAAKygL,iBACRzgL,KAAK25E,YAAY+kG,eACjB1+K,KAAK25E,YAAYglG,cACjBhwI,EACAvsC,EACApC,KAAK25E,YAAYukG,qBAIzB,wBAAwBvvI,EAAevsC,GACnC,OAAOpC,KAAKygL,iBACRzgL,KAAK25E,YAAYilG,kBACjB5+K,KAAK25E,YAAYklG,iBACjBlwI,EACAvsC,EACApC,KAAK25E,YAAYwkG,wBAIf,iBACN2B,EACAC,EACApxI,EACAvsC,EACA49K,GAEA,QAAch+K,IAAV2sC,GAAkD,IAA1BmxI,EAAex+K,QAAyC,IAAzBy+K,EAAcz+K,OACrE,OAAO0+K,EAGX,IAAIV,EACJ,MAAMoB,EAAoBt+K,EAAI6qB,OAAO,SAMrC,OAJIyzJ,UACApB,EAAeoB,EAAkBvjJ,eAIjCmiJ,IACAkB,EAA0BG,WAAWhyI,EAAO2wI,EAAcQ,OAM1DR,IACAkB,EAA0BG,WAAWhyI,EAAO2wI,EAAcS,QAK1DS,EAA0BI,eAAejyI,EAAOvsC,EAAK09K,KAIrDU,EAA0BI,eAAejyI,EAAOvsC,EAAK29K,IAIlDC,IA3Gf,+B,qGCztBA,aASA,OAGA,SAMA,OACA,QAMA,SAMA,QAEMxzK,EAAS,EAAAC,cAAcxM,SAASvB,OAAO,iBAqJ7C,SAASmiL,EAAgBxjK,GACrB,GAAKA,EAAqC85G,aACtC,OAAQ95G,EAAqC85G,aAC1C,GACF95G,EAAmCkmC,SACnClmC,EAAmComC,IAEpC,OAAO,IAAI,EAAAq9H,cAAczjK,GAEzB,MAAM,IAAI5Z,MAAM,8DAOxB,IAAIs9K,GAA+C,EAKnD,MAAMC,EAAwB,oDAKxBC,EAAuD,CACzD19H,QAASy9H,EACTvnD,UAAW,EAAAlB,UAAUyB,OACrBzzD,aAAc,UACd8zD,qBAAsB,CAClB3B,OAAQ,EAAAF,qBAAqBK,YAC7Bl7H,KAAM,UAEV6mC,cAAe,CACX,CACIzV,GAAI,WACJ05D,MAAM,IAAI7e,MAAOuxD,cACjBn1H,MAAO,OACP0iF,KAAM,kCAKZw4F,EAAiB,IAAI/+K,IAAqC,CAC5D,CAAC6+K,EAAuBC,KA2C5B,MAAallD,UAAsB,EAAAolD,eAG/B,YAAoBx2J,G,cAChB3nB,MAAM2nB,EAASy2J,aAAe,IAAI,EAAAC,YAAY,EAAAvzF,SAAU,OAAF,QAClDvnB,aAAmC,QAAvB,EAAE57C,EAAS47C,oBAAY,QAAI,MACvC+6G,6BAA8B,EAAA1zF,8BAC9B3V,aAAmC,QAAvB,EAAEttD,EAASstD,oBAAY,QAAI,EACvCC,aAAmC,QAAvB,EAAEvtD,EAASutD,oBAAY,QAAI,GACvCQ,mBAA+C,QAA7B,EAAE/tD,EAAS+tD,0BAAkB,SAAK,GAlChE,SACIr7D,G,MAEA,QAX+Brb,IAWJqb,EAXb85G,mBAWuCn1H,IAAfqb,EAAOomC,IAAmB,CAC5D,MAAMF,EAAwB,QAAjB,EAAGlmC,EAAOkmC,eAAO,QAAIy9H,EAE5BO,EAAkB,OAAH,wBACdL,EAAejjL,IAAIslD,IACnBlmC,GAGP,OAAO,OAAP,wBACOkkK,GAAe,CAClBvvF,aAAc,EAAA0T,wBACdyxB,aAAc,IAAI,EAAA2pD,cAAcS,KAIxC,OAAO,OAAP,wBACOlkK,GAAM,CACT20E,aAAc,EAAA0T,wBACdyxB,aAAc0pD,EAAgBxjK,KAcvBmkK,CAA6B72J,KAPpB,KAAAA,WAUhB3qB,KAAK83E,WAAY,EACjB93E,KAAKg4E,oBAC2Bh2E,IAA5B2oB,EAASqtD,iBAA4D,IAA5BrtD,EAASqtD,eAEtDh4E,KAAKyhL,iBAAmB,CACpBC,uBAA+D,IAAxC1hL,KAAK2qB,SAAS+2J,sBACrCC,kBAAmB3hL,KAAK2qB,SAASi3J,YACjCC,yBAAmE,IAA1C7hL,KAAK2qB,SAASk3J,wBACvCC,iBAAkB9hL,KAAK2qB,SAASo3J,kBAC1B,CAAC/hL,KAAK2qB,SAASo3J,wBACf//K,EACNohE,cAAepjE,KAAK2qB,SAASy4C,cAC7B4+G,gBAAiBhiL,KAAK2qB,SAASq3J,gBAC/BtpG,mBAA+C,QAA7B,EAAE/tD,EAAS+tD,0BAAkB,SAAK,EACpDupG,wBAAiE,IAAzCjiL,KAAK2qB,SAASs3J,wBAG1CjiL,KAAKikC,kBAAoB,EAAA2qC,eACrBjkD,EAASsZ,kBACT,EAAAj3B,eAAe6X,qBAKvB,gBACI,UACU7hB,MAAMqoE,UACd,MAAO9sD,GAWL,MATI,EAAA8gF,sBAAsBkzC,sBAAsBh0H,KAC3CwiK,IAEDv0K,EAAO6nD,KACH,wGAGJ0sH,GAAsC,GAEpCxiK,EAEVve,KAAKkiL,sBAAiBlgL,OAAWA,OAAWA,EAAWhC,KAAKyhL,kBAOhE,mBACIzhL,KAAKkiL,sBAAiBlgL,OAAWA,OAAWA,EAAW,CACnD2/K,kBAAmB,OAW3B,cAAcA,GACV3hL,KAAKyhL,iBAAiBE,kBACI,OAAtBA,EAA6BA,OAAoB3/K,EAErDhC,KAAKkiL,sBAAiBlgL,OAAWA,OAAWA,EAAW,CACnD2/K,oBACAG,iBAAkB9hL,KAAKyhL,iBAAiBK,iBACxC1+G,cAAepjE,KAAKyhL,iBAAiBr+G,gBAK7C,qBACI,OAAO,EAIX,aAAa9/C,QACSthB,IAAdshB,GACAtjB,KAAKkiL,sBAAiBlgL,OAAWA,EAAWshB,OAAWthB,GAK/D,iBAAiBohE,GAEbA,EAAgBA,aAAa,EAAbA,EAAeukE,cAC3B3nI,KAAKyhL,iBAAiBr+G,gBAAkBA,IACxCpjE,KAAKyhL,iBAAiBr+G,cAAgBA,EACtCpjE,KAAKkiL,sBAAiBlgL,OAAWA,OAAWA,EAAW,CACnD2/K,kBAAmB3hL,KAAKyhL,iBAAiBE,kBACzCG,iBAAkB9hL,KAAKyhL,iBAAiBK,iBACxC1+G,mBAAiCphE,IAAlBohE,EAA8BA,EAAgB,MAMzE,yBACI,OAAOpgE,MAAM01E,mBAIjB,uBAAuBx3C,GACnBl+B,MAAM01E,mBAAqBx3C,EAC3BlhC,KAAKyhL,iBAAiB/oG,mBAAqB14E,KAAK04E,mBAChD14E,KAAKkiL,sBAAiBlgL,OAAWA,OAAWA,EAAW,CACnD02E,mBAAoB14E,KAAK04E,qBAKjC,0BAA0BxB,GAClBl3E,KAAKyhL,iBAAiBQ,yBAA2B/qG,IACjDl3E,KAAKyhL,iBAAiBQ,uBAAyB/qG,EAC/Cl3E,KAAKkiL,sBAAiBlgL,OAAWA,OAAWA,EAAW,CACnDigL,uBAAwB/qG,KAK5B,iBACJ4B,EACAj3E,EACAyhB,EACArN,GAEAjW,KAAKutE,aACLvtE,KAAK+9B,QAAQokJ,UAAUrpG,EAAUj3E,EAAayhB,EAAWrN,GACzDjW,KAAKkO,QAAQy/D,eAAe3tE,OA9IpC,mB,iYCtQA,YACA,YACA,a,8ECVA,O,oHCQA,cASA,OAEA,SAsDA,oBAOI,YACYoiL,GAAA,KAAAA,qBAUZ,OAAOzhJ,EAAwB/c,GAC3B,OAAO,IAAI5jB,KAAKoiL,mBAAmBzhJ,EAAY/c,KASvD,MAAau9J,UAA8C,EAAAtpG,WAWvD,YACqBwqG,EACA1xI,GAgBjB,GAdA3tC,MAAM,CACFrF,KAAMgzC,EAAUhzC,KAChB4oE,aAAc51B,EAAU41B,aAExBxmD,aAAc4wB,EAAU5wB,aAExBC,aAAc2wB,EAAU3wB,aACxBi4D,aAActnC,EAAUsnC,aACxBC,aAAcvnC,EAAUunC,aACxBC,gBAAiBxnC,EAAUwnC,gBAC3BC,gBAAiBznC,EAAUynC,gBAC3BM,mBAAoB/nC,EAAU+nC,mBAC9BL,sBAAuB1nC,EAAU0nC,wBAfpB,KAAAgqG,gBACA,KAAA1xI,YAZF,KAAAnkC,OAAkB,EAAAC,cAAcxM,SAASvB,OAAO,kBAE3D,KAAA4jL,WAAqB,EA0BrB3xI,EAAU5S,QACV/9B,KAAKuiL,UAAY5xI,EAAU5S,YACxB,KAAI4S,EAAU2wI,6BAOjB,MAAM,IAAI79K,MACN,kBAAkBzD,KAAKrC,+CACnB,gCARRqC,KAAKuiL,UAAY,EAAAvnH,wBAAwBwnH,eACrC7xI,EAAU2wI,6BACV3wI,EAAU8xI,2BACV9xI,EAAU+xI,8BAQlB1iL,KAAK+3E,mBAAoB,EACzB/3E,KAAK83E,WAAY,EAIrB,UACI93E,KAAK+9B,QAAQ0H,UAIjB,QACI,OAAOzlC,KAAKsiL,WAAatiL,KAAK2wC,UAAUwmF,aAAarsD,QAOzD,cACI,OAAO9qE,KAAKuiL,UAIhB,sBACUtqI,QAAQC,IAAI,CAACl4C,KAAK2wC,UAAUwmF,aAAa9rD,UAAWrrE,KAAKuiL,UAAUl3G,YACzErrE,KAAKsiL,WAAY,EAEjBtiL,KAAKuiL,UAAUJ,eAAUngL,OAAWA,OAAWA,EAAW,CACtD02E,mBAAoB14E,KAAK2wC,UAAU+nC,qBAK3C,YAAYI,EAAqBj3E,EAA2ByhB,GACxDtjB,KAAKuiL,UAAUJ,UAAUrpG,EAAUj3E,EAAayhB,GAChDtjB,KAAKkO,QAAQy/D,eAAe3tE,MAUhC,SAAS0+D,EAAcp7C,GACnB,MAAMw1D,OACoB92E,IAAtBhC,KAAKumE,cAA8B7H,EAAMgL,OACnChL,EAAMgL,OAAO1pE,KAAKumE,mBAClBvkE,OAEOA,IAAb82E,GACA94E,KAAK2nH,YAAY7uC,EAAUpa,EAAM78D,YAAayhB,GAOtD,eACI,OAAOtjB,KAAK2wC,UAAUwmF,aAI1B,kBACI,OAAOn3H,KAAK2wC,UAAUqhD,aAY1B,QAAQpuE,GACJ,MAAMnB,EAAOziB,KAAKqiL,cAAc3jL,OAAOsB,KAAM4jB,GAsB7C,OArBAnB,EAAKE,WAAa,IAAI,EAAAu0G,WAClBl3H,KACA4jB,EACA5jB,KAAK2wC,UAAUwmF,aACfn3H,KAAK+9B,QACL,GAEJtb,EAAK+hB,cAAgBxkC,KAAK2wC,UAAUnM,mBACKxiC,IAArChC,KAAK2wC,UAAUgyI,mBACf3iL,KAAK2wC,UAAUgyI,kBACVC,cAAcngK,EAAKyT,OAAQtS,EAAQhI,OACnCopB,KAAKR,IACF/hB,EAAK+hB,mBACsBxiC,IAAvBygB,EAAK+hB,cACCA,EACA,IAAI/hB,EAAK+hB,iBAAkBA,GACrCxkC,KAAKykC,kBAGjBhiB,EAAK0P,OAEE1P,EASX,YAAYmB,GAqBR,OApBgB,IAAIq0B,QAA8B,CAACqzB,EAAS41B,KACxD,MAAMv+E,EAAa,IAAI,EAAAkgK,eACnB7iL,KACA4jB,EACA5jB,KAAK2wC,UAAUwmF,aACfn3H,KAAK+9B,QACL,GAGJpb,EAAWoiB,gBAAgBC,KAAK89I,IACxBA,IAAgB,EAAAviJ,gBAAgB2E,MAChComC,EAAQ3oD,EAAWqkB,UAEnBk6D,EACI,IAAIz9F,MAAM,iDAAiDq/K,WAvKnF,oB,0GCtGA,aAEA,QACA,QACA,OAMA,OAEA,QACA,QAEMC,EAAgB,IAAI3jL,EAAM+Z,kBAAkB,CAC9C8R,MAAO,EACP+3J,UAAW,EACX9zJ,WAAW,EACXi9E,UAAW/sG,EAAM6jL,aAGfC,EAAsB,IAAI9jL,EAAM+Y,kBAAkB,CACpD8S,MAAO,SACPiE,WAAW,EACXi9E,UAAW/sG,EAAM6jL,aAGS,IAAI7jL,EAAM+Y,kBAAkB,CACtD8S,MAAO,SACPiE,WAAW,EACXi9E,UAAW/sG,EAAM6jL,aAECrpI,WAAY,EAEH,IAAIx6C,EAAM+Y,kBAAkB,CACvD8S,MAAO,QACPiE,WAAW,EACXi9E,UAAW/sG,EAAM6jL,aAEErpI,WAAY,EAEnC,MAAMupI,EAA2B,IAAI/jL,EAAM+Y,kBAAkB,CACzD8S,MAAO,EACPiE,WAAW,EACXi9E,UAAW/sG,EAAM6jL,aAGfG,EAA0B,IAAIhkL,EAAM+Y,kBAAkB,CACxD8S,MAAO,IACPiE,WAAW,EACXi9E,UAAW/sG,EAAM6jL,WACjB/3J,QAAS,IACTxgB,aAAa,IAGX2sC,EAAkB,IAAI,EAAA7wB,gBACtB8wB,EAAkB,IAAI,EAAA5wB,gBAE5B2wB,EAAgBxsB,SAAW,CACvB5B,KAAM,EAAAjB,SAASgtC,MACf5zC,KAAM,EACNgI,eAAgB,GAEpBiuB,EAAgBnsB,QAAU,IAC1BmsB,EAAgBjsB,kBAAoB,IACpCisB,EAAgBpsB,MAAQ,IAAI7rB,EAAMsqB,MAAM,GAAK,GAAK,IAGlD,MAAM25J,EAAkBv7J,OAAOC,iBAE/B,MAAau7J,UAA2B,EAAAx1F,QACpC,YAAYntD,EAAwB/c,GAChC5gB,MAAM29B,EAAY/c,GAItB,kBACI5jB,KAAKujL,oBAMD,oBAGJ,MAAMC,EAAiB,EAAAxqI,aAAaC,SAAS,oBACvCwqI,EAAqB,EAAAzqI,aAAaC,SAAS,yBAC3CyqI,EAAoB,EAAA1qI,aAAaC,SAAS,wBAEhD,IAAMuqI,IAAkBC,QAA4CzhL,IAArBhC,KAAK6jC,YAChD,OAGJ,MAAM8/I,EAAsB,EAAAvpG,oBAAoBn6E,SAC1C4jC,EAAc7jC,KAAK6jC,YAEzB8/I,EAAoB9oG,mBAAmB76E,KAAM6jC,GAE7C,MAAM+/I,EAAW,IAAIzhL,IAGfy5E,EAAa,EAAA5iC,aAAaC,SAAS,gCACnC4qI,EAAc,EAAA7qI,aAAaC,SAAS,iCACpC72C,EAAMpC,KAAKkO,QAAQ9L,SAEcJ,IAAnC6hC,EAAY83C,qBACZ37E,KAAK+lC,kBAAoB49I,EAAoBxnG,iBACzCt4C,EAAY83C,mBACZ93C,IAIR,MAAMmzE,EAAUh3G,KAAKid,OAAOxX,EACtBwxG,EAAUj3G,KAAKid,OAAOvX,EACtBo+K,EAAU9jL,KAAKid,OAAOrX,EACtBm+K,EAAa/jL,KAAKkO,QAAQs+D,aAC1B4G,EAAepzE,KAAKqzE,sBAE1B,IAAI2wG,EAAkB,EAEtB,GAAIhkL,KAAKijC,kBAAkBlpB,QAAU,EAAG,CACpC,MAAMkqK,EAAoB,IAAI7kL,EAAMob,eAC9B0pK,EAAmB,IAAI9iL,MACvB+iL,EAAqB,IAAI/iL,MAEzBgjL,EAAmC,GAEzCpkL,KAAKijC,kBAAkB5iC,QAASyiC,IAC5B,QAAyB9gC,IAArB8gC,EAAY5b,KACZ,OAGJ,MAAMzhB,EAAIq9B,EAAY/0B,SAAStI,EAAIuxG,EAC7BtxG,EAAIo9B,EAAY/0B,SAASrI,EAAIuxG,EAC7BrxG,EAAI,EAAIk+K,EAKRO,EAAyB,EAAbN,EAElBI,EAAmBj+K,KAAKT,EAAGC,EAAI2+K,EAAWz+K,GAC1Cu+K,EAAmBj+K,KAAKT,EAAI4+K,EAAW3+K,EAAGE,GAC1Cu+K,EAAmBj+K,KAAKT,EAAGC,EAAI2+K,EAAWz+K,GAC1Cu+K,EAAmBj+K,KAAKT,EAAI4+K,EAAW3+K,EAAGE,GAE1C,MAAMk8C,EAAaqiI,EAAmB7iL,OAAS,EAS/C,GAPA4iL,EAAiBh+K,KAAK47C,EAAa,GACnCoiI,EAAiBh+K,KAAK47C,EAAa,GACnCoiI,EAAiBh+K,KAAK47C,EAAa,GACnCoiI,EAAiBh+K,KAAK47C,EAAa,GACnCoiI,EAAiBh+K,KAAK47C,EAAa,GACnCoiI,EAAiBh+K,KAAK47C,EAAa,GAE/B4hI,EAAmB,CACnB,MAAMY,EAAuB,GAAZD,EACXr+K,EAAgB,GAAG88B,EAAYtd,SAASw+J,KAExCO,EAAe,IAAI,EAAAh/J,YACrB,EAAA62D,0BAA0Bn8E,SAASo8E,QAAQr2E,GAC3C,IAAI5G,EAAMuG,QACNF,EAAI2tE,EAAe4jC,EAAUstE,EAC7B5+K,EAAIuxG,EAAUqtE,EACd1+K,EAAIk+K,GAERzsI,EACAC,EACA+rI,EACA,EACA,GAEJkB,EAAaxkK,aAAe,EAC5BwkK,EAAax9J,YAAa,EAC1Bw9J,EAAav9J,cAAe,EAC5Bu9J,EAAaj/H,aAAc,EAC3Bi/H,EAAa5kI,gBAAiB,EAC9B4kI,EAAa5+J,SAAW,EAAAJ,YAAYsC,iBAEnC08J,EAAqBC,UAAW,EAEjCJ,EAAkBl+K,KAAKq+K,GAG3BP,MAGJ,IAAK,MAAMO,KAAgBH,EACvBpkL,KAAK+iC,eAAewhJ,GAGxB,GAAIL,EAAiB5iL,OAAS,EAAG,CAC7B2iL,EAAkBpvG,SAAS,EAAGqvG,EAAiB5iL,OAAQ,GAEvD2iL,EAAkBxyH,aACd,WACA,IAAIryD,EAAM0a,gBAAgB,IAAI0X,aAAa2yJ,GAAqB,IAGpEF,EAAkBvyH,SACd,IAAItyD,EAAM0a,gBAAgB,IAAIwX,YAAY4yJ,GAAmB,IAEjE,MAAMO,EAAgB,IAAIrlL,EAAM40B,KAAKiwJ,EAAmBb,GACxDqB,EAAcn+J,YAAc+8J,EAC5BrjL,KAAK4gC,QAAQ16B,KAAKu+K,IAI1B,QAA+BziL,IAA3BhC,KAAK+lC,kBAAiC,CACtC,MAAM2+I,EAAe,IAAItlL,EAAMob,eACzBmqK,EAAc,IAAIvjL,MAClBqqF,EAAgB,IAAIrqF,MAEpBwjL,EAAmB,IAAIxlL,EAAMob,eAC7BqqK,EAAkB,IAAIzjL,MACtB0jL,EAAoB,IAAI1jL,MAExB2jL,EAAqB,IAAI3lL,EAAMob,eAC/BwqK,EAAoB,IAAI5jL,MACxB6jL,EAAsB,IAAI7jL,MAEhC,IAAImxD,EAAa,EAEjB,IAAK,MAAMnV,KAAYp9C,KAAK+lC,kBAAmB,CAC3C,MAAMzZ,EAAYuX,EAAY02C,WAAWn9B,EAAS9wB,WAClD,IAAK,EAAA0uD,gBAAgB1uD,SAA6CtqB,IAA9Bo7C,EAAiBonI,SACjD,cAEoBxiL,IAApBsqB,EAAUrB,OACV24J,EAAS58K,IACLo2C,EAAS9wB,UACT,IAAIltB,EAAMsqB,MAAM,EAAAwD,iBAAiBZ,EAAUrB,MAAO7oB,KAI1DmwD,EAAak5B,EAAcnqF,OAAS,EAEpC,MAAMkkB,EAAO43B,EAAS53B,KAEhB0/J,EAAellL,KAAK+lC,kBAAkBpT,QAAQyqB,GAMpD,KAHMw+B,GAAep2D,GAAQA,EAAKmN,QAAQipD,IAAe,UACpC55E,IAAhB6hL,GAA6BA,IAAgBqB,GAE7B,CACjB,MAAMC,EAAU,GAEhB,IAAK,IAAI/nL,EAAI,EAAGA,EAAIggD,EAASl2B,KAAK5lB,OAAQlE,GAAK,EAAG,CAC9C,MAAMgoL,EAAYhoL,EAAI,EAChBqI,EAAI23C,EAASl2B,KAAK9pB,GAAK45G,EACvBtxG,EAAI03C,EAASl2B,KAAK9pB,EAAI,GAAK65G,EAE3BrxG,EAAIu/K,EAAU/nI,EAASl2B,KAAK9pB,EAAI,GAAKA,EAAI,EAAI0mL,EAE/CN,GACA/3F,EAAcvlF,KAAKT,EAAGC,EAAGE,GAG7B,MAAMy/K,EAAmB,IAANjoL,EAEnB,GAAIqmL,GAAsB4B,EAAY,CAClC,MAAMhB,EAAYN,GAAcsB,EAAa,EAAI,GAE3C91H,EAAY81H,EAAaP,EAAoBG,EAC7Cv/F,EAAU2/F,EAAaR,EAAkBG,EAE/Cz1H,EAAUrpD,KAAKT,EAAGC,EAAI2+K,EAAWz+K,GACjC2pD,EAAUrpD,KAAKT,EAAI4+K,EAAW3+K,EAAGE,GACjC2pD,EAAUrpD,KAAKT,EAAGC,EAAI2+K,EAAWz+K,GACjC2pD,EAAUrpD,KAAKT,EAAI4+K,EAAW3+K,EAAGE,GAEjC,MAAMk8C,EAAayN,EAAUjuD,OAAS,EAStC,GAPAokF,EAAQx/E,KAAK47C,EAAa,GAC1B4jC,EAAQx/E,KAAK47C,EAAa,GAC1B4jC,EAAQx/E,KAAK47C,EAAa,GAC1B4jC,EAAQx/E,KAAK47C,EAAa,GAC1B4jC,EAAQx/E,KAAK47C,EAAa,GAC1B4jC,EAAQx/E,KAAK47C,EAAa,GAEtB2hI,EAAoB,CAEpB,MAAMz9K,EACFo/K,EAAY,GAAM,EACZ5/J,EAAO,IAAM4/J,EACbt9J,OAAOs9J,GAAWjoJ,WACtBonJ,EAAe,IAAI,EAAAh/J,YACrB,EAAA62D,0BAA0Bn8E,SAASo8E,QAAQr2E,GAC3C,IAAI5G,EAAMuG,QACNF,EAAI2tE,EAAe4jC,EACnBtxG,EAAIuxG,EACJrxG,EAAIk+K,GAERzsI,EACAC,EACA,EAAApqB,iBAAiBZ,EAAU3G,UAAY,EAAGvjB,GAC1CkqB,EAAU1G,SAAW,EACrB0G,EAAUzG,SAAW,GAEzB0+J,EAAaxkK,aAAeuM,EAAUvM,aACtCwkK,EAAax9J,YAAa,EAC1Bw9J,EAAav9J,cAAe,EAC5Bu9J,EAAaj/H,aAAc,EAC3Bi/H,EAAa5kI,gBAAiB,EAC9B4kI,EAAa5+J,SAAW,EAAAJ,YAAYsC,iBACpC7nB,KAAK+iC,eAAewhJ,KAMhC,MAAMtuD,EAAI74E,EAASl2B,KAAK5lB,OAAS,EACjC,IAAK,IAAIlE,EAAI,EAAGA,EAAI64H,IAAK74H,EACjBA,EAAI,GACJunL,EAAYz+K,KAAKqsD,EAAan1D,GAE9BA,EAAI,EAAI64H,GACR0uD,EAAYz+K,KAAKqsD,EAAan1D,IAM9C,GAAIunL,EAAYrjL,OAAS,EAAG,CACxBojL,EAAa7vG,SAAS,EAAG8vG,EAAYrjL,OAAQ,GAE7CojL,EAAajzH,aACT,WACA,IAAIryD,EAAM0a,gBAAgB,IAAI0X,aAAai6D,GAAgB,IAG/Di5F,EAAahzH,SAAS,IAAItyD,EAAM0a,gBAAgB,IAAIwX,YAAYqzJ,GAAc,IAC9E,MAAMW,EAAW,IAAIlmL,EAAMi1B,aAAaqwJ,EAAc3B,GACtDuC,EAASh/J,YAAc+8J,EAAkB,EACzCrjL,KAAK4gC,QAAQ16B,KAAKo/K,GAGtB,GAAIT,EAAgBvjL,OAAS,EAAG,CAC5BsjL,EAAiB/vG,SAAS,EAAGgwG,EAAgBvjL,OAAQ,GAErDsjL,EAAiBnzH,aACb,WACA,IAAIryD,EAAM0a,gBAAgB,IAAI0X,aAAaszJ,GAAoB,IAGnEF,EAAiBlzH,SACb,IAAItyD,EAAM0a,gBAAgB,IAAIwX,YAAYuzJ,GAAkB,IAEhE,MAAMU,EAAe,IAAInmL,EAAM40B,KAAK4wJ,EAAkB1B,GACtDqC,EAAaj/J,YAAc+8J,EAC3BrjL,KAAK4gC,QAAQ16B,KAAKq/K,GAGtB,GAAIP,EAAkB1jL,OAAS,EAAG,CAC9ByjL,EAAmBlwG,SAAS,EAAGmwG,EAAkB1jL,OAAQ,GAEzDyjL,EAAmBtzH,aACf,WACA,IAAIryD,EAAM0a,gBAAgB,IAAI0X,aAAayzJ,GAAsB,IAGrEF,EAAmBrzH,SACf,IAAItyD,EAAM0a,gBAAgB,IAAIwX,YAAY0zJ,GAAoB,IAElE,MAAMQ,EAAiB,IAAIpmL,EAAM40B,KAAK+wJ,EAAoB5B,GAC1DqC,EAAel/J,YAAc+8J,EAAkB,EAC/CrjL,KAAK4gC,QAAQ16B,KAAKs/K,MA1SlC,wB,2GCtEA,aACA,MAEA,cAIMh5K,EAFN,KAEeC,cAAcxM,SAASvB,OAAO,uBAiB7C,IAAI+mL,GAA0C,EAK9C,4BAYI,YACa9nL,EACFoD,EACPkV,GAFS,KAAAtY,OACF,KAAAoD,QAZH,KAAA2kL,cAAe,EAenB1lL,KAAK2lL,QACA1vK,GAAWA,EAAQ2vK,OACpB,EAAA9gF,sBAAsB+gF,SAAS,YAAa5vK,GAAWA,EAAQ6vK,gBAGvE,gBACI,UACU9lL,KAAK2lL,QAAQt6G,UACrB,MAAO9sD,GAWL,MATI,EAAA8gF,sBAAsBkzC,sBAAsBh0H,KAC3CknK,IAEDj5K,EAAO6nD,KACH,uGAGJoxH,GAAiC,GAE/BlnK,QAGJve,KAAK2lL,QAAQI,cAAc/lL,KAAKrC,KAAMqC,KAAKe,OACjDf,KAAK0lL,cAAe,EAGxB,YAAY3kL,GACRf,KAAKe,MAAQA,EACbf,KAAK2lL,QAAQK,YAAYhmL,KAAKrC,KAAMqC,KAAKe,OAG7C,QACI,OAAOf,KAAK0lL,aAGhB,cAAc9hK,GACV,OAAO5jB,KAAK2lL,QAAQh2D,QAAQ3vH,KAAKrC,KAAMimB,M,8GCjFlC,EAAAo4G,OAAS,8CAGT,EAAAx3F,cAAgB,CACzB,CACIzV,GAAI,WACJ05D,MAAM,IAAI7e,MAAOuxD,cACjBn1H,MAAO,OACP0iF,KAAM,kC","file":"index.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 128);\n","module.exports = THREE;","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport * from \"./index-common\";\nexport * from \"./lib/UrlPlatformUtils.web\";\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Components used for the decoding and styling of data that is used by the Datasources.\n *\n * @remarks\n * The DataSource Protocol package contains components used for the decoding and styling\n * of data that is used by the Datasources.\n * This code is shared between the ui-thread and the web-workers which are\n * used to parallelise the decoding of the data.\n * This module contains interfaces for choosing techniques form the techniques\n * catalog that are applied via the {@link Theme} files to draw geometries on the map canvas.\n *\n * @packageDocumentation\n */\n\nexport * from \"./lib/ColorUtils\";\nexport * from \"./lib/Expr\";\nexport * from \"./lib/Techniques\";\nexport * from \"./lib/TechniqueParams\";\nexport * from \"./lib/Theme\";\nexport * from \"./lib/PostEffects\";\nexport * from \"./lib/PropertyValue\";\nexport * from \"./lib/InterpolatedPropertyDefs\";\nexport * from \"./lib/WorkerServiceProtocol\";\nexport * from \"./lib/WorkerTilerProtocol\";\nexport * from \"./lib/WorkerDecoderProtocol\";\nexport * from \"./lib/ITileDecoder\";\nexport * from \"./lib/ITiler\";\nexport * from \"./lib/DecodedTile\";\nexport * from \"./lib/TileInfo\";\nexport * from \"./lib/GeoJsonDataType\";\nexport * from \"./lib/ThemeVisitor\";\nexport * from \"./lib/StringEncodedNumeral\";\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Utility classes for working with geospatial data.\n *\n * @remarks\n *\n * @packageDocumentation\n */\n\nexport * from \"./lib/coordinates/GeoBox\";\nexport * from \"./lib/coordinates/GeoBoxExtentLike\";\nexport * from \"./lib/coordinates/GeoCoordinatesLike\";\nexport * from \"./lib/coordinates/GeoCoordinates\";\nexport * from \"./lib/coordinates/GeoPointLike\";\nexport * from \"./lib/coordinates/LatLngLike\";\nexport * from \"./lib/projection/EarthConstants\";\nexport * from \"./lib/projection/EquirectangularProjection\";\nexport * from \"./lib/projection/IdentityProjection\";\nexport * from \"./lib/projection/Projection\";\nexport * from \"./lib/projection/MercatorProjection\";\nexport * from \"./lib/projection/TransverseMercatorProjection\";\nexport * from \"./lib/projection/SphereProjection\";\nexport * from \"./lib/tiling/FlatTileBoundingBoxGenerator\";\nexport * from \"./lib/tiling/HalfQuadTreeSubdivisionScheme\";\nexport * from \"./lib/tiling/QuadTreeSubdivisionScheme\";\nexport * from \"./lib/tiling/QuadTree\";\nexport * from \"./lib/tiling/SubTiles\";\nexport * from \"./lib/tiling/SubdivisionScheme\";\nexport * from \"./lib/tiling/TileKey\";\nexport * from \"./lib/tiling/TileKeyUtils\";\nexport * from \"./lib/tiling/TileTreeTraverse\";\nexport * from \"./lib/tiling/TilingScheme\";\nexport * from \"./lib/tiling/HereTilingScheme\";\nexport * from \"./lib/tiling/WebMercatorTilingScheme\";\nexport * from \"./lib/tiling/MercatorTilingScheme\";\nexport * from \"./lib/tiling/PolarTilingScheme\";\nexport * from \"./lib/math/Vector3Like\";\nexport * from \"./lib/math/Box3Like\";\nexport * from \"./lib/math/OrientedBox3Like\";\nexport * from \"./lib/math/MathUtils\";\nexport * from \"./lib/math/TransformLike\";\nexport * from \"./lib/math/OrientedBox3\";\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Materials defining the appearance of map objects.\n *\n * @remarks\n *\n * @packageDocumentation\n */\n\nexport * from \"./lib/CirclePointsMaterial\";\nexport * from \"./lib/CopyMaterial\";\nexport * from \"./lib/DisplacementFeature\";\nexport * from \"./lib/EdgeMaterial\";\nexport * from \"./lib/GroundAtmosphereMaterial\";\nexport * from \"./lib/HighPrecisionLineMaterial\";\nexport * from \"./lib/HighPrecisionPointMaterial\";\nexport * from \"./lib/IconMaterial\";\nexport * from \"./lib/LuminosityHighPassShader\";\nexport * from \"./lib/MapMeshMaterialsDefs\";\nexport * from \"./lib/MapMeshMaterials\";\nexport * from \"./lib/MSAAMaterial\";\nexport * from \"./lib/SepiaShader\";\nexport * from \"./lib/SkyAtmosphereMaterial\";\nexport * from \"./lib/SolidLineMaterial\";\nexport * from \"./lib/Utils\";\nexport * from \"./lib/VignetteShader\";\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Env, Value } from \"./Env\";\nimport { ExprEvaluator, ExprEvaluatorContext, OperatorDescriptor } from \"./ExprEvaluator\";\nimport { ExprInstantiator, InstantiationContext } from \"./ExprInstantiator\";\nimport { ExprParser } from \"./ExprParser\";\nimport { ExprPool } from \"./ExprPool\";\nimport {\n    interpolatedPropertyDefinitionToJsonExpr,\n    isInterpolatedPropertyDefinition\n} from \"./InterpolatedPropertyDefs\";\nimport { Definitions, isBoxedDefinition, isLiteralDefinition } from \"./Theme\";\n\nimport * as THREE from \"three\";\nimport { Pixels } from \"./Pixels\";\nimport { RGBA } from \"./RGBA\";\n\nexport * from \"./Env\";\n\nconst exprEvaluator = new ExprEvaluator();\n\nconst exprInstantiator = new ExprInstantiator();\n\n/**\n * A visitor for {@link Expr} nodes.\n */\nexport interface ExprVisitor<Result, Context> {\n    visitNullLiteralExpr(expr: NullLiteralExpr, context: Context): Result;\n    visitBooleanLiteralExpr(expr: BooleanLiteralExpr, context: Context): Result;\n    visitNumberLiteralExpr(expr: NumberLiteralExpr, context: Context): Result;\n    visitStringLiteralExpr(expr: StringLiteralExpr, context: Context): Result;\n    visitObjectLiteralExpr(expr: ObjectLiteralExpr, context: Context): Result;\n    visitVarExpr(expr: VarExpr, context: Context): Result;\n    visitHasAttributeExpr(expr: HasAttributeExpr, context: Context): Result;\n    visitCallExpr(expr: CallExpr, context: Context): Result;\n    visitMatchExpr(expr: MatchExpr, context: Context): Result;\n    visitCaseExpr(expr: CaseExpr, context: Context): Result;\n    visitStepExpr(expr: StepExpr, context: Context): Result;\n    visitInterpolateExpr(expr: InterpolateExpr, context: Context): Result;\n}\n\n/**\n * The dependencies of an {@link Expr}.\n */\nexport class ExprDependencies {\n    /**\n     * The properties needed to evaluate the {@link Expr}.\n     */\n    readonly properties = new Set<string>();\n\n    /**\n     * `true` if the expression depends on the feature state.\n     */\n    featureState?: boolean;\n\n    /**\n     * `true` if this expression cannot be cached.\n     */\n    volatile?: boolean;\n}\n\nclass ComputeExprDependencies implements ExprVisitor<void, ExprDependencies> {\n    static instance = new ComputeExprDependencies();\n\n    /**\n     * Gets the dependencies of an {@link Expr}.\n     *\n     * @param expr - The {@link Expr} to process.\n     * @param scope - The evaluation scope. Defaults to [[ExprScope.Value]].\n     * @param dependencies - The output [[Set]] of dependency names.\n     */\n    static of(expr: Expr) {\n        const dependencies = new ExprDependencies();\n        expr.accept(this.instance, dependencies);\n        return dependencies;\n    }\n\n    visitNullLiteralExpr(expr: NullLiteralExpr, context: ExprDependencies): void {\n        // nothing to do\n    }\n\n    visitBooleanLiteralExpr(expr: BooleanLiteralExpr, context: ExprDependencies): void {\n        // nothing to do\n    }\n\n    visitNumberLiteralExpr(expr: NumberLiteralExpr, context: ExprDependencies): void {\n        // nothing to do\n    }\n\n    visitStringLiteralExpr(expr: StringLiteralExpr, context: ExprDependencies): void {\n        // nothing to do\n    }\n\n    visitObjectLiteralExpr(expr: ObjectLiteralExpr, context: ExprDependencies): void {\n        // nothing to do\n    }\n\n    visitVarExpr(expr: VarExpr, context: ExprDependencies): void {\n        context.properties.add(expr.name);\n    }\n\n    visitHasAttributeExpr(expr: HasAttributeExpr, context: ExprDependencies): void {\n        context.properties.add(expr.name);\n    }\n\n    visitCallExpr(expr: CallExpr, context: ExprDependencies): void {\n        expr.args.forEach(childExpr => childExpr.accept(this, context));\n\n        switch (expr.op) {\n            case \"dynamic-properties\":\n                context.volatile = true;\n                break;\n            case \"feature-state\":\n                context.featureState = true;\n                context.properties.add(\"$state\");\n                context.properties.add(\"$id\");\n                break;\n            case \"id\":\n                context.properties.add(\"$id\");\n                break;\n            case \"zoom\":\n            case \"world-ppi-scale\":\n            case \"world-discrete-ppi-scale\":\n                context.properties.add(\"$zoom\");\n                break;\n            case \"geometry-type\":\n                context.properties.add(\"$geometryType\");\n                break;\n            default:\n                break;\n        }\n    }\n\n    visitMatchExpr(expr: MatchExpr, context: ExprDependencies): void {\n        expr.value.accept(this, context);\n        expr.branches.forEach(([_, branch]) => branch.accept(this, context));\n        expr.fallback.accept(this, context);\n    }\n\n    visitCaseExpr(expr: CaseExpr, context: ExprDependencies): void {\n        expr.branches.forEach(([condition, branch]) => {\n            condition.accept(this, context);\n            branch.accept(this, context);\n        });\n        expr.fallback.accept(this, context);\n    }\n\n    visitStepExpr(expr: StepExpr, context: ExprDependencies): void {\n        expr.input.accept(this, context);\n        expr.defaultValue.accept(this, context);\n        expr.stops.forEach(([_, value]) => value.accept(this, context));\n    }\n\n    visitInterpolateExpr(expr: InterpolateExpr, context: ExprDependencies): void {\n        expr.input.accept(this, context);\n        expr.stops.forEach(([_, value]) => value.accept(this, context));\n    }\n}\n\n/**\n * A type represeting JSON values.\n */\nexport type JsonValue = null | boolean | number | string | JsonObject | JsonArray;\n\n/**\n * A type representing JSON arrays.\n */\nexport interface JsonArray extends Array<JsonValue> {}\n\n/**\n * A type representing JSON objects.\n */\nexport interface JsonObject {\n    [name: string]: JsonValue;\n}\n\n/**\n * The JSON representation of an {@link Expr} object.\n */\nexport type JsonExpr = JsonArray;\n\nexport function isJsonExpr(v: any): v is JsonExpr {\n    return Array.isArray(v) && v.length > 0 && typeof v[0] === \"string\";\n}\n\n/**\n * Internal state needed by {@link Expr.fromJSON} to resolve `\"ref\"` expressions.\n */\ninterface ReferenceResolverState {\n    definitions: Definitions;\n    lockedNames: Set<string>;\n    cache: Map<string, Expr>;\n}\n\n/**\n * The evaluation scope of an {@link Expr}.\n */\nexport enum ExprScope {\n    /**\n     * The scope of an {@link Expr} used as value of an attribute.\n     */\n    Value,\n\n    /**\n     * The scope of an {@link Expr} used in a [[Technique]] `when` condition.\n     */\n    Condition,\n\n    /**\n     * The scope of an {@link Expr} used as dynamic property attribute value.\n     */\n    Dynamic\n}\n\n// tslint:disable:max-line-length\n/**\n * Abstract class representing the\n * {@link https://github.com/heremaps/harp.gl/blob/master/%40here/harp-datasource-protocol/StyleExpressions.md | style expressions}\n * used in {@link Theme}.\n */\n// tslint:enable:max-line-length\nexport abstract class Expr {\n    /**\n     * Tests of given value is an {@link Expr}.\n     *\n     * @param value - The object to test.\n     */\n    static isExpr(value: any): value is Expr {\n        return value instanceof Expr;\n    }\n\n    /**\n     * Creates an expression from the given `code`.\n     *\n     * @param code - The code to parse.\n     * @returns The parsed {@link Expr}.\n     * @deprecated `string` encoded expression are deprecated. Use {@link Expr.fromJSON} instead.\n     */\n    static parse(code: string): Expr | never {\n        const parser = new ExprParser(code);\n        const expr = parser.parse();\n        return expr;\n    }\n\n    // tslint:disable:max-line-length\n    /**\n     * Creates a style expression from JSON.\n     *\n     * @remarks\n     * The optional set of {@link Theme.definitions | definitions} is used\n     * to resolve the {@link https://github.com/heremaps/harp.gl/blob/master/%40here/harp-datasource-protocol/StyleExpressions.md#ref | ref expressions}.\n     *\n     * @param json - JSON object representing the expression to parse.\n     * @param definitions - Optional set of definitions used to expand references.\n     * @param definitionExprCache - Optional cache of `Expr` instances\n     *\n     * @example\n     * ```typescript\n     * const expr = Expr.fromJSON([\"all\",\n     *     [\"==\", [\"geometry-type\"], \"LineString\"],\n     *     [\"has\", \"text\"]\n     * ]);\n     * ```\n     */\n    // tslint:enable:max-line-length\n    static fromJSON(\n        json: JsonValue,\n        definitions?: Definitions,\n        definitionExprCache?: Map<string, Expr>\n    ) {\n        const referenceResolverState: ReferenceResolverState | undefined =\n            definitions !== undefined\n                ? {\n                      definitions,\n                      lockedNames: new Set(),\n                      cache: definitionExprCache || new Map<string, Expr>()\n                  }\n                : undefined;\n\n        return parseNode(json, referenceResolverState);\n    }\n\n    private m_dependencies?: ExprDependencies;\n    private m_isDynamic?: boolean;\n\n    /**\n     * Evaluate an expression returning a {@link Value} object.\n     *\n     * @param env - The {@link Env} used to lookup symbols.\n     * @param scope - The evaluation scope. Defaults to [[ExprScope.Value]].\n     * @param cache - A cache of previously computed results.\n     */\n    evaluate(\n        env: Env,\n        scope: ExprScope = ExprScope.Value,\n        cache?: Map<Expr, Value>\n    ): Value | never {\n        return this.accept(\n            exprEvaluator,\n            new ExprEvaluatorContext(exprEvaluator, env, scope, cache)\n        );\n    }\n\n    /**\n     * Instantiates this {@link Expr}.\n     *\n     * @remarks\n     * references to the `get` and `has` operator using the given instantiation context.\n     *\n     * @param context - The [[InstantationContext]] used to resolve names.\n     */\n    instantiate(context: InstantiationContext): Expr {\n        return this.accept(exprInstantiator, context);\n    }\n\n    /**\n     * Gets the dependencies of this {@link Expr}.\n     */\n    dependencies(): ExprDependencies {\n        if (!this.m_dependencies) {\n            this.m_dependencies = ComputeExprDependencies.of(this);\n        }\n        return this.m_dependencies;\n    }\n\n    /**\n     * Create a unique object that is structurally equivalent to this {@link Expr}.\n     *\n     * @param pool - The [[ExprPool]] used to create a unique\n     * equivalent object of this {@link Expr}.\n     */\n    intern(pool: ExprPool): Expr {\n        return pool.add(this);\n    }\n\n    toJSON(): JsonValue {\n        return new ExprSerializer().serialize(this);\n    }\n\n    /**\n     * Returns `true` if a dynamic execution context is required to evaluate this {@link Expr}.\n     */\n    isDynamic(): boolean {\n        if (this.m_isDynamic === undefined) {\n            this.m_isDynamic = this.exprIsDynamic();\n        }\n        return this.m_isDynamic;\n    }\n\n    /**\n     * Visits this expression.\n     *\n     * @param visitor The visitor used to visit the expression.\n     * @param context The context passed to the vistor.\n     */\n    abstract accept<Result, Context>(\n        visitor: ExprVisitor<Result, Context>,\n        context: Context\n    ): Result;\n\n    /**\n     * Update the dynamic state of this {@link Expr}.\n     *\n     * `exprIsDynamic` must never be called directly.\n     * @internal\n     */\n    protected abstract exprIsDynamic(): boolean;\n}\n\n/**\n * @internal\n */\nexport type RelationalOp = \"<\" | \">\" | \"<=\" | \">=\";\n\n/**\n * @internal\n */\nexport type EqualityOp = \"~=\" | \"^=\" | \"$=\" | \"==\" | \"!=\";\n\n/**\n * @internal\n */\nexport type BinaryOp = RelationalOp | EqualityOp;\n\n/**\n * A node representing a `get` expression.\n */\nexport class VarExpr extends Expr {\n    constructor(readonly name: string) {\n        super();\n    }\n\n    /** @override */\n    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result {\n        return visitor.visitVarExpr(this, context);\n    }\n\n    /** @override */\n    protected exprIsDynamic() {\n        return false;\n    }\n}\n\n/**\n * A node representing a `literal` expression.\n */\nexport abstract class LiteralExpr extends Expr {\n    /**\n     * Create a [[LiteralExpr]] from the given value.\n     *\n     * @param value - A constant value.\n     */\n    static fromValue(value: Value): Expr {\n        switch (typeof value) {\n            case \"boolean\":\n                return new BooleanLiteralExpr(value);\n            case \"number\":\n                return new NumberLiteralExpr(value);\n            case \"string\":\n                return new StringLiteralExpr(value);\n            case \"object\":\n                return value === null ? NullLiteralExpr.instance : new ObjectLiteralExpr(value);\n            default:\n                throw new Error(`failed to create a literal from '${value}'`);\n        } // switch\n    }\n\n    abstract get value(): Value;\n\n    /** @override */\n    protected exprIsDynamic() {\n        return false;\n    }\n}\n\n/**\n * Null literal expression.\n */\nexport class NullLiteralExpr extends LiteralExpr {\n    static instance = new NullLiteralExpr();\n    /** @override */\n    readonly value: Value = null;\n\n    protected constructor() {\n        super();\n    }\n\n    /** @override */\n    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result {\n        return visitor.visitNullLiteralExpr(this, context);\n    }\n\n    /** @override */\n    protected exprIsDynamic() {\n        return false;\n    }\n}\n\n/**\n * Boolean literal expression.\n */\nexport class BooleanLiteralExpr extends LiteralExpr {\n    constructor(readonly value: boolean) {\n        super();\n    }\n\n    /** @override */\n    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result {\n        return visitor.visitBooleanLiteralExpr(this, context);\n    }\n}\n\n/**\n * Number literal expression.\n */\nexport class NumberLiteralExpr extends LiteralExpr {\n    constructor(readonly value: number) {\n        super();\n    }\n\n    /** @override */\n    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result {\n        return visitor.visitNumberLiteralExpr(this, context);\n    }\n}\n\n/**\n * String literal expression.\n */\nexport class StringLiteralExpr extends LiteralExpr {\n    private m_promotedValue?: RGBA | Pixels | null;\n\n    constructor(readonly value: string) {\n        super();\n    }\n\n    /**\n     * Returns the value of parsing this string as [[RGBA]] or [[Pixels]] constant.\n     */\n    get promotedValue(): RGBA | Pixels | undefined {\n        if (this.m_promotedValue === undefined) {\n            this.m_promotedValue = RGBA.parse(this.value) ?? Pixels.parse(this.value) ?? null;\n        }\n        return this.m_promotedValue ?? undefined;\n    }\n\n    /** @override */\n    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result {\n        return visitor.visitStringLiteralExpr(this, context);\n    }\n}\n\n/**\n * Object literal expression.\n */\nexport class ObjectLiteralExpr extends LiteralExpr {\n    constructor(readonly value: object) {\n        super();\n    }\n\n    get isArrayLiteral() {\n        return Array.isArray(this.value);\n    }\n\n    /** @override */\n    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result {\n        return visitor.visitObjectLiteralExpr(this, context);\n    }\n}\n\n/**\n * A node reperesenting a `has` expression.\n */\nexport class HasAttributeExpr extends Expr {\n    constructor(readonly name: string) {\n        super();\n    }\n\n    /** @override */\n    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result {\n        return visitor.visitHasAttributeExpr(this, context);\n    }\n\n    /** @override */\n    protected exprIsDynamic() {\n        return false;\n    }\n}\n\n/**\n * A node representing a `call` expression.\n */\nexport class CallExpr extends Expr {\n    descriptor?: OperatorDescriptor;\n\n    constructor(readonly op: string, readonly args: Expr[]) {\n        super();\n    }\n\n    /**\n     * Returns the child nodes of this {@link Expr}.\n     *\n     * @deprecated Use {@link CallExpr.args} instead.\n     */\n    get children() {\n        return this.args;\n    }\n\n    /** @override */\n    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result {\n        return visitor.visitCallExpr(this, context);\n    }\n\n    /** @override */\n    protected exprIsDynamic() {\n        const descriptor = this.descriptor || ExprEvaluator.getOperator(this.op);\n\n        if (descriptor && descriptor.isDynamicOperator && descriptor.isDynamicOperator(this)) {\n            return true;\n        }\n\n        return this.args.some(e => e.isDynamic());\n    }\n}\n\n/**\n * The labels of a {@link MatchExpr} expression.\n */\nexport type MatchLabel = number | string | number[] | string[];\n\n/**\n * A node representing a `match` expression.\n */\nexport class MatchExpr extends Expr {\n    /**\n     * Tests if the given JSON node is a valid label for the `\"match\"` operator.\n     *\n     * @param node - A JSON value.\n     */\n    static isValidMatchLabel(node: JsonValue): node is MatchLabel {\n        switch (typeof node) {\n            case \"number\":\n            case \"string\":\n                return true;\n            case \"object\":\n                if (!Array.isArray(node) || node.length === 0) {\n                    return false;\n                }\n                const elementTy = typeof node[0];\n                if (elementTy === \"number\" || elementTy === \"string\") {\n                    return node.every(t => typeof t === elementTy);\n                }\n                return false;\n            default:\n                return false;\n        } // switch\n    }\n\n    constructor(\n        readonly value: Expr,\n        readonly branches: Array<[MatchLabel, Expr]>,\n        readonly fallback: Expr\n    ) {\n        super();\n    }\n\n    /** @override */\n    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result {\n        return visitor.visitMatchExpr(this, context);\n    }\n\n    /** @override */\n    protected exprIsDynamic() {\n        return (\n            this.value.isDynamic() ||\n            this.branches.some(([_, branch]) => branch.isDynamic()) ||\n            this.fallback.isDynamic()\n        );\n    }\n}\n\n/**\n * A node representing a `case` expression.\n */\nexport class CaseExpr extends Expr {\n    constructor(readonly branches: Array<[Expr, Expr]>, readonly fallback: Expr) {\n        super();\n    }\n\n    /** @override */\n    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result {\n        return visitor.visitCaseExpr(this, context);\n    }\n\n    /** @override */\n    protected exprIsDynamic() {\n        return (\n            this.branches.some(([cond, branch]) => cond.isDynamic() || branch.isDynamic()) ||\n            this.fallback.isDynamic()\n        );\n    }\n}\n\n/**\n * A node representing a `step` expression.\n */\nexport class StepExpr extends Expr {\n    constructor(\n        readonly input: Expr,\n        readonly defaultValue: Expr,\n        readonly stops: Array<[number, Expr]>\n    ) {\n        super();\n    }\n\n    /** @override */\n    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result {\n        return visitor.visitStepExpr(this, context);\n    }\n\n    /** @override */\n    protected exprIsDynamic(): boolean {\n        return (\n            this.input.isDynamic() ||\n            this.defaultValue.isDynamic() ||\n            this.stops.some(([_, value]) => value.isDynamic())\n        );\n    }\n}\n\n/**\n * The type of the interpolation mode.\n */\nexport type InterpolateMode = [\"discrete\"] | [\"linear\"] | [\"cubic\"] | [\"exponential\", number];\n\n/**\n * A node representing an `interpolate` expression.\n */\nexport class InterpolateExpr extends Expr {\n    constructor(\n        readonly mode: InterpolateMode,\n        readonly input: Expr,\n        readonly stops: Array<[number, Expr]>\n    ) {\n        super();\n    }\n\n    /** @override */\n    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result {\n        return visitor.visitInterpolateExpr(this, context);\n    }\n\n    /** @override */\n    protected exprIsDynamic(): boolean {\n        return this.input.isDynamic() || this.stops.some(([_, value]) => value.isDynamic());\n    }\n}\n\n/**\n * Serializes the Expr to JSON.\n *\n * @internal\n */\nclass ExprSerializer implements ExprVisitor<JsonValue, void> {\n    serialize(expr: Expr): JsonValue {\n        return expr.accept(this, undefined);\n    }\n\n    visitNullLiteralExpr(expr: NullLiteralExpr, context: void): JsonValue {\n        return null;\n    }\n\n    visitBooleanLiteralExpr(expr: BooleanLiteralExpr, context: void): JsonValue {\n        return expr.value;\n    }\n\n    visitNumberLiteralExpr(expr: NumberLiteralExpr, context: void): JsonValue {\n        return expr.value;\n    }\n\n    visitStringLiteralExpr(expr: StringLiteralExpr, context: void): JsonValue {\n        return expr.value;\n    }\n\n    visitObjectLiteralExpr(expr: ObjectLiteralExpr, context: void): JsonValue {\n        if (expr.value instanceof THREE.Vector2) {\n            return [\"make-vector\", expr.value.x, expr.value.y];\n        } else if (expr.value instanceof THREE.Vector3) {\n            return [\"make-vector\", expr.value.x, expr.value.y, expr.value.z];\n        } else if (expr.value instanceof THREE.Vector4) {\n            return [\"make-vector\", expr.value.x, expr.value.y, expr.value.z, expr.value.w];\n        }\n        return [\"literal\", expr.value as JsonObject];\n    }\n\n    visitVarExpr(expr: VarExpr, context: void): JsonValue {\n        return [\"get\", expr.name];\n    }\n\n    visitHasAttributeExpr(expr: HasAttributeExpr, context: void): JsonValue {\n        return [\"has\", expr.name];\n    }\n\n    visitCallExpr(expr: CallExpr, context: void): JsonValue {\n        return [expr.op, ...expr.args.map(childExpr => this.serialize(childExpr))];\n    }\n\n    visitMatchExpr(expr: MatchExpr, context: void): JsonValue {\n        const branches: JsonValue[] = [];\n        for (const [label, body] of expr.branches) {\n            branches.push(label, this.serialize(body));\n        }\n        return [\"match\", this.serialize(expr.value), ...branches, this.serialize(expr.fallback)];\n    }\n\n    visitCaseExpr(expr: CaseExpr, context: void): JsonValue {\n        const branches: JsonValue[] = [];\n        for (const [condition, body] of expr.branches) {\n            branches.push(this.serialize(condition), this.serialize(body));\n        }\n        return [\"case\", ...branches, this.serialize(expr.fallback)];\n    }\n\n    visitStepExpr(expr: StepExpr, context: void): JsonValue {\n        const result: JsonArray = [\"step\"];\n        result.push(this.serialize(expr.input));\n        result.push(this.serialize(expr.defaultValue));\n        expr.stops.forEach(([key, value]) => {\n            result.push(key);\n            result.push(this.serialize(value));\n        });\n        return result;\n    }\n\n    visitInterpolateExpr(expr: InterpolateExpr, context: void): JsonValue {\n        const result: JsonArray = [\"interpolate\", expr.mode];\n        result.push(this.serialize(expr.input));\n        expr.stops.forEach(([key, value]) => {\n            result.push(key);\n            result.push(this.serialize(value));\n        });\n        return result;\n    }\n}\n\nfunction parseNode(\n    node: JsonValue,\n    referenceResolverState: ReferenceResolverState | undefined\n): Expr {\n    if (Array.isArray(node)) {\n        return parseCall(node, referenceResolverState);\n    } else if (node === null) {\n        return NullLiteralExpr.instance;\n    } else if (typeof node === \"boolean\") {\n        return new BooleanLiteralExpr(node);\n    } else if (typeof node === \"number\") {\n        return new NumberLiteralExpr(node);\n    } else if (typeof node === \"string\") {\n        return new StringLiteralExpr(node);\n    }\n    throw new Error(`failed to create expression from: ${JSON.stringify(node)}`);\n}\n\nfunction parseCall(node: JsonArray, referenceResolverState?: ReferenceResolverState): Expr {\n    const op = node[0];\n\n    if (typeof op !== \"string\") {\n        throw new Error(\"expected a builtin function name\");\n    }\n\n    switch (op) {\n        case \"!has\":\n        case \"!in\":\n            return new CallExpr(\"!\", [parseCall([op.slice(1), ...node.slice(1)])]);\n\n        case \"ref\":\n            return resolveReference(node, referenceResolverState);\n\n        case \"get\":\n            return parseGetExpr(node, referenceResolverState);\n\n        case \"has\":\n            return parseHasExpr(node, referenceResolverState);\n\n        case \"literal\":\n            return parseLiteralExpr(node);\n\n        case \"match\":\n            return parseMatchExpr(node, referenceResolverState);\n\n        case \"case\":\n            return parseCaseExpr(node, referenceResolverState);\n\n        case \"interpolate\":\n            return parseInterpolateExpr(node, referenceResolverState);\n\n        case \"step\":\n            return parseStepExpr(node, referenceResolverState);\n\n        default:\n            return makeCallExpr(op, node, referenceResolverState);\n    } // switch\n}\n\nfunction parseGetExpr(node: JsonArray, referenceResolverState: ReferenceResolverState | undefined) {\n    if (node[2] !== undefined) {\n        return makeCallExpr(\"get\", node, referenceResolverState);\n    }\n    const name = node[1];\n    if (typeof name !== \"string\") {\n        throw new Error(`expected the name of an attribute`);\n    }\n    return new VarExpr(name);\n}\n\nfunction parseHasExpr(node: JsonArray, referenceResolverState: ReferenceResolverState | undefined) {\n    if (node[2] !== undefined) {\n        return makeCallExpr(\"has\", node, referenceResolverState);\n    }\n    const name = node[1];\n    if (typeof name !== \"string\") {\n        throw new Error(`expected the name of an attribute`);\n    }\n    return new HasAttributeExpr(name);\n}\n\nfunction parseLiteralExpr(node: JsonArray) {\n    const obj = node[1];\n    if (obj === null || typeof obj !== \"object\") {\n        throw new Error(\"expected an object or array literal\");\n    }\n    return new ObjectLiteralExpr(obj);\n}\n\nfunction parseMatchExpr(\n    node: JsonArray,\n    referenceResolverState: ReferenceResolverState | undefined\n) {\n    if (node.length < 4) {\n        throw new Error(\"not enough arguments\");\n    }\n    if (!(node.length % 2)) {\n        throw new Error(\"fallback is missing in 'match' expression\");\n    }\n    const value = parseNode(node[1], referenceResolverState);\n    const conditions: Array<[MatchLabel, Expr]> = [];\n    for (let i = 2; i < node.length - 1; i += 2) {\n        const label = node[i];\n        if (!MatchExpr.isValidMatchLabel(label)) {\n            throw new Error(`'${JSON.stringify(label)}' is not a valid label for 'match'`);\n        }\n        const expr = parseNode(node[i + 1], referenceResolverState);\n        conditions.push([label, expr]);\n    }\n    const fallback = parseNode(node[node.length - 1], referenceResolverState);\n    return new MatchExpr(value, conditions, fallback);\n}\n\nfunction parseCaseExpr(\n    node: JsonArray,\n    referenceResolverState: ReferenceResolverState | undefined\n) {\n    if (node.length < 3) {\n        throw new Error(\"not enough arguments\");\n    }\n    if (node.length % 2) {\n        throw new Error(\"fallback is missing in 'case' expression\");\n    }\n    const branches: Array<[Expr, Expr]> = [];\n    for (let i = 1; i < node.length - 1; i += 2) {\n        const condition = parseNode(node[i], referenceResolverState);\n        const expr = parseNode(node[i + 1], referenceResolverState);\n        branches.push([condition, expr]);\n    }\n    const caseFallback = parseNode(node[node.length - 1], referenceResolverState);\n    return new CaseExpr(branches, caseFallback);\n}\n\nfunction isInterpolationMode(object: any): object is InterpolateMode {\n    if (!Array.isArray(object)) {\n        return false;\n    }\n    switch (object[0]) {\n        case \"discrete\":\n        case \"linear\":\n        case \"cubic\":\n        case \"exponential\":\n            return true;\n        default:\n            return false;\n    }\n}\n\nfunction parseInterpolateExpr(\n    node: JsonArray,\n    referenceResolverState: ReferenceResolverState | undefined\n) {\n    const mode: InterpolateMode = node[1] as any;\n    if (!isInterpolationMode(mode)) {\n        throw new Error(\"expected an interpolation type\");\n    }\n    if (mode[0] === \"exponential\" && typeof mode[1] !== \"number\") {\n        throw new Error(\"expected the base of the exponential interpolation\");\n    }\n    const input = node[2] ? parseNode(node[2], referenceResolverState) : undefined;\n    if (!Expr.isExpr(input)) {\n        throw new Error(`expected the input of the interpolation`);\n    }\n    if (node.length === 3 || !(node.length % 2)) {\n        throw new Error(\"invalid number of samples\");\n    }\n\n    const stops: Array<[number, Expr]> = [];\n    for (let i = 3; i < node.length - 1; i += 2) {\n        const key = node[i] as number;\n        const value = parseNode(node[i + 1], referenceResolverState);\n        stops.push([key, value]);\n    }\n    return new InterpolateExpr(mode, input, stops);\n}\n\nfunction parseStepExpr(\n    node: JsonArray,\n    referenceResolverState: ReferenceResolverState | undefined\n) {\n    if (node.length < 2) {\n        throw new Error(\"expected the input of the 'step' operator\");\n    }\n    if (node.length < 3 || !(node.length % 2)) {\n        throw new Error(\"not enough arguments\");\n    }\n    const input = parseNode(node[1], referenceResolverState);\n    const defaultValue = parseNode(node[2], referenceResolverState);\n    const stops: Array<[number, Expr]> = [];\n    for (let i = 3; i < node.length; i += 2) {\n        const key = node[i] as number;\n        const value = parseNode(node[i + 1], referenceResolverState);\n        stops.push([key, value]);\n    }\n    return new StepExpr(input, defaultValue, stops);\n}\n\nfunction makeCallExpr(\n    op: string,\n    node: any[],\n    referenceResolverState?: ReferenceResolverState\n): Expr {\n    return new CallExpr(\n        op,\n        node.slice(1).map(childExpr => parseNode(childExpr, referenceResolverState))\n    );\n}\n\nfunction resolveReference(node: JsonArray, referenceResolverState?: ReferenceResolverState) {\n    if (typeof node[1] !== \"string\") {\n        throw new Error(`expected the name of an attribute`);\n    }\n    if (referenceResolverState === undefined) {\n        throw new Error(`ref used with no definitions`);\n    }\n    const name = node[1] as string;\n\n    if (referenceResolverState.lockedNames.has(name)) {\n        throw new Error(`circular referene to '${name}'`);\n    }\n\n    if (!(name in referenceResolverState.definitions)) {\n        throw new Error(`definition '${name}' not found`);\n    }\n\n    const cachedEntry = referenceResolverState.cache.get(name);\n    if (cachedEntry !== undefined) {\n        return cachedEntry;\n    }\n    let definitionEntry = referenceResolverState.definitions[name] as any;\n    let result: Expr;\n    if (isLiteralDefinition(definitionEntry)) {\n        return Expr.fromJSON(definitionEntry);\n    } else if (isBoxedDefinition(definitionEntry)) {\n        if (isInterpolatedPropertyDefinition(definitionEntry.value)) {\n            // found a reference to an interpolation using\n            // the deprecated object-like syntax.\n            return Expr.fromJSON(interpolatedPropertyDefinitionToJsonExpr(definitionEntry.value));\n        } else if (isJsonExpr(definitionEntry.value)) {\n            definitionEntry = definitionEntry.value;\n        } else {\n            return Expr.fromJSON(definitionEntry.value);\n        }\n    }\n\n    if (isJsonExpr(definitionEntry)) {\n        referenceResolverState.lockedNames.add(name);\n        try {\n            result = parseNode(definitionEntry, referenceResolverState);\n        } finally {\n            referenceResolverState.lockedNames.delete(name);\n        }\n    } else {\n        throw new Error(`unsupported definition ${name}`);\n    }\n    referenceResolverState.cache.set(name, result);\n    return result;\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * SDF based text rendering for TypeScript.\n *\n * @remarks\n *\n * @packageDocumentation\n */\n\nexport * from \"./lib/rendering/FontCatalog\";\nexport * from \"./lib/rendering/GlyphData\";\nexport * from \"./lib/rendering/TextStyle\";\nexport * from \"./lib/rendering/TextBufferObject\";\nexport * from \"./lib/TextCanvas\";\n\nexport * from \"./lib/utils/ContextualArabicConverter\";\nexport * from \"./lib/utils/MaterialUtils\";\nexport * from \"./lib/utils/TypesettingUtils\";\nexport * from \"./lib/utils/UnicodeUtils\";\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeoCoordinatesLike, isGeoCoordinatesLike } from \"./GeoCoordinatesLike\";\nimport { GeoPointLike, isGeoPointLike } from \"./GeoPointLike\";\nimport { isLatLngLike, LatLngLike } from \"./LatLngLike\";\n\nimport * as THREE from \"three\";\n\n/**\n * Represents an object in different geo coordinate formats\n */\nexport type GeoCoordLike = GeoPointLike | GeoCoordinatesLike | LatLngLike;\n\n/**\n * `GeoCoordinates` is used to represent geo positions.\n */\nexport class GeoCoordinates implements GeoCoordinatesLike {\n    /**\n     * Returns a `GeoCoordinates` from the given latitude, longitude, and optional altitude.\n     *\n     * @param latitude - Latitude in degrees.\n     * @param longitude - Longitude in degrees.\n     * @param altitude - Altitude in meters.\n     */\n    static fromDegrees(latitude: number, longitude: number, altitude?: number): GeoCoordinates {\n        return new GeoCoordinates(latitude, longitude, altitude);\n    }\n\n    /**\n     * Returns a `GeoCoordinates` from the given latitude, longitude, and optional altitude.\n     *\n     * @param latitude - Latitude in radians.\n     * @param longitude - Longitude in radians.\n     * @param altitude - Altitude in meters.\n     */\n    static fromRadians(latitude: number, longitude: number, altitude?: number): GeoCoordinates {\n        return new GeoCoordinates(\n            THREE.MathUtils.radToDeg(latitude),\n            THREE.MathUtils.radToDeg(longitude),\n            altitude\n        );\n    }\n\n    /**\n     * Creates a {@link GeoCoordinates} from a {@link LatLngLike} literal.\n     * ```typescript\n     * const center = { lat: 53.3, lng: 13.4 };\n     * mapView.geoCenter = GeoCoordinates.fromLatLng(center);\n     * ```\n     * @param latLng - A {@link LatLngLike} object literal.\n     */\n    static fromLatLng(latLng: LatLngLike) {\n        return new GeoCoordinates(latLng.lat, latLng.lng);\n    }\n\n    /**\n     * Creates a {@link GeoCoordinates} from a [[GeoPointLike]] tuple.\n     *\n     * Example:\n     * ```typescript\n     * mapView.geoCenter = GeoCoordinates.fromGeoPoint([longitude, latitude]);\n     *\n     * let geoCoords: number[] = ...;\n     *\n     * if (isGeoPointLike(geoCoords)) {\n     *     const p = GeoCoordinates.fromGeoPoint(geoCoords);\n     * }\n     * ```\n     * @param geoPoint - An [[Array]] of at least two elements following the order\n     * longitude, latitude, altitude.\n     */\n    static fromGeoPoint(geoPoint: GeoPointLike): GeoCoordinates {\n        return new GeoCoordinates(geoPoint[1], geoPoint[0], geoPoint[2]);\n    }\n\n    /**\n     * Creates a {@link GeoCoordinates} from different types of geo coordinate objects.\n     *\n     * Example:\n     * ```typescript\n     * const fromGeoPointLike = GeoCoordinates.fromObject([longitude, latitude]);\n     * const fromGeoCoordinateLike = GeoCoordinates.fromObject({ longitude, latitude });\n     * const fromGeoCoordinate = GeoCoordinates.fromObject(new GeoCoordinates(latitude, longitude));\n     * const fromLatLngLike = GeoCoordinates.fromObject({ lat: latitude , lng: longitude });\n     * ```\n     *\n     * @param geoPoint - Either [[GeoPointLike]], {@link GeoCoordinatesLike}\n     * or {@link LatLngLike} object literal.\n     */\n    static fromObject(geoPoint: GeoCoordLike): GeoCoordinates {\n        if (isGeoPointLike(geoPoint)) {\n            return GeoCoordinates.fromGeoPoint(geoPoint);\n        } else if (isGeoCoordinatesLike(geoPoint)) {\n            return GeoCoordinates.fromDegrees(\n                geoPoint.latitude,\n                geoPoint.longitude,\n                geoPoint.altitude\n            );\n        } else if (isLatLngLike(geoPoint)) {\n            return GeoCoordinates.fromDegrees(geoPoint.lat, geoPoint.lng);\n        }\n\n        throw new Error(\"Invalid input coordinate format.\");\n    }\n\n    /**\n     * Creates a `GeoCoordinates` from the given latitude, longitude, and optional altitude.\n     *\n     * @param latitude - Latitude in degrees.\n     * @param longitude - Longitude in degrees.\n     * @param altitude - Altitude in meters.\n     */\n    constructor(public latitude: number, public longitude: number, public altitude?: number) {}\n\n    /**\n     * Returns the latitude in radians.\n     */\n    get latitudeInRadians(): number {\n        return THREE.MathUtils.degToRad(this.latitude);\n    }\n\n    /**\n     * Returns the longitude in radians.\n     */\n    get longitudeInRadians(): number {\n        return THREE.MathUtils.degToRad(this.longitude);\n    }\n\n    /**\n     * Returns the latitude in degrees.\n     * @deprecated Use the [[latitude]] property instead.\n     */\n    get latitudeInDegrees(): number {\n        return this.latitude;\n    } // compat api\n\n    /**\n     * Returns the longitude in degrees.\n     * @deprecated Use the [[longitude]] property instead.\n     */\n    get longitudeInDegrees(): number {\n        return this.longitude;\n    } // compat api\n\n    /**\n     * The latitude in the degrees.\n     */\n    get lat() {\n        return this.latitude;\n    }\n\n    /**\n     * The longitude in the degrees.\n     */\n    get lng() {\n        return this.longitude;\n    }\n\n    /**\n     * Returns `true` if this `GeoCoordinates` is valid; returns `false` otherwise.\n     */\n    isValid(): boolean {\n        return !isNaN(this.latitude) && !isNaN(this.longitude);\n    }\n\n    /**\n     * Returns the normalized `GeoCoordinates`.\n     */\n    normalized(): GeoCoordinates {\n        let { latitude, longitude } = this;\n\n        if (isNaN(latitude) || isNaN(longitude)) {\n            return this;\n        }\n\n        if (latitude > 90) {\n            let wrapped = (latitude + 90) % 360;\n            if (wrapped >= 180) {\n                longitude += 180;\n                wrapped = 360 - wrapped;\n            }\n\n            latitude = wrapped - 90;\n        }\n\n        if (latitude < -90) {\n            let wrapped = (latitude - 90) % 360;\n            if (wrapped <= -180) {\n                longitude += 180;\n                wrapped = -360 - wrapped;\n            }\n\n            latitude = wrapped + 90;\n        }\n\n        if (longitude < -180 || longitude > 180) {\n            const sign = Math.sign(longitude);\n            longitude = (((longitude % 360) + 180 * sign) % 360) - 180 * sign;\n        }\n\n        if (latitude === this.latitude && longitude === this.longitude) {\n            return this;\n        }\n\n        return new GeoCoordinates(latitude, longitude, this.altitude);\n    }\n\n    /**\n     * Returns `true` if this `GeoCoordinates` is equal to the other.\n     *\n     * @param other - GeoCoordinatesLike to compare to.\n     */\n    equals(other: GeoCoordinatesLike): boolean {\n        return (\n            this.latitude === other.latitude &&\n            this.longitude === other.longitude &&\n            this.altitude === other.altitude\n        );\n    }\n\n    /**\n     * Copy values from the other.\n     *\n     * @param other - GeoCoordinatesLike to copy all values from.\n     */\n    copy(other: GeoCoordinatesLike): GeoCoordinates {\n        this.latitude = other.latitude;\n        this.longitude = other.longitude;\n        this.altitude = other.altitude;\n        return this;\n    }\n\n    /**\n     * Clones this `GeoCoordinates`.\n     */\n    clone(): GeoCoordinates {\n        return new GeoCoordinates(this.latitude, this.longitude, this.altitude);\n    }\n\n    /**\n     * Returns this {@link GeoCoordinates} as {@link LatLngLike} literal.\n     */\n    toLatLng(): LatLngLike {\n        return { lat: this.latitude, lng: this.longitude };\n    }\n\n    /**\n     * Converts this {@link GeoCoordinates} to a [[GeoPointLike]].\n     */\n    toGeoPoint(): GeoPointLike {\n        return this.altitude !== undefined\n            ? [this.longitude, this.latitude, this.altitude]\n            : [this.longitude, this.latitude];\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Box3Like } from \"./Box3Like\";\nimport { Vector3Like } from \"./Vector3Like\";\n\nimport * as THREE from \"three\";\n\nexport namespace MathUtils {\n    /**\n     * Creates a new empty bounding box.\n     *\n     * @deprecated Use {@link https://threejs.org/docs/#api/en/math/Box3 | THREE.Box3} instead.\n     */\n    export function newEmptyBox3(): Box3Like {\n        return {\n            min: { x: Infinity, y: Infinity, z: Infinity },\n            max: { x: -Infinity, y: -Infinity, z: -Infinity }\n        };\n    }\n\n    /**\n     * Creates a new [Vector3Like] instance.\n     *\n     * @param x - The x component.\n     * @param y - The y component.\n     * @param z - The z component.\n     */\n    export function newVector3(x: number, y: number, z: number): Vector3Like;\n\n    /**\n     * Creates a new [Vector3Like] instance.\n     *\n     * @param x - The x component.\n     * @param y - The y component.\n     * @param z - The z component.\n     * @param v - The resulting [Vector3Like] instance.\n     */\n    export function newVector3<Vector extends Vector3Like>(\n        x: number,\n        y: number,\n        z: number,\n        v: Vector\n    ): Vector;\n\n    /**\n     * Set the components of the given [Vector3Like] instance.\n     *\n     * @param x - The x component.\n     * @param y - The y component.\n     * @param z - The z component.\n     * @param v - The [Vector3Like]\n     */\n    export function newVector3(x: number, y: number, z: number, v?: Vector3Like): Vector3Like {\n        if (v === undefined) {\n            return { x, y, z };\n        }\n        v.x = x;\n        v.y = y;\n        v.z = z;\n        return v;\n    }\n\n    /**\n     * Copies the vector across.\n     *\n     * @param from - The vector to copy from.\n     * @param to - The resulting [Vector3Like] instance, with the contents copied from from\n     */\n    export function copyVector3<Vector extends Vector3Like>(from: Vector3Like, to: Vector): Vector {\n        to.x = from.x;\n        to.y = from.y;\n        to.z = from.z;\n        return to;\n    }\n\n    /**\n     * Converts an angle measured in degrees to an equivalent value in radians.\n     *\n     * @param degrees - Value in degrees.\n     * @returns Value in radians.\n     * @deprecated use THREE.MathUtils.degToRad instead\n     */\n    export const degToRad = THREE.MathUtils.degToRad;\n\n    /**\n     * Converts an angle measured in radians to an equivalent value in degrees.\n     *\n     * @param degrees - Value in radians.\n     * @returns Value in degrees.\n     * @deprecated Use {@link https://threejs.org/docs/#api/en/math/MathUtils.radToDeg\n     *                | THREE.MathUtils.radToDeg}.\n     */\n    export const radToDeg = THREE.MathUtils.radToDeg;\n\n    /**\n     * Ensures that input value fits in a given range.\n     *\n     * @param value - The value to be clamped.\n     * @param min - Minimum value.\n     * @param max - Maximum value.\n     * @returns Clamped value.\n     * @deprecated Use {@link https://threejs.org/docs/#api/en/math/MathUtils.clamp\n     *                | THREE.MathUtils.clamp}.\n     */\n    export const clamp = THREE.MathUtils.clamp;\n\n    /**\n     * Normalize angle in degrees to range `[0, 360)`.\n     *\n     * @param a - Angle in degrees.\n     * @returns Angle in degrees in range `[0, 360)`.\n     */\n    export function normalizeAngleDeg(a: number): number {\n        a = a % 360;\n        if (a < 0) {\n            a = a + 360;\n        }\n        return a;\n    }\n\n    /**\n     * Normalize latitude angle in degrees to range `[-180, 180]`.\n     *\n     * @param a - Latitude angle in degrees.\n     * @returns Latitude angle in degrees in range `[-180, 180]`.\n     */\n    export function normalizeLongitudeDeg(a: number): number {\n        a = normalizeAngleDeg(a);\n        if (a > 180) {\n            a = a - 360;\n        }\n        return a;\n    }\n\n    /**\n     * Return the minimal delta between angles `a` and `b` given in degrees.\n     *\n     * Equivalent to `a - b` in coordinate space with exception vector direction can be reversed\n     * that if `abs(a-b) > 180` because trip is shorter in 'other' direction.\n     *\n     * Useful when interpolating between `b` and `a` in angle space.\n     *\n     * @param a - Start angle in degrees.\n     * @param b - End angle in degrees.\n     * @returns Angle that that satisfies condition `a - b - d = 0` in angle space.\n     */\n    export function angleDistanceDeg(a: number, b: number): number {\n        a = normalizeAngleDeg(a);\n        b = normalizeAngleDeg(b);\n\n        const d = a - b;\n        if (d > 180) {\n            return d - 360;\n        } else if (d <= -180) {\n            return d + 360;\n        } else {\n            return d;\n        }\n    }\n\n    /**\n     * Interpolate linearly between two angles given in degrees.\n     *\n     * @param p0 - Angle from in degrees\n     * @param p1 - Angle to in degrees\n     * @param t - Interpolation factor (alpha), in range `0-1`.\n     */\n    export function interpolateAnglesDeg(p0: number, p1: number, t: number): number {\n        // hand crafted version,\n        // see stack for maybe better versions:\n        //    https://stackoverflow.com/questions/2708476/rotation-interpolation\n\n        const d = angleDistanceDeg(p1, p0);\n        const r = (p0 + d * t) % 360;\n        return r;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { assert } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\n/**\n * Values for boolean shader defines\n */\nexport const DEFINE_BOOL_TRUE = \"\";\nexport const DEFINE_BOOL_FALSE = undefined;\n\n/**\n * Insert shader includes after another shader include.\n *\n * @param shaderContent - Original string.\n * @param shaderName - String to append to.\n * @param insertedShaderName - String to append after string `shaderA`.\n * @param addTab - If `true`, a tab character will be inserted before `shaderB`.\n */\nexport function insertShaderInclude(\n    shaderContent: string,\n    shaderName: string,\n    insertedShaderName: string,\n    addTab?: boolean\n): string {\n    const tabChar = addTab === true ? \"\\t\" : \"\";\n\n    const result = shaderContent.replace(\n        `#include <${shaderName}>`,\n        `#include <${shaderName}>\n${tabChar}#include <${insertedShaderName}>`\n    );\n    return result;\n}\n\nexport interface ForcedBlending {\n    /**\n     * This material has `blending` always enabled regardless of `opacity` setting.s\n     */\n    forcedBlending?: true;\n}\n\n/**\n * THREE.js is enabling blending only when transparent is `true` or when a blend mode\n * different than `NormalBlending` is set.\n * Since we don't want to set transparent to true and mess up the render order we set\n * `CustomBlending` with the same parameters as the `NormalBlending`.\n\n * @param material - `Material` that should use blending\n * @note This function should not be used in frame update after material has been passed to WebGL.\n * In such cases use [[enableBlending]] instead.\n */\nexport function enforceBlending(\n    material: (THREE.Material | THREE.ShaderMaterialParameters) & ForcedBlending\n) {\n    if (material.transparent) {\n        // Nothing to do\n        return;\n    }\n\n    enableBlending(material);\n    material.forcedBlending = true;\n}\n\n/**\n * Enable alpha blending using THREE.CustomBlending setup.\n *\n * Function enables blending using one of predefined modes, for both color and alpha components:\n * - Src: [[THREE.SrcAlphaFactor]], Dst: [[THREE.OneMinusSrcAlphaFactor]]\n * - Src: [[THREE.OneFactor]], Dst: [[THREE.OneMinusSrcAlphaFactor]]\n * The second blending equation is used when [[THREE.Material.premultipliedAlpha]] is enabled\n * for this material.\n * @note Blending mode change does not require material update.\n * @see THREE.Material.needsUpdate.\n * @param material - The material or material parameters to modify.\n */\nexport function enableBlending(\n    material: (THREE.Material | THREE.ShaderMaterialParameters) & ForcedBlending\n) {\n    if (material.transparent || material.forcedBlending) {\n        // Nothing to do\n        return;\n    }\n\n    material.blending = THREE.CustomBlending;\n    if (material.premultipliedAlpha === true) {\n        material.blendSrc = THREE.OneFactor;\n        material.blendDst = THREE.OneMinusSrcAlphaFactor;\n        material.blendSrcAlpha = THREE.OneFactor;\n        material.blendDstAlpha = THREE.OneMinusSrcAlphaFactor;\n    } else {\n        material.blendSrc = THREE.SrcAlphaFactor;\n        material.blendDst = THREE.OneMinusSrcAlphaFactor;\n        material.blendSrcAlpha = THREE.OneFactor;\n        material.blendDstAlpha = THREE.OneMinusSrcAlphaFactor;\n    }\n}\n\n/**\n * Disable alpha blending using THREE.CustomBlending mode, switches to [[THREE.NormalBlending]].\n *\n * @note Blending mode change does not require material update.\n * @see THREE.Material.needsUpdate.\n * @see enableBlending.\n * @param material - The material or material parameters to modify.\n */\nexport function disableBlending(\n    material: (THREE.Material | THREE.ShaderMaterialParameters) & ForcedBlending\n) {\n    if (material.transparent || material.forcedBlending) {\n        // Nothing to do\n        return;\n    }\n\n    material.blending = THREE.NormalBlending;\n}\n\n/**\n * Setup material shader _define_ using two allowable semantics.\n *\n * Function accepts two types of values for shader preprocessor _define_:\n * - [[boolean]], simple [[true]] or [[false]] which causes _define_ to be set with empty string,\n * such defines may be handled in the shader using __#ifdef__ semantics:\n * ```\n * #ifdef SOME_DEFINE && !defined(OTHER_DEFINE)\n * // do something\n * #endif\n * ```\n *\n * - [[number]] which sets _define_ to explicit value. You may use it to enable/disable some\n * code or even set compile time constants affecting shaders math:\n * ```\n * #if SOME_DEFINE_SWITCH && OTHER_DEFINE_SWITCH == 0\n * gl_FragColor = vec4(1, 1, 1, DEFINE_ALPHA)\n * #endif\n * ```\n * @note Setting _define_ with `false` value is not the same as setting is with number value of `0`.\n *\n * @param material - The [[THREE.ShaderMaterial]] which shader _define_ will be set.\n * @param key - Name of shader _define_ as used in shader, i.e. `USE_FOG`, `COLOR_ALPHA`, etc.\n * @param value - The value to be set as number or boolean specifying if preprocessor define\n * should be defined or not.\n * @returns [[true]] if material has been forced to update (re-compile) due to define changes,\n * return [[false]] whenever define has not been changed.\n */\nexport function setShaderMaterialDefine(\n    material: THREE.ShaderMaterial,\n    key: string,\n    value: boolean | number\n): boolean {\n    assert(\n        material.defines !== undefined,\n        \"Do not use this function in ShaderMaterial derived c-tor.\"\n    );\n    const semanticValue = getShaderMaterialDefine(material, key);\n    const needsUpdate = value !== semanticValue;\n    // Nothing to change - early exit\n    if (!needsUpdate) {\n        return false;\n    }\n    setShaderDefine(material.defines, key, value);\n    material.needsUpdate = needsUpdate;\n    return true;\n}\n\n/**\n * Acquire value of [[THREE.ShaderMaterial]] GPU shader preprocessor define.\n *\n * The semantic used in entire engine assumes that preprocessor defines may have only binary\n * (defined / not defined) or numerical values, this ensures consistency in the shaders and\n * materials code.\n * @note If _define_ with [[key]] is _undefined_ function returns [[false]], if defined but\n * not numerical value it returns [[true]], otherwise returns number.\n * @see setShaderMaterialDefine.\n *\n * @param material - The material which shader defines are accessed.\n * @param key - The _define_ name (identifier).\n * @param fallbackValue - The value returned when material `defines` are not initialized yet,\n * specified by default as [[false]], provide your own default if you expect numeric value.\n */\nexport function getShaderMaterialDefine(\n    material: THREE.ShaderMaterial,\n    key: string,\n    fallbackValue: boolean | number = false\n): boolean | number {\n    if (material.defines === undefined) {\n        return fallbackValue;\n    }\n    return getShaderDefine(material.defines, key);\n}\n\n/**\n * Sets new value of 'define' regardless of current value set.\n *\n * Update `defines` map with new key and value, if key is already occupied it overrides its value.\n * Helper function that may be used to setup [[THREE.ShaderMaterialParameters]] before\n * material is create (i.e. in c-tor).\n *\n * @param defines - Shader `defines` stored in key-value map.\n * @param key - The key used to identify _define_.\n * @param value - The value to be stored.\n * @returns [[true]] if define has actually changed, false is stayed the same.\n * @see setShaderMaterialDefine.\n */\nexport function setShaderDefine(\n    defines: { [key: string]: any },\n    key: string,\n    value: boolean | number\n): boolean {\n    let updated = false;\n    if (typeof value === \"number\") {\n        updated = defines[key] !== value;\n        defines[key] = value;\n    } else if (value === true) {\n        updated = defines[key] !== DEFINE_BOOL_TRUE;\n        defines[key] = DEFINE_BOOL_TRUE;\n    } else if (value === false && defines[key] !== undefined) {\n        // Sets to DEFINE_BOOL_FALSE === undefined\n        delete defines[key];\n        updated = true;\n    }\n    return updated;\n}\n\n/**\n * Acquire shader 'define' value from `defines` map.\n *\n * If there is no value under [[key]] specified, function returns false, otherwise result is\n * true or numeric value if there is a number stored.\n * @param defines - The `defines` map.\n * @param key - The identifier of the _define_.\n */\nexport function getShaderDefine(defines: { [key: string]: any }, key: string): boolean | number {\n    const currentValue = defines[key];\n    const semanticValue =\n        currentValue === DEFINE_BOOL_FALSE\n            ? false\n            : currentValue === DEFINE_BOOL_TRUE\n            ? true\n            : currentValue;\n    return semanticValue;\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport {\n    GeoBox,\n    GeoCoordinates,\n    GeoCoordLike,\n    MathUtils,\n    Projection,\n    ProjectionType,\n    TileKey\n} from \"@here/harp-geoutils\";\nimport { EarthConstants } from \"@here/harp-geoutils/lib/projection/EarthConstants\";\nimport { MapMeshBasicMaterial, MapMeshStandardMaterial } from \"@here/harp-materials\";\nimport { assert, LoggerManager } from \"@here/harp-utils\";\nimport { ElevationProvider } from \"./ElevationProvider\";\nimport { LodMesh } from \"./geometry/LodMesh\";\nimport { MapView } from \"./MapView\";\nimport { getFeatureDataSize, TileFeatureData } from \"./Tile\";\n\nconst logger = LoggerManager.instance.create(\"MapViewUtils\");\n\n// Estimation of the size of an Object3D with all the simple properties, like matrices and flags.\n// There may be cases where it is possible to construct Object3Ds with considerable less memory\n// consumption, but this value is used to simplify the estimation.\nconst MINIMUM_OBJECT3D_SIZE_ESTIMATION = 1000;\n\nconst MINIMUM_ATTRIBUTE_SIZE_ESTIMATION = 56;\n\n/**\n * Zoom level to request terrain tiles for getting the height of the camera above terrain.\n */\nconst TERRAIN_ZOOM_LEVEL = 4;\n\n// Caching those for performance reasons.\nconst groundNormalPlanarProj = new THREE.Vector3(0, 0, 1);\nconst groundPlane = new THREE.Plane(groundNormalPlanarProj.clone());\nconst groundSphere = new THREE.Sphere(undefined, EarthConstants.EQUATORIAL_RADIUS);\nconst rayCaster = new THREE.Raycaster();\nconst epsilon = 1e-5;\n\n/**\n * Cached ThreeJS instances for realtime maths.\n */\nconst space = {\n    x: new THREE.Vector3(),\n    y: new THREE.Vector3(),\n    z: new THREE.Vector3()\n};\nconst tangentSpace = {\n    x: new THREE.Vector3(),\n    y: new THREE.Vector3(),\n    z: new THREE.Vector3()\n};\nconst cache = {\n    quaternions: [new THREE.Quaternion(), new THREE.Quaternion()],\n    vector3: [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()],\n    matrix4: [new THREE.Matrix4(), new THREE.Matrix4()],\n    transforms: [\n        {\n            xAxis: new THREE.Vector3(),\n            yAxis: new THREE.Vector3(),\n            zAxis: new THREE.Vector3(),\n            position: new THREE.Vector3()\n        }\n    ]\n};\n\n/**\n * Rounds a given zoom level up to the nearest integer value if it's close enough.\n *\n * The zoom level set in {@link MapView} after a zoom level\n * target is given to {@link (MapView.lookAt:WITH_PARAMS)} or\n * {@link @here/harp-map-controls#MapControls} never matches\n * exactly the target due to the precision loss caused by the\n * conversion from zoom level to camera distance (done in\n * {@link (MapView.lookAt:WITH_PARAMS)} and {@link @here/harp-map-controls#MapControls})\n * and from distance back to zoom level (done at every frame on camera update).\n * As a result, given a fixed integer zoom level input, the final zoom level computed at every frame\n * may fall sometimes below the integer value and others above. This causes flickering since each\n * frame will use different tile levels and different style evaluations for object visibility.\n * See HARP-9673 and HARP-8523.\n * @param zoomLevel - Input zoom level\n * @return The ceiling zoom level if input zoom level is close enough, otherwise the unmodified\n * input zoom level.\n */\nfunction snapToCeilingZoomLevel(zoomLevel: number) {\n    const eps = 1e-6;\n    const ceiling = Math.ceil(zoomLevel);\n    return ceiling - zoomLevel < eps ? ceiling : zoomLevel;\n}\n\nexport namespace MapViewUtils {\n    export const MAX_TILT_DEG = 89;\n    export const MAX_TILT_RAD = MAX_TILT_DEG * THREE.MathUtils.DEG2RAD;\n\n    /**\n     * The anti clockwise rotation of an object along the axes of its tangent space, with itself\n     * as origin.\n     */\n    export interface Attitude {\n        /**\n         * Rotation of the object along its vertical axis.\n         */\n        yaw: number;\n\n        /**\n         * Rotation of the object along its horizontal axis.\n         */\n        pitch: number;\n\n        /**\n         * Rotation of the object along its forward axis.\n         */\n        roll: number;\n    }\n\n    /**\n     * Describes estimated usage of memory on heap and GPU.\n     */\n    export interface MemoryUsage {\n        heapSize: number;\n        gpuSize: number;\n    }\n\n    /**\n     * Zooms and moves the map in such a way that the given target position remains at the same\n     * position after the zoom.\n     *\n     * @param mapView - Instance of MapView.\n     * @param targetNDCx - Target x position in NDC space.\n     * @param targetNDCy - Target y position in NDC space.\n     * @param zoomLevel - The desired zoom level.\n     * @param maxTiltAngle - The maximum tilt angle to comply by, in globe projection, in radian.\n     */\n    export function zoomOnTargetPosition(\n        mapView: MapView,\n        targetNDCx: number,\n        targetNDCy: number,\n        zoomLevel: number,\n        maxTiltAngle: number = MAX_TILT_RAD\n    ): void {\n        const { elevationProvider, camera } = mapView;\n\n        // Use for now elevation at camera position. See getTargetAndDistance.\n        const elevation = elevationProvider\n            ? elevationProvider.getHeight(\n                  mapView.projection.unprojectPoint(camera.position),\n                  TERRAIN_ZOOM_LEVEL\n              )\n            : undefined;\n\n        // Get current target position in world space before we zoom.\n        const worldTarget = rayCastWorldCoordinates(mapView, targetNDCx, targetNDCy, elevation);\n        const groundDistance = calculateDistanceToGroundFromZoomLevel(mapView, zoomLevel);\n        const cameraHeight = groundDistance + (elevation ?? 0);\n\n        // Set the cameras height according to the given zoom level.\n        if (mapView.projection.type === ProjectionType.Planar) {\n            camera.position.setZ(cameraHeight);\n        } else if (mapView.projection.type === ProjectionType.Spherical) {\n            camera.position.setLength(EarthConstants.EQUATORIAL_RADIUS + cameraHeight);\n        }\n\n        // In sphere, we may have to also orbit the camera around the position located at the\n        // center of the screen, in order to limit the tilt to `maxTiltAngle`, as we change\n        // this tilt by changing the camera's height above.\n        if (mapView.projection.type === ProjectionType.Spherical) {\n            // FIXME: We cannot use mapView.tilt here b/c it does not reflect the latest camera\n            // changes.\n            // tslint:disable-next-line: deprecation\n            const tilt = extractCameraTilt(camera, mapView.projection);\n            const deltaTilt = tilt - maxTiltAngle;\n            if (deltaTilt > 0) {\n                orbitFocusPoint(mapView, 0, deltaTilt, maxTiltAngle);\n            }\n        }\n\n        // Get new target position after the zoom\n        const newWorldTarget = rayCastWorldCoordinates(mapView, targetNDCx, targetNDCy, elevation);\n        if (!worldTarget || !newWorldTarget) {\n            return;\n        }\n\n        if (mapView.projection.type === ProjectionType.Planar) {\n            // Calculate the difference and pan the map to maintain the map relative to the target\n            // position.\n            worldTarget.sub(newWorldTarget);\n            panCameraAboveFlatMap(mapView, worldTarget.x, worldTarget.y);\n        } else if (mapView.projection.type === ProjectionType.Spherical) {\n            panCameraAroundGlobe(mapView, worldTarget, newWorldTarget);\n        }\n    }\n\n    /**\n     * Orbits the camera around the focus point of the camera.\n     *\n     * @param mapView - The {@link MapView} instance to manipulate.\n     * @param deltaAzimuthDeg - Delta azimuth in degrees.\n     * @param deltaTiltDeg - Delta tilt in degrees.\n     * @param maxTiltAngleRad - The maximum tilt between the camera and its target in radian.\n     */\n    export function orbitFocusPoint(\n        mapView: MapView,\n        deltaAzimuthDeg: number,\n        deltaTiltDeg: number,\n        maxTiltAngleRad = MAX_TILT_RAD\n    ) {\n        const target = mapView.target;\n        const sphericalCoordinates = extractSphericalCoordinatesFromLocation(\n            mapView,\n            mapView.camera,\n            target\n        );\n        const tilt = Math.max(\n            Math.min(\n                THREE.MathUtils.radToDeg(maxTiltAngleRad),\n                deltaTiltDeg + THREE.MathUtils.radToDeg(sphericalCoordinates.tilt)\n            ),\n            0\n        );\n        const heading =\n            THREE.MathUtils.radToDeg(sphericalCoordinates.azimuth + Math.PI) + deltaAzimuthDeg;\n        mapView.lookAt({\n            target,\n            distance: mapView.targetDistance,\n            tilt,\n            heading\n        });\n    }\n\n    /**\n     * Calculate target (focus) point geo-coordinates for given camera.\n     * @see getTargetPositionFromCamera\n     *\n     * @param camera - The camera looking on target point.\n     * @param projection - The geo-projection used.\n     * @param elevation - Optional elevation above (or below) sea level measured in world units.\n     *\n     * @deprecated This function is for internal use only and will be removed in the future. Use\n     * MapView.worldTarget instead.\n     */\n    export function getGeoTargetFromCamera(\n        camera: THREE.Camera,\n        projection: Projection,\n        elevation?: number\n    ): GeoCoordinates | null {\n        // This function does almost the same as:\n        // rayCastGeoCoordinates(mapView, 0, 0)\n        // but in more gentle and performance wise manner\n        // tslint:disable-next-line: deprecation\n        const targetWorldPos = getWorldTargetFromCamera(camera, projection, elevation);\n        if (targetWorldPos !== null) {\n            return projection.unprojectPoint(targetWorldPos);\n        }\n        return null;\n    }\n\n    /**\n     * Calculate target (focus) point world coordinates for given camera position and orientation.\n     * @param camera - The camera looking on target point.\n     * @param projection - The geo-projection used.\n     * @param elevation - Optional elevation above (or below) sea level in world units.\n     *\n     * @deprecated This function is for internal use only and will be removed in the future.\n     */\n    export function getWorldTargetFromCamera(\n        camera: THREE.Camera,\n        projection: Projection,\n        elevation?: number\n    ): THREE.Vector3 | null {\n        const cameraPos = cache.vector3[0].copy(camera.position);\n        const cameraLookAt = camera.getWorldDirection(cache.vector3[1]);\n        rayCaster.set(cameraPos, cameraLookAt);\n        if (elevation !== undefined) {\n            groundPlane.constant -= elevation;\n            groundSphere.radius += elevation;\n        }\n        const targetWorldPos = new THREE.Vector3();\n        const result =\n            projection.type === ProjectionType.Planar\n                ? rayCaster.ray.intersectPlane(groundPlane, targetWorldPos)\n                : rayCaster.ray.intersectSphere(groundSphere, targetWorldPos);\n        if (elevation !== undefined) {\n            groundPlane.constant = 0;\n            groundSphere.radius = EarthConstants.EQUATORIAL_RADIUS;\n        }\n        return result;\n    }\n\n    /**\n     * Returns the height of the camera above the earths surface.\n     *\n     * If there is an ElevationProvider, this is used. Otherwise the projection is used to determine\n     * how high the camera is above the surface.\n     *\n     * @param level - Which level to request the surface height from.\n     * @return Height in world units.\n     */\n    function getHeightAboveTerrain(\n        location: THREE.Vector3,\n        projection: Projection,\n        elevationProvider?: ElevationProvider,\n        level?: number\n    ): number {\n        if (elevationProvider !== undefined) {\n            const geoLocation = projection.unprojectPoint(location);\n            const heightAboveTerrain = elevationProvider.getHeight(geoLocation, level);\n            if (heightAboveTerrain !== undefined) {\n                const height = projection.unprojectAltitude(location) - heightAboveTerrain;\n                return Math.max(height, 1);\n            }\n        }\n        return Math.abs(projection.groundDistance(location));\n    }\n\n    /**\n     * @internal\n     * @deprecated This method will be moved to MapView.\n     */\n    export function getTargetAndDistance(\n        projection: Projection,\n        camera: THREE.Camera,\n        elevationProvider?: ElevationProvider\n    ): { target: THREE.Vector3; distance: number } {\n        const cameraPitch = extractAttitude({ projection }, camera).pitch;\n\n        //FIXME: For now we keep the old behaviour when terrain is enabled (i.e. use the camera\n        //       height above terrain to deduce the target distance).\n        //       This leads to zoomlevel changes while panning. We have to find a proper solution\n        //       for terrain (e.g. raycast with the ground surfcae that is elevated by the average\n        //       elevation in the scene)\n        const elevation = elevationProvider\n            ? elevationProvider.getHeight(\n                  projection.unprojectPoint(camera.position),\n                  TERRAIN_ZOOM_LEVEL\n              )\n            : undefined;\n\n        // Even for a tilt of 90 raycastTargetFromCamera is returning some point almost at\n        // infinity.\n        const target =\n            cameraPitch < MAX_TILT_RAD\n                ? // tslint:disable-next-line: deprecation\n                  getWorldTargetFromCamera(camera, projection, elevation)\n                : null;\n        if (target !== null) {\n            const distance = camera.position.distanceTo(target);\n            return { target, distance };\n        } else {\n            // We either reached the [[PITCH_LIMIT]] or we did not hit the ground surface.\n            // In this case we do the reverse, i.e. compute some fallback distance and\n            // use it to compute the tagret point by using the camera direction.\n            const cameraPosZ = getHeightAboveTerrain(\n                camera.position,\n                projection,\n                elevationProvider,\n                TERRAIN_ZOOM_LEVEL\n            );\n\n            //For flat projection we fallback to the target distance at 89 degree pitch.\n            //For spherical projection we fallback to the tangent line distance\n            const distance =\n                projection.type === ProjectionType.Planar\n                    ? cameraPosZ / Math.cos(Math.min(cameraPitch, MAX_TILT_RAD))\n                    : Math.sqrt(\n                          Math.pow(cameraPosZ + EarthConstants.EQUATORIAL_RADIUS, 2) -\n                              Math.pow(EarthConstants.EQUATORIAL_RADIUS, 2)\n                      );\n            const cameraDir = camera.getWorldDirection(cache.vector3[0]);\n            cameraDir.multiplyScalar(distance);\n            const fallbackTarget = cache.vector3[1];\n            fallbackTarget.copy(camera.position).add(cameraDir);\n            return { target: fallbackTarget, distance };\n        }\n    }\n\n    /**\n     * Returns the {@link @here/harp-geoutils#GeoCoordinates} of the camera,\n     * given its target coordinates on the map and its\n     * zoom, yaw and pitch.\n     *\n     * @param targetCoordinates - Coordinates of the center of the view.\n     * @param distance - Distance to the target in meters.\n     * @param yawDeg - Camera yaw in degrees.\n     * @param pitchDeg - Camera pitch in degrees.\n     * @param projection - Active MapView, needed to get the camera fov and map projection.\n     * @param result - Optional output vector.\n     * @returns Camera position in world space.\n     */\n    export function getCameraPositionFromTargetCoordinates(\n        targetCoordinates: GeoCoordinates,\n        distance: number,\n        yawDeg: number,\n        pitchDeg: number,\n        projection: Projection,\n        result: THREE.Vector3 = new THREE.Vector3()\n    ): THREE.Vector3 {\n        const pitchRad = THREE.MathUtils.degToRad(pitchDeg);\n        const altitude = Math.cos(pitchRad) * distance;\n        const yawRad = THREE.MathUtils.degToRad(yawDeg);\n        projection.projectPoint(targetCoordinates, result);\n        const groundDistance = distance * Math.sin(pitchRad);\n        if (projection.type === ProjectionType.Planar) {\n            result.x = result.x + Math.sin(yawRad) * groundDistance;\n            result.y = result.y - Math.cos(yawRad) * groundDistance;\n            result.z = result.z + altitude;\n        } else if (projection.type === ProjectionType.Spherical) {\n            // In globe yaw and pitch are understood to be in tangent space. The approach below is\n            // to find the Z and Y tangent space axes, then rotate Y around Z by the given yaw, and\n            // set its new length (groundDistance). Finally the up vector's length is set to the\n            // camera height and added to the transformed Y above.\n\n            // Get the Z axis in tangent space: it is the normalized position vector of the target.\n            tangentSpace.z.copy(result).normalize();\n\n            // Get the Y axis (north axis in tangent space):\n            tangentSpace.y\n                .set(0, 0, 1)\n                .projectOnPlane(tangentSpace.z)\n                .normalize();\n\n            // Rotate this north axis by the given yaw, giving the camera direction relative to\n            // the target.\n            cache.quaternions[0].setFromAxisAngle(tangentSpace.z, yawRad - Math.PI);\n            tangentSpace.y.applyQuaternion(cache.quaternions[0]);\n\n            // Push the camera to the specified distance.\n            tangentSpace.y.setLength(groundDistance);\n\n            // Now get the actual camera position vector: from the target position, add the\n            // previous computation to get the projection of the camera on the ground, then add\n            // the height of the camera in the tangent space.\n            const height = distance * Math.cos(pitchRad);\n            result.add(tangentSpace.y).add(tangentSpace.z.setLength(height));\n\n            const a = EarthConstants.EQUATORIAL_RADIUS + altitude;\n            const b = Math.sin(pitchRad) * distance;\n            const cameraHeight = Math.sqrt(a * a + b * b);\n            result.setLength(cameraHeight);\n        }\n\n        return result;\n    }\n\n    /**\n     * @hidden\n     * @internal\n     *\n     * Add offset to geo points for minimal view box in flat projection with tile wrapping.\n     *\n     * In flat projection, with wrap around enabled, we should detect clusters of points around that\n     * wrap antimeridian.\n     *\n     * Here, we fit points into minimal geo box taking world wrapping into account.\n     */\n    export function wrapGeoPointsToScreen(\n        points: GeoCoordLike[],\n        startPosition?: GeoCoordinates\n    ): GeoCoordinates[] {\n        let startIndex = 0;\n        if (startPosition === undefined) {\n            startPosition = GeoCoordinates.fromObject(points[0]);\n            startIndex = 1;\n        }\n        let north = startPosition.latitude;\n        let south = startPosition.latitude;\n        let lonCenter = MathUtils.normalizeLongitudeDeg(startPosition.longitude);\n        let lonSpan = 0;\n        let east = startPosition.longitude;\n        let west = startPosition.longitude;\n\n        const result: GeoCoordinates[] = [];\n        result.push(new GeoCoordinates(north, lonCenter));\n        for (let i = startIndex; i < points.length; i++) {\n            const p = GeoCoordinates.fromObject(points[i]);\n            if (p.latitude > north) {\n                north = p.latitude;\n            } else if (p.latitude < south) {\n                south = p.latitude;\n            }\n\n            let longitude = MathUtils.normalizeLongitudeDeg(p.longitude);\n\n            const relToCenter = MathUtils.angleDistanceDeg(lonCenter, longitude);\n            longitude = lonCenter - relToCenter;\n            if (relToCenter < 0 && -relToCenter > lonSpan / 2) {\n                east = Math.max(east, lonCenter - relToCenter);\n                lonSpan = east - west;\n                lonCenter = (east + west) / 2;\n            } else if (relToCenter > 0 && relToCenter > lonSpan / 2) {\n                west = Math.min(west, longitude);\n                lonSpan = east - west;\n                lonCenter = (east + west) / 2;\n            }\n            result.push(new GeoCoordinates(p.latitude, longitude));\n        }\n        return result;\n    }\n\n    /**\n     * @hidden\n     * @internal\n     *\n     * Given `cameraPos`, force all points that lie on non-visible sphere half to be \"near\" max\n     * possible viewable circle from given camera position.\n     *\n     * Assumes that shpere projection with world center is in `(0, 0, 0)`.\n     */\n    export function wrapWorldPointsToView(points: THREE.Vector3[], cameraPos: THREE.Vector3) {\n        const cameraPosNormalized = cameraPos.clone().normalize();\n        for (const point of points) {\n            if (point.angleTo(cameraPos) > Math.PI / 2) {\n                // Point is on other side of sphere, we \"clamp it to\" max possible viewable circle\n                // from given camera position\n\n                const pointLen = point.length();\n\n                point.projectOnPlane(cameraPosNormalized).setLength(pointLen);\n            }\n        }\n    }\n\n    /**\n     * @hidden\n     * @internal\n     *\n     * Return [[GeoPoints]] bounding {@link @here/harp-geoutils#GeoBox}\n     * applicable for [[getFitBoundsDistance]].\n     *\n     * @returns {@link @here/harp-geoutils#GeoCoordinates} set that covers `box`\n     */\n    export function geoBoxToGeoPoints(box: GeoBox): GeoCoordinates[] {\n        const center = box.center;\n        return [\n            new GeoCoordinates(box.north, box.west),\n            new GeoCoordinates(box.north, box.east),\n            new GeoCoordinates(center.latitude, box.west),\n            new GeoCoordinates(center.latitude, box.east),\n            new GeoCoordinates(box.south, box.west),\n            new GeoCoordinates(box.south, box.east),\n            new GeoCoordinates(box.north, center.longitude),\n            new GeoCoordinates(box.south, center.longitude)\n        ];\n    }\n\n    /**\n     * @hidden\n     * @internal\n     *\n     * Get minimal distance required for `camera` looking at `worldTarget` to cover `points`.\n     *\n     * All dimensions belong to world space.\n     *\n     * @param points - points which shall are to be covered by view\n     *\n     * @param worldTarget - readonly, world target of {@link MapView}\n     * @param camera - readonly, camera with proper `position` and rotation set\n     * @returns new distance to camera to be used with {@link (MapView.lookAt:WITH_PARAMS)}\n     */\n    export function getFitBoundsDistance(\n        points: THREE.Vector3[],\n        worldTarget: THREE.Vector3,\n        camera: THREE.PerspectiveCamera\n    ): number {\n        const cameraRotationMatrix = new THREE.Matrix4();\n        cameraRotationMatrix.extractRotation(camera.matrixWorld);\n        const screenUpVector = new THREE.Vector3(0, 1, 0).applyMatrix4(cameraRotationMatrix);\n        const screenSideVector = new THREE.Vector3(1, 0, 0).applyMatrix4(cameraRotationMatrix);\n        const screenVertMidPlane = new THREE.Plane().setFromCoplanarPoints(\n            camera.position,\n            worldTarget,\n            worldTarget.clone().add(screenUpVector)\n        );\n        const screenHorzMidPlane = new THREE.Plane().setFromCoplanarPoints(\n            camera.position,\n            worldTarget,\n            worldTarget.clone().add(screenSideVector)\n        );\n\n        const cameraPos = cache.vector3[0];\n        cameraPos.copy(camera.position);\n\n        const halfVertFov = THREE.MathUtils.degToRad(camera.fov / 2);\n        const halfHorzFov = THREE.MathUtils.degToRad((camera.fov / 2) * camera.aspect);\n\n        // tan(fov/2)\n        const halfVertFovTan = 1 / Math.tan(halfVertFov);\n        const halfHorzFovTan = 1 / Math.tan(halfHorzFov);\n\n        const cameraToTarget = cache.vector3[1];\n        cameraToTarget\n            .copy(cameraPos)\n            .sub(worldTarget)\n            .negate();\n\n        const cameraToTargetNormalized = new THREE.Vector3().copy(cameraToTarget).normalize();\n\n        const offsetVector = new THREE.Vector3();\n\n        const cameraToPointOnRefPlane = new THREE.Vector3();\n        const pointOnRefPlane = new THREE.Vector3();\n\n        function checkAngle(\n            point: THREE.Vector3,\n            referencePlane: THREE.Plane,\n            maxAngle: number,\n            fovFactor: number\n        ) {\n            referencePlane.projectPoint(point, pointOnRefPlane);\n            cameraToPointOnRefPlane\n                .copy(cameraPos)\n                .sub(pointOnRefPlane)\n                .negate();\n\n            const viewAngle = cameraToTarget.angleTo(cameraToPointOnRefPlane);\n\n            if (viewAngle <= maxAngle) {\n                return;\n            }\n\n            const cameraToPointLen = cameraToPointOnRefPlane.length();\n            const cameraToTargetLen = cameraToTarget.length();\n\n            const newCameraDistance =\n                cameraToPointLen * (Math.sin(viewAngle) * fovFactor - Math.cos(viewAngle)) +\n                cameraToTargetLen;\n\n            offsetVector\n                .copy(cameraToTargetNormalized)\n                .multiplyScalar(cameraToTargetLen - newCameraDistance);\n\n            cameraPos.add(offsetVector);\n            cameraToTarget.sub(offsetVector);\n        }\n\n        for (const point of points) {\n            checkAngle(point, screenVertMidPlane, halfVertFov, halfVertFovTan);\n            checkAngle(point, screenHorzMidPlane, halfHorzFov, halfHorzFovTan);\n        }\n\n        return cameraToTarget.length();\n    }\n\n    /**\n     * @hidden\n     * @internal\n     *\n     * Paremeters for [[getFitBoundsLookAtParams]] function.\n     */\n    export interface FitPointParams {\n        tilt: number;\n        heading: number;\n        projection: Projection;\n        minDistance: number;\n        camera: THREE.PerspectiveCamera;\n    }\n\n    /**\n     * @hidden\n     * @internal\n     *\n     * Get {@link LookAtParams} that fit all `worldPoints`\n     * giving that {@link MapView} will target at\n     * `geoTarget`.\n     *\n     * @param geoTarget - desired target (see {@link MapView.target}) as geo point\n     * @param worldTarget - same as `geoTarget` but in world space\n     * @param worldPoints - points we want to see\n     * @param params - other params derived from {@link MapView}.\n     */\n    export function getFitBoundsLookAtParams(\n        geoTarget: GeoCoordinates,\n        worldTarget: THREE.Vector3,\n        worldPoints: THREE.Vector3[],\n        params: FitPointParams\n    ) {\n        const { tilt, heading, projection } = params;\n        const startDistance = params.minDistance;\n        const tmpCamera = params.camera.clone();\n\n        getCameraRotationAtTarget(projection, geoTarget, -heading, tilt, tmpCamera.quaternion);\n        getCameraPositionFromTargetCoordinates(\n            geoTarget,\n            startDistance,\n            -heading,\n            tilt,\n            projection,\n            tmpCamera.position\n        );\n        tmpCamera.updateMatrixWorld(true);\n\n        if (projection.type === ProjectionType.Spherical) {\n            wrapWorldPointsToView(worldPoints, tmpCamera.position);\n        }\n        const distance = getFitBoundsDistance(worldPoints, worldTarget, tmpCamera);\n        return {\n            target: geoTarget,\n            distance,\n            heading,\n            tilt\n        };\n    }\n\n    /**\n     * @deprecated use getCameraPositionFromTargetCoordinates instead\n     */\n    export function getCameraCoordinatesFromTargetCoordinates(\n        targetCoordinates: GeoCoordinates,\n        distance: number,\n        yawDeg: number,\n        pitchDeg: number,\n        mapView: MapView\n    ): GeoCoordinates {\n        return mapView.projection.unprojectPoint(\n            getCameraPositionFromTargetCoordinates(\n                targetCoordinates,\n                distance,\n                yawDeg,\n                pitchDeg,\n                mapView.projection,\n                cache.vector3[1]\n            )\n        );\n    }\n\n    /**\n     * Casts a ray in NDC space from the current map view and returns the intersection point of that\n     * ray wih the map in world space.\n     *\n     * @param mapView - Instance of MapView.\n     * @param pointOnScreenXinNDC - X coordinate in NDC space.\n     * @param pointOnScreenYinNDC - Y coordinate in NDC space.\n     * @param elevation - Optional param used to offset the ground plane. Used when wanting to pan\n     * based on a plane at some altitude. Necessary for example when panning with terrain.\n     *\n     * @returns Intersection coordinates, or `null` if raycast failed.\n     */\n    export function rayCastWorldCoordinates(\n        mapView: MapView,\n        pointOnScreenXinNDC: number,\n        pointOnScreenYinNDC: number,\n        elevation?: number\n    ): THREE.Vector3 | null {\n        const pointInNDCPosition = cache.vector3[0].set(\n            pointOnScreenXinNDC,\n            pointOnScreenYinNDC,\n            0\n        );\n        const cameraPos = cache.vector3[1].copy(mapView.camera.position);\n\n        cache.matrix4[0].extractRotation(mapView.camera.matrixWorld);\n\n        // Prepare the unprojection matrix which projects from NDC space to camera space\n        // and takes the current rotation of the camera into account.\n        cache.matrix4[1].multiplyMatrices(\n            cache.matrix4[0],\n            cache.matrix4[1].getInverse(mapView.camera.projectionMatrix)\n        );\n        // Unproject the point via the unprojection matrix.\n        const pointInCameraSpace = pointInNDCPosition.applyMatrix4(cache.matrix4[1]);\n        // Use the point in camera space as the vector towards this point.\n        rayCaster.set(cameraPos, pointInCameraSpace.normalize());\n        if (elevation !== undefined) {\n            groundPlane.constant -= elevation;\n            groundSphere.radius += elevation;\n        }\n\n        const worldPosition = new THREE.Vector3();\n        const result =\n            mapView.projection.type === ProjectionType.Planar\n                ? rayCaster.ray.intersectPlane(groundPlane, worldPosition)\n                : rayCaster.ray.intersectSphere(groundSphere, worldPosition);\n\n        if (elevation !== undefined) {\n            groundPlane.constant = 0;\n            groundSphere.radius = EarthConstants.EQUATORIAL_RADIUS;\n        }\n        return result;\n    }\n\n    /**\n     * Pans the camera according to the projection.\n     *\n     * @param mapView - Instance of MapView.\n     * @param xOffset - In world space. Value > 0 will pan the map to the right, value < 0 will pan\n     *                  the map to the left in default camera orientation.\n     * @param yOffset - In world space. Value > 0 will pan the map upwards, value < 0 will pan the\n     *                  map downwards in default camera orientation.\n     */\n    export function panCameraAboveFlatMap(\n        mapView: MapView,\n        offsetX: number,\n        offsetY: number\n    ): void {\n        mapView.camera.position.x += offsetX;\n        mapView.camera.position.y += offsetY;\n    }\n\n    /**\n     * The function doing a pan in the spherical space\n     * when {@link MapView}'s active [[ProjectionType]]\n     * is spherical. In other words, the function that rotates the camera around the globe.\n     *\n     * @param mapView - MapView instance.\n     * @param fromWorld - Start vector representing the scene position of a geolocation.\n     * @param toWorld - End vector representing the scene position of a geolocation.\n     */\n    export function panCameraAroundGlobe(\n        mapView: MapView,\n        fromWorld: THREE.Vector3,\n        toWorld: THREE.Vector3\n    ) {\n        cache.quaternions[0]\n            .setFromUnitVectors(fromWorld.normalize(), toWorld.normalize())\n            .inverse();\n        cache.matrix4[0].makeRotationFromQuaternion(cache.quaternions[0]);\n        mapView.camera.applyMatrix4(cache.matrix4[0]);\n        mapView.camera.updateMatrixWorld();\n    }\n\n    /**\n     * Rotates the camera by the given delta yaw and delta pitch. The pitch will be clamped to the\n     * maximum possible tilt to the new target, and under the horizon in sphere projection.\n     *\n     * @param mapView - The {@link MapView} instance in use.\n     * @param deltaYawDeg - Delta yaw in degrees.\n     * @param deltaPitchDeg - Delta pitch in degrees.\n     * @param maxTiltAngleRad - Max tilt angle in radians.\n     */\n    export function rotate(\n        mapView: MapView,\n        deltaYawDeg: number,\n        deltaPitchDeg: number = 0,\n        maxTiltAngleRad = Math.PI / 4\n    ) {\n        // 1. Apply yaw: rotate around the vertical axis.\n        mapView.camera.rotateOnWorldAxis(\n            mapView.projection.type === ProjectionType.Spherical\n                ? cache.vector3[0].copy(mapView.camera.position).normalize()\n                : cache.vector3[0].set(0, 0, 1),\n            THREE.MathUtils.degToRad(-deltaYawDeg)\n        );\n        mapView.camera.updateMatrixWorld();\n\n        // 2. Apply pitch: rotate around the camera's local X axis.\n        if (deltaPitchDeg === 0) {\n            return;\n        }\n        const pitch = MapViewUtils.extractAttitude(mapView, mapView.camera).pitch;\n        // `maxTiltAngle` is equivalent to a `maxPitchAngle` in flat projections.\n        let newPitch = THREE.MathUtils.clamp(\n            pitch + THREE.MathUtils.degToRad(deltaPitchDeg),\n            0,\n            maxTiltAngleRad\n        );\n        // In sphere projection, the value of a maximum pitch is smaller than the value of the\n        // maximum tilt, as the curvature of the surface adds up to it.\n        if (mapView.projection.type === ProjectionType.Spherical) {\n            // Deduce max pitch from max tilt. To this end the sine law of triangles is used below.\n            const maxPitch = Math.asin(\n                (EarthConstants.EQUATORIAL_RADIUS * Math.sin(Math.PI - maxTiltAngleRad)) /\n                    mapView.camera.position.length()\n            );\n            newPitch = Math.min(newPitch, maxPitch);\n        }\n        mapView.camera.rotateX(newPitch - pitch);\n    }\n\n    /**\n     * Computes the rotation of the camera according to yaw and pitch in degrees. The computations\n     * hinge on the current `projection` and `target`, because yaw and pitch are defined in\n     * tangent space of the target point.\n     *\n     * **Note:** `yaw == 0 && pitch == 0` will north up the map and you will look downwards onto the\n     * map.\n     *\n     * @param projection - Current projection.\n     * @param target - The camera target.\n     * @param yawDeg - Yaw in degrees, counter-clockwise (as opposed to azimuth), starting north.\n     * @param pitchDeg - Pitch in degrees.\n     */\n    export function getCameraRotationAtTarget(\n        projection: Projection,\n        target: GeoCoordinates,\n        yawDeg: number,\n        pitchDeg: number,\n        result: THREE.Quaternion = new THREE.Quaternion()\n    ): THREE.Quaternion {\n        const transform = cache.transforms[0];\n        projection.localTangentSpace(target, transform);\n\n        cache.matrix4[0].makeBasis(transform.xAxis, transform.yAxis, transform.zAxis);\n        result.setFromRotationMatrix(cache.matrix4[0]);\n\n        cache.quaternions[0].setFromAxisAngle(\n            cache.vector3[1].set(0, 0, 1),\n            THREE.MathUtils.degToRad(yawDeg)\n        );\n        cache.quaternions[1].setFromAxisAngle(\n            cache.vector3[1].set(1, 0, 0),\n            THREE.MathUtils.degToRad(pitchDeg)\n        );\n\n        result.multiply(cache.quaternions[0]);\n        result.multiply(cache.quaternions[1]);\n        return result;\n    }\n\n    /**\n     * Sets the rotation of the camera according to yaw and pitch in degrees. The computations hinge\n     * on the current projection and `geoCenter`, because yaw and pitch are defined in tangent\n     * space. In particular, `MapView#geoCenter` needs to be set before calling `setRotation`.\n     *\n     * **Note:** `yaw == 0 && pitch == 0` will north up the map and you will look downwards onto the\n     * map.\n     *\n     * @param mapView - Instance of MapView.\n     * @param yawDeg - Yaw in degrees, counter-clockwise (as opposed to azimuth), starting north.\n     * @param pitchDeg - Pitch in degrees.\n     */\n    export function setRotation(mapView: MapView, yawDeg: number, pitchDeg: number) {\n        getCameraRotationAtTarget(\n            mapView.projection,\n            mapView.geoCenter,\n            yawDeg,\n            pitchDeg,\n            mapView.camera.quaternion\n        );\n    }\n\n    /**\n     * Extracts current camera tilt angle in radians.\n     *\n     * @param camera - The [[Camera]] in use.\n     * @param projection - The {@link @here/harp-geoutils#Projection} used to\n     *                     convert between geo and world coordinates.\n     *\n     * @deprecated Use MapView.tilt\n     */\n    export function extractCameraTilt(camera: THREE.Camera, projection: Projection): number {\n        // For planar projections the camera target point local tangent is the same\n        // at every point on the ground (ignoring terrain fluctuations), so we may\n        // simply use inverted ground normal for tilt calculation. This simplifies\n        // the more generic calculus used for spherical projections.\n        if (projection.type === ProjectionType.Planar) {\n            const lookAt: THREE.Vector3 = camera.getWorldDirection(cache.vector3[0]).normalize();\n            const normal: THREE.Vector3 = projection\n                .surfaceNormal(camera.position, cache.vector3[1])\n                .negate();\n            const cosTheta = lookAt.dot(normal);\n            return Math.acos(THREE.MathUtils.clamp(cosTheta, -1, 1));\n        } else {\n            // Sanity check if new projection type is introduced.\n            assert(projection.type === ProjectionType.Spherical);\n            // tslint:disable-next-line: deprecation\n            const targetGeoCoords = MapViewUtils.getGeoTargetFromCamera(camera, projection);\n            // If focus point is lost we then expose maximum allowable tilt value.\n            if (targetGeoCoords !== null) {\n                return MapViewUtils.extractTiltAngleFromLocation(\n                    projection,\n                    camera,\n                    targetGeoCoords\n                );\n            } else {\n                logger.warn(\n                    \"MapView camera is pointing in the void, using maxTilt: \",\n                    MAX_TILT_RAD\n                );\n                return MAX_TILT_RAD;\n            }\n        }\n    }\n\n    /**\n     * Extracts yaw, pitch, and roll rotation in radians.\n     * - Yaw : Rotation around the vertical axis, counter-clockwise (as opposed to azimuth),\n     * starting north.\n     * - Pitch :Rotation around the horizontal axis.\n     * - Roll : Rotation around the view axis.\n     *\n     * @see https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles\n     *\n     * @param options - Subset of necessary {@link MapView} properties.\n     * @param object - The [[THREE.Object3D]] instance to extract the rotations from.\n     */\n    export function extractAttitude(\n        options: { projection: Projection },\n        object: THREE.Object3D\n    ): Attitude {\n        // 1. Build the matrix of the tangent space of the object.\n        cache.vector3[1].setFromMatrixPosition(object.matrixWorld); // Ensure using world position.\n        options.projection.localTangentSpace(options.projection.unprojectPoint(cache.vector3[1]), {\n            xAxis: tangentSpace.x,\n            yAxis: tangentSpace.y,\n            zAxis: tangentSpace.z,\n            position: cache.vector3[0]\n        });\n        cache.matrix4[1].makeBasis(tangentSpace.x, tangentSpace.y, tangentSpace.z);\n\n        // 2. Change the basis of matrixWorld to the tangent space to get the new base axes.\n        cache.matrix4[0].getInverse(cache.matrix4[1]).multiply(object.matrixWorld);\n        space.x.setFromMatrixColumn(cache.matrix4[0], 0);\n        space.y.setFromMatrixColumn(cache.matrix4[0], 1);\n        space.z.setFromMatrixColumn(cache.matrix4[0], 2);\n\n        // 3. Deduce orientation from the base axes.\n        let yaw = 0;\n        let pitch = 0;\n        let roll = 0;\n\n        // Decompose rotation matrix into Z0 X Z1 Euler angles.\n        const d = space.z.dot(cache.vector3[1].set(0, 0, 1));\n        if (d < 1.0 - epsilon) {\n            if (d > -1.0 + epsilon) {\n                yaw = Math.atan2(space.z.x, -space.z.y);\n                pitch = Math.acos(space.z.z);\n                roll = Math.atan2(space.x.z, space.y.z);\n            } else {\n                // Looking bottom-up with space.z.z == -1.0\n                yaw = -Math.atan2(-space.y.x, space.x.x);\n                pitch = 180;\n                roll = 0;\n            }\n        } else {\n            // Looking top-down with space.z.z == 1.0\n            yaw = Math.atan2(-space.y.x, space.x.x);\n            pitch = 0.0;\n            roll = 0.0;\n        }\n\n        return {\n            yaw,\n            pitch,\n            roll\n        };\n    }\n\n    /**\n     * Gets the spherical coordinates in radian of the object to the coordinates of `point`.\n     *\n     * Note: this method can be used to get the direction that an object points to, when `location`\n     * is the target of that object, by adding PI to it. Otherwise it only returns the spherical\n     * coordinates of `object` in the tangent space of `location`.\n     *\n     * @param mapView - The {@link MapView} instance to consider.\n     * @param object - The object to get the coordinates from.\n     * @param location - The reference point.\n     */\n    export function extractSphericalCoordinatesFromLocation(\n        mapView: MapView,\n        object: THREE.Object3D,\n        location: GeoCoordinates\n    ): { azimuth: number; tilt: number } {\n        mapView.projection.localTangentSpace(location, {\n            xAxis: tangentSpace.x,\n            yAxis: tangentSpace.y,\n            zAxis: tangentSpace.z,\n            position: cache.vector3[0]\n        });\n\n        let tilt = 0;\n        let azimuth = 0;\n\n        // Get point to object vector in `cache.vector3[1]` and deduce `tilt` from the angle with\n        // tangent Z.\n        cache.vector3[1]\n            .copy(object.position)\n            .sub(cache.vector3[0])\n            .normalize();\n        if (cache.vector3[1].dot(tangentSpace.z) > 1 - epsilon) {\n            // Top down view: the azimuth of the object would be opposite the yaw, and clockwise.\n            azimuth = Math.PI - extractAttitude(mapView, object).yaw;\n            // Wrap between -PI and PI.\n            azimuth = Math.atan2(Math.sin(azimuth), Math.cos(azimuth));\n            tilt = 0;\n            return { tilt, azimuth };\n        }\n        tilt = cache.vector3[1].angleTo(tangentSpace.z);\n        // Tilted view: the azimuth is the direction of the object from the origin.\n        cache.vector3[1]\n            .copy(object.position)\n            .sub(cache.vector3[0])\n            .projectOnPlane(tangentSpace.z)\n            .normalize();\n        azimuth = cache.vector3[1].angleTo(tangentSpace.y);\n        if (cache.vector3[1].cross(tangentSpace.y).dot(tangentSpace.z) < 0) {\n            azimuth = -azimuth;\n        }\n        return { tilt, azimuth };\n    }\n\n    /**\n     * Gets the tilt angle (in radians) of the object relative to the coordinates of `location`.\n     *\n     * Note: this method can be used to get the direction that an object points to, when `location`\n     * is the target of that object, by adding PI to it. Otherwise it only returns the tilt angle\n     * (in radians) of `object` in the tangent space of `location`.\n     *\n     * @param projection - The {@link @here/harp-geoutils#Projection} used when\n     *                     converting from geo to world coordinates.\n     * @param object - The object to get the coordinates from.\n     * @param location - The reference point.\n     */\n    export function extractTiltAngleFromLocation(\n        projection: Projection,\n        object: THREE.Object3D,\n        location: GeoCoordinates\n    ): number {\n        projection.localTangentSpace(location, {\n            xAxis: tangentSpace.x,\n            yAxis: tangentSpace.y,\n            zAxis: tangentSpace.z,\n            position: cache.vector3[0]\n        });\n\n        // Get point to object vector (dirVec) and compute the `tilt` as the angle with tangent Z.\n        const dirVec = cache.vector3[1].copy(object.position).sub(cache.vector3[0]);\n        const dirLen = dirVec.length();\n        if (dirLen < epsilon) {\n            logger.error(\"Can not calculate tilt for the zero length vector!\");\n            return 0;\n        }\n        dirVec.divideScalar(dirLen);\n\n        const cosTheta = dirVec.dot(tangentSpace.z);\n        if (cosTheta > 1 - epsilon) {\n            // Top down view.\n            return 0;\n        }\n        return Math.acos(THREE.MathUtils.clamp(cosTheta, -1, 1));\n    }\n\n    /**\n     * Get perspective camera frustum planes distances.\n     * @return all plane distances in helper object.\n     */\n    export function getCameraFrustumPlanes(\n        camera: THREE.PerspectiveCamera\n    ): { left: number; right: number; top: number; bottom: number; near: number; far: number } {\n        const near = camera.near;\n        const far = camera.far;\n        let top = (near * Math.tan(THREE.MathUtils.degToRad(0.5 * camera.fov))) / camera.zoom;\n        let height = 2 * top;\n        let width = camera.aspect * height;\n        let left = -0.5 * width;\n\n        const view = camera.view;\n        if (view !== null && view.enabled) {\n            const fullWidth = view.fullWidth;\n            const fullHeight = view.fullHeight;\n\n            left += (view.offsetX * width) / fullWidth;\n            top -= (view.offsetY * height) / fullHeight;\n            width *= view.width / fullWidth;\n            height *= view.height / fullHeight;\n        }\n\n        // Correct by skew factor\n        left += camera.filmOffset !== 0 ? (near * camera.filmOffset) / camera.getFilmWidth() : 0;\n\n        return {\n            left,\n            right: left + width,\n            top,\n            bottom: top - height,\n            near,\n            far\n        };\n    }\n\n    /**\n     * Casts a ray in NDC space from the current view of the camera and returns the intersection\n     * point of that ray against the map in geo coordinates. The return value can be `null` when\n     * the raycast is above the horizon.\n     *\n     * @param mapView - Instance of MapView.\n     * @param pointOnScreenXNDC -  Abscissa in NDC space.\n     * @param pointOnScreenYNDC -  Ordinate in NDC space.\n     * @returns Intersection geo coordinates, or `null` if raycast is above the horizon.\n     */\n    export function rayCastGeoCoordinates(\n        mapView: MapView,\n        pointOnScreenXinNDC: number,\n        pointOnScreenYinNDC: number\n    ): GeoCoordinates | null {\n        const worldCoordinates = rayCastWorldCoordinates(\n            mapView,\n            pointOnScreenXinNDC,\n            pointOnScreenYinNDC\n        );\n\n        if (!worldCoordinates) {\n            return null;\n        }\n\n        return mapView.projection.unprojectPoint(worldCoordinates);\n    }\n\n    /**\n     * Calculates and returns the distance from the ground, which is needed to put the camera to\n     * this height, to see the size of the area that would be covered by one tile for the given zoom\n     * level.\n     *\n     * @param mapView - Instance of MapView.\n     * @param options - Subset of necessary {@link MapView} properties.\n     */\n    export function calculateDistanceToGroundFromZoomLevel(\n        options: { projection: Projection; focalLength: number; camera: THREE.Object3D },\n        zoomLevel: number\n    ): number {\n        const cameraPitch = extractAttitude(options, options.camera).pitch;\n        const tileSize = EarthConstants.EQUATORIAL_CIRCUMFERENCE / Math.pow(2, zoomLevel);\n        return ((options.focalLength * tileSize) / 256) * Math.cos(cameraPitch);\n    }\n\n    /**\n     * Calculates and returns the distance to the target point.\n     *\n     * @param options - Necessary subset of MapView properties to compute the distance.\n     * @param zoomLevel - The zoom level to get the equivalent height to.\n     */\n    export function calculateDistanceFromZoomLevel(\n        options: { focalLength: number },\n        zoomLevel: number\n    ): number {\n        const tileSize = EarthConstants.EQUATORIAL_CIRCUMFERENCE / Math.pow(2, zoomLevel);\n        return (options.focalLength * tileSize) / 256;\n    }\n\n    /**\n     * Calculates the zoom level, which corresponds to the current distance from\n     * camera to lookAt point.\n     * Therefore the zoom level is a `float` and not an `int`. The height of the camera can be in\n     * between zoom levels. By setting the zoom level, you change the height position of the camera\n     * in away that the field of view of the camera should be able to cover one tile for the given\n     * zoom level.\n     *\n     * As an example for this, when you have a tile of zoom level 14 in front of the camera and you\n     * set the zoom level of the camera to 14, then you are able to see the whole tile in front of\n     * you.\n     *\n     * @param options - Subset of necessary {@link MapView} properties.\n     * @param distance - The distance in meters, which are scene units in {@link MapView}.\n     */\n    export function calculateZoomLevelFromDistance(\n        options: { focalLength: number; minZoomLevel: number; maxZoomLevel: number },\n        distance: number\n    ): number {\n        const tileSize = (256 * distance) / options.focalLength;\n        const zoomLevel = THREE.MathUtils.clamp(\n            Math.log2(EarthConstants.EQUATORIAL_CIRCUMFERENCE / tileSize),\n            options.minZoomLevel,\n            options.maxZoomLevel\n        );\n        return snapToCeilingZoomLevel(zoomLevel);\n    }\n\n    /**\n     * Translates a linear clip-space distance value to the actual value stored in the depth buffer.\n     * This is useful as the depth values are not stored in the depth buffer linearly, and this can\n     * lead into confusing behavior when not taken into account.\n     *\n     * @param clipDistance - Distance from the camera in clip space (range: [0, 1]).\n     * @param camera - Camera applying the perspective projection.\n     */\n    export function calculateDepthFromClipDistance(\n        clipDistance: number,\n        camera: THREE.Camera\n    ): number {\n        const perspCam = camera as THREE.PerspectiveCamera;\n        const cameraRange = perspCam.far - perspCam.near;\n        const viewSpaceDistance = clipDistance * perspCam.far;\n\n        return (1.0 - perspCam.near / viewSpaceDistance) * (perspCam.far / cameraRange);\n    }\n\n    /**\n     * Translates a linear distance value [0..1], where 1 is the distance to the far plane, into\n     * [0..cameraFar].\n     *\n     * @param distance - Distance from the camera (range: [0, 1]).\n     * @param camera - Camera applying the perspective projection.\n     */\n    export function cameraToWorldDistance(distance: number, camera: THREE.Camera): number {\n        const perspCam = camera as THREE.PerspectiveCamera;\n        return distance * perspCam.far;\n    }\n\n    /**\n     * Calculates vertical field of view for given horizontal field of vision and aspect ratio.\n     *\n     * @param hFov - Horizontal field of view in rad.\n     * @param aspect - Aspect ratio.\n     */\n    export function calculateVerticalFovByHorizontalFov(hFov: number, aspect: number): number {\n        return 2 * Math.atan(Math.tan(hFov / 2) / aspect);\n    }\n\n    /**\n     * Calculates horizontal field of view for given vertical field of vision and aspect ratio.\n     *\n     * @param hFov - Vertical field of view in rad.\n     * @param aspect - Aspect ratio.\n     */\n    export function calculateHorizontalFovByVerticalFov(vFov: number, aspect: number): number {\n        return 2 * Math.atan(Math.tan(vFov / 2) * aspect);\n    }\n\n    /**\n     * Calculates the focal length based on the vertical FOV and height.\n     *\n     * @param vFov - Vertical field of view in rad.\n     * @param height - Height of canvas in pixels.\n     */\n    export function calculateFocalLengthByVerticalFov(vFov: number, height: number): number {\n        return height / 2 / Math.tan(vFov / 2);\n    }\n\n    /**\n     * Calculates the vertical field of view based on the focal length and the height.\n     *\n     * @param focalLength - Focal length in pixels (see [[calculateFocalLengthByVerticalFov]])\n     * @param height - Height of canvas in pixels.\n     */\n    export function calculateFovByFocalLength(focalLength: number, height: number): number {\n        return THREE.MathUtils.radToDeg(2 * Math.atan(height / 2 / focalLength));\n    }\n\n    /**\n     * Calculates object's screen size based on the focal length and it's camera distance.\n     *\n     * @param focalLength - Focal length in pixels (see [[calculateFocalLengthByVerticalFov]])\n     * @param distance - Object distance in world space.\n     * @param worldSize - Object size in world space.\n     * @return object size in screen space.\n     */\n    export function calculateScreenSizeByFocalLength(\n        focalLength: number,\n        distance: number,\n        worldSize: number\n    ): number {\n        return (focalLength * worldSize) / distance;\n    }\n\n    /**\n     * Calculates object's world size based on the focal length and it's camera distance.\n     *\n     * @param focalLength - Focal length in pixels (see [[calculateFocalLengthByVerticalFov]])\n     * @param distance - Object distance in world space.\n     * @param screenSize - Object size in screen space.\n     * @return object size in world space.\n     */\n    export function calculateWorldSizeByFocalLength(\n        focalLength: number,\n        distance: number,\n        screenSize: number\n    ): number {\n        return (distance * screenSize) / focalLength;\n    }\n\n    /**\n     * Computes estimate for size of a THREE.Object3D object and its children. Shared materials\n     * and/or attributes will be counted multiple times.\n     *\n     * @param object - The mesh object to evaluate\n     * @param size - The {@link MemoryUsage} to update.\n     * @param visitedObjects - Optional map to store large objects that could be shared.\n     *\n     * @returns Estimate of object size in bytes for heap and GPU.\n     */\n    export function estimateObject3dSize(\n        object: THREE.Object3D,\n        parentSize?: MemoryUsage,\n        visitedObjects?: Map<string, boolean>\n    ): MemoryUsage {\n        const size =\n            parentSize !== undefined\n                ? parentSize\n                : {\n                      heapSize: 0,\n                      gpuSize: 0\n                  };\n\n        if (visitedObjects === undefined) {\n            visitedObjects = new Map();\n        }\n\n        estimateMeshSize(object, size, visitedObjects);\n\n        if (object.children.length > 0) {\n            for (const child of object.children) {\n                estimateObject3dSize(child, size, visitedObjects);\n            }\n        }\n        return size;\n    }\n\n    /**\n     * Check if tiles or other content is currently being loaded.\n     *\n     * This method can be removed once HARP-7932 is implemented.\n     *\n     * @returns `true` if MapView has visible tiles or other content that is being loaded.\n     */\n    export function mapViewIsLoading(mapView: MapView) {\n        let numTilesLoading = 0;\n\n        for (const tileList of mapView.visibleTileSet.dataSourceTileList) {\n            numTilesLoading += tileList.numTilesLoading;\n\n            for (const tile of tileList.visibleTiles) {\n                if (tile.tileLoader !== undefined && !tile.tileLoader.isFinished) {\n                    numTilesLoading++;\n                }\n                if (tile.tileGeometryLoader !== undefined && !tile.tileGeometryLoader.isFinished) {\n                    numTilesLoading++;\n                }\n            }\n        }\n        let isLoading = numTilesLoading > 0;\n\n        if (mapView.textElementsRenderer !== undefined) {\n            isLoading = isLoading || mapView.textElementsRenderer.loading;\n        }\n\n        isLoading =\n            isLoading ||\n            !mapView.poiTableManager.finishedLoading ||\n            !mapView.visibleTileSet.allVisibleTilesLoaded;\n\n        return isLoading;\n    }\n\n    function estimateTextureSize(\n        texture: THREE.Texture | null,\n        objectSize: MemoryUsage,\n        visitedObjects: Map<string, boolean>\n    ): void {\n        if (texture === null || texture === undefined || texture.image === undefined) {\n            return;\n        }\n\n        if (texture.uuid !== undefined && visitedObjects.get(texture.uuid) === true) {\n            return;\n        }\n        visitedObjects.set(texture.uuid, true);\n\n        // May be HTMLImage or ImageData\n        const image = texture.image;\n        // Assuming RGBA\n        const imageBytes = 4 * image.width * image.height;\n        objectSize.heapSize += imageBytes;\n        objectSize.gpuSize += imageBytes;\n    }\n\n    function estimateMaterialSize(\n        material: THREE.Material,\n        objectSize: MemoryUsage,\n        visitedObjects: Map<string, boolean>\n    ): void {\n        if (material.uuid !== undefined && visitedObjects.get(material.uuid) === true) {\n            return;\n        }\n        visitedObjects.set(material.uuid, true);\n\n        if (\n            material instanceof THREE.RawShaderMaterial ||\n            material instanceof THREE.ShaderMaterial\n        ) {\n            const rawMaterial = material;\n            for (const name in rawMaterial.uniforms) {\n                if (rawMaterial.uniforms[name] !== undefined) {\n                    const uniform = rawMaterial.uniforms[name];\n                    if (uniform instanceof THREE.Texture) {\n                        estimateTextureSize(uniform, objectSize, visitedObjects);\n                    }\n                }\n            }\n        } else if (\n            material instanceof THREE.MeshBasicMaterial ||\n            material instanceof MapMeshBasicMaterial\n        ) {\n            const meshMaterial = material;\n            estimateTextureSize(meshMaterial.map, objectSize, visitedObjects);\n            estimateTextureSize(meshMaterial.aoMap, objectSize, visitedObjects);\n            estimateTextureSize(meshMaterial.specularMap, objectSize, visitedObjects);\n            estimateTextureSize(meshMaterial.alphaMap, objectSize, visitedObjects);\n            estimateTextureSize(meshMaterial.envMap, objectSize, visitedObjects);\n        } else if (material instanceof MapMeshStandardMaterial) {\n            const standardMaterial = material;\n\n            estimateTextureSize(standardMaterial.map, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.lightMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.aoMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.emissiveMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.bumpMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.normalMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.displacementMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.roughnessMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.metalnessMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.alphaMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.envMap, objectSize, visitedObjects);\n        } else if (\n            material instanceof THREE.LineBasicMaterial ||\n            material instanceof THREE.LineDashedMaterial\n        ) {\n            // Nothing to be done here\n        } else {\n            logger.warn(\"estimateMeshSize: unidentified material: \", material);\n        }\n    }\n\n    function estimateAttributeSize(\n        attribute: any,\n        attrName: string,\n        objectSize: MemoryUsage,\n        visitedObjects: Map<string, boolean>\n    ): void {\n        // Attributes (apparently) do not have their uuid set up.\n        if (attribute.uuid === undefined) {\n            attribute.uuid = THREE.MathUtils.generateUUID();\n        }\n\n        if (visitedObjects.get(attribute.uuid) === true) {\n            return;\n        }\n        visitedObjects.set(attribute.uuid, true);\n\n        let attrBytes = 0;\n        let bytesPerElement = 4;\n        if (attribute.array.BYTES_PER_ELEMENT !== undefined) {\n            bytesPerElement = attribute.array.BYTES_PER_ELEMENT;\n        }\n        if (\n            attribute instanceof THREE.InterleavedBufferAttribute ||\n            attribute instanceof THREE.BufferAttribute\n        ) {\n            attrBytes = bytesPerElement * attribute.count * attribute.itemSize;\n        } else {\n            logger.warn(\"estimateMeshSize: unidentified attribute: \", attrName);\n        }\n\n        objectSize.heapSize += attrBytes + MINIMUM_ATTRIBUTE_SIZE_ESTIMATION;\n        objectSize.gpuSize += attrBytes;\n    }\n\n    function estimateGeometrySize(\n        geometry: THREE.Geometry | THREE.BufferGeometry,\n        objectSize: MemoryUsage,\n        visitedObjects: Map<string, boolean>\n    ): void {\n        const isNewObject =\n            geometry.uuid === undefined || visitedObjects.get(geometry.uuid) !== true;\n\n        if (!isNewObject) {\n            return;\n        }\n        visitedObjects.set(geometry.uuid, true);\n\n        let bufferGeometry: THREE.BufferGeometry | undefined;\n\n        if (geometry instanceof THREE.Geometry) {\n            // Each vertex is represented as 3 floats vector (24 bytes).\n            objectSize.heapSize += geometry.vertices.length * 24;\n            // Face: 3 indices (24 byte), 1 normal (3 floats = 24). Vertex normals and\n            // colors are not counted here.\n            objectSize.heapSize += geometry.faces.length * (24 + 24);\n            // Additionally, the internal _bufferGeometry is also counted:\n            bufferGeometry = (geometry as any)._bufferGeometry;\n        } else if (geometry instanceof THREE.BufferGeometry) {\n            bufferGeometry = geometry;\n        }\n\n        if (bufferGeometry === undefined) {\n            // Nothing more to calculate.\n            return;\n        }\n\n        const attributes = bufferGeometry.attributes;\n        if (attributes === undefined) {\n            logger.warn(\"estimateGeometrySize: unidentified geometry: \", geometry);\n            return;\n        }\n\n        for (const property in attributes) {\n            if (attributes[property] !== undefined) {\n                estimateAttributeSize(attributes[property], property, objectSize, visitedObjects);\n            }\n        }\n        if (bufferGeometry.index !== null) {\n            estimateAttributeSize(bufferGeometry.index, \"index\", objectSize, visitedObjects);\n        }\n    }\n\n    function estimateMeshSize(\n        object: THREE.Object3D,\n        objectSize: MemoryUsage,\n        visitedObjects: Map<string, boolean>\n    ): void {\n        if (!object.isObject3D || object instanceof THREE.Scene) {\n            return;\n        }\n\n        if (object.uuid !== undefined && visitedObjects.get(object.uuid) === true) {\n            return;\n        }\n        visitedObjects.set(object.uuid, true);\n\n        if ((object as any).isMesh || (object as any).isLine || (object as any).isPoints) {\n            // Estimated minimum impact on heap.\n            let heapSize = MINIMUM_OBJECT3D_SIZE_ESTIMATION;\n            const gpuSize = 0;\n\n            // Cast to LodMesh class which contains the minimal required properties sub-set.\n            const mesh = object as LodMesh;\n\n            // Calculate material(s) impact.\n            if (mesh.material !== undefined) {\n                if (Array.isArray(mesh.material)) {\n                    const materials = mesh.material as THREE.Material[];\n                    for (const material of materials) {\n                        estimateMaterialSize(material, objectSize, visitedObjects);\n                    }\n                } else {\n                    const material = mesh.material as THREE.Material;\n                    estimateMaterialSize(material, objectSize, visitedObjects);\n                }\n            }\n\n            // Calculate cost of geometry.\n            if (mesh.geometries !== undefined) {\n                for (const geometry of mesh.geometries) {\n                    estimateGeometrySize(geometry, objectSize, visitedObjects);\n                }\n            } else if (mesh.geometry !== undefined) {\n                estimateGeometrySize(mesh.geometry, objectSize, visitedObjects);\n            }\n\n            // Add info that is required for picking (parts of) objects and match them to\n            // the featureID in the map data.\n            const featureData: TileFeatureData | undefined =\n                object.userData !== undefined\n                    ? (object.userData.feature as TileFeatureData)\n                    : undefined;\n\n            if (featureData !== undefined) {\n                heapSize += getFeatureDataSize(featureData);\n            }\n\n            objectSize.heapSize += heapSize;\n            objectSize.gpuSize += gpuSize;\n        } else {\n            logger.warn(\"estimateMeshSize: unidentified object\", object);\n        }\n    }\n\n    /**\n     * Gets language list used by the browser\n     *\n     * @returns Array of iso language codes\n     */\n    export function getBrowserLanguages(): string[] | undefined {\n        if (navigator.languages !== undefined && navigator.languages.length > 0) {\n            const languageList = [];\n            for (const lang of navigator.languages) {\n                languageList.push(getIsoLanguageCode(lang));\n            }\n            return languageList;\n        }\n        if (navigator.language !== undefined) {\n            return [getIsoLanguageCode(navigator.language)];\n        }\n        return undefined;\n    }\n\n    /**\n     * Gets ISO-639-1 language code from browser's code (ex. en for en-US)\n     */\n    function getIsoLanguageCode(language: string) {\n        return language.substring(0, 2);\n    }\n}\n\n/** @hidden */\nconst powerOfTwo = [\n    0x1,\n    0x2,\n    0x4,\n    0x8,\n    0x10,\n    0x20,\n    0x40,\n    0x80,\n    0x100,\n    0x200,\n    0x400,\n    0x800,\n    0x1000,\n    0x2000,\n    0x4000,\n    0x8000,\n    0x10000,\n    0x20000,\n    0x40000,\n    0x80000,\n    0x100000,\n    0x200000,\n    0x400000,\n    0x800000,\n    0x1000000,\n    0x2000000,\n    0x4000000,\n    0x8000000,\n    0x10000000,\n    0x20000000,\n    0x40000000,\n    0x80000000,\n    0x100000000,\n    0x200000000,\n    0x400000000,\n    0x800000000,\n    0x1000000000,\n    0x2000000000,\n    0x4000000000,\n    0x8000000000,\n    0x10000000000,\n    0x20000000000,\n    0x40000000000,\n    0x80000000000,\n    0x100000000000,\n    0x200000000000,\n    0x400000000000,\n    0x800000000000,\n    0x1000000000000,\n    0x2000000000000,\n    0x4000000000000,\n    0x8000000000000,\n    0x10000000000000\n];\n\nexport namespace TileOffsetUtils {\n    /**\n     * Creates a unique key based on the supplied parameters. Note, the uniqueness is bounded by the\n     * bitshift. The [[TileKey.mortonCode()]] supports currently up to 26 levels (this is because\n     * 26*2 equals 52, and 2^52 is the highest bit that can be set in an integer in Javascript), the\n     * bitshift reduces this accordingly, so given the default bitshift of four, we support up to 24\n     * levels. Given the current support up to level 19 this should be fine.\n     *\n     * @param tileKey - The unique {@link @here/harp-geoutils#TileKey}\n     *                  from which to compute the unique key.\n     * @param offset - How much the given {@link @here/harp-geoutils#TileKey} is offset\n     * @param bitshift - How much space we have to store the offset. The default of 4 means we have\n     *      enough space to store 16 unique tiles in a single view.\n     */\n    export function getKeyForTileKeyAndOffset(\n        tileKey: TileKey,\n        offset: number,\n        bitshift: number = 4\n    ) {\n        const shiftedOffset = getShiftedOffset(offset, bitshift);\n        return tileKey.mortonCode() + shiftedOffset;\n    }\n\n    /**\n     * Extracts the offset and morton key from the given key (must be created by:\n     * [[getKeyForTileKeyAndOffset]])\n     *\n     * Note, we can't use bitshift operators in Javascript because they work on 32-bit integers, and\n     * would truncate the numbers, hence using powers of two.\n     *\n     * @param key - Key to extract offset and morton key.\n     * @param bitshift - How many bits to shift by, must be the same as was used when creating the\n     * key.\n     */\n    export function extractOffsetAndMortonKeyFromKey(key: number, bitshift: number = 4) {\n        let offset = 0;\n        let mortonCode = key;\n        let i = 0;\n        // Compute the offset\n        for (; i < bitshift; i++) {\n            // Note, we use 52, because 2^53-1 is the biggest value, the highest value\n            // that can be set is the bit in the 52th position.\n            const num = powerOfTwo[52 - i];\n            if (mortonCode >= num) {\n                mortonCode -= num;\n                offset += powerOfTwo[bitshift - 1 - i];\n            }\n        }\n        // We subtract half of the total amount, this undoes what is computed in getShiftedOffset\n        offset -= powerOfTwo[bitshift - 1];\n        return { offset, mortonCode };\n    }\n\n    /**\n     * Returns the key of the parent. Key must have been computed using the function\n     * [[getKeyForTileKeyAndOffset]].\n     *\n     * @param calculatedKey - Key to decompose\n     * @param bitshift - Bit shift used to create the key\n     */\n    export function getParentKeyFromKey(calculatedKey: number, bitshift: number = 4) {\n        const { offset, mortonCode } = extractOffsetAndMortonKeyFromKey(calculatedKey, bitshift);\n        const parentTileKey = TileKey.fromMortonCode(TileKey.parentMortonCode(mortonCode));\n        return getKeyForTileKeyAndOffset(parentTileKey, offset, bitshift);\n    }\n\n    /**\n     * Packs the supplied offset into the high bits, where the highbits are between 2^52 and\n     * 2^(52-bitshift).\n     *\n     * Offsets are wrapped around, to fit in the offsetBits. In practice, this doesn't really\n     * matter, this is primarily used to find a unique id, if there is an offset 10, which is\n     * wrapped to 2, it doesn't matter, because the offset of 10 is still stored in the tile.\n     * What can be a problem though is that the cache gets filled up and isn't emptied.\n     *\n     * Note, because bit shifting in JavaScript works on 32 bit integers, we use powers of 2 to set\n     * the high bits instead.\n     *\n     * @param offset - Offset to pack into the high bits.\n     * @param offsetBits - How many bits to use to pack the offset.\n     */\n    function getShiftedOffset(offset: number, offsetBits: number = 4) {\n        let result = 0;\n        const totalOffsetsToStore = powerOfTwo[offsetBits];\n        //Offsets are stored by adding half 2 ^ (bitshift - 1), i.e.half of the max amount stored,\n        //and then wrapped based on this value.For example, given a bitshift of 3, and an offset -\n        //3, it would have 4 added(half of 2 ^ 3), and be stored as 1, 3 would have 4 added and be\n        //stored as 7, 4 would be added with 4 and be stored as 0 (it wraps around).\n        offset += totalOffsetsToStore / 2;\n        while (offset < 0) {\n            offset += totalOffsetsToStore;\n        }\n        while (offset >= totalOffsetsToStore) {\n            offset -= totalOffsetsToStore;\n        }\n        // Offset is now a number between >= 0 and < totalOffsetsToStore\n        for (let i = 0; i < offsetBits && offset > 0; i++) {\n            // tslint:disable: no-bitwise\n            // 53 is used because 2^53-1 is the biggest number that Javascript can represent as an\n            // integer safely.\n            if (offset & 0x1) {\n                result += powerOfTwo[53 - offsetBits + i];\n            }\n            offset >>>= 1;\n            // tslint:enable: no-bitwise\n        }\n        assert(offset === 0);\n        return result;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport class EarthConstants {\n    /** The equatorial circumference in meters. */\n    static EQUATORIAL_CIRCUMFERENCE: number = 40075016.6855784861531768177614;\n\n    /** The equatorial radius in meters. */\n    static EQUATORIAL_RADIUS: number = 6378137.0;\n\n    /** The lowest point on earth (Dead Sea) in meters. */\n    static MIN_ELEVATION: number = -433.0;\n\n    /** The highest point on earth (Mt. Everest) in meters. */\n    static MAX_ELEVATION: number = 8848.0;\n\n    /** The highest artificial structure (building) on earth, Burj Khalifa tower in Dubai */\n    static MAX_BUILDING_HEIGHT: number = 828;\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Vector3Like } from \"./Vector3Like\";\n\n/**\n * An interface representing bounding box in world coordinates.\n */\nexport interface Box3Like {\n    /**\n     * The minimum position in world coordinates of this bounding box.\n     */\n    readonly min: Vector3Like;\n\n    /**\n     * The maximum position in world coordinates of this bounding box.\n     */\n    readonly max: Vector3Like;\n}\n\n/**\n * Returns true if the given object implements the {@link Box3Like} interface.\n *\n * @param object - A valid object.\n */\nexport function isBox3Like(object: {}): object is Box3Like {\n    const box3 = object as Partial<Box3Like>;\n    return box3.min !== undefined && box3.max !== undefined;\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { TransformLike } from \"./TransformLike\";\nimport { Vector3Like } from \"./Vector3Like\";\n\n/**\n * The interface {@link OrientedBox3Like} is used to represent oriented bounding box.\n */\nexport interface OrientedBox3Like extends TransformLike {\n    /**\n     * The extents of this bounding box.\n     */\n    readonly extents: Vector3Like;\n}\n\n/**\n * Returns true if the given object implements the interface {@link OrientedBox3Like}.\n *\n * @param object - The object.\n */\nexport function isOrientedBox3Like(object: {}): object is OrientedBox3Like {\n    const obb = object as Partial<OrientedBox3Like>;\n    return (\n        obb.position !== undefined &&\n        obb.xAxis !== undefined &&\n        obb.yAxis !== undefined &&\n        obb.zAxis !== undefined &&\n        obb.extents !== undefined\n    );\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeoBox } from \"../coordinates/GeoBox\";\nimport { GeoCoordinates } from \"../coordinates/GeoCoordinates\";\nimport { GeoCoordinatesLike, isGeoCoordinatesLike } from \"../coordinates/GeoCoordinatesLike\";\nimport { Box3Like } from \"../math/Box3Like\";\nimport { MathUtils } from \"../math/MathUtils\";\nimport { OrientedBox3Like } from \"../math/OrientedBox3Like\";\nimport { TransformLike } from \"../math/TransformLike\";\nimport { Vector3Like } from \"../math/Vector3Like\";\n\n/**\n * The type of projection.\n */\nexport enum ProjectionType {\n    /**\n     * A type of [Projection] with zero curvature.\n     */\n    Planar,\n\n    /**\n     * A spherical [Projection].\n     */\n    Spherical\n}\n\n/**\n * `Projection` is used to convert positions from geo coordinates to world coordinates and vice\n * versa.\n */\nexport abstract class Projection {\n    /**\n     * The type of this [Projection].\n     */\n    abstract get type(): ProjectionType;\n\n    /**\n     * Constructs the Projection\n     *\n     * @param unitScale - How to transform the projected coordinates to world units.\n     */\n    constructor(readonly unitScale: number) {\n        //Prevent empty constructor error.\n    }\n\n    /**\n     * Returns the world extents in world coordinates.\n     *\n     * @param minElevation - The minimum elevation in meters.\n     * @param maxElevation - The maximum elevation in meters.\n     * @param result - The optional object that will be used to create the resulting bounding box.\n     */\n    abstract worldExtent<Bounds extends Box3Like>(\n        minElevation: number,\n        maxElevation: number,\n        result?: Bounds\n    ): Bounds;\n\n    /**\n     * Projects a point from geo coordinates (latitude, longitude, altitude) to world coordinates\n     * (x,y,z).\n     *\n     * Example:\n     * ```typescript\n     * const worldPos = new THREE.Vector3();\n     * projection.projectPoint(geoPos, worldPos);\n     * ```\n     *\n     * @param geoPoint - The position in geo coordinates.\n     * @param result - The optional object used to store the resulting world position, result must\n     * implement {@link Vector3Like}.\n     */\n    abstract projectPoint<WorldCoordinates extends Vector3Like>(\n        geoPoint: GeoCoordinatesLike,\n        result?: WorldCoordinates\n    ): WorldCoordinates;\n\n    /**\n     * Gets the {@link TransformLike} of the local tangent space at the given point.\n     *\n     * @param point - The geo / world coordinates.\n     * @param result - The {@link TransformLike}.\n     */\n    localTangentSpace(\n        point: GeoCoordinatesLike | Vector3Like,\n        result: TransformLike\n    ): TransformLike {\n        if (isGeoCoordinatesLike(point)) {\n            this.projectPoint(point, result.position);\n        } else {\n            MathUtils.copyVector3(point, result.position);\n        }\n        MathUtils.newVector3(1, 0, 0, result.xAxis);\n        MathUtils.newVector3(0, 1, 0, result.yAxis);\n        MathUtils.newVector3(0, 0, 1, result.zAxis);\n        return result;\n    }\n\n    /**\n     * Returns the geo coordinates (latitude, longitude, altitude) from the given world position\n     * (x,y,z).\n     *\n     * Example:\n     * ```typescript\n     * const geoPos = projection.unprojectPoint(worldPos);\n     * console.log(geoPos.latitude, geoPos.longitude, geoPos.altitude);\n     * ```\n     *\n     * @param worldPoint - The position in world coordinates.\n     */\n    abstract unprojectPoint(worldPoint: Vector3Like): GeoCoordinates;\n\n    /**\n     * Returns the altitude at the given world position (x,y,z) in meters.\n     *\n     * @param worldPoint - The position in world coordinates.\n     */\n    abstract unprojectAltitude(worldPoint: Vector3Like): number;\n\n    /**\n     * Projects bounds in geo coordinates to a bounding box in world coordinates.\n     *\n     * Example:\n     * ```typescript\n     * const bounds = projection.projectBox(geoBox);\n     * console.log(bounds.min, bounds.max);\n     * ```\n     *\n     * @param geoBox - The bounding box in geo coordinates.\n     */\n    abstract projectBox(geoBox: GeoBox): Box3Like;\n\n    /**\n     * Projects bounds in geo coordinates to a bounding box in world coordinates.\n     *\n     * Example:\n     * ```typescript\n     * const bounds = projection.projectBox(geoBox, new THREE.Box3());\n     * console.log(bounds.min, bounds.max);\n     * ```\n     *\n     * @param geoBox - The bounding box in geo coordinates.\n     * @param result - The resulting {@link OrientedBox3Like}.\n     */\n    abstract projectBox<WorldBoundingBox extends Box3Like | OrientedBox3Like>(\n        geoBox: GeoBox,\n        result: WorldBoundingBox\n    ): WorldBoundingBox;\n\n    /**\n     * Converts a bounding box in world coordinates to a bounding box in geo coordinates.\n     *\n     * Example:\n     * ```typescript\n     * const geoPos = projection.unprojectPoint(worldPos);\n     * console.log(geoPos.latitude, geoPos.longitude, geoPos.altitude);\n     * ```\n     *\n     * @param worldBox - The bounding box in world coordinates.\n     */\n    abstract unprojectBox(worldBox: Box3Like): GeoBox;\n\n    /**\n     * Returns the scaling factor that must be used to convert the units used by `worldPoint` to\n     * meters.\n     *\n     * @param worldPoint - The position in world coordinates.\n     */\n    abstract getScaleFactor(worldPoint: Vector3Like): number;\n\n    /**\n     * Returns the surface normal at the given world position.\n     *\n     * @param worldPoint - The position in world coordinates.\n     */\n    abstract surfaceNormal(worldPoint: Vector3Like): Vector3Like;\n\n    /**\n     * Returns the surface normal at the given world position.\n     *\n     * @param worldPoint - The position in world coordinates.\n     * @returns The resulting normal vector.\n     */\n    abstract surfaceNormal<Normal extends Vector3Like>(\n        worldPoint: Vector3Like,\n        result: Normal\n    ): Normal;\n\n    /**\n     * Returns the signed distance between the given coordinates and\n     * the closest point on the surface.\n     *\n     * @param worldPoint - The position in world coordinates.\n     */\n    abstract groundDistance(worldPoint: Vector3Like): number;\n\n    /**\n     * Scales the given world coordinates to the surface.\n     *\n     * @param worldPoint - The position in world coordinates.\n     */\n    abstract scalePointToSurface(worldPoint: Vector3Like): Vector3Like;\n\n    /**\n     * Reproject a world position from the given source {@link Projection}.\n     *\n     * @param sourceProjection - The source projection.\n     * @param worldPos - A valid world position for the given source projection.\n     * @returns The world position reprojected using this {@link Projection}.\n     */\n    reprojectPoint(sourceProjection: Projection, worldPos: Vector3Like): Vector3Like;\n\n    /**\n     * Reproject a world position from the given source {@link Projection}.\n     *\n     * @param sourceProjection - The source projection.\n     * @param worldPos - A valid position in the world space defined by the source projection.\n     * @param result - The resulting position reprojected using this {@link Projection}.\n     */\n    reprojectPoint<WorldCoordinates extends Vector3Like>(\n        sourceProjection: Projection,\n        worldPos: Vector3Like,\n        result: WorldCoordinates\n    ): WorldCoordinates;\n\n    /**\n     * Reproject a world position from the given source {@link Projection}.\n     * Implementations should be aware of worldPos and result may be one object\n     *\n     * @param sourceProjection - The source projection.\n     * @param worldPos - A valid position in the world space defined by the source projection.\n     * @param result - The resulting position reprojected using this {@link Projection}.\n     * @hidden\n     */\n    reprojectPoint(\n        sourceProjection: Projection,\n        worldPos: Vector3Like,\n        result?: Vector3Like\n    ): Vector3Like {\n        if (sourceProjection === this) {\n            if (result === undefined) {\n                return { x: worldPos.x, y: worldPos.y, z: worldPos.z };\n            }\n            result.x = worldPos.x;\n            result.y = worldPos.y;\n            result.z = worldPos.z;\n            return result;\n        }\n        return this.projectPoint(sourceProjection.unprojectPoint(worldPos), result);\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Functionality needed to render a map.\n *\n * @remarks\n *\n * @packageDocumentation\n */\n\nexport * from \"./lib/AnimatedExtrusionHandler\";\nexport * from \"./lib/CameraMovementDetector\";\nexport * from \"./lib/ClipPlanesEvaluator\";\nexport * from \"./lib/ColorCache\";\nexport * from \"./lib/composing\";\nexport * from \"./lib/ConcurrentDecoderFacade\";\nexport * from \"./lib/ConcurrentDecoderFacade\";\nexport * from \"./lib/ConcurrentTilerFacade\";\nexport * from \"./lib/ConcurrentTilerFacade\";\nexport * from \"./lib/copyrights/CopyrightElementHandler\";\nexport * from \"./lib/copyrights/CopyrightInfo\";\nexport * from \"./lib/copyrights/CopyrightProvider\";\nexport * from \"./lib/copyrights/CopyrightCoverageProvider\";\nexport * from \"./lib/copyrights/UrlCopyrightProvider\";\nexport * from \"./lib/DataSource\";\nexport * from \"./lib/PolarTileDataSource\";\nexport * from \"./lib/DecodedTileHelpers\";\nexport * from \"./lib/DepthPrePass\";\nexport * from \"./lib/DisplacementMap\";\nexport * from \"./lib/ElevationProvider\";\nexport * from \"./lib/ElevationRangeSource\";\nexport * from \"./lib/image/Image\";\nexport * from \"./lib/image/ImageCache\";\nexport * from \"./lib/image/MapViewImageCache\";\nexport * from \"./lib/MapAnchors\";\nexport * from \"./lib/MapView\";\nexport * from \"./lib/MapViewAtmosphere\";\nexport * from \"./lib/MapViewFog\";\nexport * from \"./lib/MapViewPoints\";\nexport * from \"./lib/PickHandler\";\nexport * from \"./lib/poi/Poi\";\nexport * from \"./lib/poi/PoiManager\";\nexport * from \"./lib/poi/PoiTableManager\";\nexport * from \"./lib/Statistics\";\nexport * from \"./lib/text/TextElement\";\nexport * from \"./lib/text/TextElementsRenderer\";\nexport * from \"./lib/text/TextStyleCache\";\nexport * from \"./lib/TextureLoader\";\nexport * from \"./lib/ThemeLoader\";\nexport * from \"./lib/Tile\";\nexport * from \"./lib/geometry/TileDataAccessor\";\nexport * from \"./lib/geometry/TileGeometry\";\nexport * from \"./lib/Utils\";\nexport * from \"./lib/VisibleTileSet\";\nexport * from \"./lib/WorkerBasedDecoder\";\nexport * from \"./lib/WorkerBasedTiler\";\nexport * from \"./lib/workers/WorkerLoader\";\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    GeometryKind,\n    GeometryKindSet,\n    ImageTexture,\n    LineMarkerTechnique,\n    PoiStackMode,\n    PoiTechnique\n} from \"@here/harp-datasource-protocol\";\nimport {\n    GlyphData,\n    TextBufferObject,\n    TextLayoutParameters,\n    TextLayoutStyle,\n    TextRenderParameters,\n    TextRenderStyle\n} from \"@here/harp-text-canvas\";\nimport { Math2D, MathUtils } from \"@here/harp-utils\";\n\nimport * as THREE from \"three\";\n\nimport { ImageItem } from \"../image/Image\";\nimport { PickResult } from \"../PickHandler\";\nimport { TextElementType } from \"./TextElementType\";\n\n/**\n * Additional information for an icon that is to be rendered along with a {@link TextElement}.\n */\nexport interface PoiInfo {\n    /**\n     * Technique defining the POI or LineMarker\n     */\n    technique: PoiTechnique | LineMarkerTechnique;\n\n    /**\n     * Name of the {@link @here/harp-datasource-protocol#ImageTexture}.\n     */\n    imageTextureName: string;\n\n    /**\n     * Icon color override\n     *\n     * @see {@link @here/harp-datasource-protocol#MarkerTechniqueParams.iconColor};\n     */\n    iconColor?: THREE.Color;\n\n    /**\n     * Icon brightness.\n     *\n     * @see {@link @here/harp-datasource-protocol#MarkerTechniqueParams.iconBrightness};\n     */\n    iconBrightness?: number;\n\n    /**\n     * Name of the POI table {@link PoiTable}.\n     */\n    poiTableName?: string;\n\n    /**\n     * Name of the POI description in the {@link PoiTable}.\n     */\n    poiName?: string;\n\n    /**\n     * Specify stack mode. Defaults to `ShowInStack`.\n     */\n    stackMode?: PoiStackMode;\n\n    /**\n     * Minimum zoomLevel at which to display the label icon. No default.\n     */\n    iconMinZoomLevel?: number;\n\n    /**\n     * Maximum zoomLevel at which to display the label icon. No default.\n     */\n    iconMaxZoomLevel?: number;\n\n    /**\n     * Minimum zoomLevel at which to display the label text. No default.\n     */\n    textMinZoomLevel?: number;\n\n    /**\n     * Maximum zoomLevel at which to display the label text. No default.\n     */\n    textMaxZoomLevel?: number;\n\n    /**\n     * If true, the text icon will appear even if the text part is blocked by other labels. Defaults\n     * to `false`.\n     */\n    textIsOptional?: boolean;\n\n    /**\n     * If true, the text will appear even if the icon cannot be rendered because of missing icon\n     * graphics. Defaults to `true`.\n     */\n    iconIsOptional?: boolean;\n\n    /**\n     * If `true`, icon is allowed to overlap other labels or icons of lower priority.\n     */\n    mayOverlap?: boolean;\n\n    /**\n     * If `true`, icon will reserve screen space, other markers of lower priority will not be\n     * able to overlap.\n     */\n    reserveSpace?: boolean;\n\n    /**\n     * If isValid is `false`, the icon will no longer be placed or rendered. The reason may be a\n     * missing resource.\n     */\n    isValid?: boolean;\n\n    /**\n     * ID to identify the (POI) icon.\n     */\n    featureId?: number;\n\n    /**\n     * Reference back to owning {@link TextElement}.\n     */\n    textElement: TextElement;\n\n    /**\n     * @hidden\n     * If false, text will not be rendered during camera movements. Defaults to `true`;\n     */\n    renderTextDuringMovements?: boolean;\n\n    /**\n     * @hidden\n     * Direct access to {@link ImageItem} once it is resolved.\n     */\n    imageItem?: ImageItem;\n\n    /**\n     * @hidden\n     * Direct access to {@link @here/harp-datasource-protocol#ImageTexture} once it is resolved.\n     */\n    imageTexture?: ImageTexture;\n\n    /**\n     * @hidden\n     * Layout help: A shield group is for all [[LineMarker]]s that have the same icon and text,\n     * making them the same road shield icon.\n     */\n    shieldGroupIndex?: number;\n\n    /**\n     * @hidden\n     * Internal reference to a render batch, made up of all icons that use the same Material.\n     */\n    poiRenderBatch?: number;\n\n    /**\n     * @hidden\n     * Should be computed during loading/initializing of `ImageTexture`.\n     */\n    computedWidth?: number;\n\n    /**\n     * @hidden\n     * Should be computed during loading/initializing of `ImageTexture`.\n     */\n    computedHeight?: number;\n\n    /**\n     * @hidden\n     * Should be computed during loading/initializing of `ImageTexture`.\n     */\n    uvBox?: Math2D.UvBox;\n\n    /**\n     * @hidden\n     * Computed from owning {@link TextElement}. Value is set when `PoiInfo` is assigned to\n     * {@link TextElement}.\n     */\n    renderOrder?: number;\n}\n\n/**\n * Return 'true' if the POI has been successfully prepared for rendering.\n *\n * @param poiInfo - PoiInfo containing information for rendering the POI icon.\n */\nexport function poiIsRenderable(poiInfo: PoiInfo): boolean {\n    return poiInfo.poiRenderBatch !== undefined;\n}\n\nexport interface TextPickResult extends PickResult {\n    /**\n     * Text of the picked {@link TextElement}\n     */\n    text?: string;\n}\n\n/**\n * State of loading.\n */\nexport enum LoadingState {\n    Requested,\n    Loaded,\n    Initialized\n}\n\n/**\n * `TextElement` is used to create 2D text elements (for example, labels).\n */\nexport class TextElement {\n    /**\n     * Text elements with this priority are placed on screen before any others.\n     */\n    static readonly HIGHEST_PRIORITY = Number.MAX_SAFE_INTEGER;\n\n    /**\n     * Determines visibility. If set to `false`, it will not be rendered.\n     */\n    visible: boolean = true;\n\n    /**\n     * Determines minimum zoom level for visibility. Can be used to reduce the number of visible\n     * `TextElement`s based on zoom level.\n     */\n    minZoomLevel?: number;\n    /**\n     * Determines maximum zoom level for visibility. Can be used to reduce the number of visible\n     * `TextElement`s based on zoom level.\n     */\n    maxZoomLevel?: number;\n\n    /**\n     * If `true`, label is allowed to overlap other labels or icons of lower priority.\n     * @default `false`\n     */\n    mayOverlap?: boolean;\n\n    /**\n     * If `true`, label will reserve screen space, other markers of lower priority will not be\n     * able to overlap.\n     * @default `true`\n     */\n    reserveSpace?: boolean;\n\n    /**\n     * If `true`, the label will always be rendered on top. If overlapping with other labels, the\n     * render order is undefined;\n     * @default `false`\n     */\n    alwaysOnTop?: boolean;\n\n    /**\n     * Ignore distance limit. Used for label in labeled-icons.\n     */\n    ignoreDistance?: boolean;\n\n    /**\n     * Scaling factor of text. Defaults to 0.5, reducing the size ot 50% in the distance.\n     */\n    distanceScale: number = 0.5;\n\n    /**\n     * Optional user data. Will be retrieved during picking.\n     */\n    userData?: any;\n\n    /**\n     * If specified, determines the render order between `TextElement`s. The number different\n     * renderOrders should be as small as possible, because every specific `renderOrder` may result\n     * in one or more draw calls.\n     *\n     * TextElements with the same integer `renderOrder` will be rendered in the same batch.\n     *\n     * The `renderOrder` of `TextElement`s are only relative to other `TextElement`s, and not other\n     * map elements.\n     *\n     * A `TextElement` with a higher `renderOrder` will be rendered after a `TextElement` with a\n     * lower `renderOrder`.\n     */\n    renderOrder?: number = 0;\n\n    /**\n     * Specified kind of geometry. One kind is set as default in the technique, and can be\n     * overridden in the style.\n     */\n    kind?: GeometryKind | GeometryKindSet;\n\n    /**\n     * @hidden\n     * Used during rendering.\n     */\n    loadingState?: LoadingState;\n\n    /**\n     * If set to `true` the geometry has been already overlaid on elevation.\n     */\n    elevated: boolean = false;\n\n    /**\n     * @hidden\n     * Array storing the style {@link @here/harp-text-canvas#GlyphData} for\n     * this `TextElement` to speed up label placement in\n     * {@link TextElementsRenderer}. Valid after `loadingState` is `Initialized`.\n     */\n    glyphs?: GlyphData[];\n\n    /**\n     * @hidden\n     * Array storing the casing (`true`: uppercase, `false`: lowercase)\n     * for this `TextElement`.\n     * Used by labels in {@link TextElementsRenderer} to support\n     * `SmallCaps`. Valid after `loadingState`\n     * is `Initialized`.\n     */\n    glyphCaseArray?: boolean[];\n\n    /**\n     * Screen space bounds for this `TextElement`.\n     *\n     * @remarks\n     * Used by point labels in {@link TextElementsRenderer}.\n     * Valid after `loadingState` is `Initialized`.\n     */\n    bounds?: THREE.Box2;\n\n    /**\n     * @hidden\n     * Pre-computed text vertex buffer. Used by point labels in {@link TextElementsRenderer}. Valid\n     * after label becomes visible for the first time.\n     */\n    textBufferObject?: TextBufferObject;\n\n    /**\n     * @hidden\n     * If `true`, the estimated bounding box of the path is too small for the label to fit, so it is\n     * being ignored for rendering in the latest frame.\n     */\n    dbgPathTooSmall?: boolean;\n\n    pathLengthSqr?: number;\n\n    /**\n     * Time to fade in text in milliseconds.\n     * @default [[DEFAULT_FADE_TIME]] 800\n     */\n    textFadeTime?: number;\n\n    type: TextElementType;\n\n    private m_poiInfo?: PoiInfo;\n\n    private m_renderStyle?: TextRenderStyle;\n\n    private m_layoutStyle?: TextLayoutStyle;\n\n    /**\n     * Creates a new `TextElement`.\n     *\n     * @param text - The text to display.\n     * @param points - The position or a list of points for a curved text, both in world space.\n     * @param renderParams - `TextElement` text rendering parameters.\n     * @param layoutParams - `TextElement` text layout parameters.\n     * @param priority - The priority of the `TextElement. Elements with the highest priority get\n     *              placed first, elements with priority of `0` are placed last, elements with a\n     *              negative value are always rendered, ignoring priorities and allowing overrides.\n     * @param xOffset - Optional X offset of this `TextElement` in screen coordinates.\n     * @param yOffset - Optional Y offset of this `TextElement` in screen coordinates.\n     * @param featureId - Optional number to identify feature (originated from `OmvDataSource`).\n     * @param fadeNear - Distance to the camera (0.0 = camera position, 1.0 = farPlane) at which the\n     *              label starts fading out (opacity decreases).\n     * @param fadeFar - Distance to the camera (0.0 = camera position, 1.0 = farPlane) at which the\n     *              label becomes transparent. A value of <= 0.0 disables fading.\n     * @param offsetDirection - Direction represented as an angle in degrees clockwise from north to\n     * offset the icon in world space.\n     */\n    constructor(\n        readonly text: string,\n        readonly points: THREE.Vector3[] | THREE.Vector3,\n        readonly renderParams: TextRenderParameters | TextRenderStyle,\n        readonly layoutParams: TextLayoutParameters | TextLayoutStyle,\n        public priority = 0,\n        public xOffset: number = 0,\n        public yOffset: number = 0,\n        public featureId?: number,\n        public style?: string,\n        public fadeNear?: number,\n        public fadeFar?: number,\n        readonly tileOffset?: number,\n        readonly offsetDirection?: number\n    ) {\n        if (renderParams instanceof TextRenderStyle) {\n            this.renderStyle = renderParams;\n        }\n        if (layoutParams instanceof TextLayoutStyle) {\n            this.layoutStyle = layoutParams;\n        }\n\n        this.type =\n            points instanceof THREE.Vector3 ? TextElementType.PoiLabel : TextElementType.PathLabel;\n    }\n\n    /**\n     * The text element position or the first point of the path used to render a curved text, both\n     * in world space.\n     */\n    get position(): THREE.Vector3 {\n        if (this.points instanceof Array) {\n            const p = this.points[0];\n            return p;\n        }\n        return this.points as THREE.Vector3;\n    }\n\n    /**\n     * The list of points in world space used to render the text along a path or `undefined`.\n     */\n    get path(): THREE.Vector3[] | undefined {\n        if (this.points instanceof Array) {\n            return this.points;\n        }\n        return undefined;\n    }\n\n    /**\n     * If `true`, `TextElement` is allowed to overlap other labels or icons of lower priority.\n     *\n     * @default `false`\n     */\n    get textMayOverlap(): boolean {\n        return this.mayOverlap === true;\n    }\n\n    set textMayOverlap(mayOverlap: boolean) {\n        this.mayOverlap = mayOverlap;\n    }\n\n    /**\n     * If `true`, `TextElement` will reserve screen space, other markers of lower priority will not\n     * be able to overlap.\n     *\n     * @default `true`\n     */\n    get textReservesSpace(): boolean {\n        return this.reserveSpace !== false;\n    }\n\n    set textReservesSpace(reserveSpace: boolean) {\n        this.reserveSpace = reserveSpace;\n    }\n\n    /**\n     * Contains additional information about icon to be rendered along with text.\n     */\n    get poiInfo(): PoiInfo | undefined {\n        return this.m_poiInfo;\n    }\n\n    set poiInfo(poiInfo: PoiInfo | undefined) {\n        this.m_poiInfo = poiInfo;\n        if (poiInfo !== undefined) {\n            if (this.path !== undefined) {\n                this.type = TextElementType.LineMarker;\n            }\n            const poiRenderOrder = this.renderOrder !== undefined ? this.renderOrder : 0;\n            poiInfo.renderOrder = poiRenderOrder;\n        }\n    }\n\n    /**\n     * @returns The style used to render this text element, undefined if not set yet.\n     */\n    get renderStyle(): TextRenderStyle | undefined {\n        return this.m_renderStyle;\n    }\n\n    /**\n     * Sets style used for text rendering.\n     * @param style - The style to use.\n     */\n    set renderStyle(style: TextRenderStyle | undefined) {\n        this.m_renderStyle = style;\n    }\n\n    /**\n     * @returns The style used to layout this text element, undefined if not set yet.\n     */\n    get layoutStyle(): TextLayoutStyle | undefined {\n        return this.m_layoutStyle;\n    }\n\n    /**\n     * Sets the style used for text layout.\n     * @param style - The style to use.\n     */\n    set layoutStyle(style: TextLayoutStyle | undefined) {\n        this.m_layoutStyle = style;\n    }\n\n    hasFeatureId(): boolean {\n        return this.featureId !== undefined && this.featureId !== 0;\n    }\n\n    /**\n     * Update the minZoomLevel and maxZoomLevel from the values set in {@link PoiInfo}.\n     * Selects the smaller/larger one of the two min/max values for icon and text, because the\n     * TextElement is a container for both.\n     */\n    updateMinMaxZoomLevelsFromPoiInfo() {\n        if (this.poiInfo !== undefined) {\n            if (this.minZoomLevel === undefined) {\n                this.minZoomLevel = MathUtils.min2(\n                    this.poiInfo.iconMinZoomLevel,\n                    this.poiInfo.textMinZoomLevel\n                );\n            }\n            if (this.maxZoomLevel === undefined) {\n                this.maxZoomLevel = MathUtils.max2(\n                    this.poiInfo.iconMaxZoomLevel,\n                    this.poiInfo.textMaxZoomLevel\n                );\n            }\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\n/**\n * Unit of measurement used to specify a font's size.\n */\nexport enum FontUnit {\n    Em,\n    Pixel,\n    Point,\n    Percent\n}\n\n/**\n * Pair of unit and size specifying a font's size.\n */\nexport interface FontSize {\n    unit: FontUnit;\n    size: number;\n    backgroundSize: number;\n}\n\n/**\n * Style to be used when rendering glyphs.\n */\nexport enum FontStyle {\n    Regular,\n    Bold,\n    Italic,\n    BoldItalic\n}\n\n/**\n * Variant to be used when rendering.\n */\nexport enum FontVariant {\n    Regular,\n    AllCaps,\n    SmallCaps\n}\n\n/**\n * Vertical alignment to be used when placing text.\n */\nexport enum VerticalAlignment {\n    Above = 0.0,\n    Center = -0.5,\n    Below = -1.0\n}\n\n/**\n * Horizontal alignment to be used when placing text.\n */\nexport enum HorizontalAlignment {\n    Left = 0.0,\n    Center = -0.5,\n    Right = -1.0\n}\n\n/**\n * Vertical position of text area relative to the placement context (point, line).\n */\nexport enum VerticalPlacement {\n    Top = 0.0,\n    Center = -0.5,\n    Bottom = -1.0\n}\n\n/**\n * Horizontal position of text element relative to the placement context (point, line).\n *\n * @note [[HorizontalPlacement]] value is exactly opposite to [[HorizontalAlignment]] value,\n * cause when you place text on the right side of point (or icon) it will be left-aligned.\n */\nexport enum HorizontalPlacement {\n    Left = -1.0,\n    Center = -0.5,\n    Right = 0.0\n}\n\nexport interface TextPlacement {\n    v: VerticalPlacement;\n    h: HorizontalPlacement;\n}\n\nexport type TextPlacements = TextPlacement[];\n\n/**\n * Text wrapping rule used when `lineWidth` is reached.\n */\nexport enum WrappingMode {\n    None,\n    Character,\n    Word\n}\n\n/**\n * @hidden\n * @internal\n * Utility function that gets deduced [[HorizontalAlignment]] from [[HorizontalPlacement]].\n * Horizontal alignments are exactly opposite to the placements.\n */\nexport function hAlignFromPlacement(hP: HorizontalPlacement): HorizontalAlignment {\n    return (hP as unknown) as HorizontalAlignment;\n}\n\n/**\n * @hidden\n * @internal\n * Utility function that gets deduced [[VerticalAlignment]] from [[VerticalPlacement]].\n */\nexport function vAlignFromPlacement(vP: VerticalPlacement): VerticalAlignment {\n    return (vP as unknown) as VerticalAlignment;\n}\n\n/**\n * @hidden\n * @internal\n * Utility function that gets deduced [[HorizontalPlacement]] from [[HorizontalAlignment]].\n * Horizontal placements are exactly opposite to the alignment values.\n */\nexport function hPlacementFromAlignment(hA: HorizontalAlignment): HorizontalPlacement {\n    return (hA as unknown) as HorizontalPlacement;\n}\n\n/**\n * @hidden\n * @internal\n * Utility function that gets deduced [[VerticalPlacement]] from [[VerticalAlignment]].\n */\nexport function vPlacementFromAlignment(vA: VerticalAlignment): VerticalPlacement {\n    return (vA as unknown) as VerticalPlacement;\n}\n\n/**\n * Namespace containing default values for all members of [[TextRenderParameters]] and\n * [[TextLayoutParameters]].\n */\nexport namespace DefaultTextStyle {\n    export const DEFAULT_FONT_NAME: string = \"\";\n    export const DEFAULT_FONT_SIZE: FontSize = {\n        unit: Object.freeze(FontUnit.Pixel),\n        size: Object.freeze(16.0),\n        backgroundSize: Object.freeze(0.0)\n    };\n    export const DEFAULT_FONT_STYLE: FontStyle = FontStyle.Regular;\n    export const DEFAULT_FONT_VARIANT: FontVariant = FontVariant.Regular;\n    export const DEFAULT_ROTATION: number = 0.0;\n    export const DEFAULT_COLOR: THREE.Color = new THREE.Color(0x000000);\n    export const DEFAULT_OPACITY: number = 1.0;\n    export const DEFAULT_BACKGROUND_COLOR: THREE.Color = new THREE.Color(0x000000);\n    export const DEFAULT_BACKGROUND_OPACITY: number = 0.0;\n\n    export const DEFAULT_TRACKING: number = 0.0;\n    export const DEFAULT_LEADING: number = 0.0;\n    export const DEFAULT_MAX_LINES: number = Infinity;\n    export const DEFAULT_LINE_WIDTH: number = Infinity;\n    export const DEFAULT_CANVAS_ROTATION: number = 0.0;\n    export const DEFAULT_LINE_ROTATION: number = 0.0;\n    export const DEFAULT_WRAPPING_MODE: WrappingMode = WrappingMode.Word;\n    export const DEFAULT_VERTICAL_ALIGNMENT: VerticalAlignment = VerticalAlignment.Above;\n    export const DEFAULT_HORIZONTAL_ALIGNMENT: HorizontalAlignment = HorizontalAlignment.Left;\n    export const DEFAULT_PLACEMENTS: TextPlacement[] = [];\n}\n\n/**\n * [[TextCanvas]] text rendering parameters.\n */\nexport interface TextRenderParameters {\n    fontName?: string;\n    fontSize?: FontSize;\n    fontStyle?: FontStyle;\n    fontVariant?: FontVariant;\n    rotation?: number;\n    color?: THREE.Color;\n    backgroundColor?: THREE.Color;\n    opacity?: number;\n    backgroundOpacity?: number;\n}\n\n/**\n * [[TextCanvas]] text rendering style.\n */\nexport class TextRenderStyle {\n    private m_params: TextRenderParameters;\n\n    /**\n     * Creates a new `TextRenderStyle`.\n     *\n     * @param params - Input [[TextRenderParameters]].\n     *\n     * @returns New `TextRenderStyle`.\n     */\n    constructor(params: TextRenderParameters = {}) {\n        this.m_params = {\n            fontName:\n                params.fontName !== undefined\n                    ? params.fontName\n                    : DefaultTextStyle.DEFAULT_FONT_NAME,\n            fontSize:\n                params.fontSize !== undefined\n                    ? { ...params.fontSize }\n                    : {\n                          unit: DefaultTextStyle.DEFAULT_FONT_SIZE.unit,\n                          size: DefaultTextStyle.DEFAULT_FONT_SIZE.size,\n                          backgroundSize: DefaultTextStyle.DEFAULT_FONT_SIZE.backgroundSize\n                      },\n            fontStyle:\n                params.fontStyle !== undefined\n                    ? params.fontStyle\n                    : DefaultTextStyle.DEFAULT_FONT_STYLE,\n            fontVariant:\n                params.fontVariant !== undefined\n                    ? params.fontVariant\n                    : DefaultTextStyle.DEFAULT_FONT_VARIANT,\n            rotation:\n                params.rotation !== undefined ? params.rotation : DefaultTextStyle.DEFAULT_ROTATION,\n            color:\n                params.color !== undefined\n                    ? params.color.clone()\n                    : DefaultTextStyle.DEFAULT_COLOR.clone(),\n            opacity:\n                params.opacity !== undefined ? params.opacity : DefaultTextStyle.DEFAULT_OPACITY,\n            backgroundColor:\n                params.backgroundColor !== undefined\n                    ? params.backgroundColor.clone()\n                    : DefaultTextStyle.DEFAULT_BACKGROUND_COLOR.clone(),\n            backgroundOpacity:\n                params.backgroundOpacity !== undefined\n                    ? params.backgroundOpacity\n                    : DefaultTextStyle.DEFAULT_BACKGROUND_OPACITY\n        };\n    }\n\n    /**\n     * Current [[TextRenderParameters]] for this style.\n     */\n    get params(): TextRenderParameters {\n        return this.m_params;\n    }\n    set params(value: TextRenderParameters) {\n        this.m_params = { ...this.m_params, ...value };\n    }\n\n    /**\n     * Name of the preferred [[Font]] to be used when rendering.\n     */\n    get fontName(): string {\n        return this.m_params.fontName!;\n    }\n    set fontName(value: string) {\n        this.m_params.fontName = value;\n    }\n\n    /**\n     * Collection of unit and sizes to apply for the currently active [[Font]].\n     */\n    get fontSize(): FontSize {\n        return this.m_params.fontSize!;\n    }\n    set fontSize(value: FontSize) {\n        this.m_params.fontSize = { ...value };\n    }\n\n    /**\n     * Glyph style to apply for the currently active [[Font]].\n     */\n    get fontStyle(): FontStyle {\n        return this.m_params.fontStyle!;\n    }\n    set fontStyle(value: FontStyle) {\n        this.m_params.fontStyle = value;\n    }\n\n    /**\n     * Glyph variant to apply for the currently active [[Font]].\n     */\n    get fontVariant(): FontVariant {\n        return this.m_params.fontVariant!;\n    }\n    set fontVariant(value: FontVariant) {\n        this.m_params.fontVariant = value;\n    }\n\n    /**\n     * Glyph local rotation (radians).\n     */\n    get rotation(): number {\n        return this.m_params.rotation!;\n    }\n    set rotation(value: number) {\n        this.m_params.rotation = value;\n    }\n\n    /**\n     * Glyph color.\n     */\n    get color(): THREE.Color {\n        return this.m_params.color!;\n    }\n    set color(value: THREE.Color) {\n        this.m_params.color!.copy(value);\n    }\n\n    /**\n     * Glyph background color.\n     */\n    get backgroundColor(): THREE.Color {\n        return this.m_params.backgroundColor!;\n    }\n    set backgroundColor(value: THREE.Color) {\n        this.m_params.backgroundColor!.copy(value);\n    }\n\n    /**\n     * Glyph opacity.\n     */\n    get opacity(): number {\n        return this.m_params.opacity!;\n    }\n    set opacity(value: number) {\n        this.m_params.opacity = value;\n    }\n\n    /**\n     * Glyph background opacity.\n     */\n    get backgroundOpacity(): number {\n        return this.m_params.backgroundOpacity!;\n    }\n    set backgroundOpacity(value: number) {\n        this.m_params.backgroundOpacity = value;\n    }\n\n    /**\n     * Clone this [[TextRenderStyle]].\n     *\n     * @param params - Input [[TextRenderParameters]].\n     *\n     * @returns Cloned [[TextRenderStyle]].\n     */\n    clone(params: TextRenderParameters = {}): TextRenderStyle {\n        return new TextRenderStyle({ ...this.m_params, ...params });\n    }\n\n    /**\n     * Copy other [[TextRenderStyle]] properties into this object instance.\n     *\n     * @param source - The source object to be copied.\n     *\n     * @returns reference to `this` object.\n     */\n    copy(source: TextRenderStyle): TextRenderStyle {\n        // Given that all source and this params are always defined:\n        this.m_params.fontName = source.fontName;\n        this.m_params.fontSize = { ...source.fontSize };\n        this.m_params.fontStyle = source.fontStyle;\n        this.m_params.fontVariant = source.fontVariant;\n        this.m_params.rotation = source.rotation;\n        this.m_params.color!.copy(source.color);\n        this.m_params.backgroundColor!.copy(source.backgroundColor);\n        this.m_params.opacity = source.opacity;\n        this.m_params.backgroundOpacity = source.backgroundOpacity;\n        return this;\n    }\n}\n\n/**\n * [[TextCanvas]] text layout parameters.\n */\nexport interface TextLayoutParameters {\n    tracking?: number;\n    leading?: number;\n    maxLines?: number;\n    lineWidth?: number;\n    canvasRotation?: number;\n    lineRotation?: number;\n    wrappingMode?: WrappingMode;\n    verticalAlignment?: VerticalAlignment;\n    horizontalAlignment?: HorizontalAlignment;\n    placements?: TextPlacements;\n}\n\n/**\n * [[TextCanvas]] text rendering style.\n */\nexport class TextLayoutStyle {\n    private m_params: TextLayoutParameters;\n\n    /**\n     * Creates a new `TextLayoutStyle`.\n     *\n     * @param params - Input [[TextLayoutParameters]].\n     *\n     * @returns New `TextLayoutStyle`.\n     */\n    constructor(params: TextLayoutParameters = {}) {\n        // Solve alignment and placement dependencies and fallbacks.\n        const { horizontalAlignment, verticalAlignment, placements } = resolvePlacementAndAlignment(\n            params.horizontalAlignment,\n            params.verticalAlignment,\n            params.placements\n        );\n        this.m_params = {\n            tracking:\n                params.tracking !== undefined ? params.tracking : DefaultTextStyle.DEFAULT_TRACKING,\n            leading:\n                params.leading !== undefined ? params.leading : DefaultTextStyle.DEFAULT_LEADING,\n            maxLines:\n                params.maxLines !== undefined\n                    ? params.maxLines\n                    : DefaultTextStyle.DEFAULT_MAX_LINES,\n            lineWidth:\n                params.lineWidth !== undefined\n                    ? params.lineWidth\n                    : DefaultTextStyle.DEFAULT_LINE_WIDTH,\n            canvasRotation:\n                params.canvasRotation !== undefined\n                    ? params.canvasRotation\n                    : DefaultTextStyle.DEFAULT_CANVAS_ROTATION,\n            lineRotation:\n                params.lineRotation !== undefined\n                    ? params.lineRotation\n                    : DefaultTextStyle.DEFAULT_LINE_ROTATION,\n            wrappingMode:\n                params.wrappingMode !== undefined\n                    ? params.wrappingMode\n                    : DefaultTextStyle.DEFAULT_WRAPPING_MODE,\n            verticalAlignment,\n            horizontalAlignment,\n            placements\n        };\n    }\n\n    /**\n     * Current [[TextLayoutParameters]] for this style.\n     */\n    get params(): TextLayoutParameters {\n        return this.m_params;\n    }\n    set params(value: TextLayoutParameters) {\n        this.m_params = { ...this.m_params, ...value };\n    }\n\n    /**\n     * Inter-glyph spacing (pixels). Scaled by [[FontSize]].\n     */\n    get tracking(): number {\n        return this.m_params.tracking!;\n    }\n    set tracking(value: number) {\n        this.m_params.tracking = value;\n    }\n\n    /**\n     * Inter-line spacing (pixels). Scaled by [[FontSize]].\n     */\n    get leading(): number {\n        return this.m_params.leading!;\n    }\n    set leading(value: number) {\n        this.m_params.leading = value;\n    }\n\n    /**\n     * Maximum number of lines to be considered when using [[TextCanvas]].\n     */\n    get maxLines(): number {\n        return this.m_params.maxLines!;\n    }\n    set maxLines(value: number) {\n        this.m_params.maxLines = value;\n    }\n\n    /**\n     * Maximum line width (pixels).\n     */\n    get lineWidth(): number {\n        return this.m_params.lineWidth!;\n    }\n    set lineWidth(value: number) {\n        this.m_params.lineWidth = value;\n    }\n\n    /**\n     * [[TextCanvas]] rotation (radians).\n     */\n    get canvasRotation(): number {\n        return this.m_params.canvasRotation!;\n    }\n    set canvasRotation(value: number) {\n        this.m_params.canvasRotation = value;\n    }\n\n    /**\n     * Line typesetting rotation (radians).\n     */\n    get lineRotation(): number {\n        return this.m_params.lineRotation!;\n    }\n    set lineRotation(value: number) {\n        this.m_params.lineRotation = value;\n    }\n\n    /**\n     * Wrapping (line-breaking) mode.\n     */\n    get wrappingMode(): WrappingMode {\n        return this.m_params.wrappingMode!;\n    }\n    set wrappingMode(value: WrappingMode) {\n        this.m_params.wrappingMode = value;\n    }\n\n    /**\n     * Text position regarding the baseline.\n     */\n    get verticalAlignment(): VerticalAlignment {\n        return this.m_params.verticalAlignment!;\n    }\n    set verticalAlignment(value: VerticalAlignment) {\n        this.m_params.verticalAlignment = value;\n    }\n\n    /**\n     * Text position inside a line.\n     */\n    get horizontalAlignment(): HorizontalAlignment {\n        return this.m_params.horizontalAlignment!;\n    }\n    set horizontalAlignment(value: HorizontalAlignment) {\n        this.m_params.horizontalAlignment = value;\n    }\n\n    /**\n     * Text placement options relative to label anchor (origin).\n     *\n     * @note [[TextPlacement]]s options may override alignment settings.\n     */\n    get placements(): TextPlacements {\n        return this.m_params.placements!;\n    }\n    set placements(value: TextPlacements) {\n        const { horizontalAlignment, verticalAlignment, placements } = resolvePlacementAndAlignment(\n            this.horizontalAlignment,\n            this.verticalAlignment,\n            value\n        );\n        this.m_params.horizontalAlignment = horizontalAlignment;\n        this.m_params.verticalAlignment = verticalAlignment;\n        this.m_params.placements = placements;\n    }\n\n    /**\n     * Clone this [[TextLayoutStyle]].\n     *\n     * @param params - Input [[TextLayoutParameters]].\n     *\n     * @returns Cloned [[TextLayoutStyle]].\n     */\n    clone(params: TextLayoutParameters = {}): TextLayoutStyle {\n        return new TextLayoutStyle({ ...this.m_params, ...params });\n    }\n\n    /**\n     * Copy other [[TextLayoutStyle]] properties into this object instance.\n     *\n     * @param other - The object to be copied.\n     *\n     * @returns reference to `this` object.\n     */\n    copy(other: TextLayoutStyle): TextLayoutStyle {\n        this.params = { ...other.params };\n        return this;\n    }\n}\n\n/**\n * Deduce alignment and placement attributes depending on the availability.\n *\n * If placement is defined it may override alignment settings, if no attributes are\n * provided they may be retrieved from defaults.\n *\n * @param hAlignment - The optional horizontal alignment.\n * @param vAlignment - The vertical alignment - optional.\n * @param placementsOpt - Possible text placements - optional.\n * @internal\n */\nexport function resolvePlacementAndAlignment(\n    hAlignment?: HorizontalAlignment,\n    vAlignment?: VerticalAlignment,\n    placementsOpt?: TextPlacements\n): {\n    horizontalAlignment: HorizontalAlignment;\n    verticalAlignment: VerticalAlignment;\n    placements: TextPlacements;\n} {\n    // Make a deep copy or create new array from defaults.\n    const placements: TextPlacements =\n        placementsOpt?.map(v => ({ ...v })) ??\n        DefaultTextStyle.DEFAULT_PLACEMENTS.map(v => ({ ...v }));\n    // Ignore alignment attributes when placements attributes are defined or provide default\n    // values if none of them are provided.\n    // NOTE: Alignment override may be removed if we decide to support both attributes.\n    const horizontalAlignment =\n        placements.length > 0\n            ? hAlignFromPlacement(placements[0].h)\n            : hAlignment ?? DefaultTextStyle.DEFAULT_HORIZONTAL_ALIGNMENT;\n\n    const verticalAlignment =\n        placements.length > 0\n            ? vAlignFromPlacement(placements[0].v)\n            : vAlignment ?? DefaultTextStyle.DEFAULT_VERTICAL_ALIGNMENT;\n\n    return { horizontalAlignment, verticalAlignment, placements };\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    BufferAttribute,\n    ColorUtils,\n    Env,\n    Expr,\n    getPropertyValue,\n    isExtrudedLineTechnique,\n    isExtrudedPolygonTechnique,\n    isShaderTechnique,\n    isStandardTechnique,\n    isTerrainTechnique,\n    isTextureBuffer,\n    parseStringEncodedColor,\n    ShaderTechnique,\n    Technique,\n    techniqueDescriptors,\n    TextureProperties,\n    TEXTURE_PROPERTY_KEYS,\n    TRANSPARENCY_PROPERTY_KEYS,\n    Value\n} from \"@here/harp-datasource-protocol\";\nimport {\n    CirclePointsMaterial,\n    disableBlending,\n    enableBlending,\n    HighPrecisionLineMaterial,\n    MapMeshBasicMaterial,\n    MapMeshStandardMaterial,\n    SolidLineMaterial\n} from \"@here/harp-materials\";\nimport { assert, LoggerManager, pick } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\nimport { DisplacedMesh } from \"./geometry/DisplacedMesh\";\nimport { SolidLineMesh } from \"./geometry/SolidLineMesh\";\nimport { MapAdapterUpdateEnv, MapMaterialAdapter, StyledProperties } from \"./MapMaterialAdapter\";\nimport { Circles, Squares } from \"./MapViewPoints\";\nimport { toPixelFormat, toTextureDataType, toTextureFilter, toWrappingMode } from \"./ThemeHelpers\";\nimport { Tile } from \"./Tile\";\n\nconst logger = LoggerManager.instance.create(\"DecodedTileHelpers\");\n\n/**\n * The structure of the options to pass into [[createMaterial]].\n */\nexport interface MaterialOptions {\n    /**\n     * The shader [[Technique]] to choose.\n     */\n    technique: Technique;\n\n    /**\n     * Environment used to evaluate dynamic technique attributes.\n     *\n     * Usually {@link MapView.env}.\n     */\n    env: Env;\n\n    /**\n     * Properties to skip.\n     *\n     * @see [[applyTechniqueToMaterial]]\n     */\n    skipExtraProps?: string[];\n\n    /**\n     * `RawShaderMaterial` instances need to know about the fog at instantiation in order to avoid\n     * recompiling them manually later (ThreeJS does not update fog for `RawShaderMaterial`s).\n     */\n    fog?: boolean;\n\n    /**\n     * Whether shadows are enabled or not, this is required because we change the material used.\n     */\n    shadowsEnabled?: boolean;\n}\n\n/**\n * Create a material, depending on the rendering technique provided in the options.\n *\n * @param options - The material options the subsequent functions need.\n * @param materialUpdateCallback - Optional callback when the material gets updated,\n *                               e.g. after texture loading.\n *\n * @returns new material instance that matches `technique.name`\n */\nexport function createMaterial(\n    options: MaterialOptions,\n    textureReadyCallback?: (texture: THREE.Texture) => void\n): THREE.Material | undefined {\n    const technique = options.technique;\n    const Constructor = getMaterialConstructor(technique, options.shadowsEnabled === true);\n\n    const settings: { [key: string]: any } = {};\n\n    if (Constructor === undefined) {\n        return undefined;\n    }\n\n    if (\n        Constructor.prototype instanceof THREE.RawShaderMaterial &&\n        Constructor !== HighPrecisionLineMaterial\n    ) {\n        settings.fog = options.fog;\n    }\n    if (options.shadowsEnabled === true && technique.name === \"fill\") {\n        settings.removeDiffuseLight = true;\n    }\n\n    const material = new Constructor(settings);\n\n    if (technique.id !== undefined) {\n        material.name = technique.id;\n    }\n\n    if (isExtrudedPolygonTechnique(technique)) {\n        material.flatShading = true;\n    }\n\n    material.depthTest = isExtrudedPolygonTechnique(technique) && technique.depthTest !== false;\n\n    if (\n        isStandardTechnique(technique) ||\n        isTerrainTechnique(technique) ||\n        isExtrudedPolygonTechnique(technique)\n    ) {\n        TEXTURE_PROPERTY_KEYS.forEach((texturePropertyName: string) => {\n            const textureProperty = (technique as any)[texturePropertyName];\n            if (textureProperty === undefined) {\n                return;\n            }\n\n            const onLoad = (texture: THREE.Texture) => {\n                const properties = (technique as any)[\n                    texturePropertyName + \"Properties\"\n                ] as TextureProperties;\n                if (properties !== undefined) {\n                    if (properties.wrapS !== undefined) {\n                        texture.wrapS = toWrappingMode(properties.wrapS);\n                    }\n                    if (properties.wrapT !== undefined) {\n                        texture.wrapT = toWrappingMode(properties.wrapT);\n                    }\n                    if (properties.magFilter !== undefined) {\n                        texture.magFilter = toTextureFilter(properties.magFilter);\n                    }\n                    if (properties.minFilter !== undefined) {\n                        texture.minFilter = toTextureFilter(properties.minFilter);\n                    }\n                    if (properties.flipY !== undefined) {\n                        texture.flipY = properties.flipY;\n                    }\n                    if (properties.repeatU !== undefined) {\n                        texture.repeat.x = properties.repeatU;\n                    }\n                    if (properties.repeatV !== undefined) {\n                        texture.repeat.y = properties.repeatV;\n                    }\n                }\n                (material as any)[texturePropertyName] = texture;\n                texture.needsUpdate = true;\n                material.needsUpdate = true;\n\n                if (textureReadyCallback) {\n                    textureReadyCallback(texture);\n                }\n            };\n\n            const onError = (error: ErrorEvent | string) => {\n                logger.error(\"#createMaterial: Failed to load texture: \", error);\n            };\n\n            let textureUrl: string | undefined;\n            if (typeof textureProperty === \"string\") {\n                textureUrl = textureProperty;\n            } else if (isTextureBuffer(textureProperty)) {\n                if (textureProperty.type === \"image/raw\") {\n                    const properties = textureProperty.dataTextureProperties;\n                    if (properties !== undefined) {\n                        const textureDataType: THREE.TextureDataType | undefined = properties.type\n                            ? toTextureDataType(properties.type)\n                            : undefined;\n                        const textureBuffer = getTextureBuffer(\n                            textureProperty.buffer,\n                            textureDataType\n                        );\n\n                        const texture = new THREE.DataTexture(\n                            textureBuffer,\n                            properties.width,\n                            properties.height,\n                            properties.format ? toPixelFormat(properties.format) : undefined,\n                            textureDataType\n                        );\n                        onLoad(texture);\n                    } else {\n                        onError(\"no data texture properties provided.\");\n                    }\n                } else {\n                    const textureBlob = new Blob([textureProperty.buffer], {\n                        type: textureProperty.type\n                    });\n                    textureUrl = URL.createObjectURL(textureBlob);\n                }\n            }\n\n            if (textureUrl) {\n                new THREE.TextureLoader().load(\n                    textureUrl,\n                    onLoad,\n                    undefined, // onProgress\n                    onError\n                );\n            }\n        });\n    }\n\n    if (isShaderTechnique(technique)) {\n        // Special case for ShaderTechnique.\n        applyShaderTechniqueToMaterial(technique, material);\n    } else {\n        MapMaterialAdapter.create(material, getMainMaterialStyledProps(technique));\n    }\n    return material;\n}\n\n/**\n * Returns a [[THREE.BufferAttribute]] created from a provided\n * {@link @here/harp-datasource-protocol#BufferAttribute} object.\n *\n * @param attribute - BufferAttribute a WebGL compliant buffer\n */\nexport function getBufferAttribute(attribute: BufferAttribute): THREE.BufferAttribute {\n    switch (attribute.type) {\n        case \"float\":\n            return new THREE.BufferAttribute(\n                new Float32Array(attribute.buffer),\n                attribute.itemCount\n            );\n        case \"uint8\":\n            return new THREE.BufferAttribute(\n                new Uint8Array(attribute.buffer),\n                attribute.itemCount,\n                attribute.normalized\n            );\n        case \"uint16\":\n            return new THREE.BufferAttribute(\n                new Uint16Array(attribute.buffer),\n                attribute.itemCount,\n                attribute.normalized\n            );\n        case \"uint32\":\n            return new THREE.BufferAttribute(\n                new Uint32Array(attribute.buffer),\n                attribute.itemCount,\n                attribute.normalized\n            );\n        case \"int8\":\n            return new THREE.BufferAttribute(\n                new Int8Array(attribute.buffer),\n                attribute.itemCount,\n                attribute.normalized\n            );\n        case \"int16\":\n            return new THREE.BufferAttribute(\n                new Int16Array(attribute.buffer),\n                attribute.itemCount,\n                attribute.normalized\n            );\n        case \"int32\":\n            return new THREE.BufferAttribute(\n                new Int32Array(attribute.buffer),\n                attribute.itemCount,\n                attribute.normalized\n            );\n        default:\n            throw new Error(`unsupported buffer of type ${attribute.type}`);\n    } // switch\n}\n\n/**\n * Determines if a technique uses THREE.Object3D instances.\n * @param technique - The technique to check.\n * @returns true if technique uses THREE.Object3D, false otherwise.\n */\nexport function usesObject3D(technique: Technique): boolean {\n    const name = technique.name;\n    return (\n        name !== undefined &&\n        name !== \"text\" &&\n        name !== \"labeled-icon\" &&\n        name !== \"line-marker\" &&\n        name !== \"label-rejection-line\"\n    );\n}\n\n/**\n * Builds the object associated with the given technique.\n *\n * @param technique - The technique.\n * @param geometry - The object's geometry.\n * @param material - The object's material.\n * @param tile - The tile where the object is located.\n * @param elevationEnabled - True if elevation is enabled, false otherwise.\n */\nexport function buildObject(\n    technique: Technique,\n    geometry: THREE.BufferGeometry,\n    material: THREE.Material | THREE.Material[],\n    tile: Tile,\n    elevationEnabled: boolean\n): THREE.Object3D {\n    assert(technique.name !== undefined);\n\n    switch (technique.name) {\n        case \"extruded-line\":\n        case \"standard\":\n        case \"extruded-polygon\":\n        case \"fill\":\n            return elevationEnabled\n                ? new DisplacedMesh(geometry, material, () => ({\n                      min: tile.elevationRange.minElevation,\n                      max: tile.elevationRange.maxElevation\n                  }))\n                : new THREE.Mesh(geometry, material);\n        case \"terrain\":\n            return new THREE.Mesh(geometry, material);\n        case \"dashed-line\":\n        case \"solid-line\":\n            return elevationEnabled\n                ? new DisplacedMesh(\n                      geometry,\n                      material,\n                      () => ({\n                          min: tile.elevationRange.minElevation,\n                          max: tile.elevationRange.maxElevation\n                      }),\n                      SolidLineMesh.raycast\n                  )\n                : new SolidLineMesh(geometry, material);\n\n        case \"circles\":\n            return new Circles(geometry, material);\n\n        case \"squares\":\n            return new Squares(geometry, material);\n\n        case \"line\":\n            return new THREE.LineSegments(geometry, material);\n\n        case \"segments\":\n            return new THREE.LineSegments(geometry, material);\n\n        case \"shader\": {\n            assert(isShaderTechnique(technique), \"Invalid technique\");\n\n            switch (technique.primitive) {\n                case \"line\":\n                    return new THREE.Line(geometry, material);\n                case \"segments\":\n                    return new THREE.LineSegments(geometry, material);\n                case \"point\":\n                    return new THREE.Points(geometry, material);\n                case \"mesh\":\n                    return new THREE.Mesh(geometry, material);\n            }\n        }\n    }\n    assert(false, \"Invalid technique\");\n    return new THREE.Object3D();\n}\n\n/**\n * Non material properties of [[BaseTechnique]]\n */\nexport const BASE_TECHNIQUE_NON_MATERIAL_PROPS = [\"name\", \"id\", \"renderOrder\", \"transient\"];\n\n/**\n * Generic material type constructor.\n */\nexport type MaterialConstructor = new (params?: {}) => THREE.Material;\n\n/**\n * Returns a [[MaterialConstructor]] basing on provided technique object.\n *\n * @param technique - [[Technique]] object which the material will be based on.\n * @param shadowsEnabled - Whether the material can accept shadows, this is required for some\n * techniques to decide which material to create.\n */\nexport function getMaterialConstructor(\n    technique: Technique,\n    shadowsEnabled: boolean\n): MaterialConstructor | undefined {\n    if (technique.name === undefined) {\n        return undefined;\n    }\n\n    switch (technique.name) {\n        case \"extruded-line\":\n            if (!isExtrudedLineTechnique(technique)) {\n                throw new Error(\"Invalid extruded-line technique\");\n            }\n            return technique.shading === \"standard\"\n                ? MapMeshStandardMaterial\n                : MapMeshBasicMaterial;\n\n        case \"standard\":\n        case \"terrain\":\n        case \"extruded-polygon\":\n            return MapMeshStandardMaterial;\n\n        case \"dashed-line\":\n        case \"solid-line\":\n            return SolidLineMaterial;\n\n        case \"fill\":\n            return shadowsEnabled ? MapMeshStandardMaterial : MapMeshBasicMaterial;\n\n        case \"squares\":\n            return THREE.PointsMaterial;\n\n        case \"circles\":\n            return CirclePointsMaterial;\n\n        case \"line\":\n        case \"segments\":\n            return THREE.LineBasicMaterial;\n\n        case \"shader\":\n            return THREE.ShaderMaterial;\n\n        case \"text\":\n        case \"labeled-icon\":\n        case \"line-marker\":\n        case \"label-rejection-line\":\n            return undefined;\n    }\n}\n\n/**\n * Styled properties of main material (created by [[createMaterial]]) managed by\n * [[MapObjectAdapter]].\n */\nfunction getMainMaterialStyledProps(technique: Technique): StyledProperties {\n    switch (technique.name) {\n        case \"dashed-line\":\n        case \"solid-line\": {\n            const baseProps: StyledProperties = pick(technique, [\n                \"color\",\n                \"outlineColor\",\n                \"transparent\",\n                \"opacity\",\n                \"caps\",\n                \"drawRangeStart\",\n                \"drawRangeEnd\",\n                \"dashes\",\n                \"dashColor\",\n                \"polygonOffset\",\n                \"polygonOffsetFactor\",\n                \"polygonOffsetUnits\"\n            ]);\n            baseProps.lineWidth = buildMetricValueEvaluator(\n                technique.lineWidth ?? 0, // Compatibility: `undefined` lineWidth means hidden.\n                // tslint:disable-next-line: deprecation\n                technique.metricUnit\n            );\n            baseProps.outlineWidth = buildMetricValueEvaluator(\n                technique.outlineWidth,\n                // tslint:disable-next-line: deprecation\n                technique.metricUnit\n            );\n            baseProps.dashSize = buildMetricValueEvaluator(\n                technique.dashSize,\n                // tslint:disable-next-line: deprecation\n                technique.metricUnit\n            );\n            baseProps.gapSize = buildMetricValueEvaluator(\n                technique.gapSize,\n                // tslint:disable-next-line: deprecation\n                technique.metricUnit\n            );\n            baseProps.offset = buildMetricValueEvaluator(\n                technique.offset,\n                // tslint:disable-next-line: deprecation\n                technique.metricUnit\n            );\n            return baseProps;\n        }\n        case \"fill\":\n            return pick(technique, [\n                \"color\",\n                \"transparent\",\n                \"opacity\",\n                \"polygonOffset\",\n                \"polygonOffsetFactor\",\n                \"polygonOffsetUnits\"\n            ]);\n        case \"standard\":\n        case \"terrain\":\n        case \"extruded-polygon\": {\n            const baseProps: StyledProperties = pick(technique, [\n                \"vertexColors\",\n                \"wireframe\",\n                \"roughness\",\n                \"metalness\",\n                \"alphaTest\",\n                \"depthTest\",\n                \"transparent\",\n                \"opacity\",\n                \"emissive\",\n                \"emissiveIntensity\",\n                \"refractionRatio\",\n                \"normalMapType\"\n                // All texture related properties are skipped as for now as they are handled by\n                // [[createMaterial]] directly without possibility for them to be dynamic.\n                // TODO: move handling of texture-like params to [[MapMaterialAdapter]] with proper\n                // support for dynamic params\n            ]);\n            if (technique.vertexColors !== true) {\n                baseProps.color = technique.color;\n            }\n            return baseProps;\n        }\n        case \"circles\":\n        case \"squares\":\n            return pick(technique, [\"color\", \"size\", \"opacity\", \"transparent\"]);\n        case \"extruded-line\":\n            return pick(technique, [\n                \"color\",\n                \"wireframe\",\n                \"transparent\",\n                \"opacity\",\n                \"polygonOffset\",\n                \"polygonOffsetFactor\",\n                \"polygonOffsetUnits\"\n            ]);\n        case \"line\":\n        case \"segments\":\n            return pick(technique, [\"color\", \"transparent\", \"opacity\"]);\n        default:\n            return {};\n    }\n}\n\n/**\n * Convert metric style property to expression that accounts {@link MapView.pixelToWorld} if\n * `metricUnit === 'Pixel'`.\n */\nexport function buildMetricValueEvaluator(\n    value: Expr | Value | undefined,\n    metricUnit: string | undefined\n) {\n    if (value === undefined || value === null) {\n        return value;\n    }\n    if (typeof value === \"string\") {\n        if (value.endsWith(\"px\")) {\n            metricUnit = \"Pixel\";\n            value = Number.parseFloat(value);\n        } else if (value.endsWith(\"m\")) {\n            value = Number.parseFloat(value);\n        }\n    }\n    if (metricUnit === \"Pixel\") {\n        return (context: MapAdapterUpdateEnv) => {\n            const pixelToWorld = (context.env.lookup(\"$pixelToMeters\") as number) ?? 1;\n            const evaluated = getPropertyValue(value, context.env);\n            return pixelToWorld * evaluated;\n        };\n    } else {\n        return value;\n    }\n}\n\n/**\n * Allows to easy parse/encode technique's base color property value as number coded color.\n *\n * Function takes care about property parsing, interpolation and encoding if neccessary.\n *\n * @see ColorUtils\n * @param technique - the technique where we search for base (transparency) color value\n * @param env - {@link @here/harp-datasource-protocol#Env} instance\n *              used to evaluate {@link @here/harp-datasource-protocol#Expr}\n *              based properties of [[Technique]]\n * @returns [[number]] encoded color value (in custom #TTRRGGBB) format or `undefined` if\n * base color property is not defined in the technique passed.\n */\nexport function evaluateBaseColorProperty(technique: Technique, env: Env): number | undefined {\n    const baseColorProp = getBaseColorProp(technique);\n    if (baseColorProp !== undefined) {\n        return evaluateColorProperty(baseColorProp, env);\n    }\n    return undefined;\n}\n\n/**\n * Apply [[ShaderTechnique]] parameters to material.\n *\n * @param technique - the [[ShaderTechnique]] which requires special handling\n * @param material - material to which technique will be applied\n */\nfunction applyShaderTechniqueToMaterial(technique: ShaderTechnique, material: THREE.Material) {\n    if (technique.transparent) {\n        enableBlending(material);\n    } else {\n        disableBlending(material);\n    }\n\n    // The shader technique takes the argument from its `params' member.\n    const params = technique.params as { [key: string]: any };\n    // Remove base color and transparency properties from the processed set.\n    const baseColorPropName = getBaseColorPropName(technique);\n    const hasBaseColor = baseColorPropName && baseColorPropName in technique.params;\n    const props = Object.getOwnPropertyNames(params).filter(propertyName => {\n        // Omit base color and related transparency attributes if its defined in technique\n        if (\n            baseColorPropName === propertyName ||\n            (hasBaseColor && TRANSPARENCY_PROPERTY_KEYS.indexOf(propertyName) !== -1)\n        ) {\n            return false;\n        }\n        const prop = propertyName as keyof typeof params;\n        if (prop === \"name\") {\n            // skip reserved property names\n            return false;\n        }\n        return true;\n    });\n\n    // Apply all technique properties omitting base color and transparency attributes.\n    props.forEach(propertyName => {\n        // TODO: Check if properties values should not be interpolated, possible bug in old code!\n        // This behavior is kept in the new version too, level is set to undefined.\n        applyTechniquePropertyToMaterial(material, propertyName, params[propertyName]);\n    });\n\n    if (hasBaseColor) {\n        const propColor = baseColorPropName as keyof THREE.Material;\n        // Finally apply base color and related properties to material (opacity, transparent)\n        applyBaseColorToMaterial(material, material[propColor], technique, params[propColor]);\n    }\n}\n\n/**\n * Apply single and generic technique property to corresponding material parameter.\n *\n * @note Special handling for material attributes of [[THREE.Color]] type is provided thus it\n * does not provide constructor that would take [[string]] or [[number]] values.\n *\n * @param material - target material\n * @param propertyName - material and technique parameter name (or index) that is to be transferred\n * @param techniqueAttrValue - technique property value which will be applied to material attribute\n * @param env - {@link @here/harp-datasource-protocol#Env} instance used\n *              to evaluate {@link @here/harp-datasource-protocol#Expr}\n *              based properties of [[Technique]]\n */\nfunction applyTechniquePropertyToMaterial(\n    material: THREE.Material,\n    propertyName: string,\n    techniqueAttrValue: Value,\n    env?: Env\n) {\n    const m = material as any;\n    if (m[propertyName] instanceof THREE.Color) {\n        applySecondaryColorToMaterial(\n            material[propertyName as keyof THREE.Material],\n            techniqueAttrValue,\n            env\n        );\n    } else {\n        const value = evaluateProperty(techniqueAttrValue, env);\n        if (value !== null) {\n            m[propertyName] = value;\n        }\n    }\n}\n\n/**\n * Apply technique color to material taking special care with transparent (RGBA) colors.\n *\n * @note This function is intended to be used with secondary, triary etc. technique colors,\n * not the base ones that may contain transparency information. Such colors should be processed\n * with [[applyTechniqueBaseColorToMaterial]] function.\n *\n * @param technique - an technique the applied color comes from\n * @param material - the material to which color is applied\n * @param prop - technique property (color) name\n * @param value - color value\n * @param env - {@link @here/harp-datasource-protocol#Env} instance used\n *              to evaluate {@link @here/harp-datasource-protocol#Expr}\n *              based properties of [[Technique]]\n */\nexport function applySecondaryColorToMaterial(\n    materialColor: THREE.Color,\n    techniqueColor: Value | Expr,\n    env?: Env\n) {\n    let value = evaluateColorProperty(techniqueColor, env);\n    if (value === undefined) {\n        return;\n    }\n    if (ColorUtils.hasAlphaInHex(value)) {\n        logger.warn(\"Used RGBA value for technique color without transparency support!\");\n        // Just for clarity remove transparency component, even if that would be ignored\n        // by THREE.Color.setHex() function.\n        value = ColorUtils.removeAlphaFromHex(value);\n    }\n\n    materialColor.setHex(value);\n}\n\n/**\n * Apply technique base color (transparency support) to material with modifying material opacity.\n *\n * This method applies main (or base) technique color with transparency support to the corresponding\n * material color, with an effect on entire [[THREE.Material]] __opacity__ and __transparent__\n * attributes.\n *\n * @note Transparent colors should be processed as the very last technique attributes,\n * since their effect on material properties like [[THREE.Material.opacity]] and\n * [[THREE.Material.transparent]] could be overridden by corresponding technique params.\n *\n * @param technique - an technique the applied color comes from\n * @param material - the material to which color is applied\n * @param prop - technique property (color) name\n * @param value - color value in custom number format\n * @param env - {@link @here/harp-datasource-protocol#Env} instance used to evaluate\n *              {@link @here/harp-datasource-protocol#Expr} based properties of [[Technique]]\n */\nexport function applyBaseColorToMaterial(\n    material: THREE.Material,\n    materialColor: THREE.Color,\n    technique: Technique,\n    techniqueColor: Value,\n    env?: Env\n) {\n    const colorValue = evaluateColorProperty(techniqueColor, env);\n    if (colorValue === undefined) {\n        return;\n    }\n\n    const { r, g, b, a } = ColorUtils.getRgbaFromHex(colorValue);\n    // Override material opacity and blending by mixing technique defined opacity\n    // with main color transparency\n    const tech = technique as any;\n    let opacity = a;\n    if (tech.opacity !== undefined) {\n        opacity *= evaluateProperty(tech.opacity, env);\n    }\n\n    opacity = THREE.MathUtils.clamp(opacity, 0, 1);\n    material.opacity = opacity;\n    materialColor.setRGB(r, g, b);\n\n    const opaque = opacity >= 1.0;\n    if (!opaque) {\n        enableBlending(material);\n    } else {\n        disableBlending(material);\n    }\n}\n\n/**\n * Calculates the value of the technique defined property.\n *\n * Function takes care about property interpolation (when @param `env` is set) as also parsing\n * string encoded numbers.\n *\n * @note Use with care, because function does not recognize property type.\n * @param value - the value of color property defined in technique\n * @param env - {@link @here/harp-datasource-protocol#Env} instance used to evaluate\n *              {@link @here/harp-datasource-protocol#Expr} based properties of [[Technique]]\n */\nfunction evaluateProperty(value: any, env?: Env): any {\n    if (env !== undefined && Expr.isExpr(value)) {\n        value = getPropertyValue(value, env);\n    }\n    return value;\n}\n\n/**\n * Calculates the numerical value of the technique defined color property.\n *\n * Function takes care about color interpolation (when @param `env is set) as also parsing\n * string encoded colors.\n *\n * @note Use with care, because function does not recognize property type.\n * @param value - the value of color property defined in technique\n * @param env - {@link @here/harp-datasource-protocol#Env} instance used to evaluate\n *              {@link @here/harp-datasource-protocol#Expr} based properties of [[Technique]]\n */\nexport function evaluateColorProperty(value: Value, env?: Env): number | undefined {\n    value = evaluateProperty(value, env);\n\n    if (value === undefined || value === null) {\n        return undefined;\n    }\n\n    if (typeof value === \"number\") {\n        return value;\n    }\n\n    if (typeof value === \"string\") {\n        const parsed = parseStringEncodedColor(value);\n        if (parsed !== undefined) {\n            return parsed;\n        }\n    }\n\n    logger.error(`Unsupported color format: '${value}'`);\n    return undefined;\n}\n\n/**\n * Allows to access base color property value for given technique.\n *\n * The color value may be encoded in [[number]], [[string]] or even as\n * [[InterpolateProperty]].\n *\n * @param technique - The techniqe where we seach for base color property.\n * @returns The value of technique color used to apply transparency.\n */\nfunction getBaseColorProp(technique: Technique): any {\n    const baseColorPropName = getBaseColorPropName(technique);\n    if (baseColorPropName !== undefined) {\n        if (!isShaderTechnique(technique)) {\n            const propColor = baseColorPropName as keyof typeof technique;\n            return technique[propColor];\n        } else {\n            const params = technique.params as { [key: string]: any };\n            const propColor = baseColorPropName as keyof typeof params;\n            return params[propColor];\n        }\n    }\n    return undefined;\n}\n\nfunction getBaseColorPropName(technique: Technique): string | undefined {\n    const techDescriptor = techniqueDescriptors[technique.name];\n    return techDescriptor !== undefined ? techDescriptor.attrTransparencyColor : undefined;\n}\n\nfunction getTextureBuffer(\n    buffer: ArrayBuffer,\n    textureDataType: THREE.TextureDataType | undefined\n): THREE.TypedArray {\n    if (textureDataType === undefined) {\n        return new Uint8Array(buffer);\n    }\n\n    switch (textureDataType) {\n        case THREE.UnsignedByteType:\n            return new Uint8Array(buffer);\n        case THREE.ByteType:\n            return new Int8Array(buffer);\n        case THREE.ShortType:\n            return new Int16Array(buffer);\n        case THREE.UnsignedShortType:\n            return new Uint16Array(buffer);\n        case THREE.IntType:\n            return new Int32Array(buffer);\n        case THREE.UnsignedIntType:\n            return new Uint32Array(buffer);\n        case THREE.FloatType:\n            return new Float32Array(buffer);\n        case THREE.HalfFloatType:\n            return new Uint16Array(buffer);\n    }\n\n    throw new Error(\"Unsupported texture data type\");\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeoBoxExtentLike } from \"./GeoBoxExtentLike\";\nimport { GeoCoordinates } from \"./GeoCoordinates\";\n\nimport * as THREE from \"three\";\n\n/**\n * `GeoBox` is used to represent a bounding box in geo coordinates.\n */\nexport class GeoBox implements GeoBoxExtentLike {\n    /**\n     * Returns a `GeoBox` with the given geo coordinates.\n     *\n     * @param southWest - The south west position in geo coordinates.\n     * @param northEast - The north east position in geo coordinates.\n     */\n    static fromCoordinates(southWest: GeoCoordinates, northEast: GeoCoordinates): GeoBox {\n        return new GeoBox(southWest, northEast);\n    }\n\n    /**\n     * Returns a `GeoBox` with the given center and dimensions.\n     *\n     * @param center - The center position of geo box.\n     * @param extent - Box latitude and logitude span\n     */\n    static fromCenterAndExtents(center: GeoCoordinates, extent: GeoBoxExtentLike): GeoBox {\n        return new GeoBox(\n            new GeoCoordinates(\n                center.latitude - extent.latitudeSpan / 2,\n                center.longitude - extent.longitudeSpan / 2\n            ),\n            new GeoCoordinates(\n                center.latitude + extent.latitudeSpan / 2,\n                center.longitude + extent.longitudeSpan / 2\n            )\n        );\n    }\n\n    /**\n     * Constructs a new `GeoBox` with the given geo coordinates.\n     *\n     * @param southWest - The south west position in geo coordinates.\n     * @param northEast - The north east position in geo coordinates.\n     */\n    constructor(readonly southWest: GeoCoordinates, readonly northEast: GeoCoordinates) {}\n\n    /**\n     * Returns the minimum altitude or `undefined`.\n     */\n    get minAltitude(): number | undefined {\n        if (this.southWest.altitude === undefined || this.northEast.altitude === undefined) {\n            return undefined;\n        }\n        return Math.min(this.southWest.altitude, this.northEast.altitude);\n    }\n\n    /**\n     * Returns the maximum altitude or `undefined`.\n     */\n    get maxAltitude(): number | undefined {\n        if (this.southWest.altitude === undefined || this.northEast.altitude === undefined) {\n            return undefined;\n        }\n        return Math.max(this.southWest.altitude, this.northEast.altitude);\n    }\n\n    /**\n     * Returns the south latitude in degrees of this `GeoBox`.\n     */\n    get south(): number {\n        return this.southWest.latitude;\n    }\n\n    /**\n     * Returns the north altitude in degrees of this `GeoBox`.\n     */\n    get north(): number {\n        return this.northEast.latitude;\n    }\n\n    /**\n     * Returns the west longitude in degrees of this `GeoBox`.\n     */\n    get west(): number {\n        return this.southWest.longitude;\n    }\n\n    /**\n     * Returns the east longitude in degrees of this `GeoBox`.\n     */\n    get east(): number {\n        return this.northEast.longitude;\n    }\n\n    /**\n     * Returns the center of this `GeoBox`.\n     */\n    get center(): GeoCoordinates {\n        const latitude = (this.south + this.north) * 0.5;\n        const { west, east } = this;\n        const { minAltitude, altitudeSpan } = this;\n\n        let altitude: number | undefined;\n\n        if (minAltitude !== undefined && altitudeSpan !== undefined) {\n            altitude = minAltitude + altitudeSpan * 0.5;\n        }\n\n        if (west < east) {\n            return new GeoCoordinates(latitude, (west + east) * 0.5, altitude);\n        }\n\n        let longitude = (360 + east + west) * 0.5;\n\n        if (longitude > 360) {\n            longitude -= 360;\n        }\n\n        return new GeoCoordinates(latitude, longitude, altitude);\n    }\n\n    /**\n     * Returns the latitude span in radians.\n     */\n    get latitudeSpanInRadians(): number {\n        return THREE.MathUtils.degToRad(this.latitudeSpan);\n    }\n\n    /**\n     * Returns the longitude span in radians.\n     */\n    get longitudeSpanInRadians(): number {\n        return THREE.MathUtils.degToRad(this.longitudeSpan);\n    }\n\n    /**\n     * Returns the latitude span in degrees.\n     */\n    get latitudeSpan(): number {\n        return this.north - this.south;\n    }\n\n    get altitudeSpan(): number | undefined {\n        if (this.maxAltitude === undefined || this.minAltitude === undefined) {\n            return undefined;\n        }\n        return this.maxAltitude - this.minAltitude;\n    }\n\n    /**\n     * Returns the longitude span in degrees.\n     */\n    get longitudeSpan(): number {\n        let width = this.northEast.longitude - this.southWest.longitude;\n\n        if (width < 0) {\n            width += 360;\n        }\n\n        return width;\n    }\n\n    /**\n     * Returns the latitude span in degrees.\n     * @deprecated Use [[latitudeSpan]] instead.\n     */\n    get latitudeSpanInDegrees(): number {\n        return this.latitudeSpan;\n    }\n\n    /**\n     * Returns the longitude span in degrees.\n     * @deprecated Use [[longitudeSpan]] instead.\n     */\n    get longitudeSpanInDegrees(): number {\n        return this.longitudeSpan;\n    }\n\n    /**\n     * Returns `true` if the given geo coordinates are contained in this `GeoBox`.\n     *\n     * @param point - The geo coordinates.\n     */\n    contains(point: GeoCoordinates): boolean {\n        if (\n            point.altitude === undefined ||\n            this.minAltitude === undefined ||\n            this.maxAltitude === undefined\n        ) {\n            return this.containsHelper(point);\n        }\n\n        const isFlat = this.minAltitude === this.maxAltitude;\n        const isSameAltitude = this.minAltitude === point.altitude;\n        const isWithinAltitudeRange =\n            this.minAltitude <= point.altitude && this.maxAltitude > point.altitude;\n\n        // If box is flat, we should check the altitude and containment,\n        // otherwise we should check also altitude difference where we consider\n        // point to be inside if alt is from [m_minAltitude, m_maxAltitude) range!\n        if (isFlat ? isSameAltitude : isWithinAltitudeRange) {\n            return this.containsHelper(point);\n        }\n\n        return false;\n    }\n\n    /**\n     * Clones this `GeoBox` instance.\n     */\n    clone(): GeoBox {\n        return new GeoBox(this.southWest, this.northEast);\n    }\n\n    /**\n     * Update the bounding box by considering a given point.\n     *\n     * @param point - The point that may expand the bounding box.\n     */\n    growToContain(point: GeoCoordinates) {\n        this.southWest.latitude = Math.min(this.southWest.latitude, point.latitude);\n        this.southWest.longitude = Math.min(this.southWest.longitude, point.longitude);\n        this.southWest.altitude =\n            this.southWest.altitude !== undefined && point.altitude !== undefined\n                ? Math.min(this.southWest.altitude, point.altitude)\n                : this.southWest.altitude !== undefined\n                ? this.southWest.altitude\n                : point.altitude !== undefined\n                ? point.altitude\n                : undefined;\n\n        this.northEast.latitude = Math.max(this.northEast.latitude, point.latitude);\n        this.northEast.longitude = Math.max(this.northEast.longitude, point.longitude);\n        this.northEast.altitude =\n            this.northEast.altitude !== undefined && point.altitude !== undefined\n                ? Math.max(this.northEast.altitude, point.altitude)\n                : this.northEast.altitude !== undefined\n                ? this.northEast.altitude\n                : point.altitude !== undefined\n                ? point.altitude\n                : undefined;\n    }\n\n    private containsHelper(point: GeoCoordinates): boolean {\n        if (point.latitude < this.southWest.latitude || point.latitude >= this.northEast.latitude) {\n            return false;\n        }\n\n        const { west, east } = this;\n\n        if (east > west) {\n            return point.longitude >= west && point.longitude < east;\n        }\n\n        return point.longitude > east || point.longitude <= west;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Represents an object with `GeoCoordinates` like interface.\n */\nexport interface GeoCoordinatesLike {\n    /** The latitude in degrees. */\n    latitude: number;\n\n    /** The longitude in degrees. */\n    longitude: number;\n\n    /** The optional altitude in meters. */\n    altitude?: number;\n}\n\n/**\n * Type guard to assert that `object` conforms to {@link GeoCoordinatesLike} data interface.\n */\nexport function isGeoCoordinatesLike(object: any): object is GeoCoordinatesLike {\n    return (\n        object &&\n        typeof object.latitude === \"number\" &&\n        typeof object.longitude === \"number\" &&\n        (typeof object.altitude === \"number\" || typeof object.altitude === \"undefined\")\n    );\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeoBox } from \"../coordinates/GeoBox\";\nimport { GeoCoordinatesLike } from \"../coordinates/GeoCoordinatesLike\";\nimport { Box3Like } from \"../math/Box3Like\";\nimport { Projection } from \"../projection/Projection\";\nimport { FlatTileBoundingBoxGenerator } from \"./FlatTileBoundingBoxGenerator\";\nimport { SubdivisionScheme } from \"./SubdivisionScheme\";\nimport { TileKey } from \"./TileKey\";\nimport { TileKeyUtils } from \"./TileKeyUtils\";\nimport { TileTreeTraverse } from \"./TileTreeTraverse\";\n\n/**\n * The `TilingScheme` represents how the data is tiled.\n */\nexport class TilingScheme {\n    readonly boundingBoxGenerator: FlatTileBoundingBoxGenerator;\n    readonly tileTreeTraverse: TileTreeTraverse;\n\n    /**\n     * Constructs a new `TilingScheme` with the given subdivision scheme and projection.\n     *\n     * @param subdivisionScheme - The subdivision scheme used by this `TilingScheme`.\n     * @param projection - The projection used by this `TilingScheme`.\n     */\n    constructor(readonly subdivisionScheme: SubdivisionScheme, readonly projection: Projection) {\n        this.boundingBoxGenerator = new FlatTileBoundingBoxGenerator(this);\n        this.tileTreeTraverse = new TileTreeTraverse(subdivisionScheme);\n    }\n\n    /**\n     * Returns the sub tile keys of the given tile.\n     *\n     * @param tileKey - The {@link TileKey}.\n     * @returns The list of the sub tile keys.\n     */\n    getSubTileKeys(tileKey: TileKey): Iterable<TileKey> {\n        return this.tileTreeTraverse.subTiles(tileKey);\n    }\n\n    /**\n     * Gets the {@link TileKey} from the given geo position and level.\n     *\n     * @param geoPoint - The position in geo coordinates.\n     * @param level - The level of the resulting `TileKey`.\n     */\n    getTileKey(geoPoint: GeoCoordinatesLike, level: number): TileKey | null {\n        return TileKeyUtils.geoCoordinatesToTileKey(this, geoPoint, level);\n    }\n\n    /**\n     * Gets the list of {@link TileKey}s contained in the given {@link GeoBox}.\n     *\n     * @param geoBox - The bounding box in geo coordinates.\n     * @param level - The level of the resulting `TileKey`.\n     */\n    getTileKeys(geoBox: GeoBox, level: number): TileKey[] {\n        return TileKeyUtils.geoRectangleToTileKeys(this, geoBox, level);\n    }\n\n    /**\n     * Returns the bounding box in geo coordinates for the given {@link TileKey}.\n     *\n     * @param tileKey - The `TileKey`.\n     */\n    getGeoBox(tileKey: TileKey): GeoBox {\n        return this.boundingBoxGenerator.getGeoBox(tileKey);\n    }\n\n    /**\n     * Returns the bounding box in world coordinates.\n     *\n     * @param tileKey - The `TileKey`.\n     * @param result - The optional object that will contain the resulting bounding box.\n     */\n    getWorldBox(tileKey: TileKey, result?: Box3Like): Box3Like {\n        return this.boundingBoxGenerator.getWorldBox(tileKey, result);\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { assert } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\nimport { RGBA } from \"./RGBA\";\n\nconst SHIFT_TRANSPARENCY: number = 24;\nconst SHIFT_RED: number = 16;\nconst SHIFT_GREEN: number = 8;\nconst SHIFT_BLUE: number = 0;\n\n// tslint:disable: no-bitwise\n//    Allow bitwise operations for colors decoding\n\n// tslint:disable-next-line: no-bitwise\nconst HEX_FULL_CHANNEL: number = 0xff;\nconst HEX_RGB_MASK: number = 0xffffff;\nconst HEX_TRGB_MASK: number = 0xffffffff;\n\nconst tmpColor = new THREE.Color();\n\n/**\n * Utilities to convert RGBA colors encoded in custom number (hex) format to THREE.Color objects.\n *\n * The functions provided allows for conversion from and to our custom number based color format,\n * which contains transparency, red, green and blue color channels in a way that each channel\n * occupies 8 bits of resulting number (color format 0xTTRRGGBB).\n * In order to preserve compatibility with THREE.Color class and its hexadecimal color\n * representation, we do not store __alpha__ channel in encoded color's number, but replace it\n * with __transparency__ channel, which is simply opposite to alpha:\n * ```transparency = 0xFF - alpha```\n * Such channel value is stored on the oldest bits (octet) in the integral color (numeric) value,\n * so it is fully compatible with THREE.Color numerical representation (@see [[THREE.Color.getHex]],\n * [[THREE.Color.setHex]]).\n * See also [[getHexFromRgba]] and [[getRgbaFromHex]] for more info about conversion.\n */\nexport namespace ColorUtils {\n    /**\n     * Encodes RGBA channels in custom number coded format (represented in hex as 0xTTRRGGBB).\n     *\n     * We do not use direct alpha channel mapping to hex in order to preserve compatibility\n     * with THREE.js color format (0xRRGGBB). This is done by encoding transparency\n     * (255 - alpha) instead of alpha on the oldest bits, shifted by [[SHIFT_TRANSPARENCY]].\n     * This way simple 0xRRGGBB color is equal to 0x00RRGGBB without transparency and\n     * color defining transparency (alpha < 255) is always recognizable by the oldest\n     * bit set:\n     * ```typescript\n     * (color >> SHIFT_TRANSPARENCY) !== 0.\n     * ```\n     * @note All input components are floating points in <0, 1> range (inclusively).\n     * @note Although method encodes transparency channel in single number value, it is still\n     * compatible with THREE.js number based color coding (0xRRGGBB), so you may pass this value to\n     * [[THREE.Color]] c-tor, but keep in mind that transparency will be silently ignored.\n     */\n    export function getHexFromRgba(r: number, g: number, b: number, a: number): number {\n        assert(a >= 0 && a <= 1);\n        const t = HEX_FULL_CHANNEL - Math.floor(a * HEX_FULL_CHANNEL);\n        return (\n            (t << SHIFT_TRANSPARENCY) ^\n            ((r * HEX_FULL_CHANNEL) << SHIFT_RED) ^\n            ((g * HEX_FULL_CHANNEL) << SHIFT_GREEN) ^\n            ((b * HEX_FULL_CHANNEL) << SHIFT_BLUE)\n        );\n    }\n\n    /**\n     * Encodes RGB all color channels in single number with format 0xRRGGBB.\n     *\n     * All input channels should be in <0, 1> range (inclusively).\n     * See also [[getHexFromRgba]] for more information about [[THREE.Color]] compatibility.\n     *\n     * @note This method is fully compatible with THREE.js color encoding, so\n     * you may pass this value directly to THREE.Color c-tor.\n     */\n    export function getHexFromRgb(r: number, g: number, b: number): number {\n        assert(r >= 0 && r <= 1);\n        assert(g >= 0 && g <= 1);\n        assert(b >= 0 && b <= 1);\n        return (\n            ((r * HEX_FULL_CHANNEL) << SHIFT_RED) ^\n            ((g * HEX_FULL_CHANNEL) << SHIFT_GREEN) ^\n            ((b * HEX_FULL_CHANNEL) << SHIFT_BLUE)\n        );\n    }\n\n    /**\n     * Encode and convert HSL value to number coded color format (0xRRGGBB).\n     *\n     * @see getHexFromRgb.\n     * @param h - Hue component value between 0 and 1.\n     * @param s - Saturation value between 0 and 1.\n     * @param l - Lightness channel between 0 and 1.\n     */\n    export function getHexFromHsl(h: number, s: number, l: number): number {\n        assert(h >= 0 && h <= 1);\n        assert(s >= 0 && s <= 1);\n        assert(l >= 0 && l <= 1);\n        return tmpColor.setHSL(h, s, l).getHex();\n    }\n\n    /**\n     * Retrieve RGBA channels separately from number encoded custom color format.\n     *\n     * Provides an easy way for channels extraction (r, g, b, a) from custom number coded color\n     * format.\n     *\n     * @see getHexFromRgba.\n     * @param hex - The number encoded color value (0xRRGGBB or 0xTTRRGGBB in hex).\n     * @returns r, g, b, a channels in simple object, where each channel value is saved as floating\n     * point from 0 to 1 inclusively.\n     */\n    export function getRgbaFromHex(hex: number, target = new RGBA()): RGBA {\n        assert((hex & ~HEX_TRGB_MASK) === 0, \"Wrong hex format\");\n        target.r = ((hex >> SHIFT_RED) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL;\n        target.g = ((hex >> SHIFT_GREEN) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL;\n        target.b = ((hex >> SHIFT_BLUE) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL;\n        target.a =\n            (HEX_FULL_CHANNEL - ((hex >> SHIFT_TRANSPARENCY) & HEX_FULL_CHANNEL)) /\n            HEX_FULL_CHANNEL;\n        return target;\n    }\n\n    /**\n     * Determines if number encoded color contains alpha (opacity) defined and different then 255.\n     *\n     * @param hex - The number encoded color (0xRRGGBB or 0xTTRRGGBB in hex).\n     * @returns True if color has transparency defined.\n     */\n    export function hasAlphaInHex(hex: number): boolean {\n        assert((hex & ~HEX_TRGB_MASK) === 0, \"Wrong hex format\");\n        return hex >> SHIFT_TRANSPARENCY !== 0;\n    }\n\n    /**\n     * Retrieves alpha color channel from hex encoded color value.\n     *\n     * @see getHexFromRgba.\n     * @param hex - The number encoded color value (representable as 0xRRGGBB or 0xTTRRGGBB in hex).\n     * @returns The floating point alpha component in <0, 1> range.\n     */\n    export function getAlphaFromHex(hex: number): number {\n        assert((hex & ~HEX_TRGB_MASK) === 0, \"Wrong hex format\");\n        return (\n            ((HEX_FULL_CHANNEL - (hex >> SHIFT_TRANSPARENCY)) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL\n        );\n    }\n\n    /**\n     * Remove transparency info from the number coded color, makes it compatible with external libs.\n     *\n     * @see getAlphaFromHex.\n     * @param hex - The number encoded color value (representable as 0xRRGGBB or 0xTTRRGGBB in hex).\n     * @returns number coded color value representable as 0xRRGGBB in hex.\n     */\n    export function removeAlphaFromHex(hex: number): number {\n        assert((hex & ~HEX_TRGB_MASK) === 0, \"Wrong hex format\");\n        return hex & HEX_RGB_MASK;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Namespace containing useful information when dealing with Unicode's code points.\n */\nexport namespace UnicodeUtils {\n    /**\n     * Range of Unicode code points considered as white space.\n     * https://en.wikipedia.org/wiki/Whitespace_character\n     */\n    export const whiteSpaceRanges = [\n        [0x0009, 0x0009],\n        [0x0020, 0x0020],\n        [0x1680, 0x1680],\n        [0x2000, 0x2006],\n        [0x2008, 0x200a],\n        [0x205f, 0x3000],\n        [0x180e, 0x180e],\n        [0x200b, 0x200d]\n    ];\n\n    /**\n     * Checks if a character should be considered as a white space.\n     *\n     * @param codePoint - Character's Unicode code point.\n     *\n     * @returns Result of the test.\n     */\n    export function isWhiteSpace(codePoint: number) {\n        for (const range of whiteSpaceRanges) {\n            if (codePoint >= range[0] && codePoint <= range[1]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Range of Unicode code points considered as `NewLine`.\n     * https://en.wikipedia.org/wiki/Newline#Unicode\n     */\n    export const newLineRanges = [\n        [0x000a, 0x000d],\n        [0x0085, 0x0085],\n        [0x2028, 0x2029]\n    ];\n\n    /**\n     * Checks if a character should be considered as a new line.\n     *\n     * @param codePoint - Character's Unicode code point.\n     *\n     * @returns Result of the test.\n     */\n    export function isNewLine(codePoint: number) {\n        for (const range of newLineRanges) {\n            if (codePoint >= range[0] && codePoint <= range[1]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Range of Unicode code points considered as non-printable.\n     * https://en.wikipedia.org/wiki/Unicode_control_characters\n     */\n    export const nonPrintableRanges = [\n        [0x0000, 0x001f],\n        [0x007f, 0x009f]\n    ];\n\n    /**\n     * Checks if a character's can be printed (rendered).\n     *\n     * @param codePoint - Character's Unicode code point.\n     *\n     * @returns Result of the test.\n     */\n    export function isPrintable(codePoint: number) {\n        for (const range of nonPrintableRanges) {\n            if (codePoint >= range[0] && codePoint <= range[1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Unicode code point direction.\n     */\n    export enum Direction {\n        Neutral = 0.0,\n        Weak = 0.5,\n        LTR = 1.0,\n        RTL = -1.0\n    }\n\n    // TODO: Review/Remove/Add any additional needed blocks (HARP-3330).\n    /**\n     * Unicode Blocks which have inherent RTL direction.\n     * These blocks correspond to the scripts described here:\n     * https://en.wikipedia.org/wiki/Right-to-left#List_of_RTL_scripts\n     */\n    export const rtlBlocks: string[] = [\n        \"Hebrew\",\n        \"Alphabetic Presentation Forms\",\n        \"Arabic\",\n        \"Arabic Supplement\",\n        \"Arabic Extended-A\",\n        \"Arabic Presentation Forms-A\",\n        \"Arabic Presentation Forms-B\",\n        \"Arabic Mathematical Alphabetic Symbols\",\n        \"Indic Siyaq Numbers\",\n        \"Rumi Numeral Symbols\",\n        \"Syriac\",\n        \"Syriac Supplement\",\n        \"Samaritan\",\n        \"Mandaic\",\n        \"Thaana\",\n        \"Mende Kikakui\",\n        \"NKo\",\n        \"Adlam\",\n        \"Hanifi Rohingya\"\n    ];\n\n    /**\n     * ASCII punctuation is considered to have neutral direction:\n     * https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)#Table_of_characters\n     */\n    export const neutralBidirectionalRanges = [\n        [0x0020, 0x002f],\n        [0x003a, 0x0040],\n        [0x005b, 0x0060],\n        [0x007b, 0x007e]\n    ];\n\n    /**\n     * Latin and arabic numerals are considered to have weak directionality:\n     * https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)#Table_of_characters\n     * https://en.wikipedia.org/wiki/Arabic_(Unicode_block)#Block\n     */\n    export const weakBidirectionalRanges = [\n        [0x0030, 0x0039],\n        [0x0660, 0x0669],\n        [0x06f0, 0x06f9]\n    ];\n\n    /**\n     * Returns the Unicode's character direction.\n     *\n     * @param codePoint - Character's Unicode code point.\n     * @param block - Character's Unicode block.\n     *\n     * @returns Character's direction.\n     */\n    export function getDirection(codePoint: number, block: string): Direction {\n        // Test for neutral and weak code points first (they're inside LTR/RTL ranges).\n        for (const weakRange of weakBidirectionalRanges) {\n            if (codePoint >= weakRange[0] && codePoint <= weakRange[1]) {\n                return Direction.Weak;\n            }\n        }\n        for (const neutralRange of neutralBidirectionalRanges) {\n            if (codePoint >= neutralRange[0] && codePoint <= neutralRange[1]) {\n                return Direction.Neutral;\n            }\n        }\n\n        // Check for RTL/LTR.\n        const rtl = rtlBlocks.find(element => {\n            return element === block;\n        });\n        if (rtl !== undefined) {\n            return Direction.RTL;\n        } else {\n            return Direction.LTR;\n        }\n    }\n\n    /**\n     * Some punctuation characters (like: (, ), <, >, [,], {, }) need to be mirrored when rendering\n     * a RTL string to preserve their intrinsic meaning.\n     * https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)#Table_of_characters\n     */\n    export const rtlMirroredCodePoints = [\n        0x0028,\n        0x0029,\n        0x003c,\n        0x003e,\n        0x005b,\n        0x005d,\n        0x007b,\n        0x007d\n    ];\n\n    /**\n     * Checks if a character should be mirrored on an RTL run.\n     *\n     * @param codePoint - Character's Unicode code point.\n     *\n     * @returns Result of the test.\n     */\n    export function isRtlMirrored(codePoint: number): boolean {\n        return (\n            rtlMirroredCodePoints.find(element => {\n                return element === codePoint;\n            }) !== undefined\n        );\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Types of text elements.\n */\nexport enum TextElementType {\n    PoiLabel,\n    PathLabel,\n    LineMarker\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\n/**\n * The interface for the {@link Pass} class.\n */\nexport interface IPass {\n    /**\n     * Whether the {@link Pass} instance is active or not.\n     * @default `true`.\n     */\n    enabled: boolean;\n\n    /**\n     * Whether the render method should target a WebGLRenderTarget instance, or the frame buffer.\n     * @default `false`.\n     */\n    renderToScreen: boolean;\n\n    /**\n     * The resize method to extend in {@link Pass} implementations.\n     *\n     * @remarks\n     * It resizes the render targets. Call on resize events.\n     *\n     * @param width - Width to resize to.\n     * @param height - Height to resize to.\n     */\n    setSize(width: number, height: number): void;\n\n    /**\n     * The render method to extend in {@link Pass} implementations.\n     *\n     * @remarks\n     * This is the place where the desired\n     * effects or render operations are executed.\n     *\n     * @param renderer - The WebGLRenderer instance in use.\n     * @param scene - The scene to render.\n     * @param camera - The camera to render the scene through.\n     * @param writeBuffer - The optional WebGLRenderTarget instance to write to.\n     * @param readBuffer - The optional WebGLRenderTarget instance of a previous pass to write onto.\n     * @param delta - The time argument from the requestAnimationFrame.\n     */\n    render(\n        renderer: THREE.WebGLRenderer,\n        scene: THREE.Scene,\n        camera: THREE.Camera,\n        writeBuffer: THREE.WebGLRenderTarget | null,\n        readBuffer: THREE.WebGLRenderTarget | null,\n        delta?: number\n    ): void;\n}\n\n/**\n * The base class to extend for further passes in {@link MapView},\n * like the {@link MSAARenderPass},\n *\n * @remarks\n * `Pass` provides the core logic for both :\n * - render passes (proper scene renders),\n * - and shader passes (quad renders, i.e. effects added on top of the render output as a\n * postprocess).\n *\n * Even some shader passes still actually fall within the render pass category as they need to\n * re-render the scene to then deduce an effect, such as masking, AO, DoF etc. Others just need the\n * previous input image to apply a shader on top of it, as for bloom or NVIDIA's FXAA for example.\n * These only are proper shader passes.\n */\nexport class Pass implements IPass {\n    enabled: boolean = false;\n    renderToScreen: boolean = false;\n    // tslint:disable-next-line:no-unused-variable\n    setSize(width: number, height: number) {\n        // Implemented in sub-classes.\n    }\n    // tslint:disable:no-unused-variable\n    render(\n        renderer: THREE.WebGLRenderer,\n        scene: THREE.Scene,\n        camera: THREE.Camera,\n        writeBuffer: THREE.WebGLRenderTarget | null,\n        readBuffer: THREE.WebGLRenderTarget | null,\n        delta?: number\n    ) {\n        // Implemented in sub-classes.\n    }\n    // tslint:enable:no-unused-variable\n}\n\n/**\n * The pass that does a default normal scene rendering for further post-effects.\n */\nexport class RenderPass extends Pass {\n    constructor() {\n        super();\n    }\n\n    /** @override */\n    render(\n        renderer: THREE.WebGLRenderer,\n        scene: THREE.Scene,\n        camera: THREE.Camera,\n        writeBuffer: THREE.WebGLRenderTarget | null,\n        readBuffer: THREE.WebGLRenderTarget | null\n    ) {\n        renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);\n        renderer.render(scene, camera);\n    }\n}\n\n/**\n * The base class to extend for post-effects on the final render (like Vignette, Sepia, color\n * correction...)\n */\nexport class ShaderPass extends Pass {\n    uniforms: { [uniform: string]: THREE.IUniform };\n    material: THREE.Material;\n    fsQuad: FullScreenQuad;\n    constructor(shader: THREE.Shader, private textureID: string = \"tDiffuse\") {\n        super();\n        if (shader instanceof THREE.ShaderMaterial) {\n            this.uniforms = shader.uniforms;\n            this.material = shader;\n        } else {\n            this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n            this.material = new THREE.ShaderMaterial({\n                defines: { ...(shader as any).defines },\n                uniforms: this.uniforms,\n                vertexShader: shader.vertexShader,\n                fragmentShader: shader.fragmentShader\n            });\n        }\n        this.fsQuad = new FullScreenQuad(this.material);\n    }\n    /** @override */\n    render(\n        renderer: THREE.WebGLRenderer,\n        scene: THREE.Scene,\n        camera: THREE.Camera,\n        writeBuffer: THREE.WebGLRenderTarget,\n        readBuffer: THREE.WebGLRenderTarget,\n        delta?: number\n    ) {\n        if (this.uniforms[this.textureID]) {\n            this.uniforms[this.textureID].value = readBuffer.texture;\n        }\n        this.fsQuad.material = this.material;\n        renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);\n        this.fsQuad.render(renderer);\n    }\n}\n\nclass FullScreenQuad {\n    private m_mesh: THREE.Mesh;\n    private m_camera: THREE.Camera;\n    constructor(material: THREE.Material) {\n        this.m_camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n        const geometry = new THREE.PlaneBufferGeometry(2, 2);\n        this.m_mesh = new THREE.Mesh(geometry, material);\n    }\n    get material(): THREE.Material {\n        return this.m_mesh.material as THREE.Material;\n    }\n    set material(value: THREE.Material) {\n        this.m_mesh.material = value;\n    }\n    render(renderer: THREE.WebGLRenderer) {\n        renderer.render((this.m_mesh as any) as THREE.Scene, this.m_camera);\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeoBox } from \"../coordinates/GeoBox\";\nimport { GeoCoordinates } from \"../coordinates/GeoCoordinates\";\nimport { GeoCoordinatesLike, isGeoCoordinatesLike } from \"../coordinates/GeoCoordinatesLike\";\nimport { Box3Like, isBox3Like } from \"../math/Box3Like\";\nimport { MathUtils } from \"../math/MathUtils\";\nimport { isOrientedBox3Like, OrientedBox3Like } from \"../math/OrientedBox3Like\";\nimport { TransformLike } from \"../math/TransformLike\";\nimport { Vector3Like } from \"../math/Vector3Like\";\nimport { EarthConstants } from \"./EarthConstants\";\nimport { Projection, ProjectionType } from \"./Projection\";\n\nimport * as THREE from \"three\";\n\nclass MercatorProjection extends Projection {\n    protected static clamp(val: number, min: number, max: number): number {\n        return Math.min(Math.max(min, val), max);\n    }\n\n    protected static latitudeClamp(latitude: number): number {\n        return MercatorProjection.clamp(\n            latitude,\n            -MercatorConstants.MAXIMUM_LATITUDE,\n            MercatorConstants.MAXIMUM_LATITUDE\n        );\n    }\n\n    private static latitudeProject(latitude: number): number {\n        return Math.log(Math.tan(Math.PI * 0.25 + latitude * 0.5)) / Math.PI;\n    }\n\n    private static latitudeClampProject(latitude: number): number {\n        return MercatorProjection.latitudeProject(MercatorProjection.latitudeClamp(latitude));\n    }\n\n    private static unprojectLatitude(y: number): number {\n        return 2.0 * Math.atan(Math.exp(Math.PI * y)) - Math.PI * 0.5;\n    }\n\n    /** @override */\n    readonly type: ProjectionType = ProjectionType.Planar;\n\n    /** @override */\n    getScaleFactor(worldPoint: Vector3Like): number {\n        return Math.cosh(2 * Math.PI * (worldPoint.y / this.unitScale - 0.5));\n    }\n\n    /** @override */\n    worldExtent<WorldBoundingBox extends Box3Like>(\n        minAltitude: number,\n        maxAltitude: number,\n        result?: WorldBoundingBox\n    ): WorldBoundingBox {\n        if (!result) {\n            result = (new THREE.Box3() as Box3Like) as WorldBoundingBox;\n        }\n        result.min.x = 0;\n        result.min.y = 0;\n        result.min.z = minAltitude;\n        result.max.x = this.unitScale;\n        result.max.y = this.unitScale;\n        result.max.z = maxAltitude;\n        return result;\n    }\n\n    /** @override */\n    projectPoint<WorldCoordinates extends Vector3Like>(\n        geoPointLike: GeoCoordinatesLike,\n        result?: WorldCoordinates\n    ): WorldCoordinates {\n        let geoPoint: GeoCoordinates;\n\n        if (geoPointLike instanceof GeoCoordinates) {\n            geoPoint = geoPointLike;\n        } else {\n            geoPoint = new GeoCoordinates(\n                geoPointLike.latitude,\n                geoPointLike.longitude,\n                geoPointLike.altitude\n            );\n        }\n\n        if (!result) {\n            // tslint:disable-next-line:no-object-literal-type-assertion\n            result = { x: 0, y: 0, z: 0 } as WorldCoordinates;\n        }\n        result.x = ((geoPoint.longitude + 180) / 360) * this.unitScale;\n        result.y =\n            (MercatorProjection.latitudeClampProject(geoPoint.latitudeInRadians) * 0.5 + 0.5) *\n            this.unitScale;\n        result.z = geoPoint.altitude || 0;\n        return result;\n    }\n\n    /** @override */\n    unprojectPoint(worldPoint: Vector3Like): GeoCoordinates {\n        const geoPoint = GeoCoordinates.fromRadians(\n            MercatorProjection.unprojectLatitude((worldPoint.y / this.unitScale - 0.5) * 2.0),\n            (worldPoint.x / this.unitScale) * 2 * Math.PI - Math.PI,\n            worldPoint.z\n        );\n        return geoPoint;\n    }\n\n    /** @override */\n    unprojectAltitude(worldPoint: Vector3Like): number {\n        return worldPoint.z;\n    }\n\n    /** @override */\n    projectBox<WorldBoundingBox extends Box3Like | OrientedBox3Like>(\n        geoBox: GeoBox,\n        result?: WorldBoundingBox\n    ): WorldBoundingBox {\n        const worldCenter = this.projectPoint(geoBox.center);\n        const worldNorth =\n            (MercatorProjection.latitudeClampProject(geoBox.northEast.latitudeInRadians) * 0.5 +\n                0.5) *\n            this.unitScale;\n        const worldSouth =\n            (MercatorProjection.latitudeClampProject(geoBox.southWest.latitudeInRadians) * 0.5 +\n                0.5) *\n            this.unitScale;\n        const worldYCenter = (worldNorth + worldSouth) * 0.5;\n\n        worldCenter.y = worldYCenter;\n\n        const latitudeSpan = worldNorth - worldSouth;\n        const longitudeSpan = (geoBox.longitudeSpan / 360) * this.unitScale;\n        if (!result) {\n            result = (new THREE.Box3() as Box3Like) as WorldBoundingBox;\n        }\n        if (isBox3Like(result)) {\n            result.min.x = worldCenter.x - longitudeSpan * 0.5;\n            result.min.y = worldCenter.y - latitudeSpan * 0.5;\n            result.max.x = worldCenter.x + longitudeSpan * 0.5;\n            result.max.y = worldCenter.y + latitudeSpan * 0.5;\n            const altitudeSpan = geoBox.altitudeSpan;\n            if (altitudeSpan !== undefined) {\n                result.min.z = worldCenter.z - altitudeSpan * 0.5;\n                result.max.z = worldCenter.z + altitudeSpan * 0.5;\n            } else {\n                result.min.z = 0;\n                result.max.z = 0;\n            }\n        } else if (isOrientedBox3Like(result)) {\n            MathUtils.newVector3(1, 0, 0, result.xAxis);\n            MathUtils.newVector3(0, 1, 0, result.yAxis);\n            MathUtils.newVector3(0, 0, 1, result.zAxis);\n            result.position.x = worldCenter.x;\n            result.position.y = worldCenter.y;\n            result.position.z = worldCenter.z;\n            result.extents.x = longitudeSpan * 0.5;\n            result.extents.y = latitudeSpan * 0.5;\n            result.extents.z = Math.max(Number.EPSILON, (geoBox.altitudeSpan || 0) * 0.5);\n        } else {\n            throw new Error(\"invalid bounding box\");\n        }\n        return result;\n    }\n\n    /** @override */\n    unprojectBox(worldBox: Box3Like): GeoBox {\n        const minGeo = this.unprojectPoint(worldBox.min);\n        const maxGeo = this.unprojectPoint(worldBox.max);\n        const geoBox = GeoBox.fromCoordinates(minGeo, maxGeo);\n        return geoBox;\n    }\n\n    /** @override */\n    groundDistance(worldPoint: Vector3Like): number {\n        return worldPoint.z;\n    }\n\n    /** @override */\n    scalePointToSurface(worldPoint: Vector3Like): Vector3Like {\n        worldPoint.z = 0;\n        return worldPoint;\n    }\n\n    /** @override */\n    surfaceNormal(_worldPoint: Vector3Like, normal?: Vector3Like) {\n        if (normal === undefined) {\n            normal = { x: 0, y: 0, z: 1 };\n        } else {\n            normal.x = 0;\n            normal.y = 0;\n            normal.z = 1;\n        }\n        return normal;\n    }\n\n    /** @override */\n    reprojectPoint(\n        sourceProjection: Projection,\n        worldPos: Vector3Like,\n        result?: Vector3Like\n    ): Vector3Like {\n        // this implementation of [[reprojectPoint]] supports both\n        // [[WebMercatorProjection]] and [[MercatorProjection]]. The only\n        // difference betweeen these two variants of WEB Mercator\n        // is in the orientation of the Y axis, so we just flip Y coordinates\n        // when reprojecting between them.\n        if (\n            sourceProjection !== this &&\n            (sourceProjection === webMercatorProjection || sourceProjection === mercatorProjection)\n        ) {\n            if (result === undefined) {\n                // tslint:disable-next-line: no-object-literal-type-assertion\n                result = {} as Vector3Like;\n            }\n\n            result.x = worldPos.x;\n            result.y = this.unitScale - worldPos.y;\n            result.z = worldPos.z;\n\n            return result;\n        }\n\n        return super.reprojectPoint(sourceProjection, worldPos, result!);\n    }\n}\n\nclass WebMercatorProjection extends MercatorProjection {\n    /** @override */\n    projectPoint<WorldCoordinates extends Vector3Like>(\n        geoPointLike: GeoCoordinatesLike,\n        result?: WorldCoordinates\n    ): WorldCoordinates {\n        let geoPoint: GeoCoordinates;\n\n        if (geoPointLike instanceof GeoCoordinates) {\n            geoPoint = geoPointLike;\n        } else {\n            geoPoint = new GeoCoordinates(\n                geoPointLike.latitude,\n                geoPointLike.longitude,\n                geoPointLike.altitude\n            );\n        }\n\n        /*\n         * The following tslint:disable is due to the fact that the [[WorldCoordinates]]\n         * might be a concrete class which is not available at runtime.\n         * Consider the following example:\n         *\n         *  const x: THREE.Vector3 = new THREE.Vector3(0,0,0);\n         *  const result = EquirectangularProjection.projectPoint<THREE.Vector3>(x);\n         *\n         * Note: type of `result` is Vector3Like and not as expected: THREE.Vector3!\n         */\n        if (!result) {\n            // tslint:disable-next-line:no-object-literal-type-assertion\n            result = { x: 0, y: 0, z: 0 } as WorldCoordinates;\n        }\n\n        result.x = ((geoPoint.longitude + 180) / 360) * this.unitScale;\n        const sy = Math.sin(MercatorProjection.latitudeClamp(geoPoint.latitudeInRadians));\n        result.y = (0.5 - Math.log((1 + sy) / (1 - sy)) / (4 * Math.PI)) * this.unitScale;\n        result.z = geoPoint.altitude || 0;\n        return result;\n    }\n\n    /** @override */\n    unprojectPoint(worldPoint: Vector3Like): GeoCoordinates {\n        const x = worldPoint.x / this.unitScale - 0.5;\n        const y = 0.5 - worldPoint.y / this.unitScale;\n\n        const longitude = 360 * x;\n        const latitude = 90 - (360 * Math.atan(Math.exp(-y * 2 * Math.PI))) / Math.PI;\n\n        return new GeoCoordinates(latitude, longitude, worldPoint.z);\n    }\n\n    /** @override */\n    projectBox<WorldBoundingBox extends Box3Like | OrientedBox3Like>(\n        geoBox: GeoBox,\n        result?: WorldBoundingBox\n    ): WorldBoundingBox {\n        const r = super.projectBox(geoBox, result);\n        if (isBox3Like(r)) {\n            // Invert the y axis for web mercator, this means that max => min & min => max\n            const maxY = r.max.y;\n            r.max.y = this.unitScale - r.min.y;\n            r.min.y = this.unitScale - maxY;\n        } else if (isOrientedBox3Like(r)) {\n            MathUtils.newVector3(1, 0, 0, r.xAxis);\n            MathUtils.newVector3(0, -1, 0, r.yAxis);\n            MathUtils.newVector3(0, 0, -1, r.zAxis);\n            r.position.y = this.unitScale - r.position.y;\n        }\n        return r;\n    }\n\n    /** @override */\n    unprojectBox(worldBox: Box3Like): GeoBox {\n        const minGeo = this.unprojectPoint(worldBox.min);\n        const maxGeo = this.unprojectPoint(worldBox.max);\n        const geoBox = new GeoBox(\n            new GeoCoordinates(maxGeo.latitude, minGeo.longitude, minGeo.altitude),\n            new GeoCoordinates(minGeo.latitude, maxGeo.longitude, maxGeo.altitude)\n        );\n        return geoBox;\n    }\n\n    /** @override */\n    surfaceNormal(_worldPoint: Vector3Like, normal?: Vector3Like) {\n        if (normal === undefined) {\n            normal = { x: 0, y: 0, z: -1 };\n        } else {\n            normal.x = 0;\n            normal.y = 0;\n            normal.z = -1;\n        }\n        return normal;\n    }\n\n    /** @override */\n    localTangentSpace(\n        point: GeoCoordinatesLike | Vector3Like,\n        result: TransformLike\n    ): TransformLike {\n        if (isGeoCoordinatesLike(point)) {\n            this.projectPoint(point, result.position);\n        } else {\n            MathUtils.copyVector3(point, result.position);\n        }\n        MathUtils.newVector3(1, 0, 0, result.xAxis);\n        MathUtils.newVector3(0, -1, 0, result.yAxis);\n        MathUtils.newVector3(0, 0, -1, result.zAxis);\n        return result;\n    }\n}\n\nexport class MercatorConstants {\n    // Math.atan(Math.sinh(Math.PI))\n    static readonly MAXIMUM_LATITUDE: number = 1.4844222297453323;\n}\n\n/**\n * Mercator {@link Projection} used to convert geo coordinates to world coordinates and vice versa.\n */\nexport const mercatorProjection: Projection = new MercatorProjection(\n    EarthConstants.EQUATORIAL_CIRCUMFERENCE\n);\n\n/**\n * Web Mercator {@link Projection} used to convert geo coordinates to world coordinates\n * and vice versa.\n */\nexport const webMercatorProjection: Projection = new WebMercatorProjection(\n    EarthConstants.EQUATORIAL_CIRCUMFERENCE\n);\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { SubdivisionScheme } from \"./SubdivisionScheme\";\n\nclass QuadTreeSubdivisionScheme implements SubdivisionScheme {\n    getSubdivisionX(): number {\n        return 2;\n    }\n    getSubdivisionY(): number {\n        return 2;\n    }\n    getLevelDimensionX(level: number): number {\n        // tslint:disable-next-line:no-bitwise\n        return 1 << level;\n    }\n    getLevelDimensionY(level: number): number {\n        // tslint:disable-next-line:no-bitwise\n        return 1 << level;\n    }\n}\n\n/**\n * {@link SubdivisionScheme} representing a quadtree.\n */\nexport const quadTreeSubdivisionScheme: SubdivisionScheme = new QuadTreeSubdivisionScheme();\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/** @hidden */\nconst powerOfTwo = [\n    0x1,\n    0x2,\n    0x4,\n    0x8,\n    0x10,\n    0x20,\n    0x40,\n    0x80,\n    0x100,\n    0x200,\n    0x400,\n    0x800,\n    0x1000,\n    0x2000,\n    0x4000,\n    0x8000,\n    0x10000,\n    0x20000,\n    0x40000,\n    0x80000,\n    0x100000,\n    0x200000,\n    0x400000,\n    0x800000,\n    0x1000000,\n    0x2000000,\n    0x4000000,\n    0x8000000,\n    0x10000000,\n    0x20000000,\n    0x40000000,\n    0x80000000,\n    0x100000000,\n    0x200000000,\n    0x400000000,\n    0x800000000,\n    0x1000000000,\n    0x2000000000,\n    0x4000000000,\n    0x8000000000,\n    0x10000000000,\n    0x20000000000,\n    0x40000000000,\n    0x80000000000,\n    0x100000000000,\n    0x200000000000,\n    0x400000000000,\n    0x800000000000,\n    0x1000000000000,\n    0x2000000000000,\n    0x4000000000000,\n    0x8000000000000,\n    0x10000000000000 // Math.pow(2, 52), highest bit that can be set correctly.\n];\n\n/**\n * The `TileKey` instances are used to address a tile in a quadtree.\n *\n * A tile key is defined by a row, a column, and a level. The tree has a root at level 0, with one\n * single tile. On every level, each tile is divided into four children (therefore the name\n * quadtree).\n *\n * Within each [[level]], any particular tile is addressed with [[row]] and [[column]]. The number\n * of rows and columns in each level is 2 to the power of the level. This means: On level 0, only\n * one tile exists, [[columnsAtLevel]]() and [[rowsAtLevel]]() are both 1. On level 1, 4 tiles\n * exist, in 2 rows and 2 columns. On level 2 we have 16 tiles, in 4 rows and 4 columns. And so on.\n *\n * A tile key is usually created using [[fromRowColumnLevel]]() method.\n *\n * `TileKey` instances are immutable, all members return new instances of `TileKey` and do not\n * modify the original object.\n *\n * Utility functions like [[parent]](), [[changedLevelBy]](), and [[changedLevelTo]]() allow for\n * easy vertical navigation of the tree. The number of available rows and columns in the tile's\n * level is given with [[rowCount]]() and [[columnCount]]().\n *\n * Tile keys can be created from and converted into various alternative formats:\n *\n *  - [[toQuadKey]]() / [[fromQuadKey]]() - string representation 4-based\n *  - [[toHereTile]]() / [[fromHereTile]]() - string representation 10-based\n *  - [[mortonCode]]() / [[fromMortonCode]]() - number representation\n *\n * Note - as JavaScript's number type can hold 53 bits in its mantissa, only levels up to 26 can be\n * represented in the number representation returned by [[mortonCode]]().\n */\nexport class TileKey {\n    /**\n     * Creates a tile key.\n     *\n     * @param row - The requested row. Must be less than 2 to the power of level.\n     * @param column - The requested column. Must be less than 2 to the power of level.\n     * @param level - The requested level.\n     */\n    static fromRowColumnLevel(row: number, column: number, level: number): TileKey {\n        return new TileKey(row, column, level);\n    }\n\n    /**\n     * Creates a tile key from a quad string.\n     *\n     * The quad string can be created with [[toQuadKey]].\n     *\n     * @param quadkey - The quadkey to convert.\n     * @returns A new instance of `TileKey`.\n     */\n    static fromQuadKey(quadkey: string): TileKey {\n        const level = quadkey.length;\n        let row = 0;\n        let column = 0;\n        // tslint:disable:no-bitwise\n        for (let i = 0; i < quadkey.length; ++i) {\n            const mask = 1 << i;\n            const d = parseInt(quadkey.charAt(level - i - 1), 10);\n            if (d & 0x1) {\n                column |= mask;\n            }\n            if (d & 0x2) {\n                row |= mask;\n            }\n        }\n        // tslint:enable:no-bitwise\n        return TileKey.fromRowColumnLevel(row, column, level);\n    }\n    /**\n     * Creates a tile key from a numeric Morton code representation.\n     *\n     * You can convert a tile key into a numeric Morton code with [[mortonCode]].\n     *\n     * @param quadKey64 - The Morton code to be converted.\n     * @returns A new instance of {@link TileKey}.\n     */\n    static fromMortonCode(quadKey64: number): TileKey {\n        let level = 0;\n        let row = 0;\n        let column = 0;\n        let quadKey = quadKey64;\n        // tslint:disable:no-bitwise\n        while (quadKey > 1) {\n            const mask: number = 1 << level;\n\n            if (quadKey & 0x1) {\n                column |= mask;\n            }\n            if (quadKey & 0x2) {\n                row |= mask;\n            }\n\n            level++;\n            quadKey = (quadKey - (quadKey & 0x3)) / 4;\n        }\n        // tslint:enable:no-bitwise\n        const result = TileKey.fromRowColumnLevel(row, column, level);\n        result.m_mortonCode = quadKey64;\n        return result;\n    }\n\n    /**\n     * Creates a tile key from a heretile code string.\n     *\n     * The string can be created with [[toHereTile]].\n     *\n     * @param quadkey64 - The string representation of the HERE tile key.\n     * @returns A new instance of `TileKey`.\n     */\n    static fromHereTile(quadkey64: string): TileKey {\n        const result = TileKey.fromMortonCode(parseInt(quadkey64, 10));\n        result.m_hereTile = quadkey64;\n        return result;\n    }\n\n    /**\n     * Returns the number of available columns at a given level.\n     *\n     * This is 2 to the power of the level.\n     *\n     * @param level - The level for which to return the number of columns.\n     * @returns The available columns at the given level.\n     */\n    static columnsAtLevel(level: number): number {\n        return Math.pow(2, level);\n    }\n\n    /**\n     * Returns the number of available rows at a given level.\n     *\n     * This is 2 to the power of the level.\n     *\n     * @param level - The level for which to return the number of rows.\n     * @returns The available rows at the given level.\n     */\n    static rowsAtLevel(level: number): number {\n        return Math.pow(2, level);\n    }\n\n    /**\n     * Returns the closest matching `TileKey` in a cartesian coordinate system.\n     *\n     * @param level - The level for the tile key.\n     * @param coordX - The X coordinate.\n     * @param coordY - The Y coordinate.\n     * @param totalWidth - The maximum X coordinate.\n     * @param totalHeight - The maximum Y coordinate.\n     * @returns A new tile key at the given level that includes the given coordinates.\n     */\n    static atCoords(\n        level: number,\n        coordX: number,\n        coordY: number,\n        totalWidth: number,\n        totalHeight: number\n    ): TileKey {\n        return TileKey.fromRowColumnLevel(\n            Math.floor(coordY / (totalHeight / TileKey.rowsAtLevel(level))),\n            Math.floor(coordX / (totalWidth / TileKey.columnsAtLevel(level))),\n            level\n        );\n    }\n\n    /**\n     * Computes the Morton code of the parent tile key of the given Morton code.\n     *\n     * Note: The parent key of the root key is the root key itself.\n     *\n     * @param mortonCode - A Morton code, for example, obtained from [[mortonCode]].\n     * @returns The Morton code of the parent tile.\n     */\n    static parentMortonCode(mortonCode: number): number {\n        return Math.floor(mortonCode / 4);\n    }\n\n    private m_mortonCode?: number;\n    private m_hereTile?: string;\n\n    /**\n     * Constructs a new immutable instance of a `TileKey`.\n     *\n     * For the better readability, {@link TileKey.fromRowColumnLevel} should be preferred.\n     *\n     * Note - row and column must not be greater than the maximum rows/columns for the given level.\n     *\n     * @param row - Represents the row in the quadtree.\n     * @param column - Represents the column in the quadtree.\n     * @param level - Represents the level in the quadtree.\n     */\n    constructor(readonly row: number, readonly column: number, readonly level: number) {}\n\n    /**\n     * Returns a tile key representing the parent of the tile addressed by this tile key.\n     *\n     * Throws an exception is this tile is already the root.\n     */\n    parent(): TileKey {\n        if (this.level === 0) {\n            throw new Error(\"Cannot get the parent of the root tile key\");\n        }\n        // tslint:disable-next-line:no-bitwise\n        return TileKey.fromRowColumnLevel(this.row >>> 1, this.column >>> 1, this.level - 1);\n    }\n\n    /**\n     * Returns a new tile key at a level that differs from this tile's level by delta.\n     *\n     * Equivalent to `changedLevelTo(level() + delta)`.\n     *\n     * Note - root key is returned if `delta` is smaller than the level of this tile key.\n     *\n     * @param delta - The numeric difference between the current level and the requested level.\n     */\n    changedLevelBy(delta: number): TileKey {\n        const level = Math.max(0, this.level + delta);\n        let row = this.row;\n        let column = this.column;\n\n        // tslint:disable:no-bitwise\n        if (delta >= 0) {\n            row <<= delta;\n            column <<= delta;\n        } else {\n            row >>>= -delta;\n            column >>>= -delta;\n        }\n        // tslint:enable:no-bitwise\n        return TileKey.fromRowColumnLevel(row, column, level);\n    }\n\n    /**\n     * Returns a new tile key at the requested level.\n     *\n     * If the requested level is smaller than the tile's level, then the key of an ancestor of this\n     * tile is returned. If the requested level is larger than the tile's level, then the key of\n     * first child or grandchild of this tile is returned, for example, the child with the lowest\n     * row and column number. If the requested level equals this tile's level, then the tile key\n     * itself is returned. If the requested level is negative, the root tile key is returned.\n     *\n     * @param level - The requested level.\n     */\n    changedLevelTo(level: number): TileKey {\n        return this.changedLevelBy(level - this.level);\n    }\n\n    /**\n     * Converts the tile key to a numeric code representation.\n     *\n     * You can create a tile key from a numeric Morton code with [[fromMortonCode]].\n     *\n     * Note - only levels <= 26 are supported.\n     */\n    mortonCode(): number {\n        if (this.m_mortonCode === undefined) {\n            let column = this.column;\n            let row = this.row;\n\n            // tslint:disable:no-bitwise\n            let result = powerOfTwo[this.level << 1];\n            for (let i = 0; i < this.level; ++i) {\n                if (column & 0x1) {\n                    result += powerOfTwo[2 * i];\n                }\n                if (row & 0x1) {\n                    result += powerOfTwo[2 * i + 1];\n                }\n                column >>>= 1;\n                row >>>= 1;\n            }\n            // tslint:enable:no-bitwise\n\n            this.m_mortonCode = result;\n        }\n        return this.m_mortonCode;\n    }\n\n    /**\n     * Converts the tile key into a string for using in REST API calls.\n     *\n     * The string is a quadkey Morton code representation as a string.\n     *\n     * You can convert back from a quadkey string with [[fromHereTile]].\n     */\n    toHereTile(): string {\n        if (this.m_hereTile === undefined) {\n            this.m_hereTile = this.mortonCode().toString();\n        }\n        return this.m_hereTile;\n    }\n\n    /**\n     * Converts the tile key into a string for using in REST API calls.\n     *\n     * If the tile is the root tile, the quadkey is '-'. Otherwise the string is a number to the\n     * base of 4, but without the leading 1, with the following properties:\n     *  1. the number of digits equals the level.\n     *  2. removing the last digit gives the parent tile's quadkey string, i.e. appending 0,1,2,3\n     *     to a quadkey string gives the tiles's children.\n     *\n     * You can convert back from a quadkey string with [[fromQuadKey]].\n     */\n    toQuadKey(): string {\n        let result: string = \"\";\n\n        // tslint:disable:no-bitwise\n        for (let i = this.level; i > 0; --i) {\n            const mask = 1 << (i - 1);\n\n            const col = (this.column & mask) !== 0;\n            const row = (this.row & mask) !== 0;\n\n            if (col && row) {\n                result += \"3\";\n            } else if (row) {\n                result += \"2\";\n            } else if (col) {\n                result += \"1\";\n            } else {\n                result += \"0\";\n            }\n        }\n        // tslint:enable:no-bitwise\n\n        return result;\n    }\n\n    /**\n     * Equality operator.\n     *\n     * @param qnr - The tile key to compare to.\n     * @returns `true` if this tile key has identical row, column and level, `false` otherwise.\n     */\n    equals(qnr: TileKey): boolean {\n        return this.row === qnr.row && this.column === qnr.column && this.level === qnr.level;\n    }\n\n    /**\n     * Returns the absolute quadkey that is constructed from its sub quadkey.\n     *\n     * @param sub - The sub key.\n     * @returns The absolute tile key in the quadtree.\n     */\n    addedSubKey(sub: string): TileKey {\n        const subQuad = TileKey.fromQuadKey(sub.length === 0 ? \"-\" : sub);\n        const child = this.changedLevelBy(subQuad.level);\n        return TileKey.fromRowColumnLevel(\n            child.row + subQuad.row,\n            child.column + subQuad.column,\n            child.level\n        );\n    }\n\n    /**\n     * Returns the absolute quadkey that is constructed from its sub HERE tile key.\n     *\n     * @param sub - The sub HERE key.\n     * @returns The absolute tile key in the quadtree.\n     */\n    addedSubHereTile(sub: string): TileKey {\n        const subQuad = TileKey.fromHereTile(sub);\n        const child = this.changedLevelBy(subQuad.level);\n        return TileKey.fromRowColumnLevel(\n            child.row + subQuad.row,\n            child.column + subQuad.column,\n            child.level\n        );\n    }\n\n    /**\n     * Returns a sub quadkey that is relative to its parent.\n     *\n     * This function can be used to generate sub keys that are relative to a parent that is delta\n     * levels up in the quadtree.\n     *\n     * This function can be used to create shortened keys for quads on lower levels if the parent is\n     * known.\n     *\n     * Note - the sub quadkeys fit in a 16-bit unsigned integer if the `delta` is smaller than 8. If\n     * `delta` is smaller than 16, the sub quadkey fits into an unsigned 32-bit integer.\n     *\n     * Deltas larger than 16 are not supported.\n     *\n     * @param delta - The number of levels relative to its parent quadkey. Must be greater or equal\n     * to 0 and smaller than 16.\n     * @returns The quadkey relative to its parent that is `delta` levels up the tree.\n     */\n    getSubHereTile(delta: number): string {\n        const key = this.mortonCode();\n        // tslint:disable-next-line:no-bitwise\n        const msb = 1 << (delta * 2);\n        const mask = msb - 1;\n        // tslint:disable-next-line:no-bitwise\n        const result = (key & mask) | msb;\n        return result.toString();\n    }\n\n    /**\n     * Returns the number of available rows in the tile's [[level]].\n     *\n     * This is 2 to the power of the level.\n     */\n    rowCount(): number {\n        return TileKey.rowsAtLevel(this.level);\n    }\n\n    /**\n     * Returns the number of available columns in the tile's [[level]].\n     *\n     * This is 2 to the power of the level.\n     */\n    columnCount(): number {\n        return TileKey.columnsAtLevel(this.level);\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { MathUtils } from \"three\";\nimport { ColorUtils } from \"./ColorUtils\";\nimport { parseStringEncodedColor } from \"./StringEncodedNumeral\";\n\n/**\n * A class representing RGBA colors.\n *\n * @hidden\n * @internal\n */\nexport class RGBA {\n    /**\n     * Parses a string describing a color.\n     *\n     * @param text - The string color literal\n     */\n    static parse(text: string) {\n        const color = parseStringEncodedColor(text);\n\n        if (color === undefined) {\n            return undefined;\n        }\n\n        return ColorUtils.getRgbaFromHex(color);\n    }\n\n    /**\n     * Constructs a [[RGBA]] color using the given components in the [0..1] range.\n     */\n    constructor(\n        public r: number = 1,\n        public g: number = 1,\n        public b: number = 1,\n        public a: number = 1\n    ) {}\n\n    /**\n     * Clones this [[RGBA]] color.\n     */\n    clone() {\n        return new RGBA(this.r, this.g, this.b, this.a);\n    }\n\n    /**\n     * Returns this color encoded as one single number.\n     */\n    getHex() {\n        return ColorUtils.getHexFromRgba(this.r, this.g, this.b, this.a);\n    }\n\n    /**\n     * Linearly interpolate the components of this color.\n     */\n    lerp(target: RGBA, t: number) {\n        this.r = MathUtils.lerp(this.r, target.r, t);\n        this.g = MathUtils.lerp(this.g, target.g, t);\n        this.b = MathUtils.lerp(this.b, target.b, t);\n        this.a = MathUtils.lerp(this.a, target.a, t);\n        return this;\n    }\n\n    /**\n     * Returns this color encoded as JSON literal.\n     */\n    toJSON() {\n        // tslint:disable-next-line: no-bitwise\n        return `rgba(${(this.r * 255) << 0}, ${(this.g * 255) << 0}, ${(this.b * 255) << 0}, ${\n            this.a\n        })`;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { assert } from \"@here/harp-utils\";\nimport { ColorUtils } from \"./ColorUtils\";\n\n//@ts-ignore\nimport { parseCSSColor } from \"csscolorparser\";\n\n/**\n * Enumeration of supported string encoded numerals.\n * @internal\n */\nexport enum StringEncodedNumeralType {\n    Meters,\n    Pixels,\n    Hex\n}\n\n/**\n * Interface containing information about a [[StringEncodedNumeral]] format, component size and\n * evaluation.\n * @internal\n */\nexport interface StringEncodedNumeralFormat {\n    readonly type: StringEncodedNumeralType;\n    readonly size: number;\n    readonly regExp: RegExp;\n    mask?: number;\n    decoder: (encodedValue: string, target: number[]) => boolean;\n}\nconst StringEncodedMeters: StringEncodedNumeralFormat = {\n    type: StringEncodedNumeralType.Meters,\n    size: 1,\n    regExp: /^((?=\\.\\d|\\d)(?:\\d+)?(?:\\.?\\d*))m$/,\n    decoder: (encodedValue: string, target: number[]) => {\n        const match = StringEncodedMeters.regExp.exec(encodedValue);\n        return match ? (target[0] = Number(match[1])) !== undefined : false;\n    }\n};\nconst StringEncodedPixels: StringEncodedNumeralFormat = {\n    type: StringEncodedNumeralType.Pixels,\n    size: 1,\n    mask: 1.0,\n    regExp: /^((?=\\.\\d|\\d)(?:\\d+)?(?:\\.?\\d*))px$/,\n    decoder: (encodedValue: string, target: number[]) => {\n        const match = StringEncodedPixels.regExp.exec(encodedValue);\n        if (match === null) {\n            return false;\n        }\n        target[0] = Number(match[1]);\n        return true;\n    }\n};\nconst StringEncodedHex: StringEncodedNumeralFormat = {\n    type: StringEncodedNumeralType.Hex,\n    size: 4,\n    regExp: /^\\#((?:[0-9A-Fa-f][0-9A-Fa-f]){4}|[0-9A-Fa-f]{4})$/,\n    decoder: (encodedValue: string, target: number[]) => {\n        const match = StringEncodedHex.regExp.exec(encodedValue);\n        if (match === null) {\n            return false;\n        }\n        const hex = match[1];\n        const size = hex.length;\n        // Only few sizes are possible for given reg-exp.\n        assert(size === 4 || size === 8, `Matched incorrect hex color format`);\n        // Note that we simply ignore alpha channel value.\n        // TODO: To be resolved with HARP-7517\n        if (size === 4) {\n            // #RGB or #RGBA\n            target[0] = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;\n            target[1] = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;\n            target[2] = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;\n            target[3] = size === 4 ? parseInt(hex.charAt(3) + hex.charAt(3), 16) / 255 : 1;\n        } else if (size === 8) {\n            // #RRGGBB or #RRGGBBAA\n            target[0] = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;\n            target[1] = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;\n            target[2] = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;\n            target[3] = size === 8 ? parseInt(hex.charAt(6) + hex.charAt(7), 16) / 255 : 1;\n        }\n        return true;\n    }\n};\n\n/**\n * Array of all supported [[StringEncodedNumeralFormat]]s describing sizes, lengths and distances.\n * @internal\n */\nexport const StringEncodedMetricFormats: StringEncodedNumeralFormat[] = [\n    StringEncodedMeters,\n    StringEncodedPixels\n];\n\nconst StringEncodedMetricFormatMaxSize = StringEncodedMetricFormats.reduce(\n    (a, b) => Math.max(a, b.size),\n    0\n);\n\n/**\n * Array of all supported [[StringEncodedNumeralFormat]]s describing color data.\n * @internal\n */\nexport const StringEncodedColorFormats: StringEncodedNumeralFormat[] = [StringEncodedHex];\n\nconst StringEncodedColorFormatMaxSize = StringEncodedColorFormats.reduce(\n    (a, b) => Math.max(a, b.size),\n    0\n);\n\n/**\n * Array of supported [[StringEncodedNumeralFormat]]s (intended to be indexed with\n * [[StringEncodedNumeralType]] enum).\n * @internal\n */\nexport const StringEncodedNumeralFormats: StringEncodedNumeralFormat[] = [\n    ...StringEncodedMetricFormats,\n    ...StringEncodedColorFormats\n];\n\n/**\n * @internal\n */\nexport const StringEncodedNumeralFormatMaxSize = Math.max(\n    StringEncodedColorFormatMaxSize,\n    StringEncodedMetricFormatMaxSize\n);\n\nconst tmpBuffer: number[] = new Array(StringEncodedNumeralFormatMaxSize);\n\n/**\n * Parse string encoded numeral values using all known [[StringEncodedNumeralFormats]].\n *\n * @param numeral - The string representing numeric value.\n * @param pixelToMeters - The ratio used to convert from meters to pixels (default 1.0).\n * @returns Number parsed or __undefined__ if non of the numeral patterns matches the expression\n * provided in [[numeral]].\n */\nexport function parseStringEncodedNumeral(\n    numeral: string,\n    pixelToMeters: number = 1.0\n): number | undefined {\n    return parseStringLiteral(numeral, StringEncodedNumeralFormats, pixelToMeters);\n}\n\n/**\n * Parse string encoded color value using all known [[StringEncodedColorFormats]].\n *\n * @param color - The string encoded color expression (i.e. '#FFF', 'rgb(255, 0, 0)', etc.).\n * @returns The color parsed or __undefined__ if non of the known representations matches\n * the expression provided in [[color]].\n */\nexport function parseStringEncodedColor(color: string): number | undefined {\n    return parseStringLiteral(color, StringEncodedColorFormats);\n}\n\nfunction parseStringLiteral(\n    text: string,\n    formats: StringEncodedNumeralFormat[],\n    pixelToMeters: number = 1.0\n): number | undefined {\n    const matchedFormat = formats.find(format => {\n        return format.decoder(text, tmpBuffer) ? true : false;\n    });\n\n    if (matchedFormat === undefined) {\n        const components: number[] | null = parseCSSColor(text);\n\n        return Array.isArray(components) && !components.some(c => isNaN(c))\n            ? ColorUtils.getHexFromRgba(\n                  components[0] / 255,\n                  components[1] / 255,\n                  components[2] / 255,\n                  components[3]\n              )\n            : undefined;\n    }\n\n    switch (matchedFormat?.type) {\n        case StringEncodedNumeralType.Pixels:\n            return tmpBuffer[0] * pixelToMeters;\n        case StringEncodedNumeralType.Hex:\n            return ColorUtils.getHexFromRgba(\n                tmpBuffer[0],\n                tmpBuffer[1],\n                tmpBuffer[2],\n                tmpBuffer[3]\n            );\n        default:\n            return tmpBuffer[0];\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * The type representing the value of a property.\n */\nexport type Value = null | boolean | number | string | object;\n\n/**\n * An interface defining a collection of named properties.\n *\n * @example\n * ```typescript\n * const properties: ValueMap = {\n *    $id: 123,\n *    color: \"rgba(255, 0, 0, 1)\"\n * }\n * ```\n */\nexport interface ValueMap {\n    [name: string]: Value;\n}\n\n/**\n * A class used to lookup properties by name.\n *\n * @remarks\n * Concrete implementation of `Env` like {@link MapEnv} are used\n * to resolve the property names used in {@link Expr | style expressions}.\n *\n * @example\n * ```typescript\n * const env = new MapEnv({\n *     kind: \"landuse\",\n * });\n *\n * const expr = Expr.fromJson([\"get\", \"kind\"]);\n *\n * const value = expr.evaluate(env);\n *\n * console.log(`kind is '${value}`);\n * ```\n */\nexport class Env {\n    /**\n     * Returns `true` if the given object is an instance of {@link Env}.\n     *\n     * @param object - The object to test.\n     */\n    static isEnv(object: any): object is Env {\n        return object instanceof Env;\n    }\n\n    /**\n     * Returns property in {@link Env} by name.\n     *\n     * @param name - Name of property.\n     */\n    lookup(name: string): Value | undefined {\n        return undefined;\n    }\n    /**\n     * Return an object containing all properties of this environment. (Here: empty object).\n     */\n    unmap(): ValueMap {\n        return {};\n    }\n}\n\n/**\n * `MapEnv` is a concrete implementation of {@link Env} that\n * creates a lookup environment from a set of properties.\n *\n * @example\n * ```typescript\n * const baseEnv = new MapEnv({\n *     $zoom: 14,\n * });\n *\n * // extends baseEnv with a the new binding (kind, \"landuse\").\n * const env = new MapEnv({ kind: \"landuse\" }, baseEnv);\n *\n * const zoom = env.lookup(\"$zoom\"); // zoom is 14\n * const kind = env.lookup(\"kind\"); // kind is is \"landuse\"\n *\n * const expr = Expr.fromJson([\"get\", \"kind\"]);\n * const value = expr.evaluate(env); // value is \"landuse\"\n * ```\n */\nexport class MapEnv extends Env {\n    constructor(readonly entries: ValueMap, private readonly parent?: Env) {\n        super();\n    }\n    /**\n     * Returns property in {@link Env} by name.\n     *\n     * @param name - Name of property.\n     * @override\n     */\n    lookup(name: string): Value | undefined {\n        if (this.entries.hasOwnProperty(name)) {\n            const value = this.entries[name];\n            if (value !== undefined) {\n                return value;\n            }\n        }\n        return this.parent ? this.parent.lookup(name) : undefined;\n    }\n    /**\n     * Return an object containing all properties of this environment, takes care of the parent\n     * object.\n     * @override\n     */\n    unmap(): ValueMap {\n        const obj: any = this.parent ? this.parent.unmap() : {};\n        for (const key in this.entries) {\n            if (this.entries.hasOwnProperty(key)) {\n                obj[key] = this.entries[key];\n            }\n        }\n        return obj;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { JsonExpr } from \"./Expr\";\n\n/**\n * Interpolation mode used when computing a [[InterpolatedProperty]] value for a given zoom level.\n * @internal\n */\nexport enum InterpolationMode {\n    Discrete,\n    Linear,\n    Cubic,\n    Exponential\n}\n\n/**\n * Interpolated property could have its value (some initial value should be provided) changed\n * according to an interpolation type.\n *\n * Here is an example of an interpolated property from a map style:\n * \"lineWidth\": {\n *  \"interpolation\": \"Linear\",\n *  \"zoomLevels\": [13, 14, 15],\n *  \"values\": [ 1.5, 1.2, 0.9]\n * }\n * @internal\n */\nexport interface InterpolatedPropertyDefinition<T> {\n    interpolation?: \"Discrete\" | \"Linear\" | \"Cubic\" | \"Exponential\";\n    zoomLevels: number[];\n    values: T[];\n    exponent?: number;\n}\n\n/**\n * Checks if a property is interpolated.\n * @param p - property to be checked\n * @internal\n */\nexport function isInterpolatedPropertyDefinition<T>(\n    p: any\n): p is InterpolatedPropertyDefinition<T> {\n    if (\n        p &&\n        p.interpolationMode === undefined &&\n        Array.isArray(p.values) &&\n        p.values.length > 0 &&\n        p.values[0] !== undefined &&\n        Array.isArray(p.zoomLevels) &&\n        p.zoomLevels.length > 0 &&\n        p.zoomLevels[0] !== undefined &&\n        p.values.length === p.zoomLevels.length\n    ) {\n        return true;\n    }\n    return false;\n}\n\n/**\n * Converts an [[InterpolatedPropertyDefinition]] to a [[JsonExpr]].\n *\n * @param property - A valid [[InterpolatedPropertyDefinition]]\n */\nexport function interpolatedPropertyDefinitionToJsonExpr(\n    property: InterpolatedPropertyDefinition<any>\n): JsonExpr {\n    if (property.interpolation === undefined || property.interpolation === \"Discrete\") {\n        const step: JsonExpr = [\"step\", [\"zoom\"], property.values[0]];\n        for (let i = 1; i < property.zoomLevels.length; ++i) {\n            step.push(property.zoomLevels[i], property.values[i]);\n        }\n        return step;\n    }\n    const interpolation: JsonExpr = [\"interpolate\"];\n    switch (property.interpolation) {\n        case \"Linear\":\n            interpolation.push([\"linear\"]);\n            break;\n        case \"Cubic\":\n            interpolation.push([\"cubic\"]);\n            break;\n        case \"Exponential\":\n            interpolation.push([\n                \"exponential\",\n                property.exponent !== undefined ? property.exponent : 2\n            ]);\n            break;\n        default:\n            throw new Error(`interpolation mode '${property.interpolation}' is not supported`);\n    } //switch\n    interpolation.push([\"zoom\"]);\n    for (let i = 0; i < property.zoomLevels.length; ++i) {\n        interpolation.push(property.zoomLevels[i], property.values[i]);\n    }\n    return interpolation;\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Vector3Like } from \"@here/harp-geoutils/lib/math/Vector3Like\";\nimport { isJsonExpr, JsonExpr } from \"./Expr\";\nimport { isInterpolatedPropertyDefinition } from \"./InterpolatedPropertyDefs\";\nimport {\n    BaseTechniqueParams,\n    BasicExtrudedLineTechniqueParams,\n    DynamicProperty,\n    ExtrudedPolygonTechniqueParams,\n    FillTechniqueParams,\n    LineTechniqueParams,\n    MarkerTechniqueParams,\n    PointTechniqueParams,\n    SegmentsTechniqueParams,\n    ShaderTechniqueParams,\n    SolidLineTechniqueParams,\n    StandardExtrudedLineTechniqueParams,\n    StandardTechniqueParams,\n    TerrainTechniqueParams,\n    TextTechniqueParams\n} from \"./TechniqueParams\";\n\n/**\n * Map theme is used to define what features are shown and how the map is styled, for example\n * which lightning is used or whether fog should be displayed.\n */\nexport interface Theme {\n    /**\n     * The URI of the JSON schema describing themes.\n     */\n    $schema?: string;\n\n    /**\n     * The base `Theme`s or `theme` URLs to extend.\n     *\n     * @remarks\n     * If used, base themes are loaded first, and then all the properties from inherited theme\n     * overwrite these defined in base theme.\n     */\n\n    extends?: string | Theme | Array<string | Theme>;\n\n    //\n    // TODO: We support also [[FlatTheme]], but it's not exposed here since ts-json-schema-generator\n    // fails with too complex typing.\n    // See: https://github.com/vega/ts-json-schema-generator/issues/192\n    // Typing should look like this:\n    // extends?: string | Theme | FlatTheme| Array<string | Theme | FlatTheme>;\n    //\n\n    /**\n     * Actual URL the theme has been loaded from.\n     */\n    url?: string;\n\n    /**\n     * Color to be used as a clear background - no map objects.\n     * @format color-hex\n     */\n    clearColor?: string;\n\n    /**\n     * Alpha to be used as a clear background - no map objects.\n     * @format 0-1\n     */\n    clearAlpha?: number;\n\n    /**\n     * Define the default text style for styling labels and texts.\n     */\n    defaultTextStyle?: TextStyleDefinition;\n\n    /**\n     * Define the lightning available on the three.js scene.\n     */\n    lights?: Light[];\n\n    /**\n     * Define the style of the sky presented in the map scene.\n     */\n    sky?: Sky;\n\n    /**\n     * Define the fog used in the map scene.\n     */\n    fog?: Fog;\n\n    /**\n     * The definitions exported by these theme.\n     */\n    definitions?: Definitions;\n\n    /**\n     * Map styles available for datasources used to render the map.\n     */\n    styles?: Styles;\n\n    /**\n     * Define the style to render different types of text used on the map.\n     */\n    textStyles?: TextStyleDefinition[];\n\n    /**\n     * List available fonts to be used while rendering text.\n     */\n    fontCatalogs?: FontCatalogConfig[];\n\n    /**\n     * Optional images to be rendered on the map view.\n     */\n    images?: ImageDefinitions;\n\n    /**\n     * Image textures to be used while rendering geometries on the map view.\n     */\n    imageTextures?: ImageTexture[];\n\n    /**\n     * Optional list of [[ThemePoiTableDef]]s.\n     */\n    poiTables?: PoiTableRef[];\n\n    /**\n     * Optional list of symbolic priorities for the object\n     * created using this {@link Theme}.\n     *\n     * @remarks\n     * The attribute `styleSet` and `category` of the [[Technique]]\n     * are used together with [[Theme.priorities]] to sort\n     * the objects created using this {@link Theme}, for example:\n     *\n     * ```json\n     * {\n     *      \"priorities\": [\n     *          { \"group\": \"tilezen\", \"category\": \"outline-1\" }\n     *      ],\n     *      \"styles\": [\n     *          {\n     *              \"technique\": \"solid-line\",\n     *              \"styleSet\": \"tilezen\",\n     *              \"category\": \"outline-1\"\n     *          }\n     *      ]\n     * }\n     * ```\n     */\n    priorities?: StylePriority[];\n\n    /**\n     * Optional list of priorities for the screen-space\n     * objects created using this style.\n     *\n     * @remarks\n     * The name of the `category` attribute of the screen-space\n     * technique (e.g. `\"text\"`) must match on the strings\n     * defined by this [[Theme.labelPriorities]], for example:\n     *\n     * ```json\n     * {\n     *      \"labelPriorities\": [\n     *          \"continent-labels\",\n     *          \"country-labels\",\n     *          \"state-labels\"\n     *      ],\n     *      \"styles\": [\n     *          {\n     *              \"technique\": \"text\",\n     *              \"category\": \"state-labels\"\n     *          }\n     *      ]\n     * }\n     * ```\n     */\n    labelPriorities?: string[];\n}\n\n/**\n * A type representing symbolic render orders.\n */\nexport interface StylePriority {\n    /**\n     * The group of this [[StylePriority]].\n     */\n    group: string;\n\n    /**\n     * The category of this [[StylePriority]].\n     */\n    category?: string;\n}\n\n/**\n * A type representing HARP themes with all the styleset declarations\n * grouped in one [[Array]].\n *\n * @internal This type will merge with {@link Theme}.\n */\nexport type FlatTheme = Omit<Theme, \"styles\"> & {\n    /**\n     * The style rules used to render the map.\n     */\n    styles?: StyleSet;\n};\n\n/**\n * Checks if the given definition implements the [[BoxedDefinition]] interface.\n */\nexport function isBoxedDefinition(def: Definition): def is BoxedDefinition {\n    const bdef = def as BoxedDefinition;\n    return (\n        typeof bdef === \"object\" &&\n        bdef !== null &&\n        (typeof bdef.type === \"string\" || typeof bdef.type === \"undefined\") &&\n        (typeof bdef.value === \"string\" ||\n            typeof bdef.value === \"number\" ||\n            typeof bdef.value === \"boolean\" ||\n            isInterpolatedPropertyDefinition(bdef.value) ||\n            isJsonExpr(bdef.value))\n    );\n}\n\nexport function isLiteralDefinition(def: Definition): def is LiteralValue {\n    return typeof def === \"string\" || typeof def === \"number\" || typeof def === \"boolean\";\n}\n\n/**\n * Value definition commons.\n */\nexport interface BaseValueDefinition {\n    /**\n     * The type of the definition.\n     */\n    type?: string;\n\n    /**\n     * The description of the definition.\n     */\n    description?: string;\n}\n\n/**\n * Possible types of unboxed literal values carried by [[Definition]].\n */\nexport type LiteralValue = string | number | boolean;\n\n/**\n * Boxed definition without type.\n */\nexport interface BoxedAnyDefinition extends BaseValueDefinition {\n    /**\n     * The value of the definition.\n     */\n    value: LiteralValue | JsonExpr;\n}\n\n/**\n * A boxed boolean value definition.\n */\nexport interface BoxedBooleanDefinition extends BaseValueDefinition {\n    /**\n     * The type of the definition.\n     */\n    type: \"boolean\";\n\n    /**\n     * The value of the definition.\n     */\n    value: DynamicProperty<boolean>;\n}\n\n/**\n * A boxed numerical value definition.\n */\nexport interface BoxedNumericDefinition extends BaseValueDefinition {\n    /**\n     * The type of the definition.\n     */\n    type: \"number\";\n\n    /**\n     * The value of the definition.\n     */\n    value: DynamicProperty<number>;\n}\n\n/**\n * A boxed string value definition.\n */\nexport interface BoxedStringDefinition extends BaseValueDefinition {\n    /**\n     * The type of the definition.\n     */\n    type: \"string\";\n\n    /**\n     * The value of the definition.\n     */\n    value: DynamicProperty<string>;\n}\n\n/**\n * A boxed color value definition.\n */\nexport interface BoxedColorDefinition extends BaseValueDefinition {\n    /**\n     * The type of the definition.\n     */\n    type: \"color\";\n\n    /**\n     * The value of the definition.\n     */\n    value: DynamicProperty<string>;\n}\n\n/**\n * A boxed selector value definition.\n */\nexport interface BoxedSelectorDefinition extends BaseValueDefinition {\n    /**\n     * The type of the definition.\n     */\n    type: \"selector\";\n\n    /**\n     * The value of the definition.\n     *\n     * See [[BaseStyle.when]].\n     */\n    value: string | JsonExpr;\n}\n\n/**\n * A boxed value definition.\n */\nexport type BoxedDefinition =\n    | BoxedAnyDefinition\n    | BoxedBooleanDefinition\n    | BoxedNumericDefinition\n    | BoxedStringDefinition\n    | BoxedColorDefinition\n    | BoxedSelectorDefinition;\n\n/**\n * Possible values for `definitions` element of [Theme].\n */\nexport type Definition = LiteralValue | JsonExpr | BoxedDefinition | StyleDeclaration;\n\n/**\n * An array of [[Definition]]s.\n */\nexport interface Definitions {\n    [name: string]: Definition;\n}\n\n/**\n * Base [StyleSelector] attributes required to match [Style] object against given feature.\n *\n * Contains [Style]'s members related to feature matching in [[StyleSetEvaluator]].\n */\nexport interface StyleSelector {\n    /**\n     * Condition when this style rule applies.\n     *\n     * @remarks\n     * Condition that is applied to feature properties to check if given [[Style]] this feature\n     * should emit geometry of this style.\n     */\n    when: string | JsonExpr;\n\n    /**\n     * The layer containing the carto features processed by this style rule.\n     */\n    layer?: string;\n\n    /**\n     * Optional. If `true`, no more matching styles will be evaluated.\n     */\n    final?: boolean;\n}\n\nexport type JsonExprReference = [\"ref\", string];\n\n/**\n * Checks if the given value is a reference to a definition.\n *\n * @param value - The value of a technique property.\n */\nexport function isJsonExprReference(value: any): value is JsonExprReference {\n    return (\n        Array.isArray(value) &&\n        value.length === 2 &&\n        value[0] === \"ref\" &&\n        typeof value[1] === \"string\"\n    );\n}\n\n/**\n * Like [[StyleDeclaration]], but without [[Reference]] type.\n */\nexport type ResolvedStyleDeclaration = Style & StyleSelector;\n\n/**\n * Like [[StyleSet]], but without [[Reference]] type.\n */\nexport type ResolvedStyleSet = ResolvedStyleDeclaration[];\n\n/**\n * Compound type that merges all raw [Style] with selector arguments from [BaseSelector], optionally\n * a [[Reference]].\n */\nexport type StyleDeclaration = (Style & StyleSelector) | JsonExpr;\n\nexport function isActualSelectorDefinition(def: Definition): def is Style & StyleSelector {\n    const styleDef = def as StyleDeclaration;\n    return (\n        typeof styleDef === \"object\" &&\n        styleDef !== null &&\n        !Array.isArray(styleDef) &&\n        typeof styleDef.technique === \"string\"\n    );\n}\n\n/**\n * An array of [[StyleSelector]]s that are used together to define how a [[DataSource]] should be\n * rendered. `StyleSet`s are applied to sources providing vector tiles via their method\n * `setStyleSet`. This is also handle internally when a whole theme is passed to a [[MapView]] via\n * `mapview.theme`.\n */\nexport type StyleSet = StyleDeclaration[];\n\n/**\n * The object that defines what way an item of a [[DataSource]] should be decoded to assemble a\n * tile. [[Style]] is describing which features are shown on a map and in what way they are being\n * shown.\n */\nexport type BaseStyle<Technique, Params> = Partial<Params> & {\n    /**\n     * Human readable description.\n     */\n    description?: string;\n\n    /**\n     * The style set referenced by this styling rule.\n     */\n    styleSet?: string;\n\n    /**\n     * The category of this style.\n     */\n    category?: string | JsonExpr;\n\n    /**\n     * The name of the technique to use.\n     *\n     * @remarks\n     * Technique name. See the classes extending from this class to determine what possible\n     * techniques are possible, includes `\"line\"`, `\"fill\"`, `\"solid-line\"`, `\"extruded-line\"`,\n     * `\"extruded-polygon\"`, `\"text\"`, `\"none\"`.\n     */\n    technique: Technique;\n\n    /**\n     * Specify `renderOrder` of value.\n     *\n     * @remarks\n     * @default If not specified in style file, `renderOrder` will be assigned with monotonically\n     * increasing values according to style position in file.\n     */\n    renderOrder?: number | JsonExpr;\n\n    /**\n     * Minimal zoom level. If the current zoom level is smaller, the technique will not be used.\n     */\n    minZoomLevel?: number | JsonExpr;\n\n    /**\n     * Maximum zoom level. If the current zoom level is larger, the technique will not be used.\n     */\n    maxZoomLevel?: number | JsonExpr;\n\n    /**\n     * Optional. If `true`, no IDs will be saved for the geometry this style creates. Default is\n     * `false`.\n     */\n    transient?: boolean;\n\n    /**\n     * Optional: If `true`, the objects with matching `when` statement will be printed to the\n     * console.\n     */\n    debug?: boolean;\n\n    // TODO: Make pixel units default.\n    /**\n     * Units in which different size properties are specified. Either `Meter` (default) or `Pixel`.\n     *\n     * @deprecated use \"string encoded numerals\" as documented in TODO, wher eis the doc ?\n     */\n    metricUnit?: \"Meter\" | \"Pixel\";\n\n    /**\n     * XYZ defines the property to display as text label of a feature in the styles.\n     */\n    labelProperty?: string;\n\n    attr?: Partial<Params>;\n};\n\nexport type Style =\n    | SquaresStyle\n    | CirclesStyle\n    | PoiStyle\n    | LineMarkerStyle\n    | LineStyle\n    | SegmentsStyle\n    | SolidLineStyle\n    | LabelRejectionLineStyle\n    | FillStyle\n    | StandardStyle\n    | BasicExtrudedLineStyle\n    | StandardExtrudedLineStyle\n    | ExtrudedPolygonStyle\n    | ShaderStyle\n    | TerrainStyle\n    | TextTechniqueStyle\n    | NoneStyle;\n\n/**\n * A dictionary of [[StyleSet]]s.\n */\nexport interface Styles {\n    [styleSetName: string]: StyleSet;\n}\n\n/**\n * A reference to a style definition.\n *\n * Use as value `attrs` to reference value from `definitions`.\n *\n * Example of usage:\n * ```json\n * {\n *   \"definitions\": {\n *     \"roadColor\": { \"type\": \"color\", \"value\": \"#f00\" }\n *   },\n *   \"styles\": { \"tilezen\": [\n *      {\n *       \"when\": \"kind == 'road\",\n *       \"technique\": \"solid-line\",\n *       \"attr\": {\n *         \"lineColor\": { \"$ref\": \"roadColor\" }\n *       }\n *     }\n *   ] }\n * }\n *```\n */\n\n/**\n * The attributes of a technique.\n */\nexport type Attr<T> = { [P in keyof T]?: T[P] | JsonExpr };\n\n/**\n * Render feature as set of squares rendered in screen space.\n *\n * @see [[PointTechniqueParams]].\n */\nexport type SquaresStyle = BaseStyle<\"squares\", PointTechniqueParams>;\n\n/**\n * Render feature as set of circles rendered in screen space.\n *\n * @see [[PointTechniqueParams]].\n */\nexport type CirclesStyle = BaseStyle<\"circles\", PointTechniqueParams>;\n\n/**\n * Render feature as POIs (icons and text) rendered in screen space.\n *\n * @see [[MarkerTechniqueParams]].\n */\nexport type PoiStyle = BaseStyle<\"labeled-icon\", MarkerTechniqueParams>;\n\n/**\n * Render feature as line markers, which is a recurring marker along a line (usually road).\n *\n * @see [[MarkerTechniqueParams]].\n */\nexport type LineMarkerStyle = BaseStyle<\"line-marker\", MarkerTechniqueParams>;\n\n/**\n * Render feature as line.\n */\nexport type LineStyle = BaseStyle<\"line\", LineTechniqueParams>;\n\n/**\n * Render feature as segments.\n */\nexport type SegmentsStyle = BaseStyle<\"segments\", SegmentsTechniqueParams>;\n\nexport type SolidLineStyle = BaseStyle<\"solid-line\" | \"dashed-line\", SolidLineTechniqueParams>;\n\nexport type LabelRejectionLineStyle = BaseStyle<\"label-rejection-line\", BaseTechniqueParams>;\n\nexport type FillStyle = BaseStyle<\"fill\", FillTechniqueParams>;\n\nexport type StandardStyle = BaseStyle<\"standard\", StandardTechniqueParams>;\n\nexport type TerrainStyle = BaseStyle<\"terrain\", TerrainTechniqueParams>;\n\nexport type BasicExtrudedLineStyle = BaseStyle<\"extruded-line\", BasicExtrudedLineTechniqueParams>;\n\nexport type StandardExtrudedLineStyle = BaseStyle<\n    \"extruded-line\",\n    StandardExtrudedLineTechniqueParams\n>;\n\n/**\n * Style used to draw a geometry as an extruded polygon, for example extruded buildings.\n */\nexport type ExtrudedPolygonStyle = BaseStyle<\"extruded-polygon\", ExtrudedPolygonTechniqueParams>;\n\nexport type ShaderStyle = BaseStyle<\"shader\", ShaderTechniqueParams>;\n\nexport type TextTechniqueStyle = BaseStyle<\"text\", TextTechniqueParams>;\n\nexport interface NoneStyle\n    extends BaseStyle<\n        \"none\",\n        {\n            [name: string]: any;\n        }\n    > {\n    [name: string]: any;\n}\n\n/**\n * Possible lights used for light the map.\n */\nexport type Light = AmbientLight | DirectionalLight;\n\nexport interface BaseLight {\n    type: string;\n    name: string;\n}\n\n/**\n * Light type: ambient.\n *\n * @remarks\n *\n * @defaultSnippets [\n *     {\n *         \"label\": \"New Ambient Light\",\n *         \"description\": \"Adds a new Ambient Light\",\n *         \"body\": {\n *             \"type\": \"ambient\",\n *             \"name\": \"${1:ambient light}\",\n *             \"color\": \"#${2:fff}\",\n *             \"intensity\": \"^${3:1}\"\n *         }\n *     }\n * ]\n */\nexport interface AmbientLight extends BaseLight {\n    type: \"ambient\";\n    /**\n     * @format color-hex\n     */\n    color: string;\n    intensity?: number;\n}\n\n/**\n * Light type: directional.\n *\n * @remarks\n *\n * @defaultSnippets [\n *     {\n *         \"label\": \"New Directional Light\",\n *         \"description\": \"Adds a new Directional Light\",\n *         \"body\": {\n *             \"type\": \"directional\",\n *             \"name\": \"${1:directional-light$:1}\",\n *             \"color\": \"#${2:fff}\",\n *             \"intensity\": \"^${3:1}\",\n *             \"direction\": {\n *                 \"x\": \"^${4:1}\",\n *                 \"y\": \"^${5:0}\",\n *                 \"z\": \"^${6:0}\"\n *             }\n *         }\n *     }\n * ]\n */\nexport interface DirectionalLight extends BaseLight {\n    type: \"directional\";\n    /**\n     * @format color-hex\n     */\n    color: string;\n    intensity: number;\n    direction: Vector3Like;\n    castShadow?: boolean;\n}\n\n/**\n * Various text styles used with labels and texts.\n */\nexport interface TextStyleDefinition {\n    name?: string;\n    fontCatalogName?: string;\n\n    fontName?: string;\n    size?: number;\n    backgroundSize?: number;\n    fontStyle?: \"Regular\" | \"Bold\" | \"Italic\" | \"BoldItalic\";\n    fontVariant?: \"Regular\" | \"AllCaps\" | \"SmallCaps\";\n    rotation?: number;\n    /**\n     * @format color-hex\n     */\n    color?: string;\n    /**\n     * @format color-hex\n     */\n    backgroundColor?: string;\n    opacity?: number;\n    backgroundOpacity?: number;\n\n    tracking?: number;\n    leading?: number;\n    maxLines?: number;\n    lineWidth?: number;\n    canvasRotation?: number;\n    lineRotation?: number;\n    wrappingMode?: \"None\" | \"Character\" | \"Word\";\n    hAlignment?: \"Left\" | \"Center\" | \"Right\";\n    vAlignment?: \"Above\" | \"Center\" | \"Below\";\n    /**\n     * @format comma separated list of placement tokens, i.e. \"TR, TL, C\"\n     * @see [[PlacementToken]]\n     */\n    placements?: string;\n}\n\n/**\n * Interface that defines a procedural gradient sky.\n */\nexport interface GradientSky {\n    /** Sky type. */\n    type: \"gradient\";\n    /**\n     * Color of the upper part of the gradient.\n     * @format color-hex\n     */\n    topColor: string;\n    /**\n     * Color of bottom part of the gradient.\n     * @format color-hex\n     */\n    bottomColor: string;\n    /**\n     * Color of the ground plane.\n     * @format color-hex\n     */\n    groundColor: string;\n    /** Texture's gradient power. */\n    monomialPower?: number;\n}\n\n/**\n * Interface that defines a cubemap sky.\n */\nexport interface CubemapSky {\n    /** Sky type. */\n    type: \"cubemap\";\n    /** Positive X cube map face. */\n    positiveX: string;\n    /** Negative X cube map face. */\n    negativeX: string;\n    /** Positive Y cube map face. */\n    positiveY: string;\n    /** Negative Y cube map face. */\n    negativeY: string;\n    /** Positive Z cube map face. */\n    positiveZ: string;\n    /** Negative Z cube map face. */\n    negativeZ: string;\n}\n\n/**\n * Interface that defines the options to configure the sky.\n */\nexport type Sky = GradientSky | CubemapSky;\n\n/**\n * Interface that defines the options to configure fog.\n */\nexport interface Fog {\n    /** Fog's color. */\n    color: string;\n    /** Distance ratio to far plane at which the linear fog begins. */\n    startRatio: number;\n}\n\n/**\n * Define an image (e.g. icon).\n */\nexport interface ImageDefinition {\n    /** Url to load content from. */\n    url: string;\n    /** `true` to start loading at init tile, `false` to lazily wait until required. */\n    preload: boolean;\n    /** Url of JSON file containing the texture atlas */\n    atlas?: string;\n}\n\nexport interface ImageDefinitions {\n    /** Name of Image. */\n    [name: string]: ImageDefinition;\n}\n\n/**\n * Can be used to create a texture atlas.\n */\nexport interface ImageTexture {\n    /** Name of ImageTexture. Used to reference texture in the styles. */\n    name: string;\n    /** Name of ImageDefinition to use. */\n    image: string;\n    /** Origin of image, defaults to \"topleft\" */\n    origin?: string;\n    /** Specify sub-region: Defaults to 0. */\n    xOffset?: number;\n    /** Specify sub-region: Defaults to 0. */\n    yOffset?: number;\n    /** Specify sub-region:  Defaults to 0, meaning width is taken from loaded image. */\n    width?: number;\n    /** Specify sub-region:  Defaults to 0, meaning height is taken from loaded image. */\n    height?: number;\n    /** Defaults to false. */\n    flipH?: boolean;\n    /** Defaults to false. */\n    flipV?: boolean;\n    /** Defaults to 1. */\n    opacity?: number;\n}\n\n/**\n * Definition for a [[PoiTable]] reference as part of the {@link Theme} object.\n */\nexport interface PoiTableRef {\n    /** Required name of the [[PoiTable]] for later reference. */\n    name: string;\n    /**\n     * Required URL from where to load [[PoiTable]].\n     *\n     * Should refer to JSON that is matched [[PoiTableDef]] interface.\n     */\n    url: string;\n    /**\n     * If set to `true`, the list of values in the field \"altNames\" will be used as names for this\n     * POI.\n     */\n    useAltNamesForKey: boolean;\n}\n\n/**\n * Interface for the JSON description of the [[PoiTable]]. It is being implemented in [[PoiTable]].\n */\nexport interface PoiTableDef {\n    /** Name of the `PoiTable`. Must be unique. */\n    name?: string;\n    /**\n     * Stores the list of [[PoiTableEntry]]s.\n     */\n    poiList?: PoiTableEntryDef[];\n}\n\n/**\n * Interface for the JSON description of the [[PoiTableEntry]]. The interface is being implemented\n * as [[PoiTableEntry]].\n */\nexport interface PoiTableEntryDef {\n    /** Default name of the POI as the key for looking it up. */\n    name?: string;\n    /** Alternative names of the POI. */\n    altNames?: string[];\n    /** Visibility of the POI. If `false`, the POI will not be rendered. */\n    visible?: boolean;\n    /** Name of the icon, defined in the the texture atlases. */\n    iconName?: string;\n    /** Stacking mode of the POI. For future use. */\n    stackMode?: string;\n    /**\n     * Priority of the POI to select the visible set in case there are more POIs than can be\n     * handled.\n     */\n    priority?: number;\n    /** Minimum zoom level to render the icon on. */\n    iconMinLevel?: number;\n    /** Maximum zoom level to render the icon on. */\n    iconMaxLevel?: number;\n    /** Minimum zoom level to render the text label on. */\n    textMinLevel?: number;\n    /** Maximum zoom level to render the text label on. */\n    textMaxLevel?: number;\n}\n\n/**\n * Fonts used for all text related rendering.\n */\nexport interface FontCatalogConfig {\n    url: string;\n    name: string;\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport namespace ExtrusionFeatureDefs {\n    /**\n     * Minimum ratio value for extrusion effect\n     */\n    export const DEFAULT_RATIO_MIN: number = 0.0;\n    /**\n     * Maximum ratio value for extrusion effect\n     */\n    export const DEFAULT_RATIO_MAX: number = 1;\n\n    /**\n     * Buildings height used whenever no height-data is present or height is very small.\n     *\n     * Used to avoid z-fighting between ground plane and building.\n     */\n    export const MIN_BUILDING_HEIGHT = 0.01;\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { DecodedTile, GeometryType, TextPathGeometry } from \"@here/harp-datasource-protocol\";\nimport { GeoBox, OrientedBox3, Projection, TileKey } from \"@here/harp-geoutils\";\nimport { assert, CachedResource, chainCallbacks, LoggerManager } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\nimport { CopyrightInfo } from \"./copyrights/CopyrightInfo\";\nimport { DataSource } from \"./DataSource\";\nimport { ElevationRange } from \"./ElevationRangeSource\";\nimport { LodMesh } from \"./geometry/LodMesh\";\nimport { TileGeometryLoader } from \"./geometry/TileGeometryLoader\";\nimport { MapView } from \"./MapView\";\nimport { PathBlockingElement } from \"./PathBlockingElement\";\nimport { PerformanceStatistics } from \"./Statistics\";\nimport { TextElement } from \"./text/TextElement\";\nimport { TextElementGroup } from \"./text/TextElementGroup\";\nimport { TextElementGroupPriorityList } from \"./text/TextElementGroupPriorityList\";\nimport { TileTextStyleCache } from \"./text/TileTextStyleCache\";\nimport { MapViewUtils, TileOffsetUtils } from \"./Utils\";\n\nconst logger = LoggerManager.instance.create(\"Tile\");\n\nexport type TileObject = THREE.Object3D & {\n    /**\n     * Distance of this object from the {@link Tile}'s center.\n     */\n    displacement?: THREE.Vector3;\n\n    /**\n     * This stores the THREE.Object3D renderOrder property, we need to back it up because we need to\n     * reduce it if the tile is used as fall back. When it is used normally, the renderOrder needs\n     * to be reset.\n     * @hidden\n     */\n    _backupRenderOrder?: number;\n};\n\ninterface DisposableObject {\n    geometry?: THREE.BufferGeometry | THREE.Geometry;\n    geometries?: Array<THREE.BufferGeometry | THREE.Geometry>;\n    material?: THREE.Material[] | THREE.Material;\n}\n\n/**\n * An interface for optional feature data that is saved in a `THREE.Object3D`'s `userData`\n * property.\n */\nexport interface TileFeatureData {\n    /**\n     * The original type of geometry.\n     */\n    geometryType?: GeometryType;\n\n    /**\n     * An optional array of sorted indices into geometry where the feature starts. The lists of IDs\n     * and starting indices (starts) must have the same size.\n     * Feature i starts at starts[i] and ends at starts[i+1]-1, except for the last feature, which\n     * ends at the last index in the object's geometry.\n     */\n    starts?: number[];\n\n    /**\n     * An optional object containing properties defined by the developer. It has the same size as\n     * the list of IDs and the starting indices (starts).\n     */\n    objInfos?: Array<{} | undefined>;\n}\n\n/**\n * Minimum estimated size of a JS object.\n */\nconst MINIMUM_SMALL_OBJECT_SIZE_ESTIMATION = 16;\nconst MINIMUM_OBJECT_SIZE_ESTIMATION = 100;\n\n/**\n * Compute the memory footprint of `TileFeatureData`.\n */\nexport function getFeatureDataSize(featureData: TileFeatureData): number {\n    let numBytes = MINIMUM_OBJECT_SIZE_ESTIMATION;\n\n    if (featureData.starts !== undefined) {\n        numBytes += featureData.starts.length * 8;\n    }\n    if (featureData.objInfos !== undefined) {\n        // 16 (estimated) bytes per objInfos\n        numBytes += featureData.objInfos.length * MINIMUM_SMALL_OBJECT_SIZE_ESTIMATION;\n    }\n\n    return numBytes;\n}\n\n/**\n * Missing Typedoc\n */\nexport enum TileLoaderState {\n    Initialized,\n    Loading,\n    Loaded,\n    Decoding,\n    Ready,\n    Canceled,\n    Failed\n}\n\nexport interface ITileLoader {\n    state: TileLoaderState;\n    payload?: ArrayBufferLike | {};\n    decodedTile?: DecodedTile;\n\n    isFinished: boolean;\n\n    loadAndDecode(): Promise<TileLoaderState>;\n    waitSettled(): Promise<TileLoaderState>;\n\n    updatePriority(area: number): void;\n\n    cancel(): void;\n}\n\n/**\n * An object that contains information about resources used by a tile.\n */\nexport interface TileResourceUsage {\n    /**\n     * The estimated memory usage, in bytes.\n     */\n    estimatedMemoryUsage: number;\n    /**\n     * The amount of vertices used by a tile.\n     */\n    numVertices: number;\n    /**\n     * The amount of colors used by a tile.\n     */\n    numColors: number;\n    /**\n     * The amount of objects used by a tile.\n     */\n    numObjects: number;\n    /**\n     * The amount of geometries used by a tile.\n     */\n    numGeometries: number;\n    /**\n     * The amount of materials used by a tile.\n     */\n    numMaterials: number;\n}\n\n/**\n * Simple information about resource usage by the {@link Tile}. Heap and GPU information are\n * estimations.\n */\nexport interface TileResourceInfo {\n    /**\n     * Estimated number of bytes used on the heap.\n     */\n    heapSize: number;\n    /**\n     * Estimated number of bytes used on the GPU.\n     */\n    gpuSize: number;\n    /**\n     * Number of [[THREE.Object3D]] in this tile.\n     */\n    num3dObjects: number;\n    /**\n     * Number of {@link TextElement}s in this tile.\n     */\n    numTextElements: number;\n    /**\n     * @deprecated This counter has been merged with numTextElements.\n     * Number of user {@link TextElement}s in this tile.\n     */\n    numUserTextElements: number;\n}\n\nexport interface TextElementIndex {\n    groupIndex: number;\n    elementIndex: number;\n}\n\ntype TileCallback = (tile: Tile) => void;\n\n/**\n * The class that holds the tiled data for a {@link DataSource}.\n */\nexport class Tile implements CachedResource {\n    /**\n     * A list of the THREE.js objects stored in this `Tile`.\n     */\n    readonly objects: TileObject[] = [];\n\n    /**\n     * The optional list of HERE TileKeys of tiles with geometries that cross\n     * the boundaries of this `Tile`.\n     */\n    readonly dependencies: string[] = new Array<string>();\n\n    /**\n     * The bounding box of this `Tile` in geocoordinates.\n     */\n    readonly geoBox: GeoBox;\n\n    /**\n     * Copyright information of this `Tile`'s data.\n     */\n    copyrightInfo?: CopyrightInfo[];\n\n    /**\n     * Keeping some stats for the individual {@link Tile}s to analyze caching behavior.\n     *\n     * The frame the {@link Tile} was last requested. This is\n     * required to know when the given {@link Tile}\n     * can be removed from the cache.\n     */\n    frameNumLastRequested: number = -1;\n\n    /**\n     * The frame the `Tile` was first visible.\n     */\n    frameNumVisible: number = -1;\n\n    /**\n     * The last frame this `Tile` has been rendered (or was in the visible set). Used to determine\n     * visibility of `Tile` at the end of a frame, if the number is the current frame number, it is\n     * visible.\n     */\n    frameNumLastVisible: number = -1;\n\n    /**\n     * After removing from cache, this is the number of frames the `Tile` was visible.\n     */\n    numFramesVisible: number = 0;\n\n    /**\n     * Version stamp of the visibility set in the [[TileManager]]. If the counter is different, the\n     * visibility of the Tile's objects has to be calculated. Optimization to reduce overhead of\n     * computing visibility.\n     */\n    visibilityCounter: number = -1;\n\n    /**\n     * @hidden\n     *\n     * Used to tell if the Tile is used temporarily as a fallback tile.\n     *\n     * levelOffset is in in the range [-quadTreeSearchDistanceUp,\n     * quadTreeSearchDistanceDown], where these values come from the\n     * {@link VisibleTileSetOptions}\n     */\n    levelOffset: number = 0;\n\n    /**\n     * If the tile should not be rendered, this is used typically when the tile in question\n     * is completely covered by another tile and therefore can be skipped without any visual\n     * impact. Setting this value directly affects the [[willRender]] method, unless\n     * overriden by deriving classes.\n     */\n    skipRendering = false;\n\n    /**\n     * @hidden\n     *\n     * Prepared text geometries optimized for display.\n     */\n    protected preparedTextPaths: TextPathGeometry[] | undefined;\n\n    /**\n     * The bounding box of this `Tile` in world coordinates.\n     */\n    private readonly m_boundingBox = new OrientedBox3();\n\n    private m_disposed: boolean = false;\n    private m_disposeCallback?: TileCallback;\n    private m_localTangentSpace = false;\n\n    private m_forceHasGeometry: boolean | undefined = undefined;\n\n    private m_tileLoader?: ITileLoader;\n    private m_decodedTile?: DecodedTile;\n    private m_tileGeometryLoader?: TileGeometryLoader;\n\n    // Used for {@link TextElement}s that are stored in the data, and that are placed explicitly,\n    // fading in and out.\n    private m_textElementGroups = new TextElementGroupPriorityList();\n\n    // Blocks other labels from showing.\n    private readonly m_pathBlockingElements: PathBlockingElement[] = [];\n\n    // If `true`, the text content of the {@link Tile} changed after the last time it was rendered.\n    // It's `Undefined` when no text content has been added yet.\n    private m_textElementsChanged: boolean | undefined;\n\n    // Center of the tile's unelevated bounding box world coordinates.\n    private readonly m_worldCenter = new THREE.Vector3();\n    private m_visibleArea: number = 0;\n    // Tile elevation range in meters\n    private readonly m_elevationRange: ElevationRange = { minElevation: 0, maxElevation: 0 };\n    // Maximum height of geometry on this tile above ground level.\n    private m_maxGeometryHeight?: number;\n\n    private m_resourceInfo: TileResourceInfo | undefined;\n\n    // List of owned textures for disposal\n    private m_ownedTextures: WeakSet<THREE.Texture> = new WeakSet();\n\n    private m_textStyleCache: TileTextStyleCache;\n    private m_uniqueKey: number;\n    private m_offset: number;\n    /**\n     * Creates a new {@link Tile}.\n     *\n     * @param dataSource - The {@link DataSource} that created this {@link Tile}.\n     * @param tileKey - The unique identifier for this {@link Tile}.\n     *                  Currently only up to level 24 is\n     *                  supported, because of the use of the upper bits for the offset.\n     * @param offset - The optional offset, this is an integer which represents what multiple of 360\n     *                 degrees to shift, only useful for flat projections, hence optional.\n     * @param localTangentSpace - Whether the tile geometry is in local tangent space or not.\n     */\n    constructor(\n        readonly dataSource: DataSource,\n        readonly tileKey: TileKey,\n        offset: number = 0,\n        localTangentSpace?: boolean\n    ) {\n        this.geoBox = this.dataSource.getTilingScheme().getGeoBox(this.tileKey);\n        this.updateBoundingBox();\n        this.m_worldCenter.copy(this.boundingBox.position);\n        this.m_localTangentSpace = localTangentSpace !== undefined ? localTangentSpace : false;\n        this.m_textStyleCache = new TileTextStyleCache(this);\n        this.m_offset = offset;\n        this.m_uniqueKey = TileOffsetUtils.getKeyForTileKeyAndOffset(this.tileKey, this.offset);\n    }\n\n    /**\n     * The visibility status of the {@link Tile}. It is actually\n     * visible or planned to become visible.\n     */\n    get isVisible(): boolean {\n        // Tiles are not evaluated as invisible until the second frame they aren't requested.\n        // This happens in order to prevent that, during VisibleTileSet visibility evaluation,\n        // visible tiles that haven't yet been evaluated for the current frame are preemptively\n        // removed from [[DataSourceCache]].\n        return this.frameNumLastRequested >= this.dataSource.mapView.frameNumber - 1;\n    }\n\n    set isVisible(visible: boolean) {\n        this.frameNumLastRequested = visible ? this.dataSource.mapView.frameNumber : -1;\n    }\n\n    /**\n     * The {@link @here/harp-geoutils#Projection} currently used by the {@link MapView}.\n     */\n    get projection(): Projection {\n        return this.dataSource.projection;\n    }\n\n    /**\n     * The {@link MapView} this `Tile` belongs to.\n     */\n    get mapView(): MapView {\n        return this.dataSource.mapView;\n    }\n\n    /**\n     * Whether the data of this tile is in local tangent space or not.\n     * If the data is in local tangent space (i.e. up vector is (0,0,1) for high zoomlevels) then\n     * {@link MapView} will rotate the objects before rendering using the rotation matrix of the\n     * oriented [[boundingBox]].\n     */\n    get localTangentSpace(): boolean {\n        return this.m_localTangentSpace;\n    }\n\n    /*\n     * The size of this Tile in system memory.\n     */\n    get memoryUsage(): number {\n        if (this.m_resourceInfo === undefined) {\n            this.computeResourceInfo();\n        }\n        return this.m_resourceInfo!.heapSize;\n    }\n\n    /**\n     * The center of this `Tile` in world coordinates.\n     */\n    get center(): THREE.Vector3 {\n        return this.m_worldCenter;\n    }\n\n    /**\n     * Gets the key to uniquely represent this tile (based on\n     * the {@link tileKey} and {@link offset}), note\n     * this key is only unique within the given {@link DataSource},\n     * to get a key which is unique across\n     * {@link DataSource}s see [[DataSourceCache.getKeyForTile]].\n     */\n    get uniqueKey(): number {\n        return this.m_uniqueKey;\n    }\n\n    /**\n     * The optional offset, this is an integer which represents what multiple of 360 degrees to\n     * shift, only useful for flat projections, hence optional.\n     */\n    get offset(): number {\n        return this.m_offset;\n    }\n\n    /**\n     * The optional offset, this is an integer which represents what multiple of 360 degrees to\n     * shift, only useful for flat projections, hence optional.\n     * @param offset - Which multiple of 360 degrees to apply to the {@link Tile}.\n     */\n    set offset(offset: number) {\n        if (this.m_offset !== offset) {\n            this.m_uniqueKey = TileOffsetUtils.getKeyForTileKeyAndOffset(this.tileKey, offset);\n        }\n        this.m_offset = offset;\n    }\n\n    /**\n     * Compute {@link TileResourceInfo} of this `Tile`. May be using a cached value. The method\n     * `invalidateResourceInfo` can be called beforehand to force a recalculation.\n     *\n     * @returns `TileResourceInfo` for this `Tile`.\n     */\n    getResourceInfo(): TileResourceInfo {\n        if (this.m_resourceInfo === undefined) {\n            this.computeResourceInfo();\n        }\n        return this.m_resourceInfo!;\n    }\n\n    /**\n     * Force invalidation of the cached {@link TileResourceInfo}. Useful after the `Tile` has been\n     * modified.\n     */\n    invalidateResourceInfo(): void {\n        this.m_resourceInfo = undefined;\n    }\n\n    /**\n     * Add ownership of a texture to this tile. The texture will be disposed if the `Tile` is\n     * disposed.\n     * @param texture - Texture to be owned by the `Tile`\n     */\n    addOwnedTexture(texture: THREE.Texture): void {\n        this.m_ownedTextures.add(texture);\n    }\n\n    /**\n     * @internal\n     * @deprecated User text elements are deprecated.\n     *\n     * Gets the list of developer-defined {@link TextElement} in this `Tile`. This list is always\n     * rendered first.\n     */\n    get userTextElements(): TextElementGroup {\n        let group = this.m_textElementGroups.groups.get(TextElement.HIGHEST_PRIORITY);\n        if (group === undefined) {\n            group = new TextElementGroup(TextElement.HIGHEST_PRIORITY);\n            this.m_textElementGroups.groups.set(group.priority, group);\n        }\n        return group;\n    }\n\n    /**\n     * Adds a developer-defined {@link TextElement} to this `Tile`.\n     *\n     * @remarks\n     * The {@link TextElement} is always\n     * visible, if it's in the map's currently visible area.\n     *\n     * @deprecated use [[addTextElement]].\n     *\n     * @param textElement - The Text element to add.\n     */\n    addUserTextElement(textElement: TextElement) {\n        textElement.priority = TextElement.HIGHEST_PRIORITY;\n        this.addTextElement(textElement);\n    }\n\n    /**\n     * Removes a developer-defined {@link TextElement} from this `Tile`.\n     *\n     * @deprecated use [[removeTextElement]].\n     *\n     * @param textElement - A developer-defined TextElement to remove.\n     * @returns `true` if the element has been removed successfully; `false` otherwise.\n     */\n    removeUserTextElement(textElement: TextElement): boolean {\n        textElement.priority = TextElement.HIGHEST_PRIORITY;\n        return this.removeTextElement(textElement);\n    }\n\n    /**\n     * Adds a {@link TextElement} to this `Tile`, which is added to the visible set of\n     * {@link TextElement}s based on the capacity and visibility. The {@link TextElement}'s priority\n     * controls if or when it becomes visible.\n     *\n     * To ensure that a TextElement is visible, use a high value for its priority, such as\n     * `TextElement.HIGHEST_PRIORITY`. Since the number of visible TextElements is limited by the\n     * screen space, not all TextElements are visible at all times.\n     *\n     * @param textElement - The TextElement to add.\n     */\n    addTextElement(textElement: TextElement) {\n        this.textElementGroups.add(textElement);\n\n        if (this.m_textElementsChanged === false) {\n            // HARP-8733: Clone all groups so that they are handled as new element groups\n            // by TextElementsRenderer and it doesn't try to reuse the same state stored\n            // for the old groups.\n            this.m_textElementGroups = this.textElementGroups.clone();\n        }\n        this.textElementsChanged = true;\n    }\n\n    /**\n     * Adds a [[PathBlockingElement]] to this `Tile`. This path has the highest priority and blocks\n     * all other labels. There maybe in future a use case to give it a priority, but as that isn't\n     * yet required, it is left to be implemented later if required.\n     * @param blockingElement - Element which should block all other labels.\n     */\n    addBlockingElement(blockingElement: PathBlockingElement) {\n        this.m_pathBlockingElements.push(blockingElement);\n    }\n\n    /**\n     * Removes a {@link TextElement} from this `Tile`.\n     *\n     * @remarks\n     * For the element to be removed successfully, the\n     * priority of the {@link TextElement} has to be equal to its priority when it was added.\n     *\n     * @param textElement - The TextElement to remove.\n     * @returns `true` if the TextElement has been removed successfully; `false` otherwise.\n     */\n    removeTextElement(textElement: TextElement): boolean {\n        const groups = this.textElementGroups;\n        if (!groups.remove(textElement)) {\n            return false;\n        }\n        if (this.m_textElementsChanged === false) {\n            // HARP-8733: Clone all groups so that they are handled as new element groups\n            // by TextElementsRenderer and it doesn't try to reuse the same state stored\n            // for the old groups.\n            this.m_textElementGroups = groups.clone();\n        }\n        this.textElementsChanged = true;\n        return true;\n    }\n\n    /**\n     * @internal\n     *\n     * Gets the current [[GroupedPriorityList]] which\n     * contains a list of all {@link TextElement}s to be\n     * selected and placed for rendering.\n     */\n    get textElementGroups(): TextElementGroupPriorityList {\n        return this.m_textElementGroups;\n    }\n\n    /**\n     * Gets the current modification state for the list\n     * of {@link TextElement}s in the `Tile`. If the\n     * value is `true` the TextElement is placed for\n     * rendering during the next frame.\n     */\n    get textElementsChanged(): boolean {\n        return this.m_textElementsChanged ?? false;\n    }\n\n    set textElementsChanged(changed: boolean) {\n        this.m_textElementsChanged = changed;\n    }\n\n    /**\n     * Returns true if the `Tile` has any text elements to render.\n     */\n    hasTextElements(): boolean {\n        return this.m_textElementGroups.count() > 0;\n    }\n\n    /**\n     * Get the current blocking elements.\n     */\n    get blockingElements(): PathBlockingElement[] {\n        return this.m_pathBlockingElements;\n    }\n\n    /**\n     * Called before {@link MapView} starts rendering this `Tile`.\n     *\n     * @param zoomLevel - The current zoom level.\n     * @returns Returns `true` if this `Tile` should be rendered. Influenced directly by the\n     * [[skipRendering]] property unless specifically overriden in deriving classes.\n     */\n    willRender(_zoomLevel: number): boolean {\n        return !this.skipRendering;\n    }\n\n    /**\n     * Called after {@link MapView} has rendered this `Tile`.\n     */\n    didRender(): void {\n        // to be overridden by subclasses\n    }\n\n    /**\n     * Estimated visible area of tile used for sorting the priorities during loading.\n     */\n    get visibleArea(): number {\n        return this.m_visibleArea;\n    }\n\n    set visibleArea(area: number) {\n        this.m_visibleArea = area;\n        if (this.tileLoader !== undefined) {\n            this.tileLoader.updatePriority(area);\n        }\n    }\n\n    /**\n     * @internal\n     * Gets the tile's ground elevation range in meters.\n     */\n    get elevationRange(): ElevationRange {\n        return this.m_elevationRange;\n    }\n\n    /**\n     * @internal\n     * Sets the tile's ground elevation range in meters.\n     *\n     * @param elevationRange - The elevation range.\n     */\n    set elevationRange(elevationRange: ElevationRange) {\n        if (\n            elevationRange.minElevation === this.m_elevationRange.minElevation &&\n            elevationRange.maxElevation === this.m_elevationRange.maxElevation &&\n            elevationRange.calculationStatus === this.m_elevationRange.calculationStatus\n        ) {\n            return;\n        }\n\n        this.m_elevationRange.minElevation = elevationRange.minElevation;\n        this.m_elevationRange.maxElevation = elevationRange.maxElevation;\n        this.m_elevationRange.calculationStatus = elevationRange.calculationStatus;\n        this.elevateGeoBox();\n\n        // Only update bounding box if tile has already been decoded and a maximum geometry height\n        // is provided by the data source.\n        if (this.m_maxGeometryHeight !== undefined) {\n            assert(this.decodedTile?.boundingBox === undefined);\n            this.updateBoundingBox();\n        }\n    }\n\n    /**\n     * Gets the decoded tile; it is removed after geometry handling.\n     */\n    get decodedTile(): DecodedTile | undefined {\n        return this.m_decodedTile;\n    }\n\n    /**\n     * Applies the decoded tile to the tile.\n     * If the geometry is empty, then the tile's forceHasGeometry flag is set.\n     * Map is updated.\n     * @param decodedTile - The decoded tile to set.\n     */\n    set decodedTile(decodedTile: DecodedTile | undefined) {\n        this.m_decodedTile = decodedTile;\n        this.invalidateResourceInfo();\n\n        if (decodedTile === undefined) {\n            return;\n        }\n\n        if (decodedTile.geometries.length === 0) {\n            this.forceHasGeometry(true);\n        }\n\n        // If the decoder provides a more accurate bounding box than the one we computed from\n        // the flat geo box we take it instead. Otherwise, if an elevation range was set, elevate\n        // bounding box to match the elevated geometry.\n        this.m_maxGeometryHeight = decodedTile.boundingBox\n            ? undefined\n            : decodedTile.maxGeometryHeight ?? 0;\n        this.elevateGeoBox();\n        this.updateBoundingBox(decodedTile.boundingBox);\n\n        const stats = PerformanceStatistics.instance;\n        if (stats.enabled && decodedTile.decodeTime !== undefined) {\n            stats.currentFrame.addValue(\"decode.decodingTime\", decodedTile.decodeTime);\n            stats.currentFrame.addValue(\"decode.decodedTiles\", 1);\n        }\n\n        if (decodedTile.copyrightHolderIds !== undefined) {\n            this.copyrightInfo = decodedTile.copyrightHolderIds.map(id => ({ id }));\n        }\n\n        this.dataSource.requestUpdate();\n    }\n\n    /**\n     * Remove the decodedTile when no longer needed.\n     */\n    removeDecodedTile() {\n        this.m_decodedTile = undefined;\n        this.invalidateResourceInfo();\n    }\n\n    /**\n     * Called by the {@link @here/harp-mapview-decoder#TileLoader}\n     *\n     * @remarks\n     * after the `Tile` has finished loading its map data. Can be used\n     * to add content to the `Tile`.\n     * The {@link @here/harp-datasource-protocol#DecodedTile} should still be available.\n     */\n    loadingFinished() {\n        // To be used in subclasses.\n    }\n\n    /**\n     * Called when the default implementation of `dispose()` needs\n     * to free the geometry of a `Tile` object.\n     *\n     * @param object - The object that references the geometry.\n     * @returns `true` if the geometry can be disposed.\n     */\n    // tslint:disable-next-line:no-unused-variable\n    shouldDisposeObjectGeometry(object: TileObject): boolean {\n        return true;\n    }\n\n    /**\n     * Called when the default implementation of `dispose()` needs\n     * to free a `Tile` object's material.\n     *\n     * @param object - The object referencing the geometry.\n     * @returns `true` if the material can be disposed.\n     */\n    // tslint:disable-next-line:no-unused-variable\n    shouldDisposeObjectMaterial(object: TileObject): boolean {\n        return true;\n    }\n\n    /**\n     * Called when the default implementation of `dispose()` needs\n     * to free a Texture that is part of a `Tile` object's material.\n     *\n     * @param texture - The texture about to be disposed.\n     * @returns `true` if the texture can be disposed.\n     */\n    shouldDisposeTexture(texture: THREE.Texture): boolean {\n        return this.m_ownedTextures.has(texture);\n    }\n\n    /**\n     * Returns `true` if this `Tile` has been disposed.\n     */\n    get disposed(): boolean {\n        return this.m_disposed;\n    }\n\n    /**\n     * Gets the [[TileGeometryLoader]] that manages this tile.\n     */\n    get tileGeometryLoader(): TileGeometryLoader | undefined {\n        return this.m_tileGeometryLoader;\n    }\n\n    /**\n     * Sets the [[TileGeometryLoader]] to manage this tile.\n     *\n     * @param tileGeometryLoader - A [[TileGeometryLoader]] instance to manage the geometry creation\n     *      for this tile.\n     */\n    set tileGeometryLoader(tileGeometryLoader: TileGeometryLoader | undefined) {\n        this.m_tileGeometryLoader = tileGeometryLoader;\n    }\n\n    /**\n     * `True` if the basic geometry has been loaded, and the `Tile` is ready  for display.\n     */\n    get basicGeometryLoaded(): boolean {\n        return this.m_tileGeometryLoader === undefined\n            ? this.hasGeometry\n            : this.m_tileGeometryLoader.basicGeometryLoaded || this.m_tileGeometryLoader.isFinished;\n    }\n\n    /**\n     * `True` if all geometry of the `Tile` has been loaded.\n     */\n    get allGeometryLoaded(): boolean {\n        return this.m_tileGeometryLoader === undefined\n            ? this.hasGeometry\n            : this.m_tileGeometryLoader.allGeometryLoaded || this.m_tileGeometryLoader.isFinished;\n    }\n\n    /**\n     * MapView checks if this `Tile` is ready to be rendered while culling.\n     *\n     * By default, MapView checks if the [[objects]] list is not empty. However, you can override\n     * this check by manually setting this property.\n     */\n    get hasGeometry(): boolean {\n        if (this.m_forceHasGeometry === undefined) {\n            return this.objects.length !== 0;\n        } else {\n            return this.m_forceHasGeometry;\n        }\n    }\n\n    /**\n     * Overrides the default value for [[hasGeometry]] if value is not `undefined`.\n     *\n     * @param value - A new value for the [[hasGeometry]] flag.\n     */\n    forceHasGeometry(value: boolean | undefined) {\n        this.m_forceHasGeometry = value;\n    }\n\n    /**\n     * Reset the visibility counter. This will force the visibility check to be rerun on all objects\n     * in this `Tile`.\n     */\n    resetVisibilityCounter(): void {\n        this.visibilityCounter = -1;\n    }\n\n    /**\n     * Gets the {@link ITileLoader} that manages this tile.\n     */\n    get tileLoader(): ITileLoader | undefined {\n        return this.m_tileLoader;\n    }\n\n    /**\n     * Sets the {@link ITileLoader} to manage this tile.\n     *\n     * @param tileLoader - A {@link ITileLoader} instance to manage\n     *                     the loading process for this tile.\n     */\n    set tileLoader(tileLoader: ITileLoader | undefined) {\n        this.m_tileLoader = tileLoader;\n    }\n\n    /**\n     * Loads this `Tile` geometry.\n     */\n    load() {\n        const tileLoader = this.tileLoader;\n        if (tileLoader === undefined) {\n            return;\n        }\n\n        tileLoader\n            .loadAndDecode()\n            .then(tileLoaderState => {\n                assert(tileLoaderState === TileLoaderState.Ready);\n                const decodedTile = tileLoader.decodedTile;\n                this.decodedTile = decodedTile;\n            })\n            .catch(tileLoaderState => {\n                if (\n                    tileLoaderState !== TileLoaderState.Canceled &&\n                    tileLoaderState !== TileLoaderState.Failed\n                ) {\n                    logger.error(\"Unknown error\" + tileLoaderState);\n                }\n            });\n    }\n\n    /**\n     * Text style cache for this tile.\n     * @hidden\n     */\n    get textStyleCache(): TileTextStyleCache {\n        return this.m_textStyleCache;\n    }\n\n    /**\n     * Frees the rendering resources allocated by this `Tile`.\n     *\n     * The default implementation of this method frees the geometries and the materials for all the\n     * reachable objects.\n     * Textures are freed if they are owned by this `Tile` (i.e. if they where created by this\n     * `Tile`or if the ownership was explicitely set to this `Tile` by [[addOwnedTexture]]).\n     */\n    clear() {\n        const disposeMaterial = (material: THREE.Material) => {\n            Object.getOwnPropertyNames(material).forEach((property: string) => {\n                const materialProperty = (material as any)[property];\n                if (materialProperty !== undefined && materialProperty instanceof THREE.Texture) {\n                    const texture = materialProperty;\n                    if (this.shouldDisposeTexture(texture)) {\n                        texture.dispose();\n                    }\n                }\n            });\n            material.dispose();\n        };\n\n        const disposeObject = (object: TileObject & DisposableObject) => {\n            if (this.shouldDisposeObjectGeometry(object)) {\n                if (object.geometry !== undefined) {\n                    object.geometry.dispose();\n                }\n\n                if (object.geometries !== undefined) {\n                    for (const geometry of object.geometries) {\n                        geometry.dispose();\n                    }\n                }\n            }\n\n            if (object.material !== undefined && this.shouldDisposeObjectMaterial(object)) {\n                if (object.material instanceof Array) {\n                    object.material.forEach((material: THREE.Material | undefined) => {\n                        if (material !== undefined) {\n                            disposeMaterial(material);\n                        }\n                    });\n                } else {\n                    disposeMaterial(object.material);\n                }\n            }\n        };\n\n        this.objects.forEach((rootObject: TileObject & DisposableObject) => {\n            rootObject.traverse((object: TileObject & DisposableObject) => {\n                disposeObject(object);\n            });\n\n            disposeObject(rootObject);\n        });\n        this.objects.length = 0;\n\n        if (this.preparedTextPaths) {\n            this.preparedTextPaths = [];\n        }\n\n        this.m_textStyleCache.clear();\n        this.clearTextElements();\n        this.invalidateResourceInfo();\n    }\n\n    /**\n     * Removes all {@link TextElement} from the tile.\n     */\n    clearTextElements() {\n        if (!this.hasTextElements()) {\n            return;\n        }\n        this.textElementsChanged = true;\n        this.m_pathBlockingElements.splice(0);\n        this.textElementGroups.clear();\n    }\n\n    /**\n     * Adds a callback that will be called whenever the tile is disposed. Multiple callbacks may be\n     * added.\n     * @internal\n     * @param callback - The callback to be called when the tile is disposed.\n     */\n    addDisposeCallback(callback: TileCallback) {\n        this.m_disposeCallback = chainCallbacks(this.m_disposeCallback, callback);\n    }\n\n    /**\n     * Disposes this `Tile`, freeing all geometries and materials for the reachable objects.\n     */\n    dispose() {\n        if (this.m_disposed) {\n            return;\n        }\n        if (this.m_tileLoader) {\n            this.m_tileLoader.cancel();\n            this.m_tileLoader = undefined;\n        }\n        if (this.m_tileGeometryLoader !== undefined) {\n            this.m_tileGeometryLoader.dispose();\n            this.m_tileGeometryLoader = undefined;\n        }\n        this.clear();\n        this.m_disposed = true;\n        // Ensure that tile is removable from tile cache.\n        this.frameNumLastRequested = 0;\n        if (this.m_disposeCallback) {\n            this.m_disposeCallback(this);\n        }\n    }\n\n    /**\n     * Computes the offset in the x world coordinates corresponding to this tile, based on\n     * its [[offset]].\n     * @returns The x offset.\n     */\n    computeWorldOffsetX(): number {\n        return this.projection.worldExtent(0, 0).max.x * this.offset;\n    }\n\n    /**\n     * Update tile for current map view zoom level\n     * @param zoomLevel - Zoom level of the map view\n     */\n    update(zoomLevel: number): void {\n        for (const object of this.objects) {\n            if (object instanceof LodMesh) {\n                object.setLevelOfDetail(zoomLevel - this.tileKey.level);\n            }\n        }\n    }\n\n    /**\n     * Gets the tile's bounding box.\n     */\n    get boundingBox(): OrientedBox3 {\n        return this.m_boundingBox;\n    }\n\n    /**\n     * Updates the tile's world bounding box.\n     * @param [newBoundingBox] The new bounding box to set. If undefined, the bounding box will be\n     * computed by projecting the tile's geoBox.\n     */\n    private updateBoundingBox(newBoundingBox?: OrientedBox3) {\n        if (newBoundingBox) {\n            this.m_boundingBox.copy(newBoundingBox);\n            this.m_worldCenter.copy(this.boundingBox.position);\n        } else {\n            this.projection.projectBox(this.geoBox, this.boundingBox);\n        }\n    }\n\n    /**\n     * Elevates the tile's geo box using the elevation range and maximum geometry height.\n     */\n    private elevateGeoBox() {\n        this.geoBox.southWest.altitude = this.m_elevationRange.minElevation;\n        this.geoBox.northEast.altitude =\n            this.m_elevationRange.maxElevation + (this.m_maxGeometryHeight ?? 0);\n    }\n\n    private computeResourceInfo(): void {\n        let heapSize = 0;\n        let num3dObjects = 0;\n        let numTextElements = 0;\n\n        const aggregatedObjSize = {\n            heapSize: 0,\n            gpuSize: 0\n        };\n\n        // Keep a map of the uuids of the larger objects, like Geometries, Materials and Attributes.\n        // They should be counted only once even if they are shared.\n        const visitedObjects: Map<string, boolean> = new Map();\n\n        for (const object of this.objects) {\n            if (object.visible) {\n                num3dObjects++;\n            }\n            MapViewUtils.estimateObject3dSize(object, aggregatedObjSize, visitedObjects);\n        }\n\n        for (const group of this.textElementGroups.groups) {\n            numTextElements += group[1].elements.length;\n        }\n        // 216 was the shallow size of a single TextElement last time it has been checked, 312 bytes\n        // was the minimum retained size of a TextElement that was not being rendered. If a\n        // TextElement is actually rendered, the size may be _much_ bigger.\n        heapSize += numTextElements * 312;\n\n        if (this.m_decodedTile !== undefined && this.m_decodedTile.tileInfo !== undefined) {\n            aggregatedObjSize.heapSize += this.m_decodedTile.tileInfo.numBytes;\n        }\n\n        this.m_resourceInfo = {\n            heapSize: aggregatedObjSize.heapSize + heapSize,\n            gpuSize: aggregatedObjSize.gpuSize,\n            num3dObjects,\n            numTextElements,\n            numUserTextElements: 0\n        };\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { LoggerManager, PerformanceTimer } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nconst logger = LoggerManager.instance.create(\"Statistics\");\n\n/**\n * A simple ring buffer to store the last `n` values of the timer. The buffer works on\n * a First-In-First-Out (FIFO) basis.\n */\nexport class RingBuffer<T> {\n    buffer: T[];\n    size: number;\n    head: number;\n    tail: number;\n\n    /**\n     * Sets up the ring buffer.\n     *\n     * @param capacity - The buffer's capacity.\n     */\n    constructor(readonly capacity: number) {\n        this.buffer = new Array(capacity);\n        this.capacity = capacity;\n        this.head = this.tail = this.size = 0;\n    }\n\n    /**\n     * Clears the contents, removes all elements.\n     */\n    clear(): void {\n        this.head = this.tail = this.size = 0;\n    }\n\n    /**\n     * Adds a single element to the ring buffer.\n     *\n     * @param data - Data element.\n     */\n    enqOne(data: T): void {\n        let next = this.head + 1;\n        if (next >= this.capacity) {\n            next = 0;\n        }\n        if (this.size < this.capacity) {\n            this.size++;\n        }\n\n        this.buffer[this.head] = data;\n        this.head = next;\n\n        if (this.size === this.capacity) {\n            this.tail = this.head;\n        }\n    }\n\n    /**\n     * Adds one or more elements.\n     *\n     * @param data - The elements to add.\n     */\n    enq(...data: T[]): void {\n        for (const v of data) {\n            this.enqOne(v);\n        }\n    }\n\n    /**\n     * Obtains the oldest element (FIFO). May throw an exception if a buffer underrun occurs.\n     * Before calling this method, make sure that `size > 0`.\n     */\n    deq(): T {\n        if (this.size === 0) {\n            throw new Error(\"Ringbuffer underrun\");\n        }\n\n        const data = this.buffer[this.tail];\n        let next = this.tail + 1;\n        if (next >= this.capacity) {\n            next = 0;\n        }\n        if (this.size > 0) {\n            this.size--;\n        }\n\n        this.tail = next;\n        return data;\n    }\n\n    /**\n     * Obtains the oldest element (FIFO) without removing it. Throws an exception if a buffer is\n     * empty. Before calling this method, make sure that `size > 0`.\n     */\n    get top(): T {\n        if (this.size === 0) {\n            throw new Error(\"Ringbuffer underrun\");\n        }\n\n        return this.buffer[this.tail];\n    }\n\n    /**\n     * Obtains the latest element (LIFO) without removing it. Throws an exception if a buffer is\n     * empty. Before calling this method, make sure that `size > 0`.\n     */\n    get bottom(): T {\n        if (this.size === 0) {\n            throw new Error(\"Ringbuffer underrun\");\n        }\n\n        let previous = this.head - 1;\n        if (previous < 0) {\n            previous = this.capacity - 1;\n        }\n        return this.buffer[previous];\n    }\n\n    /**\n     * Creates an iterator for the buffer.\n     */\n    iterator(): RingBuffer.Iterator<T> {\n        return new RingBuffer.Iterator<T>(this);\n    }\n\n    /**\n     * Returns a copy of the buffer, where the elements are properly sorted from oldest to newest.\n     */\n    asArray(): T[] {\n        const array = new Array<T>();\n        for (let i = 0; i < this.size; i++) {\n            array.push(this.buffer[(this.tail + i) % this.capacity]);\n        }\n        return array;\n    }\n}\n\nexport namespace RingBuffer {\n    /**\n     * A local class for RingBuffer<T>\n     */\n    export class Iterator<T> {\n        /**\n         * Creates an iterator for the ring buffer.\n         *\n         * @param m_buffer - `Ringbuffer` to iterate over.\n         * @param m_index - Start index.\n         */\n        constructor(private m_buffer: RingBuffer<T>, private m_index: number = 0) {}\n\n        /**\n         * Gets the iterator's current value. This function does not fail even if an overrun occurs.\n         * To detect an overrun, watch the result for [[next]].\n         */\n        get value(): T {\n            return this.m_buffer.buffer[\n                (this.m_buffer.tail + this.m_index) % this.m_buffer.capacity\n            ];\n        }\n\n        /**\n         * Advances the iterator to the next element.\n         *\n         * @returns `true` if the iterator is still valid; `false` if an overrun occurs.\n         */\n        next(): boolean {\n            this.m_index++;\n            return this.m_index < this.m_buffer.size;\n        }\n    }\n}\n\n/**\n * An interface for a Timer class, that abstracts the basic functions of a Timer. Implemented\n * by SimpleTimer, SampledTimer, and MultiStageTimer.\n */\nexport interface Timer {\n    readonly name: string;\n    readonly value?: number;\n\n    /**\n     * Resets value to be able to start again.\n     */\n    reset(): void;\n\n    /**\n     * Starts the timer. Returns the current time, based on `Performance.now()`.\n     */\n    start(): number;\n\n    /**\n     * Stops the timer. Requires that the timer has started.\n     */\n    stop(): number;\n\n    /**\n     * Samples the timer. Requires that the timer has started. This function does not modify\n     * the timer's internal state.\n     *\n     * @returns Current timer value. `-1` if statistics are disabled.\n     */\n    now(): number;\n\n    /**\n     * Sets the measurement value for the amount of time that has elapsed from start() to stop().\n     * Use this function to override the timer's duration.\n     *\n     * @param val - The timer's duration.\n     */\n    setValue(val: number | undefined): void;\n}\n\n/**\n * A simple timer that stores only the latest measurement.\n */\nexport class SimpleTimer implements Timer {\n    /** `true` if timer has been started. */\n    running = false;\n\n    private m_currentValue?: number;\n\n    constructor(public statistics: Statistics, readonly name: string) {}\n\n    /**\n     * Gets the latest measurement. This function may return `undefined` if no measurement\n     * was done.\n     */\n    get value(): number | undefined {\n        return this.m_currentValue;\n    }\n\n    /**\n     * Sets the measurement value for the amount of time that has elapsed from start() to stop().\n     * Use this function to override the timer's duration.\n     *\n     * @param val - The timer's duration.\n     */\n    setValue(val: number | undefined) {\n        this.m_currentValue = val;\n    }\n\n    /**\n     * Resets the value to be able to start again.\n     */\n    reset() {\n        this.m_currentValue = undefined;\n    }\n\n    /**\n     * Starts the timer. Returns the current time, based on `Performance.now()`.\n     */\n    start(): number {\n        if (!this.statistics.enabled) {\n            return -1;\n        }\n        if (this.running) {\n            throw new Error(\"Timer '\" + this.name + \"' is already running\");\n        }\n        this.running = true;\n        return (this.m_currentValue = PerformanceTimer.now());\n    }\n\n    /**\n     * Stops the timer. Requires that the timer has started.\n     */\n    stop(): number {\n        if (!this.statistics.enabled) {\n            return -1;\n        }\n        if (!this.running) {\n            throw new Error(\"Timer '\" + this.name + \"' has not been started\");\n        } else {\n            // this.currentValue is a number now!\n            const t = PerformanceTimer.now() - (this.m_currentValue || 0);\n            this.m_currentValue = t;\n            this.setValue(t);\n            this.running = false;\n            return t;\n        }\n    }\n\n    /**\n     * Samples the timer. Requires that the timer has started.\n     *\n     * @returns the current timer value; `-1` if statistics are disabled.\n     */\n    now(): number {\n        if (!this.statistics.enabled) {\n            return -1;\n        }\n        if (!this.running) {\n            throw new Error(\"Timer '\" + this.name + \"' has not been started\");\n        } else {\n            const t = PerformanceTimer.now() - (this.m_currentValue || 0);\n            return t;\n        }\n    }\n}\n\n/**\n * Simple statistics about the values in an array.\n */\nexport interface Stats {\n    /**\n     * The lowest value in the array.\n     */\n    min: number;\n\n    /**\n     * The highest value in the array.\n     */\n    max: number;\n\n    /**\n     * The average duration of all values in the array.\n     */\n    avg: number;\n\n    /**\n     * The median duration of all values in the array.\n     */\n    median: number;\n\n    /**\n     * The 75th percentile median of all values in the array.\n     */\n    median75: number;\n\n    /**\n     * The 90th percentile median of all values in the array.\n     */\n    median90: number;\n\n    /**\n     * The 95th percentile median of all values in the array.\n     */\n    median95: number;\n\n    /**\n     * The 97th percentile median of all values in the array.\n     */\n    median97: number;\n\n    /**\n     * The 99th percentile median of all values in the array.\n     */\n    median99: number;\n\n    /**\n     * The 99.9th percentile median of all values in the array.\n     */\n    median999: number;\n\n    /**\n     * The number of values in the array.\n     */\n    numSamples: number;\n}\n\n/**\n * A timer that stores the last `n` samples in a ring buffer.\n */\nexport class SampledTimer extends SimpleTimer {\n    /**\n     * The number of times the timer has reset.\n     */\n    numResets = 0;\n\n    /**\n     * Maximum samples until the statistics are reset and updated, which may destroy a median\n     * computation.\n     */\n    maxNumSamples = 1000;\n\n    /**\n     * The array of sampled values, its length cannot exceed `maxNumSamples`.\n     */\n    samples = new RingBuffer<number>(this.maxNumSamples);\n\n    /**\n     * Creates a `SampledTimer` instance. Must still be added to statistics if it should be logged!\n     *\n     * @param statistics - Statistics to use for management.\n     * @param name - Name of the timer. Use colons to build a hierarchy.\n     */\n    constructor(public statistics: Statistics, readonly name: string) {\n        super(statistics, name);\n    }\n\n    /**\n     * Resets the timer and clears all of its historical values.\n     * @override\n     */\n    reset() {\n        super.reset();\n        this.getStats();\n        this.samples.clear();\n        this.numResets++;\n    }\n\n    /**\n     * Add a single measurement to the sample.\n     *\n     * @param val - A measurement to add.\n     * @override\n     */\n    setValue(val: number | undefined) {\n        super.setValue(val);\n\n        if (val !== undefined) {\n            this.samples.enqOne(val);\n        }\n    }\n\n    /**\n     * Updates the `min`, `max`, `avg`, and `median` values. Currently, this function is expensive,\n     * as it requires a copy of the sampled values.\n     */\n    getStats(): Stats | undefined {\n        return computeArrayStats(this.samples.asArray());\n    }\n}\n\n/**\n * Only exported for testing\n * @ignore\n *\n * Compute the [[ArrayStats]] for the passed in array of numbers.\n *\n * @param {number[]} samples Array containing sampled values. Will be modified (!) by sorting the\n *      entries.\n * @returns {(Stats | undefined)}\n */\nexport function computeArrayStats(samples: number[]): Stats | undefined {\n    if (samples.length === 0) {\n        return undefined;\n    }\n\n    samples.sort((a: number, b: number) => {\n        return a - b;\n    });\n\n    const min: number = samples[0];\n    const max: number = samples[samples.length - 1];\n    let median: number;\n    let median75: number;\n    let median90: number;\n    let median95: number;\n    let median97: number;\n    let median99: number;\n    let median999: number;\n\n    if (samples.length === 1) {\n        median75 = median90 = median95 = median97 = median99 = median999 = median = samples[0];\n    } else if (samples.length === 2) {\n        median = samples[0] * 0.5 + samples[1] * 0.5;\n        median75 = median90 = median95 = median97 = median99 = median999 = samples[1];\n    } else {\n        const mid = Math.floor(samples.length / 2);\n        median =\n            samples.length % 2 === 0 ? samples[mid - 1] * 0.5 + samples[mid] * 0.5 : samples[mid];\n\n        const mid75 = Math.round(samples.length * 0.75) - 1;\n        median75 = samples[mid75];\n        const mid90 = Math.round(samples.length * 0.9) - 1;\n        median90 = samples[mid90];\n        const mid95 = Math.round(samples.length * 0.95) - 1;\n        median95 = samples[mid95];\n        const mid97 = Math.round(samples.length * 0.97) - 1;\n        median97 = samples[mid97];\n        const mid99 = Math.round(samples.length * 0.99) - 1;\n        median99 = samples[mid99];\n        const mid999 = Math.round(samples.length * 0.999) - 1;\n        median999 = samples[mid999];\n    }\n\n    let sum = 0;\n\n    for (let i = 0, l = samples.length; i < l; i++) {\n        sum += samples[i];\n    }\n\n    const avg = sum / samples.length;\n\n    return {\n        min,\n        max,\n        avg,\n        median,\n        median75,\n        median90,\n        median95,\n        median97,\n        median99,\n        median999,\n        numSamples: samples.length\n    };\n}\n\n/**\n * Only exported for testing\n * @ignore\n *\n * Compute the averages for the passed in array of numbers.\n *\n * @param {number[]} samples Array containing sampled values.\n * @returns {(Stats | undefined)}\n */\nexport function computeArrayAverage(samples: number[]): number | undefined {\n    if (samples.length === 0) {\n        return undefined;\n    }\n\n    let sum = 0;\n\n    for (let i = 0, l = samples.length; i < l; i++) {\n        sum += samples[i];\n    }\n\n    const avg = sum / samples.length;\n\n    return avg;\n}\n\n/**\n * Measures a sequence of connected events, such as multiple processing stages in a function.\n * Each stage is identified with a timer name, that must be a valid timer in the statistics\n * object. Additionally, all timers within a `MultiStageTimer` must be unique.\n *\n * Internally, the `MultiStageTimer` manages a list of timers where at the end of each stage,\n * one timer stops and the next timer starts.\n */\nexport class MultiStageTimer {\n    private currentStage: string | undefined;\n\n    /**\n     * Defines the `MultiStageTimer` with a list of timer names that represent its stages.\n     *\n     * @param statistics - The statistics object that manages the timers.\n     * @param name - Name of this `MultiStageTimer`.\n     * @param stages - List of timer names.\n     */\n    constructor(private statistics: Statistics, readonly name: string, public stages: string[]) {\n        if (stages.length < 1) {\n            throw new Error(\"MultiStageTimer needs stages\");\n        }\n\n        stages.forEach(stage => {\n            if (!statistics.hasTimer(stage)) {\n                throw new Error(\"Unknown timer: \" + stage);\n            }\n        });\n    }\n\n    /**\n     * Gets the timer value for the last stage. If the `MultiStageTimer` did not finish its\n     * last stage, the value is `undefined`.\n     */\n    get value(): number | undefined {\n        return this.statistics.getTimer(this.stages[this.stages.length - 1]).value;\n    }\n\n    /**\n     * Resets the timers across all stages.\n     */\n    reset(): void {\n        if (!this.statistics.enabled) {\n            return;\n        }\n        this.stages.forEach(stage => {\n            this.statistics.getTimer(stage).reset();\n        });\n    }\n\n    /**\n     * Starts the `MultiStageTimer` at its first stage.\n     */\n    start(): number {\n        this.stage = this.stages[0];\n\n        return this.statistics.getTimer(this.stages[0]).value || -1;\n    }\n\n    /**\n     * Stops the `MultiStageTimer`. Returns the measurement of the last stage, which may be\n     * `undefined` if not all stages started.\n     */\n    stop(): number {\n        this.stage = undefined;\n        return this.value !== undefined ? this.value : -1;\n    }\n\n    /**\n     * Gets the current stage.\n     */\n    get stage(): string | undefined {\n        return this.currentStage;\n    }\n\n    /**\n     * Sets the current stage. If a new stage is provided, the current timer (if available) is\n     * stopped, and the next timer is started. If the timer in the next stage is `undefined`,\n     * this is equivalent to calling `stop` on the `MultiStageTimer`.\n     *\n     * @param stage - The next stage to start.\n     */\n    set stage(stage: string | undefined) {\n        if (this.currentStage === stage) {\n            return;\n        }\n\n        if (this.statistics.enabled && this.currentStage !== undefined) {\n            this.statistics.getTimer(this.currentStage).stop();\n        }\n\n        this.currentStage = stage;\n\n        if (this.statistics.enabled && this.currentStage !== undefined) {\n            this.statistics.getTimer(this.currentStage).start();\n        }\n    }\n}\n\n/**\n * Manages a set of timers. The main objective of `Statistics` is to log these timers. You can\n * disable statistics to minimize their impact on performance.\n */\nexport class Statistics {\n    private timers: Map<string, Timer>;\n\n    private nullTimer: Timer;\n\n    /**\n     * Sets up a group of timers.\n     *\n     * @param name - The statistics name, for logging purposes.\n     * @param enabled - If `false`, the timers do not measure the performance.\n     */\n    constructor(public name?: string, public enabled = false) {\n        this.timers = new Map<string, Timer>();\n        this.nullTimer = new SimpleTimer(this, \"<null>\");\n    }\n\n    /**\n     * Adds a timer, based on the name specified.\n     *\n     * @param name - The timer's name; must be unique.\n     */\n    createTimer(name: string, keepSamples = true): Timer {\n        const timer = keepSamples ? new SampledTimer(this, name) : new SimpleTimer(this, name);\n\n        return this.addTimer(timer);\n    }\n\n    /**\n     * Adds the timer specified.\n     *\n     * @param timer - The timer's name, which must be unique within this statistics object.\n     */\n    addTimer(timer: Timer): Timer {\n        if (this.timers.get(timer.name) !== undefined) {\n            throw new Error(\"Duplicate timer name: '\" + timer.name + \"'\");\n        }\n\n        this.timers.set(timer.name, timer);\n\n        return timer;\n    }\n\n    /**\n     * Gets a timer by name.\n     *\n     * @param name - The timer's name.\n     */\n    getTimer(name: string): Timer {\n        if (!this.enabled) {\n            return this.nullTimer;\n        }\n\n        const t = this.timers.get(name);\n        return t === undefined ? this.nullTimer : t;\n    }\n\n    /**\n     * Checks if a timer with the specified name already exists.\n     *\n     * @param name - The timer's name.\n     * @returns `true` if a timer with `name` already exists; `false` otherwise.\n     */\n    hasTimer(name: string): boolean {\n        const t = this.timers.get(name);\n        return t !== undefined;\n    }\n\n    /**\n     * Resets all timers.\n     */\n    reset() {\n        this.timers.forEach((timer: Timer) => {\n            timer.reset();\n        });\n    }\n\n    /**\n     * Prints all values to the console.\n     *\n     * @param header - Optional header line.\n     * @param footer - Optional footer line.\n     */\n    log(header?: string, footer?: string) {\n        if (header !== undefined || this.name !== undefined) {\n            logger.log(header !== undefined ? header : this.name);\n        }\n\n        let maxNameLength = 0;\n\n        this.timers.forEach((timer: Timer) => {\n            maxNameLength = Math.max(maxNameLength, timer.name.length);\n        });\n\n        // simple printing function for number limits the number of decimal points.\n        const print = (v: number | undefined) => {\n            return v !== undefined ? v.toFixed(5) : \"?\";\n        };\n\n        this.timers.forEach((timer: Timer) => {\n            let s = timer.name + \": \" + \" \".repeat(maxNameLength - timer.name.length);\n            s += print(timer.value);\n\n            // sampled timers also update their stats and log them\n            if (timer instanceof SampledTimer) {\n                const simpleStats = timer.getStats();\n                if (simpleStats !== undefined) {\n                    s +=\n                        `  [ min=${print(simpleStats.min)}, max=${print(simpleStats.max)}, ` +\n                        `avg=${print(simpleStats.avg)}, med=${print(simpleStats.median)}, ` +\n                        `med95=${print(simpleStats.median95)}, med99=${print(\n                            simpleStats.median99\n                        )}, ` +\n                        `N=${print(simpleStats.numSamples)} ]`;\n                }\n            }\n            logger.log(s);\n        });\n\n        if (footer !== undefined) {\n            logger.log(footer);\n        }\n    }\n}\n\n/**\n * Class containing all counters, timers and events of the current frame.\n */\nexport class FrameStats {\n    readonly entries: Map<string, number> = new Map();\n    messages?: string[] = undefined;\n\n    /**\n     * Retrieve the value of the performance number.\n     *\n     * @param name - Name of the performance number.\n     * @returns The value of the performance number or `undefined` if it has not been declared by\n     *      `setValue` before.\n     */\n    getValue(name: string): number | undefined {\n        return this.entries.get(name);\n    }\n\n    /**\n     * Set the value of the performance number.\n     *\n     * @param name - Name of the performance number.\n     * @param name - New value of the performance number.\n     */\n    setValue(name: string, value: number) {\n        this.entries.set(name, value);\n    }\n\n    /**\n     * Add a value to the current value of the performance number. If the performance is not known,\n     * it will be initialized with `value`.\n     *\n     * @param name - Name of the performance number.\n     * @param name - Value to be added to the performance number.\n     */\n    addValue(name: string, value: number) {\n        const oldValue = this.entries.get(name);\n        this.entries.set(name, value + (oldValue === undefined ? 0 : oldValue));\n    }\n\n    /**\n     * Add a text message to the frame, like \"Font XYZ has been loaded\"\n     *\n     * @param message - The message to add.\n     */\n    addMessage(message: string) {\n        if (this.messages === undefined) {\n            this.messages = [];\n        }\n        this.messages.push(message);\n    }\n\n    /**\n     * Reset all known performance values to `0` and the messages to `undefined`.\n     */\n    reset() {\n        this.entries.forEach((value: number, name: string) => {\n            this.entries.set(name, 0);\n        });\n\n        this.messages = undefined;\n    }\n}\n\n/**\n * @ignore\n * Only exported for testing.\n *\n * Instead of passing around an array of objects, we store the frame statistics as an object of\n * arrays. This allows convenient computations from {@link RingBuffer},\n */\nexport class FrameStatsArray {\n    readonly frameEntries: Map<string, RingBuffer<number>> = new Map();\n    readonly messages: RingBuffer<string[] | undefined>;\n\n    constructor(readonly capacity: number = 0) {\n        this.messages = new RingBuffer<string[] | undefined>(capacity);\n    }\n\n    get length(): number {\n        return this.messages.size;\n    }\n\n    reset() {\n        this.frameEntries.forEach((buffer: RingBuffer<number>, name: string) => {\n            buffer.clear();\n        });\n        this.messages.clear();\n    }\n\n    addFrame(frameStats: FrameStats) {\n        const currentSize = this.length;\n        const frameEntries = this.frameEntries;\n\n        frameStats.entries.forEach((value: number, name: string) => {\n            let buffer = frameEntries.get(name);\n\n            if (buffer === undefined) {\n                // If there is a buffer that has not been known before, add it to the known buffers,\n                // fill it up with with 0 to the size of all the other buffers to make them of equal\n                // size to make PerfViz happy.\n                buffer = new RingBuffer<number>(this.capacity);\n                for (let i = 0; i < currentSize; i++) {\n                    buffer.enqOne(0);\n                }\n                this.frameEntries.set(name, buffer);\n            }\n            buffer.enqOne(value);\n        });\n\n        this.messages.enq(frameStats.messages);\n    }\n\n    /**\n     * Prints all values to the console.\n     */\n    log() {\n        let maxNameLength = 0;\n        this.frameEntries.forEach((buffer: RingBuffer<number>, name: string) => {\n            maxNameLength = Math.max(maxNameLength, name.length);\n        });\n\n        // simple printing function for number limits the number of decimal points.\n        const print = (v: number | undefined) => {\n            return v !== undefined ? v.toFixed(5) : \"?\";\n        };\n\n        this.frameEntries.forEach((buffer: RingBuffer<number>, name: string) => {\n            let s = name + \": \" + \" \".repeat(maxNameLength - name.length);\n\n            const simpleStats = computeArrayStats(buffer.asArray());\n            if (simpleStats !== undefined) {\n                s +=\n                    `  [ min=${print(simpleStats.min)}, max=${print(simpleStats.max)}, ` +\n                    `avg=${print(simpleStats.avg)}, med=${print(simpleStats.median)}, ` +\n                    `med95=${print(simpleStats.median95)}, med99=${print(simpleStats.median99)}, ` +\n                    `N=${print(simpleStats.numSamples)} ]`;\n            }\n            logger.log(s);\n        });\n    }\n}\n\n/**\n * Chrome's MemoryInfo interface.\n */\ninterface ChromeMemoryInfo {\n    totalJSHeapSize: number;\n    usedJSHeapSize: number;\n    jsHeapSizeLimit: number;\n}\n\nexport interface SimpleFrameStatistics {\n    configs: Map<string, string>;\n    appResults: Map<string, number>;\n    frames: Map<string, number | number[]>;\n    messages: Array<string[] | undefined>;\n    frameStats?: Map<string, Stats | undefined>;\n    zoomLevelLabels?: string[];\n    zoomLevelData?: Map<string, number | number[]>;\n}\n\n/**\n * Performance measurement central. Maintains the current\n * {@link FrameStats}, which holds all individual\n * performance numbers.\n *\n * Implemented as an instance for easy access.\n */\nexport class PerformanceStatistics {\n    /**\n     * Returns `true` when the maximum number of storable frames is reached.\n     *\n     * @readonly\n     * @type {boolean}\n     * @memberof PerformanceStatistics\n     */\n    get isFull(): boolean {\n        return this.m_frameEvents.length >= this.maxNumFrames;\n    }\n    /**\n     * Global instance to the instance. The current instance can be overridden by creating a new\n     * `PerformanceStatistics`.\n     */\n    static get instance(): PerformanceStatistics {\n        if (PerformanceStatistics.m_instance === undefined) {\n            PerformanceStatistics.m_instance = new PerformanceStatistics(false, 0);\n        }\n        return PerformanceStatistics.m_instance;\n    }\n\n    private static m_instance?: PerformanceStatistics = undefined;\n\n    /**\n     * Current frame statistics. Contains all values for the current frame. Will be cleared when\n     * [[PerformanceStatistics#storeFrameInfo]] is called.\n     *\n     * @type {FrameStats}\n     * @memberof PerformanceStatistics\n     */\n    readonly currentFrame: FrameStats = new FrameStats();\n\n    /**\n     * @ignore\n     * Only exported for testing.\n     *\n     * Return the array of frame events.\n     */\n    get frameEvents(): FrameStatsArray {\n        return this.m_frameEvents;\n    }\n\n    /**\n     * Additional results stored for the current application run, not per frame. Only the last value\n     * is stored.\n     *\n     * @type {(Map<string, number>)}\n     */\n    readonly appResults: Map<string, number> = new Map();\n\n    /**\n     * Additional configuration values stored for the current application run, not per frame. Only\n     * the last value is stored.\n     *\n     * @type {(Map<string, string>)}\n     * @memberof PerformanceStatistics\n     */\n    readonly configs: Map<string, string> = new Map();\n\n    // Current array of frame events.\n    private m_frameEvents: FrameStatsArray;\n\n    /**\n     * Creates an instance of PerformanceStatistics. Overrides the current `instance`.\n     *\n     * @param {boolean} [enabled=true] If `false` the performance values will not be stored.\n     * @param {number} [maxNumFrames=1000] The maximum number of frames that are to be stored.\n     * @memberof PerformanceStatistics\n     */\n    constructor(public enabled = true, public maxNumFrames = 1000) {\n        PerformanceStatistics.m_instance = this;\n        this.m_frameEvents = new FrameStatsArray(maxNumFrames);\n    }\n\n    /**\n     * Clears all settings, all stored frame events as well as the current frame values.\n     *\n     * @memberof PerformanceStatistics\n     */\n    clear() {\n        this.clearFrames();\n        this.configs.clear();\n        this.appResults.clear();\n    }\n\n    /**\n     * Clears only all stored frame events as well as the current frame values.\n     *\n     * @memberof PerformanceStatistics\n     */\n    clearFrames() {\n        this.m_frameEvents.reset();\n        this.currentFrame.reset();\n    }\n\n    /**\n     * Add the render state information from [[THREE.WebGLInfo]] to the current frame.\n     * @param {THREE.WebGLInfo} webGlInfo\n     */\n    addWebGLInfo(webGlInfo: THREE.WebGLInfo) {\n        if (webGlInfo.render !== undefined) {\n            this.currentFrame.setValue(\n                \"gl.numCalls\",\n                webGlInfo.render.calls === null ? 0 : webGlInfo.render.calls\n            );\n            this.currentFrame.setValue(\n                \"gl.numPoints\",\n                webGlInfo.render.points === null ? 0 : webGlInfo.render.points\n            );\n            this.currentFrame.setValue(\n                \"gl.numLines\",\n                webGlInfo.render.lines === null ? 0 : webGlInfo.render.lines\n            );\n            this.currentFrame.setValue(\n                \"gl.numTriangles\",\n                webGlInfo.render.triangles === null ? 0 : webGlInfo.render.triangles\n            );\n        }\n        if (webGlInfo.memory !== undefined) {\n            this.currentFrame.setValue(\n                \"gl.numGeometries\",\n                webGlInfo.memory.geometries === null ? 0 : webGlInfo.memory.geometries\n            );\n            this.currentFrame.setValue(\n                \"gl.numTextures\",\n                webGlInfo.memory.textures === null ? 0 : webGlInfo.memory.textures\n            );\n        }\n        if (webGlInfo.programs !== undefined) {\n            this.currentFrame.setValue(\n                \"gl.numPrograms\",\n                webGlInfo.programs === null ? 0 : webGlInfo.programs.length\n            );\n        }\n    }\n\n    /**\n     * Add memory statistics to the current frame if available.\n     * @note Currently only supported on Chrome\n     */\n    addMemoryInfo() {\n        if (window !== undefined && window.performance !== undefined) {\n            const memory = (window.performance as any).memory as ChromeMemoryInfo;\n            if (memory !== undefined) {\n                this.currentFrame.setValue(\"memory.totalJSHeapSize\", memory.totalJSHeapSize);\n                this.currentFrame.setValue(\"memory.usedJSHeapSize\", memory.usedJSHeapSize);\n                this.currentFrame.setValue(\"memory.jsHeapSizeLimit\", memory.jsHeapSizeLimit);\n            }\n        }\n    }\n\n    /**\n     * Stores the current frame events into the array of events and clears all values.\n     *\n     * @returns {boolean} Returns `false` if the maximum number of storable frames has been reached.\n     * @memberof PerformanceStatistics\n     */\n    storeAndClearFrameInfo(): boolean {\n        if (this.m_frameEvents.length >= this.maxNumFrames) {\n            return false;\n        }\n\n        this.m_frameEvents.addFrame(this.currentFrame);\n\n        this.currentFrame.reset();\n        return true;\n    }\n\n    /**\n     * Logs all values to the logger.\n     *\n     * @param header - Optional header line.\n     * @param footer - Optional footer line.\n     */\n    log(header?: string, footer?: string) {\n        logger.log(header !== undefined ? header : \"PerformanceStatistics\");\n\n        const appResults = this.appResults;\n        appResults.forEach((value: number, name: string) => {\n            logger.log(name, value);\n        });\n        const configs = this.configs;\n        configs.forEach((value: string, name: string) => {\n            logger.log(name, value);\n        });\n        this.m_frameEvents.log();\n\n        if (footer !== undefined) {\n            logger.log(footer);\n        }\n    }\n\n    /**\n     * Convert to a plain object that can be serialized. Required to copy the test results over to\n     * nightwatch.\n     */\n    getAsPlainObject(onlyLastFrame: boolean = false): any {\n        const appResults: any = {};\n        const configs: any = {};\n        const frames: any = {};\n        const plainObject: any = {\n            configs,\n            appResults,\n            frames\n        };\n\n        const appResultValues = this.appResults;\n        appResultValues.forEach((value: number, name: string) => {\n            appResults[name] = value;\n        });\n\n        const configValues = this.configs;\n        configValues.forEach((value: string, name: string) => {\n            configs[name] = value;\n        });\n\n        if (onlyLastFrame) {\n            for (const [name, buffer] of this.m_frameEvents.frameEntries) {\n                frames[name] = buffer.bottom;\n            }\n        } else {\n            for (const [name, buffer] of this.m_frameEvents.frameEntries) {\n                frames[name] = buffer.asArray();\n            }\n        }\n        plainObject.messages = this.m_frameEvents.messages.asArray();\n        return plainObject;\n    }\n\n    /**\n     * Convert the last frame values to a plain object that can be serialized. Required to copy the\n     * test results over to nightwatch.\n     */\n    getLastFrameStatistics(): any {\n        return this.getAsPlainObject(true);\n    }\n\n    /**\n     * Convert to a plain object that can be serialized. Required to copy the test results over to\n     * nightwatch.\n     */\n    getAsSimpleFrameStatistics(onlyLastFrame: boolean = false): SimpleFrameStatistics {\n        const configs: Map<string, string> = new Map();\n        const appResults: Map<string, number> = new Map();\n        const frames: Map<string, number | number[]> = new Map();\n\n        const simpleStatistics: SimpleFrameStatistics = {\n            configs,\n            appResults,\n            frames,\n            messages: this.m_frameEvents.messages.asArray()\n        };\n\n        const appResultValues = this.appResults;\n        appResultValues.forEach((value: number, name: string) => {\n            appResults.set(name, value);\n        });\n\n        const configValues = this.configs;\n        configValues.forEach((value: string, name: string) => {\n            configs.set(name, value);\n        });\n\n        if (onlyLastFrame) {\n            for (const [name, buffer] of this.m_frameEvents.frameEntries) {\n                frames.set(name, buffer.bottom);\n            }\n        } else {\n            for (const [name, buffer] of this.m_frameEvents.frameEntries) {\n                frames.set(name, buffer.asArray());\n            }\n        }\n        return simpleStatistics;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { GeometryKind, Technique } from \"@here/harp-datasource-protocol\";\nimport { MapAdapterUpdateEnv, MapMaterialAdapter } from \"./MapMaterialAdapter\";\n\n/**\n * @hidden\n *\n * Construction params of [[MapObjectAdapter]].\n */\nexport interface MapObjectAdapterParams {\n    technique?: Technique;\n    kind?: GeometryKind[];\n\n    // TODO: Move here in following refactor.\n    //featureData?: TileFeatureData;\n}\n\n/**\n * @hidden\n *\n * {@link MapView} specific data assigned to `THREE.Object3D` instance in installed in `userData`.\n *\n * [[MapObjectAdapter]] is registered in `usedData.mapAdapter` property of `THREE.Object3D`.\n */\nexport class MapObjectAdapter {\n    /**\n     * Resolve `MapObjectAdapter` associated with `object`.\n     */\n    static get(object: THREE.Object3D): MapObjectAdapter | undefined {\n        return object.userData?.mapAdapter instanceof MapObjectAdapter\n            ? object.userData.mapAdapter\n            : undefined;\n    }\n\n    static install(objData: MapObjectAdapter): MapObjectAdapter {\n        if (!objData.object.userData) {\n            objData.object.userData = {};\n        }\n        return (objData.object.userData.mapAdapter = objData);\n    }\n\n    static create(object: THREE.Object3D, params: MapObjectAdapterParams): MapObjectAdapter {\n        return MapObjectAdapter.install(new MapObjectAdapter(object, params));\n    }\n\n    static ensureUpdated(object: THREE.Object3D, context: MapAdapterUpdateEnv): boolean {\n        return MapObjectAdapter.get(object)?.ensureUpdated(context) ?? false;\n    }\n\n    /**\n     * Associated scene object.\n     */\n    readonly object: THREE.Object3D;\n\n    /**\n     * [[Technique]] that constituted this object.\n     */\n    readonly technique?: Technique;\n\n    /**\n     * [[GeometryKind]] of `object`.\n     */\n    readonly kind: GeometryKind[] | undefined;\n\n    private m_lastUpdateFrameNumber = -1;\n    private m_notCompletlyTransparent = true;\n\n    constructor(object: THREE.Object3D, params: MapObjectAdapterParams) {\n        this.object = object;\n        this.technique = params.technique;\n        this.kind = params.kind;\n        this.m_notCompletlyTransparent = this.getObjectMaterials().some(\n            material => material.opacity > 0\n        );\n    }\n\n    /**\n     * Serialize contents.\n     *\n     * `THREE.Object3d.userData` is serialized during `clone`/`toJSON`, so we need to ensure that\n     * we emit only \"data\" set of this object.\n     */\n    toJSON() {\n        return { kind: this.kind, technique: this.technique };\n    }\n\n    /**\n     * Ensure that underlying object is updated to current state of {@link MapView}.\n     *\n     * Updates object and attachments like materials to current state by evaluating scene dependent\n     * expressions.\n     *\n     * Executes updates only once per frame basing on [[MapView.frameNumber]].\n     *\n     * Delegates updates of materials to [[MapMaterialAdapter.ensureUpdated]].\n     *\n     * @returns `true` if object performed some kind of update, `false` if no update was needed.\n     */\n    ensureUpdated(context: MapAdapterUpdateEnv): boolean {\n        if (this.m_lastUpdateFrameNumber === context.frameNumber) {\n            return false;\n        }\n        this.m_lastUpdateFrameNumber = context.frameNumber;\n\n        return this.updateMaterials(context);\n    }\n\n    /**\n     * Whether underlying `THREE.Object3D` is actually visible in scene.\n     */\n    isVisible() {\n        return this.object.visible && this.m_notCompletlyTransparent;\n    }\n\n    private updateMaterials(context: MapAdapterUpdateEnv) {\n        let somethingChanged: boolean = false;\n        const materials = this.getObjectMaterials();\n        for (const material of materials) {\n            const changed = MapMaterialAdapter.ensureUpdated(material, context);\n            somethingChanged = somethingChanged || changed;\n        }\n        if (somethingChanged) {\n            this.m_notCompletlyTransparent = materials.some(material => material.opacity > 0);\n        }\n        return somethingChanged;\n    }\n\n    private getObjectMaterials(): THREE.Material[] {\n        const object = this.object as THREE.Mesh;\n        return Array.isArray(object.material)\n            ? object.material\n            : object.material !== undefined\n            ? [object.material]\n            : [];\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { LineMarkerTechnique, Theme } from \"@here/harp-datasource-protocol\";\nimport {\n    AdditionParameters,\n    DEFAULT_TEXT_CANVAS_LAYER,\n    FontCatalog,\n    TextBufferAdditionParameters,\n    TextBufferCreationParameters,\n    TextCanvas,\n    TextLayoutStyle,\n    TextRenderStyle\n} from \"@here/harp-text-canvas\";\nimport {\n    assert,\n    LoggerManager,\n    LogLevel,\n    Math2D,\n    MathUtils,\n    PerformanceTimer\n} from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { TileKey } from \"@here/harp-geoutils\";\nimport { DataSource } from \"../DataSource\";\nimport { debugContext } from \"../DebugContext\";\nimport { overlayTextElement } from \"../geometry/overlayOnElevation\";\nimport { PickObjectType, PickResult } from \"../PickHandler\";\nimport { PoiManager } from \"../poi/PoiManager\";\nimport { PoiRenderer } from \"../poi/PoiRenderer\";\nimport { PoiRendererFactory } from \"../poi/PoiRendererFactory\";\nimport { IBox, LineWithBound, ScreenCollisions } from \"../ScreenCollisions\";\nimport { ScreenProjector } from \"../ScreenProjector\";\nimport { Tile } from \"../Tile\";\nimport { MapViewUtils } from \"../Utils\";\nimport { DataSourceTileList } from \"../VisibleTileSet\";\nimport { FontCatalogLoader } from \"./FontCatalogLoader\";\nimport {\n    checkReadyForPlacement,\n    computeViewDistance,\n    getMaxViewDistance,\n    getWorldPosition,\n    isPathLabelTooSmall,\n    placeIcon,\n    PlacementResult,\n    placePathLabel,\n    placePointLabel,\n    pointToPlaneDistance,\n    PrePlacementResult\n} from \"./Placement\";\nimport { PlacementStats } from \"./PlacementStats\";\nimport { RenderState } from \"./RenderState\";\nimport { SimpleLineCurve, SimplePath } from \"./SimplePath\";\nimport { TextCanvasFactory } from \"./TextCanvasFactory\";\nimport { TextCanvasRenderer } from \"./TextCanvasRenderer\";\nimport { LoadingState, TextElement, TextPickResult } from \"./TextElement\";\nimport { TextElementGroup } from \"./TextElementGroup\";\nimport { TextElementFilter, TextElementGroupState } from \"./TextElementGroupState\";\nimport {\n    initializeDefaultOptions,\n    TextElementsRendererOptions\n} from \"./TextElementsRendererOptions\";\nimport { TextElementState } from \"./TextElementState\";\nimport { TextElementStateCache } from \"./TextElementStateCache\";\nimport { TextElementType } from \"./TextElementType\";\nimport { TextElementStyle, TextStyleCache } from \"./TextStyleCache\";\nimport { UpdateStats } from \"./UpdateStats\";\nimport { ViewState } from \"./ViewState\";\n\ninterface RenderParams {\n    numRenderedTextElements: number;\n    // TODO: HARP-7373. Move to update() method at the end of the frame.\n    fadeAnimationRunning: boolean;\n    time: number;\n}\n\nenum Pass {\n    PersistentLabels,\n    NewLabels\n}\n\n/**\n * Default distance scale. Will be applied if distanceScale is not defined in the technique.\n * Defines the scale that will be applied to labeled icons (icon and text) in the distance.\n */\nexport const DEFAULT_TEXT_DISTANCE_SCALE = 0.5;\n\n/**\n * Maximum number of recommended labels. If more labels are encountered, the \"overloaded\" mode is\n * set, which modifies the behavior of label placement and rendering, trying to keep delivering an\n * interactive performance. The overloaded mode should not be activated if the {@link MapView} is\n * rendering a static image (camera not moving and no animation running).\n */\nconst OVERLOAD_LABEL_LIMIT = 20000;\n\n/**\n * If \"overloaded\" is `true`:\n *\n * Default number of labels/POIs updated in a frame. They are rendered only if they fit. If the\n * camera is not moving, it is ignored. See [[TextElementsRenderer.isDynamicFrame]].\n */\nconst OVERLOAD_UPDATED_LABEL_LIMIT = 100;\n\n/**\n * If \"overloaded\" is `true`:\n *\n * Maximum time in milliseconds available for placement. If value is <= 0, or if the camera is not\n * moving, it is ignored. See [[TextElementsRenderer.isDynamicFrame]].\n */\nconst OVERLOAD_UPDATE_TIME_LIMIT = 5;\n\n/**\n * If \"overloaded\" is `true`:\n *\n * Maximum time in milliseconds available for rendering. If value is <= 0, or if the camera is not\n * moving, it is ignored. See [[TextElementsRenderer.isDynamicFrame]].\n */\nconst OVERLOAD_PLACE_TIME_LIMIT = 10;\n\nconst logger = LoggerManager.instance.create(\"TextElementsRenderer\", { level: LogLevel.Log });\n\n// Development flag: Enable debug print.\nconst PRINT_LABEL_DEBUG_INFO: boolean = false;\nconst updateStats = PRINT_LABEL_DEBUG_INFO ? new UpdateStats(logger) : undefined;\nconst placementStats = PRINT_LABEL_DEBUG_INFO ? new PlacementStats(logger) : undefined;\n\nconst tempPosition = new THREE.Vector3();\nconst tempScreenPosition = new THREE.Vector2();\nconst tempScreenPoints: THREE.Vector2[] = [];\nconst tempPoiScreenPosition = new THREE.Vector2();\nconst tmpTextBufferCreationParams: TextBufferCreationParameters = {};\nconst tmpAdditionParams: AdditionParameters = {};\nconst tmpBufferAdditionParams: TextBufferAdditionParameters = {};\n\nclass TileTextElements {\n    constructor(readonly tile: Tile, readonly group: TextElementGroup) {}\n}\n\nclass TextElementLists {\n    constructor(readonly lists: TileTextElements[]) {}\n\n    get priority() {\n        assert(this.lists.length > 0);\n        // All text element lists here have the same priority.\n        return this.lists[0].group.priority;\n    }\n    /**\n     * Sum up the number of elements in all lists.\n     */\n    count(): number {\n        let n = 0;\n        for (const list of this.lists) {\n            n += list.group.elements.length;\n        }\n        return n;\n    }\n}\n\nfunction checkIfTextElementsChanged(dataSourceTileList: DataSourceTileList[]) {\n    let textElementsChanged = false;\n\n    dataSourceTileList.forEach(({ renderedTiles }) => {\n        renderedTiles.forEach(tile => {\n            if (tile.textElementsChanged) {\n                tile.textElementsChanged = false;\n                textElementsChanged = true;\n            }\n        });\n    });\n\n    return textElementsChanged;\n}\n\nfunction addTextToCanvas(\n    textElement: TextElement,\n    canvas: TextCanvas,\n    screenPosition: THREE.Vector3,\n    path?: THREE.Path,\n    pathOverflow?: boolean\n) {\n    tmpAdditionParams.path = path;\n    tmpAdditionParams.pathOverflow = pathOverflow;\n    tmpAdditionParams.layer = textElement.renderOrder;\n    tmpAdditionParams.letterCaseArray = textElement.glyphCaseArray;\n    tmpAdditionParams.pickingData = textElement.userData ? textElement : undefined;\n    canvas.addText(textElement.glyphs!, screenPosition, tmpAdditionParams);\n}\n\nfunction addTextBufferToCanvas(\n    textElementState: TextElementState,\n    canvas: TextCanvas,\n    screenPosition: THREE.Vector3,\n    fadeFactor: number,\n    scaleFactor: number\n): boolean {\n    const textElement = textElementState.element;\n    const textRenderState = textElementState.textRenderState;\n    const opacity = textRenderState!.opacity * fadeFactor * textElement.renderStyle!.opacity;\n\n    if (opacity === 0) {\n        return false;\n    }\n\n    // Compute the TextBufferObject when we know we're gonna render this label.\n    tmpTextBufferCreationParams.letterCaseArray = textElement.glyphCaseArray;\n    if (textElement.textBufferObject === undefined) {\n        textElement.textBufferObject = canvas.createTextBufferObject(\n            textElement.glyphs!,\n            tmpTextBufferCreationParams\n        );\n    }\n    const backgroundIsVisible =\n        textElement.renderStyle!.backgroundOpacity > 0 &&\n        canvas.textRenderStyle.fontSize.backgroundSize > 0;\n\n    tmpBufferAdditionParams.layer = textElement.renderOrder;\n    tmpBufferAdditionParams.position = screenPosition;\n    tmpBufferAdditionParams.scale = scaleFactor;\n    tmpBufferAdditionParams.opacity = opacity;\n    tmpBufferAdditionParams.backgroundOpacity = backgroundIsVisible\n        ? tmpBufferAdditionParams.opacity * textElement.renderStyle!.backgroundOpacity\n        : 0.0;\n    tmpBufferAdditionParams.pickingData = textElement.userData ? textElement : undefined;\n    canvas.addTextBufferObject(textElement.textBufferObject!, tmpBufferAdditionParams);\n    return true;\n}\n\nfunction shouldRenderPointText(\n    labelState: TextElementState,\n    viewState: ViewState,\n    options: TextElementsRendererOptions\n): boolean {\n    const textRenderState: RenderState | undefined = labelState.textRenderState;\n    const label = labelState.element;\n    const poiInfo = label.poiInfo;\n\n    assert(label.type !== TextElementType.PathLabel);\n\n    const hasText = textRenderState !== undefined && label.text !== \"\";\n    if (!hasText) {\n        return false;\n    }\n\n    const visibleInZoomLevel =\n        poiInfo === undefined ||\n        viewState.zoomLevel === undefined ||\n        MathUtils.isClamped(\n            viewState.zoomLevel,\n            poiInfo.iconMinZoomLevel,\n            poiInfo.iconMaxZoomLevel\n        );\n    if (!visibleInZoomLevel) {\n        return false;\n    }\n\n    const poiTextMaxDistance = getMaxViewDistance(viewState, options.maxDistanceRatioForPoiLabels!);\n    const visibleAtDistance =\n        label.ignoreDistance === true ||\n        labelState.viewDistance === undefined ||\n        labelState.viewDistance < poiTextMaxDistance;\n    if (!visibleAtDistance) {\n        return false;\n    }\n\n    // Do not render text if POI cannot be rendered and is not optional.\n    return poiInfo === undefined || poiInfo.isValid === true || poiInfo.iconIsOptional !== false;\n}\n\nfunction shouldRenderPoiText(labelState: TextElementState, viewState: ViewState) {\n    // Do not actually render (just allocate space) if camera is moving and\n    // renderTextDuringMovements is not true.\n    const poiInfo = labelState.element.poiInfo;\n\n    return (\n        !viewState.cameraIsMoving ||\n        poiInfo === undefined ||\n        poiInfo.renderTextDuringMovements === true\n    );\n}\n\nexport type ViewUpdateCallback = () => void;\n\nfunction isPlacementTimeExceeded(startTime: number | undefined): boolean {\n    // startTime is set in overload mode.\n    if (startTime === undefined || OVERLOAD_PLACE_TIME_LIMIT <= 0) {\n        return false;\n    }\n    const endTime = PerformanceTimer.now();\n    const elapsedTime = endTime - startTime;\n    if (elapsedTime > OVERLOAD_PLACE_TIME_LIMIT) {\n        logger.debug(\"Placement time limit exceeded.\");\n        return true;\n    }\n    return false;\n}\n\n/**\n *\n * Internal class to manage all text rendering.\n */\nexport class TextElementsRenderer {\n    private m_initialized: boolean = false;\n    private m_initPromise: Promise<void> | undefined;\n    private m_glyphLoadingCount: number = 0;\n    private m_loadPromise: Promise<any> | undefined;\n    private readonly m_options: TextElementsRendererOptions;\n\n    private readonly m_textStyleCache: TextStyleCache;\n    private m_textRenderers: TextCanvasRenderer[] = [];\n\n    private m_overlayTextElements?: TextElement[];\n\n    // TODO: Replace this for an array of textures when more fonts are in use.\n    private m_debugGlyphTextureCacheMesh?: THREE.Mesh;\n    private m_debugGlyphTextureCacheWireMesh?: THREE.LineSegments;\n\n    private m_tmpVector = new THREE.Vector2();\n    private m_tmpVector3 = new THREE.Vector3();\n    private m_cameraLookAt = new THREE.Vector3();\n    private m_overloaded: boolean = false;\n    private m_cacheInvalidated: boolean = false;\n    private m_forceNewLabelsPass: boolean = false;\n    private m_addNewLabels: boolean = true;\n\n    private readonly m_textElementStateCache: TextElementStateCache = new TextElementStateCache();\n\n    /**\n     * Create the `TextElementsRenderer` which selects which labels should be placed on screen as\n     * a preprocessing step, which is not done every frame, and also renders the placed\n     * {@link TextElement}s every frame.\n     *\n     * @param m_viewState - State of the view for which this renderer will draw text.\n     * @param m_viewCamera - Camera used by the view for which this renderer will draw text.\n     * @param m_viewUpdateCallback - To be called whenever the view needs to be updated.\n     * @param m_screenCollisions - General 2D screen occlusion management, may be shared between\n     *     instances.\n     * @param m_screenProjector - Projects 3D coordinates into screen space.\n     * @param m_textCanvasFactory - To create TextCanvas instances.\n     * @param m_poiRendererFactory - To create PoiRenderer instances.\n     * @param m_poiManager - To prepare pois for rendering.\n     * @param m_fontCatalogLoader - To load font catalogs.\n     * @param m_theme - Theme defining  text styles.\n     * @param options - Configuration options for the text renderer. See\n     * [[TextElementsRendererOptions]].\n     */\n    constructor(\n        private m_viewState: ViewState,\n        private m_viewCamera: THREE.Camera,\n        private m_viewUpdateCallback: ViewUpdateCallback,\n        private m_screenCollisions: ScreenCollisions,\n        private m_screenProjector: ScreenProjector,\n        private m_textCanvasFactory: TextCanvasFactory,\n        private m_poiManager: PoiManager,\n        private m_poiRendererFactory: PoiRendererFactory,\n        private m_fontCatalogLoader: FontCatalogLoader,\n        private m_theme: Theme,\n        options: TextElementsRendererOptions\n    ) {\n        this.m_textStyleCache = new TextStyleCache(this.m_theme);\n\n        this.m_options = { ...options };\n        initializeDefaultOptions(this.m_options);\n\n        this.m_textCanvasFactory.setGlyphCountLimits(\n            this.m_options.minNumGlyphs!,\n            this.m_options.maxNumGlyphs!\n        );\n    }\n\n    /**\n     * Disable all fading animations (for debugging and performance measurement). Defaults to\n     * `false`.\n     */\n    set disableFading(disable: boolean) {\n        this.m_options.disableFading = disable;\n    }\n\n    get disableFading(): boolean {\n        return this.m_options.disableFading === true;\n    }\n\n    get styleCache() {\n        return this.m_textStyleCache;\n    }\n\n    get delayLabelsUntilMovementFinished(): boolean {\n        return this.m_options.delayLabelsUntilMovementFinished === true;\n    }\n\n    set delayLabelsUntilMovementFinished(delay: boolean) {\n        this.m_options.delayLabelsUntilMovementFinished = delay;\n    }\n\n    /**\n     * Render the text using the specified camera into the current canvas.\n     *\n     * @param camera - Orthographic camera to use.\n     */\n    renderText(camera: THREE.OrthographicCamera) {\n        if (!this.initialized) {\n            return;\n        }\n\n        this.updateGlyphDebugMesh();\n\n        for (const textRenderer of this.m_textRenderers) {\n            textRenderer.textCanvas.render(camera);\n        }\n    }\n\n    /**\n     * Forces update of text elements in the next call to [[placeText]].\n     */\n    invalidateCache() {\n        this.m_cacheInvalidated = true;\n    }\n\n    /**\n     * Notify `TextElementsRenderer` that the camera has started a movement.\n     */\n    movementStarted() {\n        if (this.delayLabelsUntilMovementFinished) {\n            this.m_addNewLabels = false;\n        }\n    }\n\n    /**\n     * Notify `TextElementsRenderer` that the camera has finished its movement.\n     */\n    movementFinished() {\n        this.invalidateCache();\n        if (this.delayLabelsUntilMovementFinished) {\n            this.m_addNewLabels = true;\n        }\n    }\n\n    /**\n     * Is `true` if number of {@link TextElement}s in visible tiles is larger than the recommended\n     * number `OVERLOAD_LABEL_LIMIT`.\n     */\n    get overloaded(): boolean {\n        return this.m_overloaded;\n    }\n\n    /**\n     * Places text elements for the current frame.\n     * @param dataSourceTileList - List of tiles to be rendered for each data source.\n     * @param time - Current frame time.\n     */\n    placeText(dataSourceTileList: DataSourceTileList[], time: number) {\n        const tileTextElementsChanged = checkIfTextElementsChanged(dataSourceTileList);\n\n        const textElementsAvailable = this.hasOverlayText() || tileTextElementsChanged;\n        if (!this.initialize(textElementsAvailable)) {\n            return;\n        }\n\n        const updateTextElements =\n            this.m_cacheInvalidated ||\n            tileTextElementsChanged ||\n            this.m_viewState.renderedTilesChanged;\n\n        logger.debug(\n            `FRAME: ${this.m_viewState.frameNumber}, ZOOM LEVEL: ${this.m_viewState.zoomLevel}`\n        );\n\n        if (updateTextElements && this.m_addNewLabels) {\n            this.m_textElementStateCache.clearVisited();\n            this.updateTextElements(dataSourceTileList);\n        }\n        const findReplacements = updateTextElements && this.m_addNewLabels;\n        const anyTextGroupEvicted = this.m_textElementStateCache.update(\n            time,\n            this.m_options.disableFading!,\n            findReplacements,\n            this.m_viewState.zoomLevel\n        );\n\n        this.reset();\n        if (this.m_addNewLabels) {\n            this.prepopulateScreenWithBlockingElements(dataSourceTileList);\n        }\n\n        // New text elements must be placed either if text elements were updated in this frame\n        // or if any text element group was evicted. The second case happens when the group is not\n        // visited anymore and all it's elements just became invisible, which means there's newly\n        // available screen space where new text elements could be placed. A common scenario where\n        // this happens is zooming in/out: text groups from the old level may still be fading out\n        // after all groups in the new level were updated.\n        const placeNewTextElements =\n            (updateTextElements || anyTextGroupEvicted) && this.m_addNewLabels;\n        this.placeTextElements(time, placeNewTextElements);\n        this.placeOverlayTextElements();\n        this.updateTextRenderers();\n    }\n\n    /**\n     * Adds new overlay text elements to this `MapView`.\n     *\n     * @param textElements - Array of {@link TextElement} to be added.\n     */\n    addOverlayText(textElements: TextElement[]): void {\n        if (textElements.length === 0) {\n            return;\n        }\n        this.m_overlayTextElements =\n            this.m_overlayTextElements === undefined\n                ? textElements.slice()\n                : this.m_overlayTextElements.concat(textElements);\n    }\n\n    /**\n     * Adds new overlay text elements to this `MapView`.\n     *\n     * @param textElements - Array of {@link TextElement} to be added.\n     */\n    clearOverlayText(): void {\n        this.m_overlayTextElements = [];\n    }\n\n    /**\n     * @returns Whether there's overlay text to be rendered.\n     */\n    hasOverlayText(): boolean {\n        return this.m_overlayTextElements !== undefined && this.m_overlayTextElements.length > 0;\n    }\n\n    get overlayText(): TextElement[] | undefined {\n        return this.m_overlayTextElements;\n    }\n\n    /**\n     * Fill the picking results for the pixel with the given screen coordinate. If multiple\n     * {@link TextElement}s are found, the order of the results is unspecified.\n     *\n     * Note: {@link TextElement}s with identical `featureId` or\n     * identical `userData` will only appear\n     * once in the list `pickResults`.\n     *\n     * @param screenPosition - Screen coordinate of picking position.\n     * @param pickResults - Array filled with pick results.\n     */\n    pickTextElements(screenPosition: THREE.Vector2, pickResults: PickResult[]) {\n        const pickHandler = (pickData: any | undefined, pickObjectType: PickObjectType) => {\n            const textElement = pickData as TextElement;\n\n            if (textElement === undefined) {\n                return;\n            }\n\n            let isDuplicate = false;\n\n            if (textElement.featureId !== undefined) {\n                isDuplicate = pickResults.some(pickResult => {\n                    return (\n                        pickResult !== undefined &&\n                        pickObjectType === pickResult.type &&\n                        ((pickResult.featureId !== undefined &&\n                            pickResult.featureId === textElement.featureId) ||\n                            (pickResult.userData !== undefined &&\n                                pickResult.userData === textElement.userData))\n                    );\n                });\n\n                if (!isDuplicate) {\n                    const pickResult: TextPickResult = {\n                        type: pickObjectType,\n                        point: screenPosition,\n                        distance: 0,\n                        featureId: textElement.featureId,\n                        userData: textElement.userData,\n                        text: textElement.text\n                    };\n\n                    pickResults.push(pickResult);\n                }\n            }\n        };\n\n        for (const textRenderer of this.m_textRenderers) {\n            textRenderer.textCanvas.pickText(screenPosition, (pickData: any | undefined) => {\n                pickHandler(pickData, PickObjectType.Text);\n            });\n            textRenderer.poiRenderer.pickTextElements(\n                screenPosition,\n                (pickData: any | undefined) => {\n                    pickHandler(pickData, PickObjectType.Icon);\n                }\n            );\n        }\n    }\n\n    /**\n     * `true` if any resource used by any `FontCatalog` is still loading.\n     */\n    get loading(): boolean {\n        return this.m_fontCatalogLoader.loading || this.m_glyphLoadingCount > 0;\n    }\n\n    /**\n     * Waits till all pending resources from any `FontCatalog` are loaded.\n     */\n    async waitLoaded(): Promise<boolean> {\n        const initialized = await this.waitInitialized();\n        if (!initialized) {\n            return false;\n        }\n        if (this.m_loadPromise === undefined) {\n            return false;\n        }\n        await this.m_loadPromise;\n        return true;\n    }\n\n    /**\n     * Reset the current text render states of all visible tiles.\n     *\n     * @remarks\n     * All {@link TextElement}s will fade in\n     * after that as if they have just been added.\n     */\n    clearRenderStates() {\n        this.m_textElementStateCache.clear();\n    }\n\n    /**\n     * Return memory used by all objects managed by `TextElementsRenderer`.\n     *\n     * @returns `MemoryUsage` Heap and GPU memory used by this `TextElementsRenderer`.\n     */\n    getMemoryUsage(): MapViewUtils.MemoryUsage {\n        const memoryUsage = {\n            heapSize: 0,\n            gpuSize: 0\n        };\n\n        for (const renderer of this.m_textRenderers) {\n            renderer.textCanvas.getMemoryUsage(memoryUsage);\n            renderer.poiRenderer.getMemoryUsage(memoryUsage);\n        }\n\n        return memoryUsage;\n    }\n\n    get initialized(): boolean {\n        return this.m_initialized;\n    }\n\n    get initializing(): boolean {\n        return this.m_initPromise !== undefined;\n    }\n\n    /**\n     * Waits until initialization is done.\n     * @returns Promise resolved to true if initialization was done, false otherwise.\n     */\n    async waitInitialized(): Promise<boolean> {\n        if (this.initialized) {\n            return true;\n        }\n\n        if (!this.initializing) {\n            return false;\n        }\n        await this.m_initPromise;\n        return true;\n    }\n\n    /**\n     * Initializes the text renderer once there's any text element available for rendering.\n     * @param textElementsAvailable - Indicates whether there's any text element to be rendered.\n     * @returns Whether the text renderer is initialized.\n     */\n    private initialize(textElementsAvailable: boolean): boolean {\n        if (!this.initialized && !this.initializing && textElementsAvailable) {\n            this.initializeDefaultAssets();\n            this.m_initPromise = this.initializeTextCanvases().then(() => {\n                this.m_initialized = true;\n                this.m_initPromise = undefined;\n                this.invalidateCache(); // Force cache update after initialization.\n                this.m_viewUpdateCallback();\n            });\n        }\n        return this.initialized;\n    }\n\n    /**\n     * Reset internal state at the beginning of a frame.\n     */\n    private reset() {\n        this.m_cameraLookAt.copy(this.m_viewState.lookAtVector);\n        this.m_screenCollisions.reset();\n        for (const textRenderer of this.m_textRenderers) {\n            textRenderer.textCanvas.clear();\n            textRenderer.poiRenderer.reset();\n        }\n    }\n\n    /**\n     * Update state at the end of a frame.\n     */\n    private updateTextRenderers() {\n        for (const textRenderer of this.m_textRenderers) {\n            textRenderer.poiRenderer.update();\n        }\n    }\n\n    /**\n     * Fills the screen with lines projected from world space, see [[Tile.blockingElements]].\n     * @note These boxes have highest priority, so will block all other labels.\n     * @param dataSourceTileList - List of tiles to be rendered for each data source.\n     */\n    private prepopulateScreenWithBlockingElements(dataSourceTileList: DataSourceTileList[]) {\n        const boxes: IBox[] = [];\n        dataSourceTileList.forEach(renderListEntry => {\n            const startLinePointProj = new THREE.Vector3();\n            const endLinePointProj = new THREE.Vector3();\n            for (const tile of renderListEntry.renderedTiles.values()) {\n                for (const pathBlockingElement of tile.blockingElements) {\n                    if (pathBlockingElement.points.length < 2) {\n                        continue;\n                    }\n                    this.m_screenProjector.project3(\n                        pathBlockingElement.points[0],\n                        startLinePointProj\n                    );\n                    for (let i = 1; i < pathBlockingElement.points.length; i++) {\n                        this.m_screenProjector.project3(\n                            pathBlockingElement.points[i],\n                            endLinePointProj\n                        );\n                        const line = pathBlockingElement.screenSpaceLines[i - 1];\n                        line.start.copy(startLinePointProj);\n                        line.end.copy(endLinePointProj);\n                        const lineWithBound: LineWithBound = {\n                            minX: Math.min(startLinePointProj.x, endLinePointProj.x),\n                            maxX: Math.max(startLinePointProj.x, endLinePointProj.x),\n                            minY: Math.min(startLinePointProj.y, endLinePointProj.y),\n                            maxY: Math.max(startLinePointProj.y, endLinePointProj.y),\n                            line\n                        };\n                        boxes.push(lineWithBound);\n                        startLinePointProj.copy(endLinePointProj);\n                    }\n                }\n            }\n        });\n        this.m_screenCollisions.allocateIBoxes(boxes);\n    }\n\n    /**\n     * @returns True if whole group was processed for placement,\n     * false otherwise (e.g. placement limit reached).\n     */\n    private placeTextElementGroup(\n        groupState: TextElementGroupState,\n        renderParams: RenderParams,\n        maxNumPlacedLabels: number,\n        pass: Pass\n    ): boolean {\n        // Unvisited text elements are never placed.\n        assert(groupState.visited);\n\n        if (this.m_textRenderers.length === 0) {\n            logger.warn(\"No text renderers initialized.\");\n            return false;\n        }\n\n        const shieldGroups: number[][] = [];\n        const hiddenKinds = this.m_viewState.hiddenGeometryKinds;\n        const projection = this.m_viewState.projection;\n        const elevationProvider = this.m_viewState.elevationProvider;\n        const elevationMap = elevationProvider?.getDisplacementMap(groupState.tileKey);\n\n        for (const textElementState of groupState.textElementStates) {\n            if (pass === Pass.PersistentLabels) {\n                if (placementStats) {\n                    ++placementStats.total;\n                }\n            }\n            // Limit labels only in new labels pass (Pass.NewLabels).\n            else if (\n                maxNumPlacedLabels >= 0 &&\n                renderParams.numRenderedTextElements >= maxNumPlacedLabels\n            ) {\n                logger.debug(\"Placement label limit exceeded.\");\n                return false;\n            }\n\n            // Skip all labels that are not initialized (didn't pass early placement tests)\n            // or don't belong to this pass.\n            if (!textElementState.initialized) {\n                if (placementStats) {\n                    ++placementStats.uninitialized;\n                }\n                continue;\n            }\n            if (textElementState.viewDistance === undefined) {\n                if (placementStats) {\n                    ++placementStats.tooFar;\n                }\n                continue;\n            }\n\n            const elementVisible = textElementState.visible;\n            if (\n                (pass === Pass.PersistentLabels && !elementVisible) ||\n                (pass === Pass.NewLabels && elementVisible)\n            ) {\n                continue;\n            }\n\n            const textElement = textElementState.element;\n\n            // Get the TextElementStyle.\n            const textElementStyle = this.m_textStyleCache.getTextElementStyle(textElement.style);\n            const textCanvas = textElementStyle.textCanvas;\n            const poiRenderer = textElementStyle.poiRenderer;\n            if (textCanvas === undefined || poiRenderer === undefined) {\n                logger.warn(\"Text canvas or poi renderer not ready.\");\n                continue;\n            }\n\n            // TODO: HARP-7648. Discard hidden kinds sooner, before placement.\n            // Check if the label should be hidden.\n            if (\n                hiddenKinds !== undefined &&\n                textElement.kind !== undefined &&\n                hiddenKinds.hasOrIntersects(textElement.kind)\n            ) {\n                continue;\n            }\n\n            if (elevationProvider !== undefined && !textElement.elevated) {\n                if (!elevationMap) {\n                    this.m_viewUpdateCallback(); // Update view until elevation is loaded.\n                    this.m_forceNewLabelsPass = true;\n                    continue;\n                }\n                overlayTextElement(textElement, elevationProvider, elevationMap, projection);\n            }\n            const elementType = textElement.type;\n            const isPathLabel = elementType === TextElementType.PathLabel;\n\n            // For paths, check if the label may fit.\n            if (isPathLabel) {\n                if (isPathLabelTooSmall(textElement, this.m_screenProjector, tempScreenPoints)) {\n                    if (placementStats) {\n                        placementStats.numNotVisible++;\n                    }\n                    if (textElement.dbgPathTooSmall === true) {\n                        if (placementStats) {\n                            placementStats.numPathTooSmall++;\n                        }\n                    }\n                    textElementState.reset();\n                    continue;\n                }\n            }\n\n            const forceNewPassOnLoaded = true;\n            // This ensures that textElement.renderStyle and textElement.layoutStyle are\n            // already instantiated and initialized with theme style values.\n            if (!this.initializeGlyphs(textElement, textElementStyle, forceNewPassOnLoaded)) {\n                continue;\n            }\n\n            const layer = textCanvas.getLayer(textElement.renderOrder || DEFAULT_TEXT_CANVAS_LAYER);\n\n            // Move onto the next TextElement if we cannot continue adding glyphs to this layer.\n            if (layer !== undefined) {\n                if (layer.storage.drawCount + textElement.glyphs!.length > layer.storage.capacity) {\n                    if (placementStats) {\n                        ++placementStats.numCannotAdd;\n                    }\n                    logger.warn(\"layer glyph storage capacity exceeded.\");\n                    continue;\n                }\n            }\n\n            // Set the current style for the canvas.\n            // This means text canvas has always references (not a copy) to text element styles.\n            // The only exception is multi-anchor placement where layoutStyle need to be\n            // modified and thus textCanvas will using its own copy of textElement.layoutStyle.\n            // See: placePointLabel()\n            textCanvas.textRenderStyle = textElement.renderStyle!;\n            textCanvas.textLayoutStyle = textElement.layoutStyle!;\n\n            switch (elementType) {\n                case TextElementType.PoiLabel:\n                    this.addPoiLabel(textElementState, poiRenderer, textCanvas, renderParams);\n                    break;\n                case TextElementType.LineMarker:\n                    this.addLineMarkerLabel(\n                        textElementState,\n                        poiRenderer,\n                        shieldGroups,\n                        textCanvas,\n                        renderParams\n                    );\n                    break;\n                case TextElementType.PathLabel:\n                    this.addPathLabel(textElementState, tempScreenPoints, textCanvas, renderParams);\n            }\n        }\n        return true;\n    }\n\n    private initializeGlyphs(\n        textElement: TextElement,\n        textElementStyle: TextElementStyle,\n        forceNewPassOnLoaded: boolean\n    ): boolean {\n        // Trigger the glyph load if needed.\n        if (textElement.loadingState === LoadingState.Initialized) {\n            return true;\n        }\n\n        assert(textElementStyle.textCanvas !== undefined);\n        const textCanvas = textElementStyle.textCanvas!;\n\n        if (textElement.loadingState === undefined) {\n            textElement.loadingState = LoadingState.Requested;\n\n            if (textElement.renderStyle === undefined) {\n                textElement.renderStyle = new TextRenderStyle({\n                    ...textElementStyle.renderParams,\n                    ...textElement.renderParams\n                });\n            }\n            if (textElement.layoutStyle === undefined) {\n                textElement.layoutStyle = new TextLayoutStyle({\n                    ...textElementStyle.layoutParams,\n                    ...textElement.layoutParams\n                });\n            }\n\n            if (textElement.text === \"\") {\n                textElement.loadingState = LoadingState.Loaded;\n            } else {\n                const newLoadPromise = textCanvas.fontCatalog\n                    .loadCharset(textElement.text, textElement.renderStyle)\n                    .then(() => {\n                        --this.m_glyphLoadingCount;\n                        textElement.loadingState = LoadingState.Loaded;\n                        // Ensure that text elements still loading glyphs get a chance to\n                        // be rendered if there's no text element updates in the next frames.\n                        this.m_forceNewLabelsPass =\n                            this.m_forceNewLabelsPass || forceNewPassOnLoaded;\n                        this.m_viewUpdateCallback();\n                    });\n                if (this.m_glyphLoadingCount === 0) {\n                    this.m_loadPromise = undefined;\n                }\n                ++this.m_glyphLoadingCount;\n\n                this.m_loadPromise =\n                    this.m_loadPromise === undefined\n                        ? newLoadPromise\n                        : Promise.all([this.m_loadPromise, newLoadPromise]);\n            }\n        }\n        if (textElement.loadingState === LoadingState.Loaded) {\n            textCanvas.textRenderStyle = textElement.renderStyle!;\n            textCanvas.textLayoutStyle = textElement.layoutStyle!;\n            textElement.glyphCaseArray = [];\n            textElement.bounds = undefined;\n            textElement.glyphs = textCanvas.fontCatalog.getGlyphs(\n                textElement.text,\n                textCanvas.textRenderStyle,\n                textElement.glyphCaseArray\n            );\n            textElement.loadingState = LoadingState.Initialized;\n        }\n        // Return true as soon as a text element has some glyphs assigned so that it's rendered.\n        // The glyphs may be either the final ones or some temporal glyphs inherited from a\n        // predecessor as part of the text element replacement process.\n        // See TextElementState.replace().\n        return textElement.glyphs !== undefined;\n    }\n\n    private initializeDefaultAssets(): void {\n        const defaultFontCatalogName = this.m_fontCatalogLoader.initialize(\n            this.m_options.fontCatalog!\n        );\n        this.m_textStyleCache.initializeDefaultTextElementStyle(defaultFontCatalogName);\n    }\n\n    private async initializeTextCanvases(): Promise<void> {\n        const catalogCallback = (name: string, catalog: FontCatalog) => {\n            const loadedTextCanvas = this.m_textCanvasFactory.createTextCanvas(catalog);\n\n            this.m_textRenderers.push({\n                fontCatalog: name,\n                textCanvas: loadedTextCanvas,\n                poiRenderer: this.m_poiRendererFactory.createPoiRenderer(loadedTextCanvas)\n            });\n        };\n\n        return this.m_fontCatalogLoader.loadCatalogs(catalogCallback).then(() => {\n            // Find the default TextCanvas and PoiRenderer.\n            let defaultTextCanvas: TextCanvas | undefined;\n            this.m_textRenderers.forEach(textRenderer => {\n                if (defaultTextCanvas === undefined) {\n                    defaultTextCanvas = textRenderer.textCanvas;\n                }\n            });\n            const defaultPoiRenderer = this.m_poiRendererFactory.createPoiRenderer(\n                defaultTextCanvas!\n            );\n\n            this.m_textStyleCache.initializeTextElementStyles(\n                defaultPoiRenderer,\n                defaultTextCanvas!,\n                this.m_textRenderers\n            );\n        });\n    }\n\n    private updateGlyphDebugMesh() {\n        const debugGlyphs = debugContext.getValue(\"DEBUG_GLYPHS\");\n        if (debugGlyphs === undefined) {\n            return;\n        }\n\n        if (debugGlyphs && this.m_debugGlyphTextureCacheMesh === undefined) {\n            this.initializeGlyphDebugMesh();\n        }\n        assert(this.m_debugGlyphTextureCacheMesh !== undefined);\n        assert(this.m_debugGlyphTextureCacheWireMesh !== undefined);\n\n        this.m_debugGlyphTextureCacheMesh!.visible = debugGlyphs;\n        this.m_debugGlyphTextureCacheWireMesh!.visible = debugGlyphs;\n    }\n\n    private initializeGlyphDebugMesh() {\n        const defaultFontCatalog = this.m_textRenderers[0].textCanvas.fontCatalog;\n\n        // Initialize glyph-debugging mesh.\n        const planeGeometry = new THREE.PlaneGeometry(\n            defaultFontCatalog.textureSize.width / 2.5,\n            defaultFontCatalog.textureSize.height / 2.5,\n            defaultFontCatalog.textureSize.width / defaultFontCatalog.maxWidth,\n            defaultFontCatalog.textureSize.height / defaultFontCatalog.maxHeight\n        );\n        const material = new THREE.MeshBasicMaterial({\n            transparent: true,\n            depthWrite: false,\n            depthTest: false,\n            map: defaultFontCatalog.texture\n        });\n        this.m_debugGlyphTextureCacheMesh = new THREE.Mesh(planeGeometry, material);\n        this.m_debugGlyphTextureCacheMesh.renderOrder = 10000;\n        this.m_debugGlyphTextureCacheMesh.visible = false;\n\n        this.m_debugGlyphTextureCacheMesh.name = \"glyphDebug\";\n\n        const wireframe = new THREE.WireframeGeometry(planeGeometry);\n        const wireframeMaterial = new THREE.LineBasicMaterial({\n            transparent: true,\n            color: 0x999999,\n            depthWrite: false,\n            depthTest: false\n        });\n        this.m_debugGlyphTextureCacheWireMesh = new THREE.LineSegments(\n            wireframe,\n            wireframeMaterial\n        );\n        this.m_debugGlyphTextureCacheWireMesh.renderOrder = 9999;\n        this.m_debugGlyphTextureCacheWireMesh.visible = false;\n\n        this.m_debugGlyphTextureCacheWireMesh.name = \"glyphDebug\";\n\n        this.m_textRenderers[0].textCanvas\n            .getLayer(DEFAULT_TEXT_CANVAS_LAYER)!\n            .storage.scene.add(\n                this.m_debugGlyphTextureCacheMesh,\n                this.m_debugGlyphTextureCacheWireMesh\n            );\n    }\n\n    /**\n     * Visit all visible tiles and add/ their text elements to cache.\n     *\n     * @remarks\n     * The update of {@link TextElement}s is a time consuming process,\n     * and cannot be done every frame, but should only\n     * be done when the camera moved (a lot) of whenever the set of visible tiles change.\n     *\n     * The actually rendered {@link TextElement}s are stored internally\n     * until the next update is done\n     * to speed up rendering when no camera movement was detected.\n     * @param dataSourceTileList - List of tiles to be rendered for each data source.\n     */\n    private updateTextElements(dataSourceTileList: DataSourceTileList[]) {\n        logger.debug(\"updateTextElements\");\n\n        if (updateStats) {\n            updateStats.clear();\n        }\n\n        this.m_textElementStateCache.clearTextCache();\n        this.m_cacheInvalidated = false;\n\n        this.checkIfOverloaded(dataSourceTileList);\n\n        // Used with tile offset to compute the x coordinate offset for tiles.\n        const updateStartTime =\n            this.overloaded && this.m_viewState.isDynamic ? PerformanceTimer.now() : undefined;\n\n        // TODO: HARP-7648. Skip all data sources that won't contain text.\n        // TODO: HARP-7651. Higher priority labels should be updated before lower priority ones\n        // across all data sources.\n        // TODO: HARP-7373. Use rendered tiles (tiles currently rendered to cover the view,\n        // including fallbacks if necessary) instead of visible tiles (target tiles that might not\n        // be decoded yet).\n        // Otherwise labels persistent when crossing a zoom level boundary will flicker (fade out\n        // and back in) due to the delay in decoding the visible tiles.\n        dataSourceTileList.forEach(tileList => {\n            this.updateTextElementsFromSource(\n                tileList.dataSource,\n                tileList.storageLevel,\n                Array.from(tileList.renderedTiles.values()),\n                updateStartTime\n            );\n        });\n\n        if (updateStats) {\n            updateStats.log();\n        }\n    }\n\n    private updateTextElementsFromSource(\n        tileDataSource: DataSource,\n        storageLevel: number,\n        visibleTiles: Tile[],\n        updateStartTime: number | undefined\n    ) {\n        if (updateStats) {\n            updateStats.tiles += visibleTiles.length;\n        }\n        const sortedTiles = visibleTiles;\n\n        // TODO: HARP-7648. Really needed? Should it be done here or in VisibleTileSet?\n        sortedTiles.sort((a: Tile, b: Tile) => {\n            return a.tileKey.mortonCode() - b.tileKey.mortonCode();\n        });\n\n        const sortedGroups: TextElementLists[] = [];\n        this.createSortedGroupsForSorting(tileDataSource, storageLevel, sortedTiles, sortedGroups);\n\n        let numTextElementsUpdated = 0;\n\n        for (const textElementLists of sortedGroups) {\n            this.selectTextElementsToUpdateByDistance(textElementLists);\n\n            // The value of updateStartTime is set if this.overloaded is true.\n            if (updateStartTime !== undefined) {\n                // If overloaded and all time is used up, exit early.\n                if (OVERLOAD_UPDATE_TIME_LIMIT > 0) {\n                    const endTime = PerformanceTimer.now();\n                    const elapsedTime = endTime - updateStartTime;\n                    if (elapsedTime > OVERLOAD_UPDATE_TIME_LIMIT) {\n                        logger.debug(\"Update time limit exceeded.\");\n                        break;\n                    }\n                }\n\n                // Try not to update too many elements. They will be checked for visibility each\n                // frame.\n                numTextElementsUpdated += textElementLists.count();\n                if (numTextElementsUpdated >= OVERLOAD_UPDATED_LABEL_LIMIT) {\n                    logger.debug(\"Update label limit exceeded.\");\n                    break;\n                }\n            }\n        }\n    }\n\n    private prepareTextElementGroup(\n        textElementGroup: TextElementGroup,\n        tileKey: TileKey,\n        maxViewDistance?: number\n    ) {\n        if (textElementGroup.elements.length === 0) {\n            return;\n        }\n\n        const textElementSelection: TextElementFilter = (\n            textElementState: TextElementState\n        ): number | undefined => {\n            let { result, viewDistance } = checkReadyForPlacement(\n                textElementState.element,\n                this.m_viewState,\n                this.m_viewCamera,\n                this.m_poiManager,\n                maxViewDistance\n            );\n\n            if (\n                result === PrePlacementResult.Ok &&\n                !this.m_textElementStateCache.deduplicateElement(\n                    this.m_viewState.zoomLevel,\n                    textElementState\n                )\n            ) {\n                result = PrePlacementResult.Duplicate;\n                viewDistance = undefined;\n            }\n\n            if (updateStats) {\n                updateStats.totalLabels++;\n                updateStats.results[result]++;\n            }\n            return viewDistance;\n        };\n\n        const [, found] = this.m_textElementStateCache.getOrSet(\n            textElementGroup,\n            tileKey,\n            textElementSelection\n        );\n\n        if (updateStats) {\n            ++updateStats.totalGroups;\n            if (!found) {\n                ++updateStats.newGroups;\n            }\n        }\n    }\n\n    private createSortedGroupsForSorting(\n        tileDataSource: DataSource,\n        storageLevel: number,\n        sortedTiles: Tile[],\n        sortedGroups: TextElementLists[]\n    ) {\n        if (sortedTiles.length === 0) {\n            return;\n        }\n\n        const tilesToRender: Tile[] = [];\n\n        for (const tile of sortedTiles) {\n            if (tileDataSource.shouldRenderText(storageLevel, tile.tileKey)) {\n                tilesToRender.push(tile);\n            }\n        }\n\n        const groupedPriorityLists: Map<number, TextElementLists> = new Map();\n\n        for (const tile of tilesToRender) {\n            for (const group of tile.textElementGroups.groups.values()) {\n                if (group.elements.length === 0) {\n                    continue;\n                }\n\n                const foundGroup = groupedPriorityLists.get(group.priority);\n                if (foundGroup === undefined) {\n                    groupedPriorityLists.set(\n                        group.priority,\n                        new TextElementLists([new TileTextElements(tile, group)])\n                    );\n                } else {\n                    foundGroup.lists.push(new TileTextElements(tile, group));\n                }\n            }\n        }\n\n        if (groupedPriorityLists.size === 0) {\n            return;\n        }\n\n        for (const g of groupedPriorityLists) {\n            const lists = g[1];\n            sortedGroups.push(lists);\n        }\n\n        sortedGroups.sort((a: TextElementLists, b: TextElementLists) => {\n            return b.priority - a.priority;\n        });\n\n        const printTextInfo = false;\n\n        if (PRINT_LABEL_DEBUG_INFO && printTextInfo) {\n            let outString = \"\";\n            for (const textElementLists of sortedGroups) {\n                let size = 0;\n                for (const tileTextElements of textElementLists.lists) {\n                    size += tileTextElements.group.elements.length;\n                }\n                outString += `priority ${textElementLists.priority} size: ${size}\\n`;\n            }\n            logger.log(outString);\n        }\n    }\n\n    private selectTextElementsToUpdateByDistance(textElementLists: TextElementLists) {\n        const farDistanceLimitRatio = Math.max(\n            this.m_options.maxDistanceRatioForTextLabels!,\n            this.m_options.maxDistanceRatioForPoiLabels!\n        );\n        const maxViewDistance = getMaxViewDistance(this.m_viewState, farDistanceLimitRatio);\n\n        for (const tileTextElements of textElementLists.lists) {\n            this.prepareTextElementGroup(\n                tileTextElements.group,\n                tileTextElements.tile.tileKey,\n                maxViewDistance\n            );\n        }\n    }\n\n    private placeTextElements(time: number, placeNewTextElements: boolean) {\n        const renderParams: RenderParams = {\n            numRenderedTextElements: 0,\n            fadeAnimationRunning: false,\n            time\n        };\n\n        const placeStartTime =\n            this.overloaded && this.m_viewState.isDynamic ? PerformanceTimer.now() : undefined;\n\n        if (placementStats) {\n            placementStats.clear();\n        }\n\n        if (this.m_textElementStateCache.size === 0) {\n            logger.debug(\"Text element cache empty.\");\n            return;\n        }\n\n        const placeNew = this.m_forceNewLabelsPass || placeNewTextElements;\n        if (this.m_forceNewLabelsPass) {\n            if (!placeNewTextElements) {\n                logger.debug(\"Force new label pass\");\n            }\n            this.m_forceNewLabelsPass = false;\n        }\n        const maxNumPlacedTextElements = this.m_options.maxNumVisibleLabels!;\n\n        // TODO: HARP-7648. Potential performance improvement. Place persistent labels + rejected\n        // candidates from previous frame if there's been no placement in this one.\n        const groupStates = this.m_textElementStateCache.sortedGroupStates;\n        let currentPriority: number = groupStates[0].priority;\n        let currentPriorityBegin: number = 0;\n\n        for (let i = 0; i < groupStates.length; ++i) {\n            const textElementGroupState = groupStates[i];\n            if (placementStats) {\n                ++placementStats.totalGroups;\n            }\n\n            const newPriority = textElementGroupState.priority;\n            if (placeNew && currentPriority !== newPriority) {\n                // Place all new labels of the previous priority before placing the persistent\n                // labels of this priority.\n                this.placeNewTextElements(currentPriorityBegin, i, renderParams);\n                if (isPlacementTimeExceeded(placeStartTime)) {\n                    break;\n                }\n                currentPriority = newPriority;\n                currentPriorityBegin = i;\n            }\n            if (\n                !this.placeTextElementGroup(\n                    textElementGroupState,\n                    renderParams,\n                    maxNumPlacedTextElements,\n                    Pass.PersistentLabels\n                )\n            ) {\n                break;\n            }\n\n            if (isPlacementTimeExceeded(placeStartTime)) {\n                break;\n            }\n        }\n\n        if (placeNew) {\n            // Place new text elements of the last priority.\n            this.placeNewTextElements(currentPriorityBegin, groupStates.length, renderParams);\n        }\n\n        if (placementStats) {\n            placementStats.numRenderedTextElements = renderParams.numRenderedTextElements;\n            placementStats.log();\n        }\n\n        if (renderParams.fadeAnimationRunning) {\n            this.m_viewUpdateCallback();\n        }\n    }\n\n    private placeNewTextElements(\n        beginGroupIndex: number,\n        endGroupIndex: number,\n        renderParams: RenderParams\n    ) {\n        const groupStates = this.m_textElementStateCache.sortedGroupStates;\n        for (let i = beginGroupIndex; i < endGroupIndex; ++i) {\n            if (\n                !this.placeTextElementGroup(\n                    groupStates[i],\n                    renderParams,\n                    this.m_options.maxNumVisibleLabels!,\n                    Pass.NewLabels\n                )\n            ) {\n                break;\n            }\n        }\n    }\n\n    private placeOverlayTextElements() {\n        if (this.m_overlayTextElements === undefined || this.m_overlayTextElements.length === 0) {\n            return;\n        }\n\n        const screenSize = this.m_tmpVector.set(\n            this.m_screenProjector.width,\n            this.m_screenProjector.height\n        );\n        const screenXOrigin = -screenSize.width / 2.0;\n        const screenYOrigin = screenSize.height / 2.0;\n\n        // Place text elements one by one.\n        for (const textElement of this.m_overlayTextElements!) {\n            // Get the TextElementStyle.\n            const textElementStyle = this.m_textStyleCache.getTextElementStyle(textElement.style);\n            const textCanvas = textElementStyle.textCanvas;\n            if (textCanvas === undefined) {\n                continue;\n            }\n\n            const forceNewPassOnLoaded = false;\n            this.initializeGlyphs(textElement, textElementStyle, forceNewPassOnLoaded);\n\n            if (textElement.loadingState !== LoadingState.Initialized) {\n                continue;\n            }\n\n            const layer = textCanvas.getLayer(textElement.renderOrder || DEFAULT_TEXT_CANVAS_LAYER);\n\n            // Move onto the next TextElement if we cannot continue adding glyphs to this layer.\n            if (layer !== undefined) {\n                if (layer.storage.drawCount + textElement.glyphs!.length > layer.storage.capacity) {\n                    continue;\n                }\n            }\n\n            // Set the current style for the canvas.\n            textCanvas.textRenderStyle = textElement.renderStyle!;\n            textCanvas.textLayoutStyle = textElement.layoutStyle!;\n\n            // Place text.\n            let textPath;\n            if (!(textElement.type === TextElementType.PathLabel)) {\n                // Adjust the label positioning.\n                tempScreenPosition.x = screenXOrigin + textElement.position.x * screenSize.width;\n                tempScreenPosition.y = screenYOrigin - textElement.position.y * screenSize.height;\n                if (textElement.xOffset !== undefined) {\n                    tempScreenPosition.x += textElement.xOffset;\n                }\n                if (textElement.yOffset !== undefined) {\n                    tempScreenPosition.y -= textElement.yOffset;\n                }\n\n                tempPosition.x = tempScreenPosition.x;\n                tempPosition.y = tempScreenPosition.y;\n                tempPosition.z = 0.0;\n                addTextToCanvas(textElement, textCanvas, tempPosition);\n            } else {\n                // Adjust the label positioning.\n                tempScreenPosition.x = screenXOrigin;\n                tempScreenPosition.y = screenYOrigin;\n                if (textElement.xOffset !== undefined) {\n                    tempScreenPosition.x += textElement.xOffset;\n                }\n                if (textElement.yOffset !== undefined) {\n                    tempScreenPosition.y -= textElement.yOffset;\n                }\n\n                // Get the screen points that define the label's segments and create a path with\n                // them.\n                // TODO: HARP-7648. Optimize array allocations.\n                const screenPoints: THREE.Vector2[] = [];\n                for (const pt of textElement.path!) {\n                    const pX = tempScreenPosition.x + pt.x * screenSize.width;\n                    const pY = tempScreenPosition.y - pt.y * screenSize.height;\n                    screenPoints.push(new THREE.Vector2(pX, pY));\n                }\n                textPath = new SimplePath();\n                for (let i = 0; i < screenPoints.length - 1; ++i) {\n                    textPath.add(new THREE.LineCurve(screenPoints[i], screenPoints[i + 1]));\n                }\n                addTextToCanvas(textElement, textCanvas, tempPosition, textPath, true);\n            }\n        }\n    }\n\n    private getDistanceScalingFactor(\n        label: TextElement,\n        distance: number,\n        lookAtDistance: number\n    ): number {\n        // Distance scale is based on relation between camera focus point distance and\n        // the actual label distance. For labels close to camera look at point the scale\n        // remains unchanged, the farther is label from that point the smaller size it is\n        // rendered in screen space. This method is unaffected by near and far clipping planes\n        // distances, but may be improved by taking FOV into equation or customizing the\n        // focus point screen position based on horizon, actual ground, tilt ets.\n        let factor = lookAtDistance / distance;\n        // The label.distanceScale property defines the influence ratio at which\n        // distance affects the final scaling of label.\n        factor = 1.0 + (factor - 1.0) * label.distanceScale;\n        // Preserve the constraints\n        factor = Math.max(factor, this.m_options.labelDistanceScaleMin!);\n        factor = Math.min(factor, this.m_options.labelDistanceScaleMax!);\n        return factor;\n    }\n\n    private getDistanceFadingFactor(\n        label: TextElement,\n        state: TextElementState,\n        maxVisibilityDist: number\n    ): number {\n        let distanceFadeValue = 1.0;\n        const textDistance = state.viewDistance;\n\n        if (textDistance !== undefined && label.fadeFar !== undefined && label.fadeFar > 0.0) {\n            const fadeNear = label.fadeNear === undefined ? 0.0 : label.fadeNear;\n            const fadeFar = label.fadeFar;\n            if (fadeFar > fadeNear) {\n                distanceFadeValue =\n                    1.0 -\n                    THREE.MathUtils.clamp(\n                        (textDistance / maxVisibilityDist - fadeNear) / (fadeFar - fadeNear),\n                        0.0,\n                        1.0\n                    );\n            }\n        }\n        return distanceFadeValue;\n    }\n\n    private addPointLabel(\n        labelState: TextElementState,\n        position: THREE.Vector3,\n        screenPosition: THREE.Vector2,\n        poiRenderer: PoiRenderer,\n        textCanvas: TextCanvas,\n        renderParams: RenderParams,\n        iconIndex?: number\n    ): boolean {\n        const pointLabel: TextElement = labelState.element;\n        const textRenderState: RenderState | undefined = labelState.textRenderState;\n\n        assert(iconIndex === undefined || labelState.iconRenderStates !== undefined);\n        const iconRenderState: RenderState =\n            iconIndex !== undefined\n                ? labelState.iconRenderStates![iconIndex]\n                : labelState.iconRenderState!;\n        assert(iconRenderState !== undefined);\n\n        // Find the label's original position.\n        tempScreenPosition.x = tempPoiScreenPosition.x = screenPosition.x;\n        tempScreenPosition.y = tempPoiScreenPosition.y = screenPosition.y;\n\n        // Scale the text depending on the label's distance to the camera \"zero\" plane.\n        const textDistance = pointToPlaneDistance(\n            position,\n            this.m_viewState.worldCenter,\n            this.m_cameraLookAt\n        );\n        if (\n            pointLabel.fadeFar !== undefined &&\n            (pointLabel.fadeFar <= 0.0 ||\n                pointLabel.fadeFar * this.m_viewState.maxVisibilityDist < textDistance)\n        ) {\n            // The label is farther away than fadeFar value, which means it is totally\n            // transparent.\n            if (placementStats) {\n                ++placementStats.tooFar;\n            }\n            return false;\n        }\n        labelState.setViewDistance(textDistance);\n\n        // Check if there is need to check for screen space for the label's icon.\n        const poiInfo = pointLabel.poiInfo;\n        let iconRejected = false;\n\n        // Check if icon should be rendered at this zoomLevel\n        const renderIcon =\n            poiInfo !== undefined &&\n            MathUtils.isClamped(\n                this.m_viewState.zoomLevel,\n                poiInfo.iconMinZoomLevel,\n                poiInfo.iconMaxZoomLevel\n            ) &&\n            poiInfo!.isValid !== false;\n\n        const distanceScaleFactor = this.getDistanceScalingFactor(\n            pointLabel,\n            textDistance,\n            this.m_viewState.lookAtDistance\n        );\n        const iconReady = renderIcon && poiRenderer.prepareRender(pointLabel, this.m_viewState.env);\n\n        if (iconReady) {\n            const result = placeIcon(\n                iconRenderState,\n                poiInfo!,\n                tempPoiScreenPosition,\n                distanceScaleFactor,\n                this.m_viewState.env,\n                this.m_screenCollisions\n            );\n            if (result === PlacementResult.Invisible) {\n                iconRenderState.reset();\n\n                if (placementStats) {\n                    ++placementStats.numNotVisible;\n                }\n                return false;\n            }\n            iconRejected = result === PlacementResult.Rejected;\n        } else if (renderIcon && poiInfo!.isValid !== false) {\n            // Ensure that text elements still loading icons get a chance to be rendered if\n            // there's no text element updates in the next frames.\n            this.m_forceNewLabelsPass = true;\n        }\n\n        const distanceFadeFactor = this.getDistanceFadingFactor(\n            pointLabel,\n            labelState,\n            this.m_viewState.maxVisibilityDist\n        );\n        const renderText = shouldRenderPointText(labelState, this.m_viewState, this.m_options);\n\n        // Render the label's text...\n        // textRenderState is always defined at this point.\n        if (renderText) {\n            // Multi point (icons) features (line markers) will use single placement anchor, but\n            // single point labels (POIs, etc.) may use multi-placement algorithm.\n            const placeResult = placePointLabel(\n                labelState,\n                tempScreenPosition,\n                distanceScaleFactor,\n                textCanvas,\n                this.m_viewState.env,\n                this.m_screenCollisions,\n                iconRejected,\n                tempPosition,\n                iconIndex === undefined\n            );\n            if (placeResult === PlacementResult.Invisible) {\n                if (placementStats) {\n                    placementStats.numPoiTextsInvisible++;\n                }\n                labelState.reset();\n                return false;\n            }\n\n            const textRejected = placeResult === PlacementResult.Rejected;\n            if (!iconRejected) {\n                const textIsOptional: boolean =\n                    pointLabel.poiInfo !== undefined && pointLabel.poiInfo.textIsOptional === true;\n                iconRejected = textRejected && !textIsOptional;\n            }\n\n            if (textRejected) {\n                textRenderState!.startFadeOut(renderParams.time);\n            }\n\n            const textNeedsDraw =\n                (!textRejected && shouldRenderPoiText(labelState, this.m_viewState)) ||\n                textRenderState!.isFading();\n\n            if (textNeedsDraw) {\n                if (!textRejected) {\n                    textRenderState!.startFadeIn(renderParams.time);\n                }\n                renderParams.fadeAnimationRunning =\n                    renderParams.fadeAnimationRunning || textRenderState!.isFading();\n                if (\n                    addTextBufferToCanvas(\n                        labelState,\n                        textCanvas,\n                        tempPosition,\n                        distanceFadeFactor,\n                        distanceScaleFactor\n                    ) &&\n                    placementStats\n                ) {\n                    placementStats.numRenderedPoiTexts++;\n                }\n            }\n        }\n        // ... and render the icon (if any).\n        if (iconReady) {\n            if (iconRejected) {\n                iconRenderState!.startFadeOut(renderParams.time);\n            } else {\n                iconRenderState!.startFadeIn(renderParams.time);\n            }\n\n            renderParams.fadeAnimationRunning =\n                renderParams.fadeAnimationRunning || iconRenderState!.isFading();\n\n            const opacity = iconRenderState.opacity * distanceFadeFactor;\n            if (opacity > 0) {\n                // Same as for text, don't allocate screen space for an icon that's fading out so\n                // that any label blocked by it gets a chance to be placed as soon as any other\n                // surrounding new labels.\n                const allocateSpace = poiInfo!.reserveSpace !== false && !iconRejected;\n                poiRenderer.renderPoi(\n                    poiInfo!,\n                    tempPoiScreenPosition,\n                    this.m_screenCollisions,\n                    labelState.renderDistance,\n                    distanceScaleFactor,\n                    allocateSpace,\n                    opacity,\n                    this.m_viewState.env\n                );\n\n                if (placementStats) {\n                    placementStats.numRenderedPoiIcons++;\n                }\n            }\n        }\n        renderParams.numRenderedTextElements++;\n        return true;\n    }\n\n    private addPoiLabel(\n        labelState: TextElementState,\n        poiRenderer: PoiRenderer,\n        textCanvas: TextCanvas,\n        renderParams: RenderParams\n    ): boolean {\n        const worldPosition = getWorldPosition(\n            labelState.element,\n            this.m_viewState.projection,\n            this.m_viewState.env,\n            this.m_tmpVector3\n        );\n        // Only process labels frustum-clipped labels\n        if (this.m_screenProjector.project(worldPosition, tempScreenPosition) === undefined) {\n            return false;\n        }\n        // Add this POI as a point label.\n        return this.addPointLabel(\n            labelState,\n            worldPosition,\n            tempScreenPosition,\n            poiRenderer,\n            textCanvas,\n            renderParams\n        );\n    }\n\n    private addLineMarkerLabel(\n        labelState: TextElementState,\n        poiRenderer: PoiRenderer,\n        shieldGroups: number[][],\n        textCanvas: TextCanvas,\n        renderParams: RenderParams\n    ): void {\n        const lineMarkerLabel = labelState.element;\n        const path = lineMarkerLabel.points as THREE.Vector3[];\n\n        // Early exit if the line marker doesn't have the necessary data.\n        const poiInfo = lineMarkerLabel.poiInfo!;\n        if (\n            path.length === 0 ||\n            !poiRenderer.prepareRender(lineMarkerLabel, this.m_viewState.env)\n        ) {\n            return;\n        }\n\n        // Initialize the shield group for this lineMarker.\n        let shieldGroup: number[] | undefined;\n        if (poiInfo.shieldGroupIndex !== undefined) {\n            shieldGroup = shieldGroups[poiInfo.shieldGroupIndex];\n            if (shieldGroup === undefined) {\n                shieldGroup = [];\n                shieldGroups[poiInfo.shieldGroupIndex] = shieldGroup;\n            }\n        }\n\n        const lineTechnique = poiInfo.technique as LineMarkerTechnique;\n        const minDistanceSqr =\n            lineTechnique.minDistance !== undefined\n                ? lineTechnique.minDistance * lineTechnique.minDistance\n                : 0;\n\n        // Process markers (with shield groups).\n        if (minDistanceSqr > 0 && shieldGroup !== undefined) {\n            for (let pointIndex = 0; pointIndex < path.length; ++pointIndex) {\n                const point = path[pointIndex];\n                // Only process labels frustum-clipped labels\n                if (this.m_screenProjector.project(point, tempScreenPosition) !== undefined) {\n                    // Find a suitable location for the lineMarker to be placed at.\n                    let tooClose = false;\n                    for (let j = 0; j < shieldGroup.length; j += 2) {\n                        const distanceSqr = Math2D.distSquared(\n                            shieldGroup[j],\n                            shieldGroup[j + 1],\n                            tempScreenPosition.x,\n                            tempScreenPosition.y\n                        );\n                        tooClose = distanceSqr < minDistanceSqr;\n                        if (tooClose) {\n                            break;\n                        }\n                    }\n\n                    // Place it as a point label if it's not to close to other marker in the\n                    // same shield group.\n                    if (!tooClose) {\n                        if (\n                            this.addPointLabel(\n                                labelState,\n                                point,\n                                tempScreenPosition,\n                                poiRenderer,\n                                textCanvas,\n                                renderParams,\n                                pointIndex\n                            )\n                        ) {\n                            shieldGroup.push(tempScreenPosition.x, tempScreenPosition.y);\n                        }\n                    }\n                }\n            }\n        }\n        // Process markers (without shield groups).\n        else {\n            for (let pointIndex = 0; pointIndex < path.length; ++pointIndex) {\n                const point = path[pointIndex];\n                // Only process labels frustum-clipped labels\n                if (this.m_screenProjector.project(point, tempScreenPosition) !== undefined) {\n                    this.addPointLabel(\n                        labelState,\n                        point,\n                        tempScreenPosition,\n                        poiRenderer,\n                        textCanvas,\n                        renderParams,\n                        pointIndex\n                    );\n                }\n            }\n        }\n    }\n\n    private addPathLabel(\n        labelState: TextElementState,\n        screenPoints: THREE.Vector2[],\n        textCanvas: TextCanvas,\n        renderParams: RenderParams\n    ): boolean {\n        // TODO: HARP-7649. Add fade out transitions for path labels.\n        const textMaxDistance = getMaxViewDistance(\n            this.m_viewState,\n            this.m_options.maxDistanceRatioForTextLabels!\n        );\n        const pathLabel = labelState.element;\n\n        // Limit the text rendering of path labels in the far distance.\n        if (\n            !(\n                pathLabel.ignoreDistance === true ||\n                labelState.viewDistance === undefined ||\n                labelState.viewDistance < textMaxDistance\n            )\n        ) {\n            if (placementStats) {\n                ++placementStats.tooFar;\n            }\n            labelState.textRenderState!.reset();\n            return false;\n        }\n\n        if (\n            pathLabel.fadeFar !== undefined &&\n            (pathLabel.fadeFar <= 0.0 ||\n                pathLabel.fadeFar * this.m_viewState.maxVisibilityDist < labelState.renderDistance)\n        ) {\n            // The label is farther away than fadeFar value, which means it is totally\n            // transparent\n            if (placementStats) {\n                ++placementStats.tooFar;\n            }\n            labelState.textRenderState!.reset();\n            return false;\n        }\n\n        // Get the screen points that define the label's segments and create a path with\n        // them.\n        let textPath = new THREE.Path();\n        tempScreenPosition.copy(screenPoints[0]);\n        for (let i = 0; i < screenPoints.length - 1; ++i) {\n            textPath.add(new SimpleLineCurve(screenPoints[i], screenPoints[i + 1]));\n        }\n        // Flip the path if the label is gonna be rendered downwards.\n        if (textPath.getPoint(0.5).x - textPath.getPoint(0.51).x > 0) {\n            tempScreenPosition.copy(screenPoints[screenPoints.length - 1]);\n            textPath = new THREE.Path();\n            for (let i = screenPoints.length - 1; i > 0; --i) {\n                textPath.add(new SimpleLineCurve(screenPoints[i], screenPoints[i - 1]));\n            }\n        }\n\n        // Update the real rendering distance to have smooth fading and scaling\n        labelState.setViewDistance(\n            computeViewDistance(pathLabel, this.m_viewState.worldCenter, this.m_cameraLookAt)\n        );\n        const textRenderDistance = -labelState.renderDistance;\n\n        // Scale the text depending on the label's distance to the camera.\n        const distanceScaleFactor = this.getDistanceScalingFactor(\n            pathLabel,\n            textRenderDistance,\n            this.m_viewState.lookAtDistance\n        );\n        const prevSize = textCanvas.textRenderStyle.fontSize.size;\n        textCanvas.textRenderStyle.fontSize.size *= distanceScaleFactor;\n\n        if (\n            placePathLabel(\n                labelState,\n                textPath,\n                tempScreenPosition,\n                textCanvas,\n                this.m_screenCollisions\n            ) !== PlacementResult.Ok\n        ) {\n            textCanvas.textRenderStyle.fontSize.size = prevSize;\n            if (placementStats) {\n                ++placementStats.numNotVisible;\n            }\n            labelState.textRenderState!.reset();\n            return false;\n        }\n\n        labelState.textRenderState!.startFadeIn(renderParams.time);\n\n        let opacity = pathLabel.renderStyle!.opacity;\n\n        if (labelState.textRenderState!.isFading()) {\n            opacity *= labelState.textRenderState!.opacity;\n            renderParams.fadeAnimationRunning = true;\n        }\n\n        if (labelState.textRenderState!.opacity === 0) {\n            textCanvas.textRenderStyle.fontSize.size = prevSize;\n            return false;\n        }\n\n        const prevOpacity = textCanvas.textRenderStyle.opacity;\n        const prevBgOpacity = textCanvas.textRenderStyle.backgroundOpacity;\n        const distanceFadeFactor = this.getDistanceFadingFactor(\n            pathLabel,\n            labelState,\n            this.m_viewState.maxVisibilityDist\n        );\n        textCanvas.textRenderStyle.opacity = opacity * distanceFadeFactor;\n        textCanvas.textRenderStyle.backgroundOpacity =\n            textCanvas.textRenderStyle.opacity * pathLabel.renderStyle!.backgroundOpacity;\n\n        tempPosition.z = labelState.renderDistance;\n\n        addTextToCanvas(pathLabel, textCanvas, tempPosition, textPath);\n        renderParams.numRenderedTextElements++;\n\n        // Restore previous style values for text elements using the same style.\n        textCanvas.textRenderStyle.fontSize.size = prevSize;\n        textCanvas.textRenderStyle.opacity = prevOpacity;\n        textCanvas.textRenderStyle.backgroundOpacity = prevBgOpacity;\n        return true;\n    }\n\n    private checkIfOverloaded(dataSourceTileList: DataSourceTileList[]): boolean {\n        // Count the number of TextElements in the scene to see if we have to switch to\n        // \"overloadMode\".\n        let numTextElementsInScene = 0;\n\n        dataSourceTileList.forEach(renderListEntry => {\n            for (const tile of renderListEntry.renderedTiles.values()) {\n                numTextElementsInScene += tile.textElementGroups.count();\n            }\n        });\n        const newOverloaded = numTextElementsInScene > OVERLOAD_LABEL_LIMIT;\n\n        if (newOverloaded && !this.m_overloaded) {\n            logger.debug(\"Overloaded Mode enabled.\");\n        }\n        this.m_overloaded = newOverloaded;\n        return this.m_overloaded;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { IChannel } from \"./IChannel\";\n\n/**\n * Enum log levels\n */\nexport enum LogLevel {\n    Trace,\n    Debug,\n    Log,\n    Info,\n    Warn,\n    Error\n}\n\n/**\n * Logger options to configure logger\n */\nexport class LoggerOptions {\n    enabled?: boolean;\n    level?: LogLevel;\n}\n\n/**\n * Public interface for Logger class.\n */\nexport interface ILogger extends IChannel {\n    readonly name: string;\n\n    enabled: boolean;\n\n    level: LogLevel;\n\n    /**\n     * Update logger options\n     *\n     * @param  {LoggerOptions} options Set logger options and configure internal logger.\n     */\n    update(options: LoggerOptions): void;\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Resolve URI of referenced object w.r.t parent URI.\n *\n * Resolves `childUri` as it would be loaded from location specified by `parentUri`.\n *\n * If `childUri` is absolute, then it is returned unchanged.\n * If `childUri` is origin-absolute path, then only origin path is taken from `parentUri`.\n *\n * See [[baseUri]] for reference how base URL of `parentUri` is determined.\n *\n * Supports `http:`, `https:`, `file:`, `data:` schemes.\n *\n * Examples:\n *\n *     // normal case, child is sibling\n *     https://foo.com/themes/day.json + images/foo.png -> https://foo.com/themes/images/foo.png\n *\n *     // parent is \"folder\", so child is just located in this folder\n *     https://foo.com/themes/ + images/foo.png -> https://foo.com/themes/images/foo.png\n *\n *     // parent looks like leaf, so last component is stripped\n *     https://foo.com/themes + images/foo.png -> https://foo.com/images/foo.png\n *\n *     // origin-absolute URL, takes only origin from parent\n *     https://foo.com/themes/day.json + /fonts/foo.json -> https://foo.com/fonts/foo.json\n *\n * @param parentUri - URI of parent resource\n * @param childUri - URI of child as referenced from parent resource\n * @return `childUrl` as if anchored in location of `parentUrl`\n */\nexport function resolveReferenceUri(parentUri: string | undefined, childUri: string): string {\n    if (absoluteUrlWithOriginRe.test(childUri)) {\n        return childUri;\n    } else if (childUri.startsWith(\"/\")) {\n        const origin = getUrlOrigin(parentUri);\n        return origin + childUri;\n    } else {\n        if (childUri.startsWith(\"./\")) {\n            childUri = childUri.substr(2);\n        }\n        const parentBaseUrl = baseUrl(parentUri);\n        return parentBaseUrl + childUri;\n    }\n}\n\nconst absoluteUrlWithOriginRe = new RegExp(\"^(((?:[a-z]+:)?//)|(file:/)|(data:))\", \"i\");\n\n/**\n * Returns base URL of given resource URL.\n *\n * `Url` with trailing slash are considered genuine 'locations', they are returned as is, however if\n * `url` ends with name component it is treated as \"leaf\", so last path component is removed.\n *\n * Standalone files (without any folder structure) are considered relative to `./`.\n *\n * Examples:\n * ```\n *     https://foo.com/themes/a.json -> https://foo.com/themes/\n *     https://foo.com/themes/ -> https://foo.com/themes/\n *     https://foo.com/themes -> https://foo.com/ // note, themes is treated as leaf\n *     themes/day.json -> themes/\n *     themes -> ./\n * ```\n */\nexport function baseUrl(url: string | undefined) {\n    if (url === undefined) {\n        return \"./\";\n    }\n    let idx = url.indexOf(\"#\");\n    if (idx !== -1) {\n        url = url.slice(0, idx);\n    }\n    idx = url.indexOf(\"?\");\n    if (idx !== -1) {\n        url = url.slice(0, idx);\n    }\n    idx = url.lastIndexOf(\"/\");\n    if (idx === -1) {\n        return \"./\";\n    } else {\n        return url.substring(0, idx + 1);\n    }\n}\n\n/**\n * Get `origin` part of URL.\n *\n * @example\n *    https://example.com/foo -> https://example.com\n *    //example.com:8080/ -> //example.com:8080\n *    file:///etc/hosts ->\n *\n * @param url - input URL\n * @return origin of given URL\n */\nexport function getUrlOrigin(url: string | undefined): string {\n    if (url === undefined) {\n        return \"\";\n    }\n    const parsed = getUrlHostAndProtocol(url);\n    if (parsed.protocol === \"file:\") {\n        return \"file://\";\n    } else if (parsed.host && parsed.protocol) {\n        return parsed.protocol + \"//\" + parsed.host;\n    } else if (parsed.host) {\n        return \"//\" + parsed.host;\n    } else if (parsed.protocol) {\n        return parsed.protocol + \"//\";\n    } else {\n        return \"\";\n    }\n}\n\n/**\n * Parse `host` and `protocol` part from URL.\n */\nexport function getUrlHostAndProtocol(\n    url: string\n): {\n    protocol: string;\n    host: string;\n} {\n    const urlOriginRe = new RegExp(/^(?:([a-z]+:))?\\/\\/([^\\/]*)/, \"i\");\n\n    const match = url.match(urlOriginRe);\n    if (!match) {\n        throw new Error(`getUrlHostAndProtocol: unable to parse URL '${url}'`);\n    }\n    return {\n        protocol: match[1],\n        host: match[2]\n    };\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nconst RX = /^((?=\\.\\d|\\d)(?:\\d+)?(?:\\.?\\d*))px$/;\n\n/**\n * A class representing Pixels.\n *\n * @hidden\n * @internal\n */\nexport class Pixels {\n    /**\n     * Parses a pixel string literal.\n     *\n     * @param text - The string color literal\n     */\n    static parse(text: string): Pixels | undefined {\n        const match = RX.exec(text);\n        if (match === null) {\n            return undefined;\n        }\n        return new Pixels(Number(match[1]));\n    }\n\n    /**\n     * Constructs a [[Pixels]] literal\n     *\n     * @param value - The number of pixels.\n     */\n    constructor(readonly value: number) {}\n\n    toJSON() {\n        return `${this.value}px`;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    BaseTechniqueParams,\n    BasicExtrudedLineTechniqueParams,\n    ExtrudedPolygonTechniqueParams,\n    FillTechniqueParams,\n    isTextureBuffer,\n    LineTechniqueParams,\n    MarkerTechniqueParams,\n    PointTechniqueParams,\n    PolygonalTechniqueParams,\n    SegmentsTechniqueParams,\n    ShaderTechniqueParams,\n    SolidLineTechniqueParams,\n    StandardExtrudedLineTechniqueParams,\n    StandardTechniqueParams,\n    TerrainTechniqueParams,\n    TextTechniqueParams,\n    TextureCoordinateType\n} from \"./TechniqueParams\";\n\nimport { Expr, JsonExpr } from \"./Expr\";\nimport { InterpolatedPropertyDefinition } from \"./InterpolatedPropertyDefs\";\nimport {\n    AttrScope,\n    mergeTechniqueDescriptor,\n    TechniqueDescriptor,\n    TechniqueDescriptorRegistry\n} from \"./TechniqueDescriptor\";\n/**\n * Names of the supported texture properties.\n * @internal\n */\nexport const TEXTURE_PROPERTY_KEYS = [\n    \"map\",\n    \"normalMap\",\n    \"displacementMap\",\n    \"roughnessMap\",\n    \"emissiveMap\",\n    \"alphaMap\",\n    \"metalnessMap\",\n    \"bumpMap\"\n];\n\n/**\n * Names of the properties controlling transparency.\n * @internal\n */\nexport const TRANSPARENCY_PROPERTY_KEYS = [\"opacity\", \"transparent\"];\n\n// TODO: Can be removed, when all when interpolators are implemented as {@link Expr}s\nexport type RemoveInterpolatedPropDef<T> = T | InterpolatedPropertyDefinition<any> extends T\n    ? Exclude<T, InterpolatedPropertyDefinition<any>>\n    : T;\nexport type RemoveJsonExpr<T> = T | JsonExpr extends T ? Exclude<T, JsonExpr> : T;\n\n/**\n * Make runtime representation of technique attributes from JSON-compatible typings.\n *\n * Translates\n *  - InterpolatedPropertyDefinition -> InterpolatedProperty\n *  - JsonExpr -> Expr\n */\nexport type MakeTechniqueAttrs<T> = {\n    [P in keyof T]: T[P] | JsonExpr extends T[P]\n        ? RemoveInterpolatedPropDef<RemoveJsonExpr<T[P]>> | Expr\n        : T[P];\n};\n\n/** @internal  */\nexport const techniqueDescriptors: TechniqueDescriptorRegistry = {};\n\n/** @internal  */\nexport const baseTechniqueParamsDescriptor: TechniqueDescriptor<BaseTechniqueParams> = {\n    // TODO: Choose which techniques should support color with transparency.\n    // For now we chosen all, but it maybe not suitable for text or line marker techniques.\n    attrTransparencyColor: \"color\",\n    attrScopes: {\n        renderOrder: AttrScope.TechniqueGeometry,\n        enabled: AttrScope.FeatureGeometry,\n        kind: AttrScope.TechniqueGeometry,\n        transient: AttrScope.TechniqueGeometry,\n        fadeFar: AttrScope.TechniqueRendering,\n        fadeNear: AttrScope.TechniqueRendering\n    }\n};\n\n/** @internal  */\nexport const pointTechniquePropTypes = mergeTechniqueDescriptor<PointTechniqueParams>(\n    baseTechniqueParamsDescriptor,\n    {\n        attrScopes: {\n            texture: AttrScope.TechniqueGeometry,\n            enablePicking: AttrScope.TechniqueGeometry,\n            color: AttrScope.TechniqueRendering,\n            transparent: AttrScope.TechniqueRendering,\n            opacity: AttrScope.TechniqueGeometry\n        }\n    }\n);\n\n/**\n * Runtime representation of [[SquaresStyle]] as parsed by [[StyleSetEvaluator]].\n * For technique parameters see [[PointTechniqueParams]].\n */\nexport interface SquaresTechnique extends MakeTechniqueAttrs<PointTechniqueParams> {\n    name: \"squares\";\n}\n\n/** @internal  */\nexport const squaresTechniquePropTypes = mergeTechniqueDescriptor<SquaresTechnique>(\n    baseTechniqueParamsDescriptor,\n    pointTechniquePropTypes\n);\ntechniqueDescriptors.squares = squaresTechniquePropTypes;\n\n/**\n * Runtime representation of [[CirclesStyle]] as parsed by [[StyleSetEvaluator]].\n * For technique parameters see [[PointTechniqueParams]].\n */\nexport interface CirclesTechnique extends MakeTechniqueAttrs<PointTechniqueParams> {\n    name: \"circles\";\n}\n\n/** @internal  */\nexport const circlesTechniquePropTypes = mergeTechniqueDescriptor<CirclesTechnique>(\n    baseTechniqueParamsDescriptor,\n    pointTechniquePropTypes\n);\ntechniqueDescriptors.circles = circlesTechniquePropTypes;\n\n/**\n * Runtime representation of [[PoiStyle]] as parsed by [[StyleSetEvaluator]].\n * For technique parameters see [[MarkerTechniqueParams]].\n */\nexport interface PoiTechnique extends MakeTechniqueAttrs<MarkerTechniqueParams> {\n    name: \"labeled-icon\";\n}\n\n/**\n * Runtime representation of [[LineMarkerStyle]] as parsed by [[StyleSetEvaluator]].\n * For technique parameters see [[MarkerTechniqueParams]].\n */\nexport interface LineMarkerTechnique extends MakeTechniqueAttrs<MarkerTechniqueParams> {\n    name: \"line-marker\";\n}\n\nconst lineMarkerTechniquePropTypes = mergeTechniqueDescriptor<LineMarkerTechnique>(\n    baseTechniqueParamsDescriptor,\n    {\n        attrScopes: {\n            text: AttrScope.FeatureGeometry,\n            label: AttrScope.FeatureGeometry,\n            useAbbreviation: AttrScope.FeatureGeometry,\n            useIsoCode: AttrScope.FeatureGeometry,\n            priority: AttrScope.TechniqueGeometry,\n            textMinZoomLevel: AttrScope.TechniqueGeometry,\n            textMaxZoomLevel: AttrScope.TechniqueGeometry,\n            iconMinZoomLevel: AttrScope.TechniqueGeometry,\n            iconMaxZoomLevel: AttrScope.TechniqueGeometry,\n            distanceScale: AttrScope.TechniqueGeometry,\n            textMayOverlap: AttrScope.TechniqueGeometry,\n            iconMayOverlap: AttrScope.TechniqueGeometry,\n            textReserveSpace: AttrScope.TechniqueGeometry,\n            iconReserveSpace: AttrScope.TechniqueGeometry,\n            renderTextDuringMovements: AttrScope.TechniqueGeometry,\n            alwaysOnTop: AttrScope.TechniqueGeometry,\n            textIsOptional: AttrScope.TechniqueGeometry,\n            showOnMap: AttrScope.TechniqueGeometry,\n            stackMode: AttrScope.TechniqueGeometry,\n            minDistance: AttrScope.TechniqueGeometry,\n            iconIsOptional: AttrScope.TechniqueGeometry,\n            iconFadeTime: AttrScope.TechniqueGeometry,\n            textFadeTime: AttrScope.TechniqueGeometry,\n            xOffset: AttrScope.TechniqueGeometry,\n            yOffset: AttrScope.TechniqueGeometry,\n            iconXOffset: AttrScope.TechniqueGeometry,\n            iconYOffset: AttrScope.TechniqueGeometry,\n            iconScale: AttrScope.TechniqueGeometry,\n            screenHeight: AttrScope.TechniqueGeometry,\n            screenWidth: AttrScope.TechniqueGeometry,\n            poiTable: AttrScope.TechniqueGeometry,\n            poiName: AttrScope.FeatureGeometry,\n            poiNameField: AttrScope.TechniqueGeometry,\n            imageTexture: AttrScope.FeatureGeometry,\n            imageTextureField: AttrScope.TechniqueGeometry,\n            imageTexturePrefix: AttrScope.TechniqueGeometry,\n            imageTexturePostfix: AttrScope.TechniqueGeometry,\n            iconColor: AttrScope.TechniqueRendering,\n            iconBrightness: AttrScope.TechniqueRendering,\n            style: AttrScope.TechniqueGeometry,\n            fontName: AttrScope.TechniqueGeometry,\n            fontStyle: AttrScope.TechniqueGeometry,\n            fontVariant: AttrScope.TechniqueGeometry,\n            rotation: AttrScope.TechniqueGeometry,\n            tracking: AttrScope.TechniqueGeometry,\n            leading: AttrScope.TechniqueGeometry,\n            maxLines: AttrScope.TechniqueGeometry,\n            lineWidth: AttrScope.TechniqueGeometry,\n            canvasRotation: AttrScope.TechniqueGeometry,\n            lineRotation: AttrScope.TechniqueGeometry,\n            wrappingMode: AttrScope.TechniqueGeometry,\n            hAlignment: AttrScope.TechniqueGeometry,\n            vAlignment: AttrScope.TechniqueGeometry,\n            placements: AttrScope.TechniqueGeometry,\n            backgroundColor: AttrScope.TechniqueRendering,\n            backgroundSize: AttrScope.TechniqueRendering,\n            backgroundOpacity: AttrScope.TechniqueRendering,\n            color: AttrScope.TechniqueRendering,\n            opacity: AttrScope.TechniqueRendering,\n            size: AttrScope.TechniqueRendering\n        }\n    }\n);\ntechniqueDescriptors[\"line-marker\"] = lineMarkerTechniquePropTypes;\ntechniqueDescriptors[\"labeled-icon\"] = lineMarkerTechniquePropTypes;\n\n/**\n * Runtime representation of [[SegmentsStyle]] as parsed by [[StyleSetEvaluator]].\n * For technique parameters see [[SegmentsTechniqueParams]].\n */\nexport interface SegmentsTechnique extends MakeTechniqueAttrs<SegmentsTechniqueParams> {\n    name: \"segments\";\n}\n\nconst polygonalTechniqueDescriptor: TechniqueDescriptor<PolygonalTechniqueParams> = {\n    attrScopes: {\n        polygonOffset: AttrScope.TechniqueRendering,\n        polygonOffsetFactor: AttrScope.TechniqueRendering,\n        polygonOffsetUnits: AttrScope.TechniqueRendering,\n        lineColor: AttrScope.TechniqueRendering,\n        lineFadeFar: AttrScope.TechniqueRendering,\n        lineFadeNear: AttrScope.TechniqueRendering\n    }\n};\n/**\n * Runtime representation of [[BasicExtrudedLineStyle]] as parsed by [[StyleSetEvaluator]].\n * For technique parameters see [[BasicExtrudedLineTechniqueParams]].\n */\nexport interface BasicExtrudedLineTechnique\n    extends MakeTechniqueAttrs<BasicExtrudedLineTechniqueParams> {\n    name: \"extruded-line\";\n}\n\n/**\n * Runtime representation of [[StandardExtrudedLineStyle]] as parsed by [[StyleSetEvaluator]].\n * For technique parameters see [[StandardExtrudedLineTechniqueParams]].\n */\nexport interface StandardExtrudedLineTechnique\n    extends MakeTechniqueAttrs<StandardExtrudedLineTechniqueParams> {\n    name: \"extruded-line\";\n}\n\n/**\n * Runtime representation of [[SolidLineStyle]] as parsed by [[StyleSetEvaluator]].\n * For technique parameters see [[SolidLineTechniqueParams]].\n */\nexport interface SolidLineTechnique extends MakeTechniqueAttrs<SolidLineTechniqueParams> {\n    name: \"solid-line\" | \"dashed-line\";\n}\n\n/** @internal  */\nexport const solidLineTechniqueDescriptor = mergeTechniqueDescriptor<SolidLineTechnique>(\n    baseTechniqueParamsDescriptor,\n    polygonalTechniqueDescriptor,\n    {\n        attrScopes: {\n            clipping: AttrScope.TechniqueGeometry,\n            secondaryRenderOrder: AttrScope.TechniqueGeometry,\n            color: AttrScope.TechniqueRendering,\n            opacity: AttrScope.TechniqueRendering,\n            transparent: AttrScope.TechniqueRendering,\n            lineWidth: AttrScope.TechniqueRendering,\n            secondaryWidth: AttrScope.TechniqueRendering,\n            secondaryColor: AttrScope.TechniqueRendering,\n            dashSize: AttrScope.TechniqueRendering,\n            gapSize: AttrScope.TechniqueRendering\n        }\n    }\n);\ntechniqueDescriptors[\"solid-line\"] = solidLineTechniqueDescriptor;\n// TODO: Remove deprecated \"dashed-line\" support in future releases.\ntechniqueDescriptors[\"dashed-line\"] = solidLineTechniqueDescriptor;\n\n/**\n * Runtime representation of [[LineStyle]] as parsed by [[StyleSetEvaluator]].\n * For technique parameters see [[LineTechniqueParams]].\n */\nexport interface LineTechnique extends MakeTechniqueAttrs<LineTechniqueParams> {\n    name: \"line\";\n}\n\n/** @internal  */\nexport const lineTechniqueDescriptor = mergeTechniqueDescriptor<LineTechnique>(\n    baseTechniqueParamsDescriptor,\n    {\n        attrScopes: {\n            // TODO, check, which are really dynamic !\n            color: AttrScope.TechniqueRendering,\n            opacity: AttrScope.TechniqueRendering,\n            transparent: AttrScope.TechniqueRendering,\n            lineWidth: AttrScope.FeatureGeometry\n        }\n    }\n);\n\ntechniqueDescriptors.line = lineTechniqueDescriptor;\n\n/**\n * Runtime representation of [[FillStyle]] as parsed by [[StyleSetEvaluator]].\n * For technique parameters see [[FillTechniqueParams]].\n */\nexport interface FillTechnique extends MakeTechniqueAttrs<FillTechniqueParams> {\n    name: \"fill\";\n}\n\nconst fillTechniqueDescriptor = mergeTechniqueDescriptor<FillTechnique>(\n    baseTechniqueParamsDescriptor,\n    polygonalTechniqueDescriptor,\n    {\n        attrScopes: {\n            color: AttrScope.TechniqueRendering,\n            opacity: AttrScope.TechniqueRendering,\n            transparent: AttrScope.TechniqueRendering,\n            lineWidth: AttrScope.TechniqueRendering\n        }\n    }\n);\ntechniqueDescriptors.fill = fillTechniqueDescriptor;\n\n/**\n * Technique used to render a mesh geometry.\n * For technique parameters see [[StandardTechniqueParams]].\n */\nexport interface StandardTechnique extends MakeTechniqueAttrs<StandardTechniqueParams> {\n    name: \"standard\";\n}\nconst standardTechniqueDescriptor = mergeTechniqueDescriptor<StandardTechnique>(\n    baseTechniqueParamsDescriptor,\n    {\n        attrScopes: {\n            color: AttrScope.FeatureGeometry,\n            vertexColors: AttrScope.FeatureGeometry,\n            wireframe: AttrScope.TechniqueRendering,\n            roughness: AttrScope.TechniqueRendering,\n            metalness: AttrScope.TechniqueRendering,\n            alphaTest: AttrScope.TechniqueRendering,\n            depthTest: AttrScope.TechniqueRendering,\n            transparent: AttrScope.TechniqueRendering,\n            opacity: AttrScope.TechniqueRendering,\n            emissive: AttrScope.TechniqueRendering,\n            emissiveIntensity: AttrScope.TechniqueRendering,\n            refractionRatio: AttrScope.TechniqueRendering,\n            map: AttrScope.TechniqueGeometry,\n            mapProperties: AttrScope.TechniqueGeometry,\n            normalMap: AttrScope.TechniqueGeometry,\n            normalMapProperties: AttrScope.TechniqueGeometry,\n            displacementMap: AttrScope.TechniqueGeometry,\n            displacementMapProperties: AttrScope.TechniqueGeometry,\n            roughnessMap: AttrScope.TechniqueGeometry,\n            roughnessMapProperties: AttrScope.TechniqueGeometry,\n            emissiveMap: AttrScope.TechniqueGeometry,\n            emissiveMapProperties: AttrScope.TechniqueGeometry,\n            bumpMap: AttrScope.TechniqueGeometry,\n            bumpMapProperties: AttrScope.TechniqueGeometry,\n            metalnessMap: AttrScope.TechniqueGeometry,\n            metalnessMapProperties: AttrScope.TechniqueGeometry,\n            alphaMap: AttrScope.TechniqueGeometry,\n            alphaMapProperties: AttrScope.TechniqueGeometry\n        }\n    }\n);\ntechniqueDescriptors.standard = standardTechniqueDescriptor;\n\n/**\n * Runtime representation of [[ExtrudedPolygonStyle]] as parsed by [[StyleSetEvaluator]].\n * For technique parameters see [[ExtrudedPolygonTechniqueParams]].\n */\nexport interface ExtrudedPolygonTechnique\n    extends MakeTechniqueAttrs<ExtrudedPolygonTechniqueParams> {\n    name: \"extruded-polygon\";\n}\n\nconst extrudedPolygonTechniqueDescriptor = mergeTechniqueDescriptor<ExtrudedPolygonTechnique>(\n    baseTechniqueParamsDescriptor,\n    standardTechniqueDescriptor,\n    {\n        attrScopes: {\n            height: AttrScope.FeatureGeometry,\n            floorHeight: AttrScope.FeatureGeometry,\n            color: AttrScope.FeatureGeometry,\n            defaultColor: AttrScope.FeatureGeometry,\n            defaultHeight: AttrScope.FeatureGeometry,\n            constantHeight: AttrScope.FeatureGeometry,\n            boundaryWalls: AttrScope.FeatureGeometry,\n            footprint: AttrScope.FeatureGeometry,\n            maxSlope: AttrScope.FeatureGeometry,\n            enableDepthPrePass: AttrScope.TechniqueGeometry,\n            animateExtrusionDuration: AttrScope.TechniqueGeometry,\n            animateExtrusion: AttrScope.TechniqueRendering,\n            opacity: AttrScope.TechniqueRendering,\n            transparent: AttrScope.TechniqueRendering,\n            lineWidth: AttrScope.TechniqueRendering,\n            lineFadeNear: AttrScope.TechniqueRendering,\n            lineFadeFar: AttrScope.TechniqueRendering,\n            lineColorMix: AttrScope.TechniqueGeometry,\n            lineColor: AttrScope.TechniqueRendering\n        }\n    }\n);\ntechniqueDescriptors[\"extruded-polygon\"] = extrudedPolygonTechniqueDescriptor;\n/**\n * Runtime representation of [[TextStyle]] as parsed by [[StyleSetEvaluator]].\n * For technique parameters see [[TextTechniqueParams]].\n */\nexport interface TextTechnique extends MakeTechniqueAttrs<TextTechniqueParams> {\n    name: \"text\";\n}\n\nconst textTechniqueDescriptor = mergeTechniqueDescriptor<TextTechnique>(\n    baseTechniqueParamsDescriptor,\n    {\n        attrScopes: {\n            text: AttrScope.FeatureGeometry,\n            label: AttrScope.FeatureGeometry,\n            useAbbreviation: AttrScope.FeatureGeometry,\n            useIsoCode: AttrScope.FeatureGeometry,\n\n            minZoomLevel: AttrScope.TechniqueGeometry,\n            maxZoomLevel: AttrScope.TechniqueGeometry,\n            distanceScale: AttrScope.TechniqueGeometry,\n            mayOverlap: AttrScope.TechniqueGeometry,\n            reserveSpace: AttrScope.TechniqueGeometry,\n            textFadeTime: AttrScope.TechniqueGeometry,\n            xOffset: AttrScope.TechniqueGeometry,\n            yOffset: AttrScope.TechniqueGeometry,\n            style: AttrScope.TechniqueGeometry,\n            fontName: AttrScope.TechniqueGeometry,\n            fontStyle: AttrScope.TechniqueGeometry,\n            fontVariant: AttrScope.TechniqueGeometry,\n            rotation: AttrScope.TechniqueGeometry,\n            tracking: AttrScope.TechniqueGeometry,\n            leading: AttrScope.TechniqueGeometry,\n            maxLines: AttrScope.TechniqueGeometry,\n            lineWidth: AttrScope.TechniqueGeometry,\n            canvasRotation: AttrScope.TechniqueGeometry,\n            lineRotation: AttrScope.TechniqueGeometry,\n            wrappingMode: AttrScope.TechniqueGeometry,\n            hAlignment: AttrScope.TechniqueGeometry,\n            vAlignment: AttrScope.TechniqueGeometry,\n            backgroundColor: AttrScope.TechniqueRendering,\n            backgroundSize: AttrScope.TechniqueRendering,\n            backgroundOpacity: AttrScope.TechniqueRendering,\n            color: AttrScope.TechniqueRendering,\n            opacity: AttrScope.TechniqueRendering,\n            priority: AttrScope.TechniqueRendering,\n            size: AttrScope.TechniqueRendering\n        }\n    }\n);\ntechniqueDescriptors.text = textTechniqueDescriptor;\n\n/**\n * Special technique for user-defined shaders.\n * For technique parameters see [[ShaderTechniqueParams]].\n */\nexport interface ShaderTechnique extends MakeTechniqueAttrs<ShaderTechniqueParams> {\n    name: \"shader\";\n}\n\nconst shaderTechniqueDescriptor = mergeTechniqueDescriptor<ShaderTechnique>(\n    baseTechniqueParamsDescriptor,\n    {\n        attrScopes: {\n            primitive: AttrScope.TechniqueGeometry,\n            params: AttrScope.TechniqueRendering\n        }\n    }\n);\n\ntechniqueDescriptors.shader = shaderTechniqueDescriptor;\n\n/**\n * Technique used to render a terrain geometry with textures.\n * For technique parameters see [[TerrainTechniqueParams]].\n */\nexport interface TerrainTechnique extends MakeTechniqueAttrs<TerrainTechniqueParams> {\n    name: \"terrain\";\n}\n\n/**\n * Technique to avoid label rendering on top of certain line geometries.\n * For technique parameters see [[BaseTechniqueParams]].\n */\nexport interface LabelRejectionLineTechnique extends MakeTechniqueAttrs<BaseTechniqueParams> {\n    name: \"label-rejection-line\";\n}\n\n/**\n * Possible techniques that can be used to draw a geometry on the map.\n */\nexport type Technique =\n    | SquaresTechnique\n    | CirclesTechnique\n    | PoiTechnique\n    | LineMarkerTechnique\n    | LineTechnique\n    | SegmentsTechnique\n    | SolidLineTechnique\n    | FillTechnique\n    | StandardTechnique\n    | TerrainTechnique\n    | BasicExtrudedLineTechnique\n    | StandardExtrudedLineTechnique\n    | ExtrudedPolygonTechnique\n    | ShaderTechnique\n    | TextTechnique\n    | LabelRejectionLineTechnique;\n\n/**\n * Additional params used for optimized usage of `Techniques`.\n */\nexport interface IndexedTechniqueParams {\n    /**\n     * Optimization: Index into table in [[StyleSetEvaluator]] or in [[DecodedTile]].\n     * @hidden\n     */\n    _index: number;\n\n    /**\n     * Optimization: Unique [[Technique]] index of [[Style]] from which technique was derived.\n     * @hidden\n     */\n    _styleSetIndex: number;\n\n    /**\n     * The styleSet associated to this [[Technique]].\n     * @hidden\n     */\n    _styleSet?: string;\n\n    /**\n     * The category used to assign render orders to objects created using this [[Technique]].\n     * @hidden\n     */\n    _category?: string;\n\n    /**\n     * The category used to assign render orders to secondary objects\n     * created using this [[Technique]].\n     * @hidden\n     */\n    _secondaryCategory?: string;\n\n    /**\n     * `true` if any of the properties of this technique needs to access\n     * the feature's state.\n     *\n     * @hidden\n     */\n    _usesFeatureState?: boolean;\n\n    /**\n     * Last computed state derived from [[Technique.kind]].\n     */\n    _kindState?: boolean;\n}\n\n/**\n * For efficiency, [[StyleSetEvaluator]] returns [[Techniques]] additional params as defined in\n * [[IndexedTechniqueParams]].\n */\nexport type IndexedTechnique = Technique & IndexedTechniqueParams;\n\n/**\n * Type guard to check if an object is an instance of [[CirclesTechnique]].\n */\nexport function isCirclesTechnique(technique: Technique): technique is CirclesTechnique {\n    return technique.name === \"circles\";\n}\n\n/**\n * Type guard to check if an object is an instance of [[SquaresTechnique]].\n */\nexport function isSquaresTechnique(technique: Technique): technique is SquaresTechnique {\n    return technique.name === \"squares\";\n}\n\n/**\n * Type guard to check if an object is an instance of [[PoiTechnique]].\n */\nexport function isPoiTechnique(technique: Technique): technique is PoiTechnique {\n    return technique.name === \"labeled-icon\";\n}\n\n/**\n * Type guard to check if an object is an instance of [[LineMarkerTechnique]].\n */\nexport function isLineMarkerTechnique(technique: Technique): technique is LineMarkerTechnique {\n    return technique.name === \"line-marker\";\n}\n\n/**\n * Type guard to check if an object is an instance of [[LineTechnique]].\n */\nexport function isLineTechnique(technique: Technique): technique is LineTechnique {\n    return technique.name === \"line\";\n}\n\n/**\n * Type guard to check if an object is an instance of [[SolidLineTechnique]].\n */\nexport function isSolidLineTechnique(technique: Technique): technique is SolidLineTechnique {\n    return technique.name === \"solid-line\" || technique.name === \"dashed-line\";\n}\n\n/**\n * Type guard to check if an object is an instance of [[SolidLineTechnique]] and is a kind that\n * has special dashes.\n * @note Lines with special dashes need line caps to render properly.\n */\nexport function isSpecialDashesLineTechnique(\n    technique: Technique\n): technique is SolidLineTechnique {\n    return (\n        (technique.name === \"solid-line\" || technique.name === \"dashed-line\") &&\n        technique.dashes !== undefined &&\n        technique.dashes !== \"Square\"\n    );\n}\n\n/**\n * Type guard to check if an object is an instance of [[SegmentsTechnique]].\n */\nexport function isSegmentsTechnique(technique: Technique): technique is SegmentsTechnique {\n    return technique.name === \"segments\";\n}\n\n/**\n * Type guard to check if an object is an instance of [[BasicExtrudedLineTechnique]]\n * or [[StandardExtrudedLineTechnique]].\n */\nexport function isExtrudedLineTechnique(\n    technique: Technique\n): technique is BasicExtrudedLineTechnique | StandardExtrudedLineTechnique {\n    return technique.name === \"extruded-line\";\n}\n\n/**\n * Type guard to check if an object is an instance of [[BasicExtrudedLineTechnique]].\n */\nexport function isBasicExtrudedLineTechnique(\n    technique: Technique\n): technique is BasicExtrudedLineTechnique {\n    return isExtrudedLineTechnique(technique) && technique.shading === \"basic\";\n}\n\n/**\n * Type guard to check if an object is an instance of [[StandardExtrudedLineTechnique]].\n */\nexport function isStandardExtrudedLineTechnique(\n    technique: Technique\n): technique is StandardExtrudedLineTechnique {\n    return isExtrudedLineTechnique(technique) && technique.shading === \"standard\";\n}\n\n/**\n * Type guard to check if an object is an instance of [[FillTechnique]].\n */\nexport function isFillTechnique(technique: Technique): technique is FillTechnique {\n    return technique.name === \"fill\";\n}\n\n/**\n * Type guard to check if an object is an instance of [[ExtrudedPolygonTechnique]].\n */\nexport function isExtrudedPolygonTechnique(\n    technique: Technique\n): technique is ExtrudedPolygonTechnique {\n    return technique.name === \"extruded-polygon\";\n}\n\n/**\n * Type guard to check if an object is an instance of [[StandardTechnique]].\n */\nexport function isStandardTechnique(technique: Technique): technique is StandardTechnique {\n    return technique.name === \"standard\";\n}\n\n/**\n * Type guard to check if an object is an instance of [[TerrainTechnique]].\n */\nexport function isTerrainTechnique(technique: Technique): technique is TerrainTechnique {\n    return technique.name === \"terrain\";\n}\n\n/**\n * Type guard to check if an object is an instance of [[TextTechnique]].\n */\nexport function isTextTechnique(technique: Technique): technique is TextTechnique {\n    return technique.name === \"text\";\n}\n\n/**\n * Type guard to check if an object is an instance of [[ShaderTechnique]].\n */\nexport function isShaderTechnique(technique: Technique): technique is ShaderTechnique {\n    return technique.name === \"shader\";\n}\n\nexport function isLabelRejectionLineTechnique(\n    technique: Technique\n): technique is LabelRejectionLineTechnique {\n    return technique.name === \"label-rejection-line\";\n}\n\n/**\n * Check if vertex normals should be generated for this technique (if no normals are in the data).\n * @param technique - Technique to check.\n */\nexport function needsVertexNormals(technique: Technique): boolean {\n    return (\n        isFillTechnique(technique) ||\n        isStandardTechnique(technique) ||\n        isTerrainTechnique(technique) ||\n        isStandardExtrudedLineTechnique(technique)\n    );\n}\n\n/**\n * Get the texture coordinate type if the technique supports it.\n */\nexport function textureCoordinateType(technique: Technique): TextureCoordinateType | undefined {\n    if (isStandardTechnique(technique)) {\n        return technique.textureCoordinateType;\n    } else if (isExtrudedPolygonTechnique(technique)) {\n        return technique.textureCoordinateType;\n    } else if (isTerrainTechnique(technique)) {\n        return technique.textureCoordinateType;\n    } else if (isShaderTechnique(technique)) {\n        return technique.textureCoordinateType;\n    } else {\n        return undefined;\n    }\n}\n\n/**\n * Add all the buffers of the technique to the transfer list.\n */\nexport function addBuffersToTransferList(technique: Technique, transferList: ArrayBuffer[]) {\n    if (\n        isStandardTechnique(technique) ||\n        isExtrudedPolygonTechnique(technique) ||\n        isTerrainTechnique(technique)\n    ) {\n        for (const texturePropertyKey of TEXTURE_PROPERTY_KEYS) {\n            const textureProperty = (technique as any)[texturePropertyKey];\n            if (isTextureBuffer(textureProperty)) {\n                if (textureProperty.buffer instanceof ArrayBuffer) {\n                    transferList.push(textureProperty.buffer);\n                }\n            }\n        }\n    }\n}\n\n/**\n * Compose full texture name for given image name with technique specified.\n * Some techniques allows to add prefix/postfix to icons names specified, this\n * function uses technique information to create fully qualified texture name.\n * @param imageName - base name of the marker icon.\n * @param technique - the technique describing POI or line marker.\n * @returns fully qualified texture name for loading from atlas (without extension).\n */\nexport function composeTechniqueTextureName(\n    imageName: string,\n    technique: PoiTechnique | LineMarkerTechnique\n): string {\n    let textureName = imageName;\n    if (typeof technique.imageTexturePrefix === \"string\") {\n        textureName = technique.imageTexturePrefix + textureName;\n    }\n    if (typeof technique.imageTexturePostfix === \"string\") {\n        textureName = textureName + technique.imageTexturePostfix;\n    }\n    return textureName;\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ViewRanges } from \"@here/harp-datasource-protocol/lib/ViewRanges\";\nimport { applyMixinsWithoutProperties, assert, chainCallbacks } from \"@here/harp-utils\";\nimport { disableBlending, enableBlending, insertShaderInclude, setShaderDefine } from \"./Utils\";\n\nimport * as THREE from \"three\";\n\nimport { DisplacementFeature, DisplacementFeatureParameters } from \"./DisplacementFeature\";\nimport { ExtrusionFeatureDefs } from \"./MapMeshMaterialsDefs\";\nimport extrusionShaderChunk from \"./ShaderChunks/ExtrusionChunks\";\nimport fadingShaderChunk from \"./ShaderChunks/FadingChunks\";\nimport { simpleLightingShadowChunk } from \"./ShaderChunks/ShadowChunks\";\n\nconst emptyTexture = new THREE.Texture();\n\n/**\n * The MapMeshMaterials [[MapMeshBasicMaterial]] and [[MapMeshStandardMaterial]] are the standard\n * [[THREE.MeshBasicMaterial]] and [[THREE.MeshStandardMaterial]], with the addition functionality\n * of fading out the geometry between a fadeNear and fadeFar value.\n *\n * The implementation is designed around a mixin class {@link FadingFeatureMixin}, which requires\n * a bit of care when adding the FadingFeature to the existing mesh classes, but it is safe to use\n * and also reduces code duplication.\n */\n\n/**\n * Parameters used when constructing a new implementor of {@link FadingFeature}.\n */\nexport interface FadingFeatureParameters {\n    /**\n     * Distance to the camera (range: `[0.0, 1.0]`) from which the objects start fading out.\n     */\n    fadeNear?: number;\n\n    /**\n     * Distance to the camera (range: `[0.0, 1.0]`) from which the objects are transparent.\n     */\n    fadeFar?: number;\n}\n\n/**\n * Parameter used to control patching the standard material shader to ensure that the materials\n * color isn't affected by the light direction, only valid for techniques that are \"fill\"\n */\nexport interface ShadowFeatureParameters {\n    /**\n     * Whether the diffuse light component is removed (i.e. the materials color is therefore just\n     * the ambient + shadow).\n     */\n    removeDiffuseLight?: boolean;\n}\n\n/**\n * Parameters used when constructing a new implementor of {@link ExtrusionFeature}.\n */\nexport interface ExtrusionFeatureParameters {\n    /**\n     * Ratio of the extruded objects, where `1.0` is the default value\n     */\n    extrusionRatio?: number;\n\n    /**\n     * Enable z-fighting workaround that doesn't animate buildings with `height <\n     * [[ExtrusionFeatureDefs.MIN_BUILDING_HEIGHT]]`.\n     *\n     * Should be applied to `polygon` materials using this feature.\n     */\n    zFightingWorkaround?: boolean;\n}\n\n/**\n * Used internally.\n *\n * @hidden\n */\nexport interface UniformsType {\n    [index: string]: THREE.IUniform;\n}\n\n/**\n * Type of callback used internally by THREE.js for shader creation.\n *\n * @hidden\n */\ntype CompileCallback = (shader: THREE.Shader, renderer: any) => void;\n\n/**\n * Material properties used from THREE, which may not be defined in the type.\n */\nexport interface HiddenThreeJSMaterialProperties {\n    /**\n     * Informs THREE.js to re-compile material shader (due to change in code or defines).\n     */\n    needsUpdate?: boolean;\n\n    /**\n     * Hidden ThreeJS value that is made public here. Required to add new uniforms to subclasses of\n     * [[THREE.MeshBasicMaterial]]/[[THREE.MeshStandardMaterial]], basically all materials that are\n     * not THREE.ShaderMaterial.\n     * @deprecated Changes to this property are ignored.\n     */\n    uniformsNeedUpdate?: boolean;\n\n    /**\n     * Available in all materials in ThreeJS.\n     */\n    transparent?: boolean;\n\n    /**\n     * Used internally for material shader defines.\n     */\n    defines?: any;\n\n    /**\n     * Defines callback available in THREE.js materials.\n     *\n     * Called before shader program compilation to generate vertex & fragment shader output code.\n     */\n    onBeforeCompile?: CompileCallback;\n}\n\n/**\n * Used internally.\n *\n * @hidden\n */\nexport interface MixinShaderProperties {\n    /**\n     * Used internally for material shader defines.\n     */\n    shaderDefines?: any;\n\n    /**\n     * Used internally for shader uniforms, holds references to material internal shader.uniforms.\n     *\n     * Holds a reference to material's internal shader uniforms map. New custom feature based\n     * uniforms are injected using this reference, but also internal THREE.js shader uniforms\n     * will be available via this map after [[Material#onBeforeCompile]] callback is run with\n     * feature enabled.\n     * @see needsUpdate\n     */\n    shaderUniforms?: UniformsType;\n}\n\n/**\n * Translates a linear distance value [0..1], where 1 is the distance to the far plane, into\n * [0..maxVisibilityRange].\n *\n * Copy from MapViewUtils, since it cannot be accessed here because of circular dependencies.\n *\n * @param distance - Distance from the camera (range: [0, 1]).\n * @param visibilityRange - object describing maximum and minimum visibility range - distances\n * from camera at which objects won't be rendered anymore.\n */\nfunction cameraToWorldDistance(distance: number, visibilityRange: ViewRanges): number {\n    return distance * visibilityRange.maximum;\n}\n\n/**\n * Provides common interface from mixin to internal material defines and shader uniforms.\n *\n * Call this function just after [THREE.Material] is constructed, so in derived classes after\n * super c-tor call.\n * @param mixin - The mixin that will add features to [[THREE.Material]].\n * @param material - The material that mixin feature is being applied.\n */\nfunction linkMixinWithMaterial(\n    mixin: MixinShaderProperties,\n    material: HiddenThreeJSMaterialProperties\n) {\n    // Some materials (MeshBasicMaterial) have no defines property created in c-tor.\n    // In such case create it manually, such defines will be also injected to the shader\n    // via generic THREE.js code - see THREE/WebGLProgram.js.\n    if (material.defines === undefined) {\n        material.defines = {};\n    }\n    // Link internal THREE.js material defines with mixin reference.\n    // Those defines are usually created in Material c-tor, if not we have fallback above.\n    mixin.shaderDefines = material.defines;\n\n    // Prepare map for holding uniforms references from the actual shader, but check if\n    // it was not already created with other mixin feature.\n    if (mixin.shaderUniforms === undefined) {\n        mixin.shaderUniforms = {};\n    }\n    // Shader uniforms may not be linked at this stage, they are injected available via Shader\n    // object in onBeforeCompile callback, see: linkMixinWithShader().\n}\n\n/**\n * Links mixin [[MixinShaderProperties.shaderUniforms]] with actual material shader uniforms.\n *\n * Function injects features (mixin) specific shader uniforms to material's shader, it also\n * updates uniforms references so [[MixinShaderProperties.shaderUniforms]] will contain full\n * uniforms map (both feature specific and internal ones).\n * This function should be called before material's shader is pre-compiled, so the new uniforms\n * from the mixin feature are known to shader processor. The best place to use is\n * [[Material.onBeforeCompile]].\n * @param mixin - The mixin feature being applied to the material.\n * @param shader - The actual shader linked to the [[THREE.Material]].\n */\nfunction linkMixinWithShader(mixin: MixinShaderProperties, shader: THREE.Shader) {\n    Object.assign(shader.uniforms, mixin.shaderUniforms);\n    mixin.shaderUniforms = shader.uniforms;\n}\n\n/**\n * Base interface for all objects that should fade in the distance. The implementation of the actual\n * FadingFeature is done with the help of the mixin class {@link FadingFeatureMixin} and a set of\n * supporting functions in the namespace of the same name.\n */\nexport interface FadingFeature extends HiddenThreeJSMaterialProperties, MixinShaderProperties {\n    /**\n     * Distance to the camera (range: `[0.0, 1.0]`) from which the objects start fading out.\n     */\n    fadeNear?: number;\n\n    /**\n     * Distance to the camera (range: `[0.0, 1.0]`) from which the objects are transparent. A value\n     * of <= 0.0 disables fading.\n     */\n    fadeFar?: number;\n}\n\n/**\n * Base interface for all objects that should have animated extrusion effect.\n *\n * @remarks\n * The implementation of the actual ExtrusionFeature is done with\n * the help of the mixin class {@link ExtrusionFeatureMixin}\n * and a set of supporting functions in the namespace of the same name.\n */\nexport interface ExtrusionFeature extends HiddenThreeJSMaterialProperties, MixinShaderProperties {\n    /**\n     * Ratio of the extruded objects, where `1.0` is the default value. Minimum suggested value\n     * is `0.01`\n     */\n    extrusionRatio?: number;\n}\n\n/**\n * Determines whether a given material supports extrusion.\n * @param material The material to check.\n * @returns Whether the given material supports extrusion.\n */\nexport function hasExtrusionFeature(material: any): material is ExtrusionFeature {\n    return \"extrusionRatio\" in material;\n}\n\nnamespace DisplacementFeature {\n    /**\n     * Checks if feature is enabled (displacement map defined).\n     *\n     * @param displacementMaterial -\n     */\n    export function isEnabled(displacementMaterial: DisplacementFeature) {\n        return displacementMaterial.displacementMap !== null;\n    }\n\n    /**\n     * Update the internals of the `DisplacementFeature` depending on the value of\n     * [[displacementMap]].\n     *\n     * @param displacementMaterial - DisplacementFeature\n     */\n    export function updateDisplacementFeature(\n        displacementMaterial: DisplacementFeature & MixinShaderProperties\n    ): void {\n        assert(displacementMaterial.shaderDefines !== undefined);\n        assert(displacementMaterial.shaderUniforms !== undefined);\n\n        const useDisplacementMap = isEnabled(displacementMaterial);\n        // Whenever displacement feature state changes (between enabled/disabled) material will be\n        // re-compiled, forcing new shader chunks to be added (or removed).\n        const needsUpdate = setShaderDefine(\n            displacementMaterial.shaderDefines,\n            \"USE_DISPLACEMENTMAP\",\n            useDisplacementMap\n        );\n        displacementMaterial.needsUpdate = needsUpdate;\n\n        // Update texture after change.\n        if (useDisplacementMap) {\n            const texture = displacementMaterial.displacementMap!;\n            texture.needsUpdate = true;\n            displacementMaterial.shaderUniforms!.displacementMap.value = texture;\n        } else if (needsUpdate) {\n            displacementMaterial.shaderUniforms!.displacementMap.value = emptyTexture;\n        }\n    }\n\n    /**\n     * This function should be called on implementors of DisplacementFeature in the\n     * `onBeforeCompile` callback of that material. It adds the required code to the shaders to\n     * apply displacement maps.\n     *\n     * @param displacementMaterial - Material to add uniforms to.\n     * @param shader - [[THREE.WebGLShader]] containing the vertex and fragment shaders to add the\n     *                  special includes to.\n     */\n    export function onBeforeCompile(\n        displacementMaterial: DisplacementFeature & MixinShaderProperties,\n        shader: THREE.Shader\n    ) {\n        if (!isEnabled(displacementMaterial)) {\n            return;\n        }\n        assert(displacementMaterial.shaderUniforms !== undefined);\n\n        // The vertex and fragment shaders have been constructed dynamically. The uniforms and\n        // the shader includes are now appended to them.\n        //\n        // The object \"defines\" are required for this material, we use one define working as a flag,\n        // which enables/disables some chunks of shader code.\n        linkMixinWithShader(displacementMaterial, shader);\n\n        // Append the displacement map chunk to the vertex shader.\n        shader.vertexShader = shader.vertexShader.replace(\n            \"#include <skinbase_vertex>\",\n            `#include <skinbase_vertex>\n#ifndef USE_ENVMAP\n    vec3 objectNormal = vec3( normal );\n#endif`\n        );\n        shader.vertexShader = insertShaderInclude(\n            shader.vertexShader,\n            \"uv2_pars_vertex\",\n            \"displacementmap_pars_vertex\"\n        );\n\n        shader.vertexShader = insertShaderInclude(\n            shader.vertexShader,\n            \"skinning_vertex\",\n            \"displacementmap_vertex\",\n            true\n        );\n    }\n}\n\nexport class DisplacementFeatureMixin implements DisplacementFeature, MixinShaderProperties {\n    needsUpdate?: boolean;\n    uniformsNeedUpdate?: boolean;\n    defines?: any;\n    shaderDefines?: any;\n    shaderUniforms?: UniformsType;\n    onBeforeCompile?: CompileCallback;\n    private m_displacementMap: THREE.Texture | null = null;\n\n    // This is here to keep tslint from reporting a missing property, the getter that's actually\n    // used by materials is added in [[addDisplacementProperties]].\n    get displacementMap(): THREE.Texture | null {\n        return this.m_displacementMap;\n    }\n\n    // This is here to keep tslint from reporting a missing property, the setter that's actually\n    // used by materials is added in [[addDisplacementProperties]].\n    set displacementMap(map: THREE.Texture | null) {\n        this.setDisplacementMap(map);\n    }\n\n    protected getDisplacementMap(): THREE.Texture | null {\n        return this.m_displacementMap;\n    }\n\n    protected setDisplacementMap(map: THREE.Texture | null): void {\n        if (map !== this.m_displacementMap) {\n            this.m_displacementMap = map;\n            DisplacementFeature.updateDisplacementFeature(this);\n        }\n    }\n    /**\n     * The mixin class should call this method to register the property [[displacementMap]]\n     */\n    protected addDisplacementProperties(): void {\n        Object.defineProperty(this, \"displacementMap\", {\n            get: () => {\n                return this.getDisplacementMap();\n            },\n            set: val => {\n                this.setDisplacementMap(val);\n            }\n        });\n    }\n\n    /**\n     * Apply the displacementMap value from the parameters to the respective properties.\n     */\n    protected applyDisplacementParameters(params?: DisplacementFeatureParameters) {\n        linkMixinWithMaterial(this, this);\n\n        assert(this.shaderDefines !== undefined);\n        assert(this.shaderUniforms !== undefined);\n\n        // Create uniforms with default values, this ensures they are always set created,\n        // so no need for checks in setters.\n        const uniforms = this.shaderUniforms!;\n        uniforms.displacementMap = new THREE.Uniform(emptyTexture);\n        uniforms.displacementScale = new THREE.Uniform(1);\n        uniforms.displacementBias = new THREE.Uniform(0);\n\n        // Apply initial parameter values.\n        if (params !== undefined) {\n            if (params.displacementMap !== undefined) {\n                this.setDisplacementMap(params.displacementMap);\n            }\n        }\n\n        this.onBeforeCompile = chainCallbacks(this.onBeforeCompile, (shader: THREE.Shader) => {\n            DisplacementFeature.onBeforeCompile(this, shader);\n        });\n\n        // Require material update at least once, because of new shader chunks added.\n        this.needsUpdate = DisplacementFeature.isEnabled(this);\n    }\n\n    /**\n     * Copy displacementMap from other DisplacementFeature.\n     *\n     * @param source - The material to copy property values from.\n     */\n    protected copyDisplacementParameters(source: DisplacementFeature) {\n        this.setDisplacementMap(source.displacementMap);\n        return this;\n    }\n}\n\n/**\n * Namespace with support functions for implementors of `FadingFeature`.\n */\nexport namespace FadingFeature {\n    export const DEFAULT_FADE_NEAR: number = -1.0;\n    export const DEFAULT_FADE_FAR: number = -1.0;\n\n    /**\n     * Checks if feature is enabled based on feature params.\n     *\n     * Fading feature will be disabled if fadeFar is undefined or fadeFar <= 0.0.\n     * This function is crucial for shader switching (chunks injection), whenever feature state\n     * changes between enabled/disabled. Current approach is to keep feature on (once enabled)\n     * whenever fading params are reasonable, even if it causes full fade in, no transparency.\n     *\n     * @param fadingMaterial - FadingFeature.\n     */\n    export function isEnabled(fadingMaterial: FadingFeature) {\n        // NOTE: We could also check if full fade is not achieved, then feature could be\n        // disabled, but causing material re-compile.\n        return (\n            fadingMaterial.fadeNear !== undefined &&\n            fadingMaterial.fadeFar !== undefined &&\n            fadingMaterial.fadeFar > 0\n        );\n    }\n\n    /**\n     * Checks if feature is defined based on feature params.\n     *\n     * Fading feature will be defined if fadeNear and fadeFar are defined, their values\n     * are not checked for reasonable values.\n     *\n     * @param fadingMaterial FadingFeature.\n     */\n    export function isDefined(fadingMaterial: FadingFeature) {\n        return fadingMaterial.fadeNear !== undefined && fadingMaterial.fadeFar !== undefined;\n    }\n\n    /**\n     * Patch the THREE.ShaderChunk on first call with some extra shader chunks.\n     */\n    export function patchGlobalShaderChunks() {\n        if (THREE.ShaderChunk.fading_pars_vertex === undefined) {\n            Object.assign(THREE.ShaderChunk, fadingShaderChunk);\n        }\n    }\n\n    /**\n     * Update the internals of the `FadingFeature` depending on the value of [[fadeNear]]. The\n     * fading feature will be disabled if fadeFar <= 0.0.\n     *\n     * @param fadingMaterial - FadingFeature\n     */\n    export function updateFadingFeature(fadingMaterial: FadingFeature): void {\n        assert(fadingMaterial.shaderDefines !== undefined);\n        assert(fadingMaterial.shaderUniforms !== undefined);\n\n        // Update entire material to add/remove shader fading chunks, this happens when we\n        // enable/disable fading after material creation. Feature is marked via dummy define, which\n        // informs about fading feature state, even if such define is not required to control\n        // feature state, it makes it easy to check for shader changes.\n        const useFading = isEnabled(fadingMaterial);\n        const needsUpdate = setShaderDefine(\n            fadingMaterial.shaderDefines,\n            \"FADING_MATERIAL\",\n            useFading\n        );\n        // Enable/disable entire feature with material re-compile, this will also cause\n        // new uniforms injection.\n        fadingMaterial.needsUpdate = needsUpdate;\n\n        // Check if shader uniforms references are already set in onBeforeCompile callback.\n        assert(\n            fadingMaterial.shaderUniforms!.fadeNear !== undefined &&\n                fadingMaterial.shaderUniforms!.fadeFar !== undefined\n        );\n\n        // Update shader internal uniforms only if fading is enabled.\n        if (useFading) {\n            fadingMaterial.shaderUniforms!.fadeNear.value = fadingMaterial.fadeNear;\n            fadingMaterial.shaderUniforms!.fadeFar.value = fadingMaterial.fadeFar;\n            if (needsUpdate) {\n                enableBlending(fadingMaterial as THREE.Material);\n            }\n        }\n        // Perform one time update of uniforms to defaults when feature disabled (for clarity).\n        else if (needsUpdate) {\n            fadingMaterial.shaderUniforms!.fadeNear.value = FadingFeature.DEFAULT_FADE_NEAR;\n            fadingMaterial.shaderUniforms!.fadeFar.value = FadingFeature.DEFAULT_FADE_FAR;\n            disableBlending(fadingMaterial as THREE.Material);\n        }\n    }\n\n    /**\n     * This function should be called on implementors of FadingFeature in the `onBeforeCompile`\n     * callback of that material. It adds the required code to the shaders and declares the new\n     * uniforms that control fading based on view distance.\n     *\n     * @param fadingMaterial - Material to add uniforms to.\n     * @param shader - [[THREE.WebGLShader]] containing the vertex and fragment shaders to add the\n     *                  special includes to.\n     */\n    export function onBeforeCompile(fadingMaterial: FadingFeature, shader: THREE.Shader) {\n        if (!isEnabled(fadingMaterial)) {\n            return;\n        }\n        assert(fadingMaterial.shaderUniforms !== undefined);\n\n        // The vertex and fragment shaders have been constructed dynamically. The uniforms and\n        // the shader includes are now appended to them.\n        //\n        // The object \"defines\" are not required for this material, so the fading shader chunks\n        // have no #ifdef preprocessed chunks. Feature utilized one define just to denote feature\n        // attached and easy control its state, but this define may be stripped out if needed.\n        linkMixinWithShader(fadingMaterial, shader);\n\n        // Append the new fading shader cod directly after the fog code. This is done by adding an\n        // include directive for the fading code.\n        shader.vertexShader = insertShaderInclude(\n            shader.vertexShader,\n            \"fog_pars_vertex\",\n            \"fading_pars_vertex\"\n        );\n\n        shader.vertexShader = insertShaderInclude(\n            shader.vertexShader,\n            \"fog_vertex\",\n            \"fading_vertex\",\n            true\n        );\n\n        shader.fragmentShader = insertShaderInclude(\n            shader.fragmentShader,\n            \"fog_pars_fragment\",\n            \"fading_pars_fragment\"\n        );\n\n        shader.fragmentShader = insertShaderInclude(\n            shader.fragmentShader,\n            \"fog_fragment\",\n            \"fading_fragment\",\n            true\n        );\n    }\n\n    /**\n     * As three.js is rendering the transparent objects last (internally), regardless of their\n     * renderOrder value, we set the transparent value to false in the [[onAfterRenderCall]]. In\n     * [[onBeforeRender]], the function [[calculateDepthFromCameraDistance]] sets it to true if the\n     * fade distance value is less than 1.\n     *\n     * @param object - [[THREE.Object3D]] to prepare for rendering.\n     * @param viewRanges - The visibility ranges (clip planes and maximum visible distance) for\n     * actual camera setup.\n     * @param fadeNear - The fadeNear value to set in the material.\n     * @param fadeFar - The fadeFar value to set in the material.\n     * @param updateUniforms - If `true`, the fading uniforms are set. Not required if material is\n     *          handling the uniforms already, like in a [[THREE.ShaderMaterial]].\n     * @param additionalCallback - If defined, this function will be called before the function will\n     *          return.\n     */\n    export function addRenderHelper(\n        object: THREE.Object3D,\n        viewRanges: ViewRanges,\n        fadeNear: number | undefined,\n        fadeFar: number | undefined,\n        updateUniforms: boolean,\n        additionalCallback?: (\n            renderer: THREE.WebGLRenderer,\n            material: THREE.Material & FadingFeature\n        ) => void\n    ) {\n        // tslint:disable-next-line:no-unused-variable\n        object.onBeforeRender = chainCallbacks(\n            object.onBeforeRender,\n            (\n                renderer: THREE.WebGLRenderer,\n                scene: THREE.Scene,\n                camera: THREE.Camera,\n                geometry: THREE.Geometry | THREE.BufferGeometry,\n                material: THREE.Material & FadingFeature,\n                group: THREE.Group\n            ) => {\n                const fadingMaterial = material as FadingFeature;\n\n                fadingMaterial.fadeNear =\n                    fadeNear === undefined || fadeNear === FadingFeature.DEFAULT_FADE_NEAR\n                        ? FadingFeature.DEFAULT_FADE_NEAR\n                        : cameraToWorldDistance(fadeNear, viewRanges);\n\n                fadingMaterial.fadeFar =\n                    fadeFar === undefined || fadeFar === FadingFeature.DEFAULT_FADE_FAR\n                        ? FadingFeature.DEFAULT_FADE_FAR\n                        : cameraToWorldDistance(fadeFar, viewRanges);\n\n                if (additionalCallback !== undefined) {\n                    additionalCallback(renderer, material);\n                }\n            }\n        );\n    }\n}\n\n/**\n * Mixin class for extended THREE materials. Adds new properties required for `fadeNear` and\n * `fadeFar`. There is some special handling for the fadeNear/fadeFar properties, which get some\n * setters and getters in a way that works well with the mixin.\n *\n * @see [[Tile#addRenderHelper]]\n */\nexport class FadingFeatureMixin implements FadingFeature {\n    needsUpdate?: boolean;\n    uniformsNeedUpdate?: boolean;\n    defines?: any;\n    shaderDefines?: any;\n    shaderUniforms?: UniformsType;\n    onBeforeCompile?: CompileCallback;\n    private m_fadeNear: number = FadingFeature.DEFAULT_FADE_NEAR;\n    private m_fadeFar: number = FadingFeature.DEFAULT_FADE_FAR;\n\n    /**\n     * @see [[FadingFeature#fadeNear]]\n     */\n    protected getFadeNear(): number {\n        return this.m_fadeNear;\n    }\n    /**\n     * @see [[FadingFeature#fadeNear]]\n     */\n    protected setFadeNear(value: number) {\n        const needsUpdate = value !== this.m_fadeNear;\n        if (needsUpdate) {\n            this.m_fadeNear = value;\n            FadingFeature.updateFadingFeature(this);\n        }\n    }\n\n    /**\n     * @see [[FadingFeature#fadeFar]]\n     */\n    protected getFadeFar(): number {\n        return this.m_fadeFar;\n    }\n    /**\n     * @see [[FadingFeature#fadeFar]]\n     */\n    protected setFadeFar(value: number) {\n        const needsUpdate = value !== this.m_fadeFar;\n        if (needsUpdate) {\n            this.m_fadeFar = value;\n            FadingFeature.updateFadingFeature(this);\n        }\n    }\n\n    /**\n     * The mixin classes should call this method to register the properties [[fadeNear]] and\n     * [[fadeFar]].\n     */\n    protected addFadingProperties(): void {\n        Object.defineProperty(this, \"fadeNear\", {\n            get: () => {\n                return this.getFadeNear();\n            },\n            set: val => {\n                this.setFadeNear(val);\n            }\n        });\n        Object.defineProperty(this, \"fadeFar\", {\n            get: () => {\n                return this.getFadeFar();\n            },\n            set: val => {\n                this.setFadeFar(val);\n            }\n        });\n    }\n\n    /**\n     * Apply the fadeNear/fadeFar values from the parameters to the respective properties.\n     *\n     * @param params - `FadingMeshBasicMaterial` parameters.\n     */\n    protected applyFadingParameters(params?: FadingFeatureParameters) {\n        // Prepare maps for holding uniforms and defines references from the actual material.\n        linkMixinWithMaterial(this, this);\n\n        assert(this.shaderDefines !== undefined);\n        assert(this.shaderUniforms !== undefined);\n\n        // Create uniforms with default values, this ensures they are always set created,\n        // so no need for checks in setters.\n        this.shaderUniforms!.fadeNear = new THREE.Uniform(FadingFeature.DEFAULT_FADE_NEAR);\n        this.shaderUniforms!.fadeFar = new THREE.Uniform(FadingFeature.DEFAULT_FADE_FAR);\n\n        // Apply initial parameter values.\n        if (params !== undefined) {\n            if (params.fadeNear !== undefined) {\n                this.setFadeNear(params.fadeNear);\n            }\n            if (params.fadeFar !== undefined) {\n                this.setFadeFar(params.fadeFar);\n            }\n        }\n\n        this.onBeforeCompile = chainCallbacks(this.onBeforeCompile, (shader: THREE.Shader) => {\n            FadingFeature.onBeforeCompile(this, shader);\n        });\n        // Update (re-compile) shader code to include new shader chunks only if feature is enabled.\n        this.needsUpdate = FadingFeature.isEnabled(this);\n    }\n\n    /**\n     * Copy fadeNear/fadeFar values from other FadingFeature.\n     *\n     * @param source - The material to copy property values from.\n     */\n    protected copyFadingParameters(source: FadingFeature) {\n        this.setFadeNear(\n            source.fadeNear === undefined ? FadingFeature.DEFAULT_FADE_NEAR : source.fadeNear\n        );\n        this.setFadeFar(\n            source.fadeFar === undefined ? FadingFeature.DEFAULT_FADE_FAR : source.fadeFar\n        );\n        return this;\n    }\n}\n\nexport namespace ExtrusionFeature {\n    /**\n     * Checks if feature is enabled based on {@link ExtrusionFeature} properties.\n     *\n     * @param extrusionMaterial -\n     */\n    export function isEnabled(extrusionMaterial: ExtrusionFeature) {\n        return (\n            extrusionMaterial.extrusionRatio !== undefined &&\n            extrusionMaterial.extrusionRatio >= ExtrusionFeatureDefs.DEFAULT_RATIO_MIN\n        );\n    }\n\n    /**\n     * Patch the THREE.ShaderChunk on first call with some extra shader chunks.\n     */\n    export function patchGlobalShaderChunks() {\n        if (THREE.ShaderChunk.extrusion_pars_vertex === undefined) {\n            Object.assign(THREE.ShaderChunk, extrusionShaderChunk);\n        }\n    }\n\n    /**\n     * Update the internals of the `ExtrusionFeature` depending on the value of [[extrusionRatio]].\n     *\n     * @param ExtrusionMaterial - ExtrusionFeature\n     */\n    export function updateExtrusionFeature(extrusionMaterial: ExtrusionFeature): void {\n        assert(extrusionMaterial.shaderDefines !== undefined);\n        assert(extrusionMaterial.shaderUniforms !== undefined);\n\n        // Setup shader define that when changed will force material re-compile.\n        const useExtrusion = isEnabled(extrusionMaterial);\n        // Use shader define as marker if feature is enabled/disabled, this is not necessary\n        // required, but material requires update (re-compile) anyway to add/remove shader chunks.\n        const needsUpdate = setShaderDefine(\n            extrusionMaterial.shaderDefines,\n            \"EXTRUSION_MATERIAL\",\n            useExtrusion\n        );\n        // Enable/disable entire feature with material re-compile.\n        extrusionMaterial.needsUpdate = needsUpdate;\n\n        // Update uniform with new value\n        if (useExtrusion) {\n            extrusionMaterial.shaderUniforms!.extrusionRatio.value =\n                extrusionMaterial.extrusionRatio;\n        }\n        // Reset uniform to default, one time only, when feature is disabled (just for clarity).\n        else if (needsUpdate) {\n            extrusionMaterial.shaderUniforms!.extrusionRatio.value =\n                ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;\n        }\n    }\n\n    /**\n     * This function should be called on implementors of ExtrusionFeature in the `onBeforeCompile`\n     * callback of that material. It adds the required code to the shaders and declares the new\n     * uniforms that control extrusion.\n     *\n     * @param extrusionMaterial - Material to add uniforms to.\n     * @param shader - [[THREE.WebGLShader]] containing the vertex and fragment shaders to add the\n     *                  special includes to.\n     */\n    export function onBeforeCompile(extrusionMaterial: ExtrusionFeature, shader: THREE.Shader) {\n        if (!isEnabled(extrusionMaterial)) {\n            return;\n        }\n        assert(extrusionMaterial.shaderUniforms !== undefined);\n\n        // The vertex and fragment shaders have been constructed dynamically. The uniforms and\n        // the shader includes are now appended to them. No defines are required to preprocess\n        // shader chunks, but we utilize one just to note the feature is enabled/disabled\n        // (easier debugging), this define may be easily stripped out or replaced with simple\n        // boolean flag.\n        linkMixinWithShader(extrusionMaterial, shader);\n\n        shader.vertexShader = insertShaderInclude(\n            shader.vertexShader,\n            \"common\",\n            \"extrusion_pars_vertex\"\n        );\n\n        shader.vertexShader = insertShaderInclude(\n            shader.vertexShader,\n            \"begin_vertex\",\n            \"extrusion_vertex\",\n            true\n        );\n\n        shader.fragmentShader = insertShaderInclude(\n            shader.fragmentShader,\n            \"fog_pars_fragment\",\n            \"extrusion_pars_fragment\"\n        );\n\n        shader.fragmentShader = shader.fragmentShader.replace(\n            \"#include <normal_fragment_begin>\",\n            \"#include <extrusion_normal_fragment_begin>\"\n        );\n\n        shader.fragmentShader = insertShaderInclude(\n            shader.fragmentShader,\n            \"fog_fragment\",\n            \"extrusion_fragment\",\n            true\n        );\n    }\n}\n\n/**\n * Mixin class for extended THREE materials. Adds new properties required for `extrusionRatio`.\n *\n * @remarks\n * There is some special handling for the extrusionRatio property, which is animated via\n * {@link @here/harp-mapview#AnimatedExtrusionHandler} that is\n * using [[extrusionRatio]] setter and getter to update\n * extrusion in a way that works well with the mixin and EdgeMaterial.\n */\nexport class ExtrusionFeatureMixin implements ExtrusionFeature {\n    needsUpdate?: boolean;\n    uniformsNeedUpdate?: boolean;\n    defines?: any;\n    shaderDefines?: any;\n    shaderUniforms?: UniformsType;\n    onBeforeCompile?: CompileCallback;\n    private m_extrusion: number = ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;\n\n    /**\n     * @see [[ExtrusionFeature#extrusion]]\n     */\n    protected getExtrusionRatio(): number {\n        return this.m_extrusion;\n    }\n    /**\n     * @see [[ExtrusionFeature#extrusion]]\n     */\n    protected setExtrusionRatio(value: number) {\n        const needsUpdate = value !== this.m_extrusion;\n        if (needsUpdate) {\n            this.m_extrusion = value;\n            ExtrusionFeature.updateExtrusionFeature(this);\n        }\n    }\n\n    /**\n     * The mixin class should call this method to register the property [[extrusionRatio]]\n     */\n    protected addExtrusionProperties(): void {\n        Object.defineProperty(this, \"extrusionRatio\", {\n            get: () => {\n                return this.getExtrusionRatio();\n            },\n            set: val => {\n                this.setExtrusionRatio(val);\n            }\n        });\n    }\n\n    /**\n     * Apply the extrusionRatio value from the parameters to the respective properties.\n     */\n    protected applyExtrusionParameters(params?: ExtrusionFeatureParameters) {\n        // Prepare maps for holding uniforms and defines references from the actual material.\n        linkMixinWithMaterial(this, this);\n\n        assert(this.shaderDefines !== undefined);\n        assert(this.shaderUniforms !== undefined);\n\n        if (params && params.zFightingWorkaround === true) {\n            this.shaderDefines.ZFIGHTING_WORKAROUND = \"\";\n        }\n\n        // Create uniform with default value, this ensures that it is always created,\n        // so no need for checks in setters.\n        this.shaderUniforms!.extrusionRatio = new THREE.Uniform(\n            ExtrusionFeatureDefs.DEFAULT_RATIO_MAX\n        );\n\n        // Apply initial parameter values.\n        if (params !== undefined) {\n            if (params.extrusionRatio !== undefined) {\n                this.setExtrusionRatio(params.extrusionRatio);\n            }\n        }\n\n        this.onBeforeCompile = chainCallbacks(this.onBeforeCompile, (shader: THREE.Shader) => {\n            ExtrusionFeature.onBeforeCompile(this, shader);\n        });\n\n        this.needsUpdate = ExtrusionFeature.isEnabled(this);\n    }\n\n    /**\n     * Copy extrusionRatio values from other ExtrusionFeature.\n     *\n     * @param source - The material to copy property values from.\n     */\n    protected copyExtrusionParameters(source: ExtrusionFeature) {\n        if (source.extrusionRatio !== undefined) {\n            this.setExtrusionRatio(source.extrusionRatio);\n        }\n        return this;\n    }\n}\n\n/**\n * Subclass of [[THREE.MeshBasicMaterial]]. Adds new properties required for [[fadeNear]] and\n * [[fadeFar]]. In addition to the new properties (which update their respective uniforms), it is\n * also required to update the material in their objects [[onBeforeRender]] and [[OnAfterRender]]\n * calls, where their flag [[transparent]] is set and the internal fadeNear/fadeFar values are\n * updated to world space distances.\n *\n * @see [[Tile#addRenderHelper]]\n */\nexport class MapMeshBasicMaterial extends THREE.MeshBasicMaterial\n    implements FadingFeature, ExtrusionFeature, DisplacementFeature {\n    /**\n     * Constructs a new `FadingMeshBasicMaterial`.\n     *\n     * @param params - `FadingMeshBasicMaterial` parameters.\n     */\n    constructor(\n        params?: THREE.MeshBasicMaterialParameters &\n            FadingFeatureParameters &\n            ExtrusionFeatureParameters &\n            DisplacementFeatureParameters\n    ) {\n        super(params);\n\n        FadingFeature.patchGlobalShaderChunks();\n\n        this.addFadingProperties();\n        this.applyFadingParameters(params);\n\n        ExtrusionFeature.patchGlobalShaderChunks();\n\n        this.addExtrusionProperties();\n        this.applyExtrusionParameters({ ...params, zFightingWorkaround: true });\n\n        this.addDisplacementProperties();\n        this.applyDisplacementParameters(params);\n    }\n\n    // overrides with THREE.js base classes are not recognized by tslint.\n    // tslint:disable-next-line: explicit-override\n    clone(): this {\n        return new MapMeshBasicMaterial().copy(this);\n    }\n\n    // overrides with THREE.js base classes are not recognized by tslint.\n    // tslint:disable-next-line: explicit-override\n    copy(source: this): any {\n        super.copy(source);\n        this.copyFadingParameters(source);\n        this.copyExtrusionParameters(source);\n        this.copyDisplacementParameters(source);\n        return this;\n    }\n\n    // Only here to make the compiler happy, these methods will be overriden: The actual\n    // implementations are those in FadingFeatureMixin and ExtrusionFeatureMixin, see below:\n    //\n    // applyMixinsWithoutProperties(FadingMeshBasicMaterial, [FadingFeatureMixin]);\n    // applyMixinsWithoutProperties(ExtrudionMeshBasicMaterial, [ExtrusionFeatureMixin]);\n    //\n    // Mixin declarations start ---------------------------------------------------------\n\n    get fadeNear(): number {\n        return FadingFeature.DEFAULT_FADE_NEAR;\n    }\n    // tslint:disable-next-line:no-unused-variable\n    set fadeNear(value: number) {\n        // to be overridden\n    }\n\n    get fadeFar(): number {\n        return FadingFeature.DEFAULT_FADE_FAR;\n    }\n    // tslint:disable-next-line:no-unused-variable\n    set fadeFar(value: number) {\n        // to be overridden\n    }\n\n    get extrusionRatio(): number {\n        return ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;\n    }\n    // tslint:disable-next-line:no-unused-variable\n    set extrusionRatio(value: number) {\n        // to be overridden\n    }\n\n    get displacementMap(): THREE.Texture | null {\n        return null;\n    }\n\n    // tslint:disable-next-line:no-unused-variable\n    set displacementMap(value: THREE.Texture | null) {\n        // to be overridden\n    }\n\n    // tslint:disable-next-line:no-unused-variable\n    setDisplacementMap(value: THREE.Texture | null) {\n        // to be overridden\n    }\n\n    protected addFadingProperties(): void {\n        // to be overridden\n    }\n\n    // tslint:disable-next-line:no-unused-variable\n    protected applyFadingParameters(params?: FadingFeatureParameters) {\n        // to be overridden\n    }\n\n    // tslint:disable-next-line:no-unused-variable\n    protected copyFadingParameters(source: FadingFeature) {\n        // to be overridden\n    }\n\n    protected addExtrusionProperties(): void {\n        // to be overridden\n    }\n\n    // tslint:disable-next-line:no-unused-variable\n    protected applyExtrusionParameters(params?: ExtrusionFeatureParameters) {\n        // to be overridden\n    }\n\n    // tslint:disable-next-line:no-unused-variable\n    protected copyExtrusionParameters(source: FadingFeature) {\n        // to be overridden\n    }\n\n    protected addDisplacementProperties(): void {\n        // to be overridden\n    }\n\n    // tslint:disable-next-line:no-unused-variable\n    protected applyDisplacementParameters(params?: DisplacementFeatureParameters) {\n        // to be overridden\n    }\n\n    // tslint:disable-next-line:no-unused-variable\n    protected copyDisplacementParameters(source: DisplacementFeature) {\n        // to be overridden\n    }\n    // Mixin declarations end -----------------------------------------------------------\n}\n\nexport class MapMeshDepthMaterial extends THREE.MeshDepthMaterial implements ExtrusionFeature {\n    constructor(params?: THREE.MeshDepthMaterialParameters & ExtrusionFeatureParameters) {\n        super(params);\n\n        ExtrusionFeature.patchGlobalShaderChunks();\n\n        this.addExtrusionProperties();\n\n        // We need to set these to false, because otherwise three.js complains that there are\n        // outputs of the vertex shader not used in the pixel shader, the properties in question\n        // are `vExtrusionRatio` and `vExtrusionAxis`.\n        this.applyExtrusionParameters({ ...params, zFightingWorkaround: false });\n        this.flatShading = false;\n    }\n\n    // Only here to make the compiler happy, these methods will be overriden: The actual\n    // implementations are those in{@link ExtrusionFeatureMixin}, see below:\n    //\n    // applyMixinsWithoutProperties(...);\n    //\n\n    // Mixin declarations start ---------------------------------------------------------\n    get extrusionRatio(): number {\n        return ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;\n    }\n    // tslint:disable-next-line:no-unused-variable\n    set extrusionRatio(value: number) {\n        // to be overridden\n    }\n\n    protected addExtrusionProperties(): void {\n        // to be overridden\n    }\n\n    // tslint:disable-next-line:no-unused-variable\n    protected applyExtrusionParameters(params?: ExtrusionFeatureParameters) {\n        // to be overridden\n    }\n\n    // tslint:disable-next-line:no-unused-variable\n    protected copyExtrusionParameters(source: FadingFeature) {\n        // to be overridden\n    }\n    // Mixin declarations end -----------------------------------------------------------\n}\n\n/**\n * Subclass of THREE.MeshStandardMaterial. Adds new properties required for `fadeNear` and\n * `fadeFar`. In addition to the new properties (which fill respective uniforms), it is also\n * required to update the material in their objects `onBeforeRender` and `OnAfterRender` calls,\n * where their flag `transparent` is set and the internal fadeNear/fadeFar values are updated to\n * world space distances.\n *\n * @see [[Tile#addRenderHelper]]\n */\nexport class MapMeshStandardMaterial extends THREE.MeshStandardMaterial\n    implements FadingFeature, ExtrusionFeature, DisplacementFeature {\n    uniformsNeedUpdate?: boolean;\n\n    /**\n     * Constructs a new `FadingMeshStandardMaterial`.\n     *\n     * @param params - `FadingMeshStandardMaterial` parameters.\n     */\n    constructor(\n        params?: THREE.MeshStandardMaterialParameters &\n            FadingFeatureParameters &\n            ExtrusionFeatureParameters &\n            ShadowFeatureParameters\n    ) {\n        super(params);\n\n        FadingFeature.patchGlobalShaderChunks();\n\n        this.addFadingProperties();\n        this.applyFadingParameters(params);\n\n        ExtrusionFeature.patchGlobalShaderChunks();\n\n        this.addExtrusionProperties();\n        this.applyExtrusionParameters({ ...params, zFightingWorkaround: true });\n\n        if (params?.removeDiffuseLight === true) {\n            this.onBeforeCompile = chainCallbacks(this.onBeforeCompile, shader => {\n                shader.fragmentShader = THREE.ShaderChunk.meshphysical_frag.replace(\n                    \"#include <lights_physical_pars_fragment>\",\n                    simpleLightingShadowChunk\n                );\n            });\n        }\n    }\n\n    // overrides with THREE.js base classes are not recognized by tslint.\n    // tslint:disable-next-line: explicit-override\n    clone(): this {\n        return new MapMeshStandardMaterial().copy(this);\n    }\n\n    // overrides with THREE.js base classes are not recognized by tslint.\n    // tslint:disable-next-line: explicit-override\n    copy(source: this): any {\n        super.copy(source);\n        this.copyFadingParameters(source);\n        this.copyExtrusionParameters(source);\n        return this;\n    }\n\n    /** @override */\n    get displacementMap(): THREE.Texture | null {\n        return super.displacementMap === undefined ? null : super.displacementMap;\n    }\n\n    /** @override */\n    set displacementMap(map: THREE.Texture | null) {\n        if (map === this.displacementMap) {\n            return;\n        }\n\n        if (!map || !this.displacementMap) {\n            this.needsUpdate = true;\n        }\n\n        if (map) {\n            map.needsUpdate = true;\n        }\n        super.displacementMap = map;\n    }\n\n    // Only here to make the compiler happy, these methods will be overriden: The actual\n    // implementations are those in FadingFeatureMixin and ExtrusionFeatureMixin, see below:\n    //\n    // applyMixinsWithoutProperties(FadingMeshBasicMaterial, [FadingFeatureMixin]);\n    // applyMixinsWithoutProperties(ExtrudionMeshBasicMaterial, [ExtrusionFeatureMixin]);\n    //\n    // Mixin declarations start ---------------------------------------------------------\n\n    get fadeNear(): number {\n        return FadingFeature.DEFAULT_FADE_NEAR;\n    }\n    // tslint:disable-next-line:no-unused-variable\n    set fadeNear(value: number) {\n        // to be overridden\n    }\n\n    get fadeFar(): number {\n        return FadingFeature.DEFAULT_FADE_FAR;\n    }\n    // tslint:disable-next-line:no-unused-variable\n    set fadeFar(value: number) {\n        // to be overridden\n    }\n\n    get extrusionRatio(): number {\n        return ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;\n    }\n    // tslint:disable-next-line:no-unused-variable\n    set extrusionRatio(value: number) {\n        // to be overridden\n    }\n\n    /**\n     * This is needed to simplify the lighting calculation, currently there is no support for\n     * switching this at runtime. It is required here to be a property because the parameters\n     * are applied to this material, and if this isn't here, three.js will complain that the\n     * property is missing.\n     * @internal\n     */\n    get removeDiffuseLight(): boolean {\n        return false;\n    }\n    /** @internal */\n    set removeDiffuseLight(val: boolean) {\n        // Stays empty.\n    }\n\n    protected addFadingProperties(): void {\n        // to be overridden\n    }\n\n    // tslint:disable-next-line:no-unused-variable\n    protected applyFadingParameters(params?: FadingFeatureParameters) {\n        // to be overridden\n    }\n\n    // tslint:disable-next-line:no-unused-variable\n    protected copyFadingParameters(source: FadingFeature) {\n        // to be overridden\n    }\n\n    protected addExtrusionProperties(): void {\n        // to be overridden\n    }\n\n    // tslint:disable-next-line:no-unused-variable\n    protected applyExtrusionParameters(params?: ExtrusionFeatureParameters) {\n        // to be overridden\n    }\n\n    // tslint:disable-next-line:no-unused-variable\n    protected copyExtrusionParameters(source: FadingFeature) {\n        // to be overridden\n    }\n    // Mixin declarations end -----------------------------------------------------------\n}\n\n/**\n * Finish the classes MapMeshBasicMaterial and MapMeshStandardMaterial by assigning them the actual\n * implementations of the mixed in functions.\n */\napplyMixinsWithoutProperties(MapMeshBasicMaterial, [FadingFeatureMixin]);\napplyMixinsWithoutProperties(MapMeshStandardMaterial, [FadingFeatureMixin]);\napplyMixinsWithoutProperties(MapMeshBasicMaterial, [ExtrusionFeatureMixin]);\napplyMixinsWithoutProperties(MapMeshStandardMaterial, [ExtrusionFeatureMixin]);\napplyMixinsWithoutProperties(MapMeshDepthMaterial, [ExtrusionFeatureMixin]);\napplyMixinsWithoutProperties(MapMeshBasicMaterial, [DisplacementFeatureMixin]);\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Lists supported line caps types/modes.\n */\nexport enum LineCapsModes {\n    CAPS_NONE = 0,\n    CAPS_SQUARE,\n    CAPS_ROUND,\n    CAPS_TRIANGLE_IN,\n    CAPS_TRIANGLE_OUT\n}\n\nexport default {\n    extrude_line_vert_func: `\nvec3 extrudeLine(\n        in vec3 vertexPosition,\n        in float linePosition,\n        in float extrusionWidth,\n        in vec4 bitangent,\n        in vec3 tangent,\n        in float tanHalfAngle,\n        inout vec2 uv\n    ) {\n    vec3 result = vertexPosition;\n    // Retrieve the angle between this segment and the previous one (stored in the bitangent w\n    // component).\n    float angle = bitangent.w;\n    // Extrude according to the angle between segments to properly render narrow joints...\n    if (angle != 0.0) {\n        result += uv.y * extrusionWidth * bitangent.xyz / cos(angle / 2.0);\n        uv.x = linePosition + uv.x * extrusionWidth * uv.y * tanHalfAngle;\n    }\n    // ... or extrude in a simple manner for segments that keep the same direction.\n    else {\n        result += uv.y * extrusionWidth * bitangent.xyz + uv.x * extrusionWidth * tangent;\n        uv.x = linePosition + uv.x * extrusionWidth;\n    }\n    uv.y *= extrusionWidth;\n    return result;\n}\n`,\n    round_edges_and_add_caps: `\n#define CAPS_NONE ${LineCapsModes.CAPS_NONE}\n#define CAPS_SQUARE ${LineCapsModes.CAPS_SQUARE}\n#define CAPS_ROUND ${LineCapsModes.CAPS_ROUND}\n#define CAPS_TRIANGLE_IN ${LineCapsModes.CAPS_TRIANGLE_IN}\n#define CAPS_TRIANGLE_OUT ${LineCapsModes.CAPS_TRIANGLE_OUT}\n\nfloat roundEdgesAndAddCaps(in vec4 coords, in vec3 range) {\n    // Compute the line's width to length ratio.\n    float widthRatio = range.y / range.x;\n\n    // Compute the inner segment distance (same for all cap mode).\n    float dist = abs(coords.y);\n    float segmentBeginMask = clamp(ceil(coords.z - coords.x), 0.0, 1.0);\n    float segmentEndMask = clamp(ceil(coords.x - coords.w), 0.0, 1.0);\n    dist = max(dist, segmentBeginMask * length(vec2((coords.x - coords.z) / widthRatio, coords.y)));\n    dist = max(dist, segmentEndMask * length(vec2((coords.x - coords.w) / widthRatio, coords.y)));\n\n    #if CAPS_MODE != CAPS_ROUND\n    // Compute the caps mask.\n    float capRangeMask = clamp(1.0 - ceil(range.z - drawRange.y), 0.0, 1.0);\n    float beginCapMask = clamp(ceil(drawRange.x - coords.x), 0.0, 1.0);\n    float endCapMask = clamp(ceil(coords.x - drawRange.y), 0.0, 1.0);\n    float capMask = capRangeMask * max(beginCapMask, endCapMask);\n\n    // Compute the outer segment distance (specific for each cap mode).\n    float capDist = max(coords.x - drawRange.y, drawRange.x - coords.x) / widthRatio;\n    #if CAPS_MODE == CAPS_NONE\n    dist = mix(dist, max(abs(coords.y), (capDist + 0.1) / 0.1), capMask);\n    #elif CAPS_MODE == CAPS_SQUARE\n    dist = mix(dist, max(abs(coords.y), capDist), capMask);\n    #elif CAPS_MODE == CAPS_TRIANGLE_OUT\n    dist = mix(dist, abs(coords.y) + capDist, capMask);\n    #elif CAPS_MODE == CAPS_TRIANGLE_IN\n    dist = mix(dist, max(abs(coords.y), (capDist - abs(coords.y)) + capDist), capMask);\n    #endif\n    #endif // CAPS_MODE != CAPS_ROUND\n\n    return dist;\n}\n`,\n    tile_clip_func: `\nvoid tileClip(vec2 tilePos, vec2 tileSize) {\n    if (tileSize.x > 0.0 && (tilePos.x < -tileSize.x / 2.0 || tilePos.x > tileSize.x / 2.0))\n        discard;\n    if (tileSize.y > 0.0 && (tilePos.y < -tileSize.y / 2.0 || tilePos.y > tileSize.y / 2.0))\n        discard;\n}\n`,\n    high_precision_vert_func: `\nvec3 subtractDblEyePos( const in vec3 pos ) {\n    vec3 t1 = positionLow - u_eyepos_lowpart;\n    vec3 e = t1 - positionLow;\n    vec3 t2 = ((-u_eyepos_lowpart - e) + (positionLow - (t1 - e))) + pos - u_eyepos;\n    vec3 high_delta = t1 + t2;\n    vec3 low_delta = t2 - (high_delta - t1);\n    return (high_delta + low_delta);\n}\n`\n};\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { UnicodeUtils } from \"../utils/UnicodeUtils\";\nimport { Font } from \"./FontCatalog\";\n\n/**\n * Structure containing all the required information necessary to render a BMFont glyph using\n * [[TextCanvas]].\n */\nexport class GlyphData {\n    /**\n     * Unicode character represented by this glyph.\n     */\n    readonly character: string;\n\n    /**\n     * Glyph' direction.\n     */\n    readonly direction: UnicodeUtils.Direction;\n\n    /**\n     * Array containing the positions for all corners of this glyph.\n     */\n    positions: THREE.Vector3[] = [];\n\n    /**\n     * Array containing the source texture coordinates for all corners of this glyph.\n     * Used to sample the original texture atlas pages.\n     */\n    sourceTextureCoordinates: THREE.Vector2[] = [];\n\n    /**\n     * Array containing the dynamic texture coordinates for all corners of this glyph.\n     * Used to sample the dynamic texture atlas page.\n     */\n    dynamicTextureCoordinates: THREE.Vector2[] = [];\n\n    /**\n     * Source texture atlas' page copy index.\n     */\n    copyIndex: number = 0;\n\n    /**\n     * Flag indicating if glyph can be currently rendered.\n     */\n    isInCache: boolean = false;\n\n    /**\n     * Creates a new `GlyphData` object.\n     *\n     * @param codePoint - Unicode code point.\n     * @param block - Unicode block.\n     * @param width - Glyph' width.\n     * @param height - Glyph' height.\n     * @param advanceX - Amount of pixel to move after placing this glyph.\n     * @param offsetX - Horizontal offset from the glyph' origin.\n     * @param offsetY - Vertical offset from the glyph' origin.\n     * @param u0 - Glyph' left texture coordinate.\n     * @param v0 - Glyph' bottom texture coordinate.\n     * @param u1 - Glyph' right texture coordinate.\n     * @param v1 - Glyph' top texture coordinate.\n     * @param texture - Glyph' source texture atlas page.\n     * @param font - Glyph' font.\n     *\n     * @returns New `GlyphData`.\n     */\n    constructor(\n        readonly codePoint: number,\n        readonly block: string,\n        readonly width: number,\n        readonly height: number,\n        readonly advanceX: number,\n        readonly offsetX: number,\n        readonly offsetY: number,\n        u0: number,\n        v0: number,\n        u1: number,\n        v1: number,\n        readonly texture: THREE.Texture,\n        readonly font: Font\n    ) {\n        this.character = String.fromCodePoint(codePoint);\n        this.direction = UnicodeUtils.getDirection(codePoint, block);\n\n        const left = this.offsetX;\n        const right = left + this.width;\n        const top = font.metrics.lineHeight - this.offsetY;\n        const bottom = top - this.height;\n\n        this.positions.push(\n            new THREE.Vector3(left, bottom, 1.0),\n            new THREE.Vector3(right, bottom, 1.0),\n            new THREE.Vector3(left, top, 1.0),\n            new THREE.Vector3(right, top, 1.0)\n        );\n\n        this.sourceTextureCoordinates.push(\n            new THREE.Vector2(u0, v0),\n            new THREE.Vector2(u1, v0),\n            new THREE.Vector2(u0, v1),\n            new THREE.Vector2(u1, v1)\n        );\n\n        this.dynamicTextureCoordinates.push(\n            new THREE.Vector2(0.0, 0.0),\n            new THREE.Vector2(1.0, 0.0),\n            new THREE.Vector2(0.0, 1.0),\n            new THREE.Vector2(1.0, 1.0)\n        );\n    }\n\n    /**\n     * Clone this `GlyphData`.\n     *\n     * @returns Cloned `GlyphData`.\n     */\n    clone(): GlyphData {\n        return new GlyphData(\n            this.codePoint,\n            this.block,\n            this.width,\n            this.height,\n            this.advanceX,\n            this.offsetX,\n            this.offsetY,\n            this.sourceTextureCoordinates[0].x,\n            this.sourceTextureCoordinates[0].y,\n            this.sourceTextureCoordinates[3].x,\n            this.sourceTextureCoordinates[3].y,\n            this.texture,\n            this.font\n        );\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport * as THREE from \"three\";\n\nimport { MemoryUsage } from \"../TextCanvas\";\nimport { GlyphData } from \"./GlyphData\";\nimport { TextBufferObject } from \"./TextBufferObject\";\nimport { TextRenderStyle } from \"./TextStyle\";\n\nexport const MAX_CAPACITY = 65536;\nexport const VERTEX_BUFFER_STRIDE = 16;\nexport const INDEX_BUFFER_STRIDE = 1;\nexport const VERTICES_PER_QUAD = 4;\nexport const INDICES_PER_QUAD = 6;\nexport const QUAD_VERTEX_MEMORY_FOOTPRINT = VERTICES_PER_QUAD * VERTEX_BUFFER_STRIDE;\nexport const QUAD_INDEX_MEMORY_FOOTPRINT = INDICES_PER_QUAD * INDEX_BUFFER_STRIDE;\n\n/**\n * Number of bytes for float in an Float32Array.\n */\nconst NUM_BYTES_PER_FLOAT = 4;\n\n/**\n * Number of bytes for integer number in an UInt32Array.\n */\nconst NUM_BYTES_PER_INT32 = 4;\n\n/**\n * Interface containing user-supplied picking data, as well as the [[TextGeometry]] range it's\n * assigned to.\n */\ninterface PickingData {\n    start: number;\n    end: number;\n    data: any;\n}\n\n/**\n * Procedural geometry that holds vertex attribute data for all glyphs in a [[TextCanvas]].\n */\nexport class TextGeometry {\n    /**\n     * Count of currently drawn glyphs.\n     */\n    get drawCount(): number {\n        return this.m_drawCount;\n    }\n\n    /**\n     * Mesh used to render foreground glyphs.\n     */\n    get mesh(): THREE.Mesh {\n        return this.m_mesh;\n    }\n\n    /**\n     * Mesh used to render background glyphs.\n     */\n    get backgroundMesh(): THREE.Mesh {\n        return this.m_bgMesh;\n    }\n    /**\n     * Maximum glyph capacity.\n     */\n    readonly capacity: number;\n\n    private m_currentCapacity: number;\n    private m_drawCount: number;\n    private m_updateOffset: number;\n\n    private m_vertexBuffer: THREE.InterleavedBuffer;\n    private m_positionAttribute: THREE.InterleavedBufferAttribute;\n    private m_uvAttribute: THREE.InterleavedBufferAttribute;\n    private m_colorAttribute: THREE.InterleavedBufferAttribute;\n    private m_bgColorAttribute: THREE.InterleavedBufferAttribute;\n    private m_indexBuffer: THREE.BufferAttribute;\n\n    private m_geometry: THREE.BufferGeometry;\n    private m_mesh: THREE.Mesh;\n    private m_bgMesh: THREE.Mesh;\n\n    private m_pickingCount: number;\n    private m_pickingDataArray: PickingData[];\n\n    /**\n     * Creates a new `TextGeometry`.\n     *\n     * @param material - Material used to render foreground glyphs.\n     * @param backgroundMaterial - Material used to render background glyphs.\n     * @param initialSize - Initial amount of glyphs that can be stored.\n     * @param capacity - Maximum glyph capacity.\n     *\n     * @returns New `TextGeometry`.\n     */\n    constructor(\n        readonly scene: THREE.Scene,\n        material: THREE.Material,\n        backgroundMaterial: THREE.Material,\n        initialSize: number,\n        capacity: number\n    ) {\n        this.capacity = Math.min(capacity, MAX_CAPACITY);\n        this.m_currentCapacity = Math.min(initialSize, capacity);\n        this.m_drawCount = 0;\n        this.m_updateOffset = 0;\n        this.m_pickingCount = 0;\n\n        this.m_vertexBuffer = new THREE.InterleavedBuffer(\n            new Float32Array(this.m_currentCapacity * QUAD_VERTEX_MEMORY_FOOTPRINT),\n            VERTEX_BUFFER_STRIDE\n        );\n        this.m_vertexBuffer.setUsage(THREE.DynamicDrawUsage);\n        this.m_positionAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 0);\n        this.m_uvAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 4);\n        this.m_colorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 8);\n        this.m_bgColorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 12);\n\n        this.m_indexBuffer = new THREE.BufferAttribute(\n            new Uint32Array(this.m_currentCapacity * QUAD_INDEX_MEMORY_FOOTPRINT),\n            INDEX_BUFFER_STRIDE\n        );\n        this.m_indexBuffer.setUsage(THREE.DynamicDrawUsage);\n\n        this.m_geometry = new THREE.BufferGeometry();\n        this.m_geometry.setAttribute(\"position\", this.m_positionAttribute);\n        this.m_geometry.setAttribute(\"uv\", this.m_uvAttribute);\n        this.m_geometry.setAttribute(\"color\", this.m_colorAttribute);\n        this.m_geometry.setAttribute(\"bgColor\", this.m_bgColorAttribute);\n        this.m_geometry.setIndex(this.m_indexBuffer);\n\n        this.m_pickingDataArray = new Array(this.m_currentCapacity);\n\n        this.m_mesh = new THREE.Mesh(this.m_geometry, material);\n        this.m_bgMesh = new THREE.Mesh(this.m_geometry, backgroundMaterial);\n        this.m_mesh.renderOrder = Number.MAX_SAFE_INTEGER;\n        this.m_bgMesh.renderOrder = Number.MAX_SAFE_INTEGER - 1;\n        this.m_mesh.frustumCulled = false;\n        this.m_bgMesh.frustumCulled = false;\n        this.scene.add(this.m_bgMesh, this.m_mesh);\n    }\n\n    /**\n     * Release all allocated resources.\n     */\n    dispose() {\n        this.scene.remove(this.m_bgMesh, this.m_mesh);\n        this.m_geometry.dispose();\n    }\n\n    /**\n     * Clear the geometry.\n     */\n    clear() {\n        this.m_drawCount = 0;\n        this.m_updateOffset = 0;\n        this.m_pickingCount = 0;\n    }\n\n    /**\n     * Update the GPU resources to reflect the latest additions to the geometry.\n     */\n    update() {\n        if (this.drawCount > this.m_updateOffset) {\n            this.m_vertexBuffer.needsUpdate = true;\n            this.m_vertexBuffer.updateRange.offset =\n                this.m_updateOffset * QUAD_VERTEX_MEMORY_FOOTPRINT;\n            this.m_vertexBuffer.updateRange.count =\n                (this.m_drawCount - this.m_updateOffset) * QUAD_VERTEX_MEMORY_FOOTPRINT;\n            this.m_indexBuffer.needsUpdate = true;\n            this.m_indexBuffer.updateRange.offset =\n                this.m_updateOffset * QUAD_INDEX_MEMORY_FOOTPRINT;\n            this.m_indexBuffer.updateRange.count =\n                (this.m_drawCount - this.m_updateOffset) * QUAD_INDEX_MEMORY_FOOTPRINT;\n        }\n        this.m_updateOffset = this.m_drawCount;\n        this.m_geometry.setDrawRange(0, this.m_drawCount * INDICES_PER_QUAD);\n    }\n\n    /**\n     * Add a new glyph to the `TextGeometry`.\n     *\n     * @param glyphData - [[GlyphData]] holding the glyph description.\n     * @param corners - Transformed glyph corners.\n     * @param weight - Foreground glyph sampling weight.\n     * @param bgWeight - Foreground glyph sampling weight.\n     * @param mirrored - If `true`, UVs will be horizontally mirrored (needed for RTL punctuation).\n     * @param style - Currently set [[TextRenderStyle]].\n     *\n     * @returns Result of the addition.\n     */\n    add(\n        glyphData: GlyphData,\n        corners: THREE.Vector3[],\n        weight: number,\n        bgWeight: number,\n        mirrored: boolean,\n        style: TextRenderStyle\n    ): boolean {\n        if (this.m_drawCount >= this.capacity) {\n            return false;\n        } else if (this.m_drawCount >= this.m_currentCapacity) {\n            const newSize = Math.min(this.m_currentCapacity * 2, this.capacity);\n            this.resizeBuffers(newSize);\n        }\n\n        const baseVertex = this.m_drawCount * VERTICES_PER_QUAD;\n        const baseIndex = this.m_drawCount * INDICES_PER_QUAD;\n\n        for (let i = 0; i < VERTICES_PER_QUAD; ++i) {\n            this.m_positionAttribute.setXYZW(\n                baseVertex + i,\n                corners[i].x,\n                corners[i].y,\n                corners[i].z,\n                (mirrored ? -1.0 : 1.0) * style.rotation\n            );\n            const mirroredUVIdx = mirrored ? ((i + 1) % 2) + Math.floor(i / 2) * 2 : i;\n            this.m_uvAttribute.setXYZW(\n                baseVertex + i,\n                glyphData.dynamicTextureCoordinates[mirroredUVIdx].x,\n                glyphData.dynamicTextureCoordinates[mirroredUVIdx].y,\n                weight,\n                bgWeight\n            );\n            this.m_colorAttribute.setXYZW(\n                baseVertex + i,\n                style.color.r,\n                style.color.g,\n                style.color.b,\n                style.opacity\n            );\n            this.m_bgColorAttribute.setXYZW(\n                baseVertex + i,\n                style.backgroundColor.r,\n                style.backgroundColor.g,\n                style.backgroundColor.b,\n                style.backgroundOpacity\n            );\n        }\n\n        this.m_indexBuffer.setX(baseIndex, baseVertex);\n        this.m_indexBuffer.setX(baseIndex + 1, baseVertex + 1);\n        this.m_indexBuffer.setX(baseIndex + 2, baseVertex + 2);\n        this.m_indexBuffer.setX(baseIndex + 3, baseVertex + 2);\n        this.m_indexBuffer.setX(baseIndex + 4, baseVertex + 1);\n        this.m_indexBuffer.setX(baseIndex + 5, baseVertex + 3);\n\n        ++this.m_drawCount;\n        return true;\n    }\n\n    /**\n     * Add a new glyph to a text buffer.\n     *\n     * @param buffer - Target buffer where glyph attributes will be stored.\n     * @param offset - Offset of the target buffer.\n     * @param glyphData - [[GlyphData]] holding the glyph description.\n     * @param corners - Transformed glyph corners.\n     * @param weight - Foreground glyph sampling weight.\n     * @param bgWeight - Foreground glyph sampling weight.\n     * @param mirrored - If `true`, UVs will be mirrored (needed for RTL punctuation).\n     * @param style - Currently set [[TextRenderStyle]].\n     */\n    addToBuffer(\n        buffer: Float32Array,\n        offset: number,\n        glyphData: GlyphData,\n        corners: THREE.Vector3[],\n        weight: number,\n        bgWeight: number,\n        mirrored: boolean,\n        style: TextRenderStyle\n    ): void {\n        for (let i = 0; i < VERTICES_PER_QUAD; ++i) {\n            const vertexOffset = offset + VERTEX_BUFFER_STRIDE * i;\n            buffer[vertexOffset] = corners[i].x;\n            buffer[vertexOffset + 1] = corners[i].y;\n            buffer[vertexOffset + 2] = corners[i].z;\n            buffer[vertexOffset + 3] = (mirrored ? -1.0 : 1.0) * style.rotation;\n\n            const mirroredUVIdx = mirrored ? ((i + 1) % 2) + Math.floor(i / 2) * 2 : i;\n            buffer[vertexOffset + 4] = glyphData.dynamicTextureCoordinates[mirroredUVIdx].x;\n            buffer[vertexOffset + 5] = glyphData.dynamicTextureCoordinates[mirroredUVIdx].y;\n            buffer[vertexOffset + 6] = weight;\n            buffer[vertexOffset + 7] = bgWeight;\n\n            buffer[vertexOffset + 8] = style.color.r;\n            buffer[vertexOffset + 9] = style.color.g;\n            buffer[vertexOffset + 10] = style.color.b;\n            buffer[vertexOffset + 11] = style.opacity;\n\n            buffer[vertexOffset + 12] = style.backgroundColor.r;\n            buffer[vertexOffset + 13] = style.backgroundColor.g;\n            buffer[vertexOffset + 14] = style.backgroundColor.b;\n            buffer[vertexOffset + 15] = style.backgroundOpacity;\n        }\n    }\n\n    /**\n     * Add a previously computed [[TextBufferObject]] to the `TextGeometry`. Extra parameters can\n     * be passed to override the passed attribute data.\n     *\n     * @param textBufferObject - [[TextBufferObject]] containing computed glyphs.\n     * @param position - Override position value.\n     * @param scale - Override scale value.\n     * @param rotation - Override rotation value.\n     * @param color - Override color value.\n     * @param opacity - Override opacity value.\n     * @param bgColor - Override background color value.\n     * @param bgOpacity - Override background opacity value.\n     *\n     * @returns Result of the addition.\n     */\n    addTextBufferObject(\n        textBufferObject: TextBufferObject,\n        position?: THREE.Vector3,\n        scale?: number,\n        rotation?: number,\n        color?: THREE.Color,\n        opacity?: number,\n        bgColor?: THREE.Color,\n        bgOpacity?: number\n    ): boolean {\n        if (this.m_drawCount + textBufferObject.glyphs.length >= this.capacity) {\n            return false;\n        } else if (this.m_drawCount + textBufferObject.glyphs.length >= this.m_currentCapacity) {\n            const newSize = Math.min(this.m_currentCapacity * 2, this.capacity);\n            this.resizeBuffers(newSize);\n        }\n\n        const s = scale || 1.0;\n        const r = rotation || 0.0;\n        const cosR = Math.cos(r);\n        const sinR = Math.sin(r);\n        const offsetX = position !== undefined ? position.x : 0.0;\n        const offsetY = position !== undefined ? position.y : 0.0;\n        const offsetZ = position !== undefined ? position.z : 0.0;\n\n        const buffer = textBufferObject.buffer;\n\n        const rot = buffer[3];\n        const rotSign = rot < 0 ? -1.0 : 1.0;\n\n        const red = color !== undefined ? color.r : buffer[8];\n        const green = color !== undefined ? color.g : buffer[9];\n        const blue = color !== undefined ? color.b : buffer[10];\n        const alpha = opacity !== undefined ? opacity : buffer[11];\n        const bgRed = bgColor !== undefined ? bgColor.r : buffer[12];\n        const bgGreen = bgColor !== undefined ? bgColor.g : buffer[13];\n        const bgBlue = bgColor !== undefined ? bgColor.b : buffer[14];\n        const bgAlpha = bgOpacity !== undefined ? bgOpacity : buffer[15];\n\n        const targetOffset = this.m_drawCount * VERTICES_PER_QUAD;\n        for (let i = 0; i < textBufferObject.glyphs.length; ++i) {\n            const srcOffset = i * QUAD_VERTEX_MEMORY_FOOTPRINT;\n\n            const glyph = textBufferObject.glyphs[i];\n            if (!glyph.isInCache) {\n                return false;\n            }\n\n            const mirrored = buffer[srcOffset + 4] > buffer[srcOffset + VERTEX_BUFFER_STRIDE + 4];\n            const w = buffer[srcOffset + 6];\n            const bw = buffer[srcOffset + 7];\n\n            for (let j = 0; j < VERTICES_PER_QUAD; ++j) {\n                const x = buffer[srcOffset + j * VERTEX_BUFFER_STRIDE];\n                const y = buffer[srcOffset + j * VERTEX_BUFFER_STRIDE + 1];\n                this.m_positionAttribute.setXYZW(\n                    targetOffset + i * VERTICES_PER_QUAD + j,\n                    x * s * cosR + y * s * -sinR + offsetX,\n                    x * s * sinR + y * s * cosR + offsetY,\n                    buffer[srcOffset + j * VERTEX_BUFFER_STRIDE + 2] + offsetZ,\n                    buffer[srcOffset + j * VERTEX_BUFFER_STRIDE + 3] + rotSign * r\n                );\n                const mirroredUVIdx = mirrored ? ((j + 1) % 2) + Math.floor(j / 2) * 2 : j;\n                this.m_uvAttribute.setXYZW(\n                    targetOffset + i * VERTICES_PER_QUAD + j,\n                    glyph.dynamicTextureCoordinates[mirroredUVIdx].x,\n                    glyph.dynamicTextureCoordinates[mirroredUVIdx].y,\n                    w,\n                    (bw - w) / s + w\n                );\n                this.m_colorAttribute.setXYZW(\n                    targetOffset + i * VERTICES_PER_QUAD + j,\n                    red,\n                    green,\n                    blue,\n                    alpha\n                );\n                this.m_bgColorAttribute.setXYZW(\n                    targetOffset + i * VERTICES_PER_QUAD + j,\n                    bgRed,\n                    bgGreen,\n                    bgBlue,\n                    bgAlpha\n                );\n            }\n\n            this.m_indexBuffer.setX(\n                (this.m_drawCount + i) * INDICES_PER_QUAD,\n                (this.m_drawCount + i) * VERTICES_PER_QUAD\n            );\n            this.m_indexBuffer.setX(\n                (this.m_drawCount + i) * INDICES_PER_QUAD + 1,\n                (this.m_drawCount + i) * VERTICES_PER_QUAD + 1\n            );\n            this.m_indexBuffer.setX(\n                (this.m_drawCount + i) * INDICES_PER_QUAD + 2,\n                (this.m_drawCount + i) * VERTICES_PER_QUAD + 2\n            );\n            this.m_indexBuffer.setX(\n                (this.m_drawCount + i) * INDICES_PER_QUAD + 3,\n                (this.m_drawCount + i) * VERTICES_PER_QUAD + 2\n            );\n            this.m_indexBuffer.setX(\n                (this.m_drawCount + i) * INDICES_PER_QUAD + 4,\n                (this.m_drawCount + i) * VERTICES_PER_QUAD + 1\n            );\n            this.m_indexBuffer.setX(\n                (this.m_drawCount + i) * INDICES_PER_QUAD + 5,\n                (this.m_drawCount + i) * VERTICES_PER_QUAD + 3\n            );\n        }\n\n        this.m_drawCount += textBufferObject.glyphs.length;\n        return true;\n    }\n\n    /**\n     * Adds picking data for glyphs from the specified start until the last glyph added.\n     *\n     * @param startIdx - First glyph index that this picking data is associated to.\n     * @param endIdx - Last glyph index that this picking data is associated to.\n     * @param pickingData - Picking data to be added.\n     */\n    addPickingData(startIdx: number, endIdx: number, pickingData: any): boolean {\n        if (this.m_pickingCount >= this.m_currentCapacity) {\n            return false;\n        }\n\n        this.m_pickingDataArray[this.m_pickingCount] = {\n            start: Math.min(startIdx, this.capacity),\n            end: Math.min(endIdx, this.capacity),\n            data: pickingData\n        };\n\n        ++this.m_pickingCount;\n        return true;\n    }\n\n    /**\n     * Fill the picking results for the pixel with the given screen coordinate. If multiple glyphs\n     * are found, the order of the results is unspecified.\n     *\n     * @param screenPosition - Screen coordinate of picking position.\n     * @param pickCallback - Callback to be called for every picked element.\n     */\n    pick(screenPosition: THREE.Vector2, pickCallback: (pickData: any | undefined) => void) {\n        for (const pickingData of this.m_pickingDataArray) {\n            if (pickingData === undefined) {\n                return;\n            }\n\n            for (let i = pickingData.start; i < pickingData.end; ++i) {\n                const positionIndex = i * VERTICES_PER_QUAD;\n\n                const minX = Math.min(\n                    this.m_positionAttribute.getX(positionIndex + 2),\n                    this.m_positionAttribute.getX(positionIndex + 1)\n                );\n                if (screenPosition.x < minX) {\n                    continue;\n                }\n\n                const maxX = Math.max(\n                    this.m_positionAttribute.getX(positionIndex + 2),\n                    this.m_positionAttribute.getX(positionIndex + 1)\n                );\n                if (screenPosition.x > maxX) {\n                    continue;\n                }\n\n                const minY = Math.min(\n                    this.m_positionAttribute.getY(positionIndex + 2),\n                    this.m_positionAttribute.getY(positionIndex + 1)\n                );\n                if (screenPosition.y < minY) {\n                    continue;\n                }\n\n                const maxY = Math.max(\n                    this.m_positionAttribute.getY(positionIndex + 2),\n                    this.m_positionAttribute.getY(positionIndex + 1)\n                );\n                if (screenPosition.y > maxY) {\n                    continue;\n                }\n\n                pickCallback(pickingData.data);\n                break;\n            }\n        }\n    }\n\n    /**\n     * Update the info with the memory footprint caused by objects owned by the `TextGeometry`.\n     *\n     * @param info - The info object to increment with the values from this `TextGeometry`.\n     */\n    updateMemoryUsage(info: MemoryUsage) {\n        const numBytes =\n            this.m_vertexBuffer.count * NUM_BYTES_PER_FLOAT +\n            this.m_indexBuffer.count * NUM_BYTES_PER_INT32;\n        info.heapSize += numBytes;\n        info.gpuSize += numBytes;\n    }\n\n    private resizeBuffers(size: number) {\n        this.m_currentCapacity = size;\n\n        const newVertexBuffer = new Float32Array(size * QUAD_VERTEX_MEMORY_FOOTPRINT);\n        newVertexBuffer.set(this.m_vertexBuffer.array);\n        this.m_vertexBuffer = new THREE.InterleavedBuffer(newVertexBuffer, VERTEX_BUFFER_STRIDE);\n        this.m_vertexBuffer.setUsage(THREE.DynamicDrawUsage);\n        this.m_positionAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 0);\n        this.m_uvAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 4);\n        this.m_colorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 8);\n        this.m_bgColorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 12);\n\n        const newIndexBuffer = new Uint32Array(size * QUAD_INDEX_MEMORY_FOOTPRINT);\n        newIndexBuffer.set(this.m_indexBuffer.array);\n        this.m_indexBuffer = new THREE.BufferAttribute(newIndexBuffer, INDEX_BUFFER_STRIDE);\n        this.m_indexBuffer.setUsage(THREE.DynamicDrawUsage);\n\n        this.m_geometry.dispose();\n        this.m_geometry = new THREE.BufferGeometry();\n        this.m_geometry.setAttribute(\"position\", this.m_positionAttribute);\n        this.m_geometry.setAttribute(\"uv\", this.m_uvAttribute);\n        this.m_geometry.setAttribute(\"color\", this.m_colorAttribute);\n        this.m_geometry.setAttribute(\"bgColor\", this.m_bgColorAttribute);\n        this.m_geometry.setIndex(this.m_indexBuffer);\n\n        this.m_pickingDataArray.length = this.m_currentCapacity;\n\n        this.scene.remove(this.m_bgMesh, this.m_mesh);\n        this.m_mesh = new THREE.Mesh(this.m_geometry, this.m_mesh.material);\n        this.m_bgMesh = new THREE.Mesh(this.m_geometry, this.m_bgMesh.material);\n        this.m_mesh.renderOrder = Number.MAX_SAFE_INTEGER;\n        this.m_bgMesh.renderOrder = Number.MAX_SAFE_INTEGER - 1;\n        this.m_mesh.frustumCulled = false;\n        this.m_bgMesh.frustumCulled = false;\n        this.scene.add(this.m_bgMesh, this.m_mesh);\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { GlyphData } from \"../rendering/GlyphData\";\nimport { FontUnit, FontVariant } from \"../rendering/TextStyle\";\nimport { UnicodeUtils } from \"../utils/UnicodeUtils\";\n\n/**\n * Collection of different constants and utility functions used by [[Typesetter]]s.\n */\nexport namespace TypesettingUtils {\n    /**\n     * Ratio between EMs and Pixels.\n     */\n    export const EM_TO_PX = 16.0;\n\n    /**\n     * Ratio between Points and Pixels.\n     */\n    export const PT_TO_PX = 1.25;\n\n    /**\n     * Angle used when emulating italic fonts (oblique).\n     */\n    export const OBLIQUE_ANGLE = 0.174533;\n\n    /**\n     * Horizontal offset used when emulating italic fonts (oblique).\n     */\n    export const OBLIQUE_OFFSET = Math.tan(OBLIQUE_ANGLE);\n\n    /**\n     * Convert between any size specified in any [[FontUnit]] to pixels.\n     *\n     * @param size - Font size (specified in `unit`).\n     * @param unit - Size unit.\n     * @param originalSize - Original size (pixels)\n     *\n     * @returns Pixel size.\n     */\n    export function getPixelSize(size: number, unit: FontUnit, originalSize: number) {\n        let result = size;\n        switch (unit) {\n            case FontUnit.Em:\n                result *= EM_TO_PX;\n                break;\n            case FontUnit.Point:\n                result *= PT_TO_PX;\n                break;\n            case FontUnit.Percent:\n                result *= (1.0 / 100) * originalSize;\n                break;\n        }\n        return result;\n    }\n\n    /**\n     * Gets the scale applied to a certain character when using the [[FontVariant]].`SmallCaps`.\n     *\n     * @param glyphs - Array containing [[TransformedGlyphData]].\n     * @param index - Index to `glyphDataArray`.\n     * @param fontVariant - Currently active [[FontVariant]].\n     *\n     * @returns Glyph `SmallCaps` scale.\n     */\n    export function getSmallCapsScale(\n        glyphs: GlyphData[],\n        smallCapsTransformations: boolean[],\n        index: number,\n        fontVariant: FontVariant\n    ): number {\n        const isSmallCaps =\n            smallCapsTransformations[index] && fontVariant === FontVariant.SmallCaps;\n        return isSmallCaps\n            ? glyphs[index].font.metrics.xHeight / glyphs[index].font.metrics.capHeight\n            : 1.0;\n    }\n\n    /**\n     * Returns the first strong direction (LTR or RTL) found for a given array of [[GlyphData]].\n     *\n     * @param glyphs - Array containing [[GlyphData]].\n     * @param offset - `glyphDataArray` offset.\n     *\n     * @returns Strong direction.\n     */\n    export function getDirection(glyphs: GlyphData[], offset: number): UnicodeUtils.Direction {\n        let result = UnicodeUtils.Direction.LTR;\n        let index = offset;\n        while (\n            glyphs[index].direction !== UnicodeUtils.Direction.LTR &&\n            glyphs[index].direction !== UnicodeUtils.Direction.RTL &&\n            index < glyphs.length - 1\n        ) {\n            ++index;\n        }\n\n        if (Math.abs(glyphs[index].direction) === 1.0) {\n            result = glyphs[index].direction;\n        }\n        return result;\n    }\n\n    /**\n     * Computes the transformation matrix for a glyph.\n     *\n     * @param transform - Matrix used to store the results.\n     * @param position - Glyph' position.\n     * @param scale - Glyph' scale.\n     * @param rotation - [[TextCanvas]] rotation.\n     * @param localRotation - Glyph' local rotation.\n     */\n    export function computeGlyphTransform(\n        transform: THREE.Matrix3,\n        position: THREE.Vector3,\n        scale: number,\n        rotation: number,\n        localRotation: number\n    ): void {\n        const cosAngle = Math.cos(rotation);\n        const sinAngle = Math.sin(rotation);\n        const localCosAngle = Math.cos(localRotation);\n        const localSinAngle = Math.sin(localRotation);\n        transform.set(\n            scale * localCosAngle,\n            scale * -localSinAngle,\n            cosAngle * position.x - sinAngle * position.y,\n            scale * localSinAngle,\n            scale * localCosAngle,\n            sinAngle * position.x + cosAngle * position.y,\n            0,\n            0,\n            1.0\n        );\n    }\n\n    /**\n     * Updates the supplied bounds with the computed screen-space corners for a given glyph.\n     *\n     * @param corners - Glyph' corners.\n     * @param globalBounds - Global text bounds.\n     * @param individualBounds - Individual per-character bounds.\n     */\n    export function updateBounds(\n        corners: THREE.Vector3[],\n        globalBounds: THREE.Box2,\n        individualBounds?: { array: THREE.Box2[]; offset: number }\n    ): void {\n        const minX = Math.min(corners[0].x, corners[1].x, corners[2].x, corners[3].x);\n        const maxX = Math.max(corners[0].x, corners[1].x, corners[2].x, corners[3].x);\n        const minY = Math.min(corners[0].y, corners[1].y, corners[2].y, corners[3].y);\n        const maxY = Math.max(corners[0].y, corners[1].y, corners[2].y, corners[3].y);\n\n        if (individualBounds !== undefined) {\n            if (individualBounds.array[individualBounds.offset] !== undefined) {\n                individualBounds.array[individualBounds.offset].min.set(minX, minY);\n                individualBounds.array[individualBounds.offset].max.set(maxX, maxY);\n            } else {\n                individualBounds.array.push(\n                    new THREE.Box2(new THREE.Vector2(minX, minY), new THREE.Vector2(maxX, maxY))\n                );\n            }\n            ++individualBounds.offset;\n        }\n\n        globalBounds.min.set(\n            Math.min(globalBounds.min.x, minX),\n            Math.min(globalBounds.min.y, minY)\n        );\n        globalBounds.max.set(\n            Math.max(globalBounds.max.x, maxX),\n            Math.max(globalBounds.max.y, maxY)\n        );\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ViewRanges } from \"@here/harp-datasource-protocol/lib/ViewRanges\";\nimport { EarthConstants, Projection, ProjectionType } from \"@here/harp-geoutils\";\nimport { assert } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\nimport { ElevationProvider } from \"./ElevationProvider\";\nimport { MapViewUtils } from \"./Utils\";\n\nconst epsilon = 0.000001;\n\nexport interface ClipPlanesEvaluator {\n    /**\n     * Minimum elevation to be rendered, values beneath the sea level are negative.\n     */\n    minElevation: number;\n\n    /**\n     * Set maximum elevation to be rendered, values above sea level are positive.\n     */\n    maxElevation: number;\n\n    /**\n     * Compute near and far clipping planes distance.\n     *\n     * Evaluation method should be called on every frame  and camera clip planes updated.\n     * This is related to evaluator implementation and its input data, that may suddenly change\n     * such as camera position or angle, projection type or so.\n     * Some evaluators may not depend on all or even any of input objects, but to preserve\n     * compatibility with any evaluator type it is strongly recommended to update on every frame.\n     * @note The camera clipping planes (near/far properties) aren't automatically updated\n     * via #evaluateClipPlanes() call, user should do it manually if needed.\n     * @param camera - The [[THREE.Camera]] in use.\n     * @param projection - The geo-projection currently used for encoding geographic data.\n     * @param elevationProvider - The optional elevation provider for fine tuned range calculation,\n     * taking into account terrain variability and unevenness.\n     *\n     */\n    evaluateClipPlanes(\n        camera: THREE.Camera,\n        projection: Projection,\n        elevationProvider?: ElevationProvider\n    ): ViewRanges;\n}\n\n/**\n * Simplest camera clip planes evaluator, interpolates near/far planes based on ground distance.\n *\n * At general ground distance to camera along the surface normal is used as reference point for\n * planes evaluation, where near plane distance is set as fraction of this distance refereed as\n * [[nearMultiplier]]. Far plane equation has its own multiplier - [[nearFarMultiplier]],\n * which is applied to near plane and offset giving finally far plane distance.\n * This evaluator supports both planar and spherical projections, although it's behavior is\n * slightly different in each case. General algorithm sets near plane between camera and\n * ground level, while far plane is just calculated using scale and bias approach with far offset\n * and multiplier.\n * @deprecated Class contains the legacy (first and original) clip planes evaluation method, which\n * is widely used in examples thus is still kept for backward compatibility and comparisons.\n */\nexport class InterpolatedClipPlanesEvaluator implements ClipPlanesEvaluator {\n    readonly farMin: number;\n\n    protected m_tmpVectors: THREE.Vector3[] = [\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3()\n    ];\n    protected m_tmpQuaternion: THREE.Quaternion = new THREE.Quaternion();\n\n    constructor(\n        readonly nearMin: number = 0.1,\n        readonly nearMultiplier: number = 0.1,\n        readonly nearFarMultiplier = 50.0,\n        readonly farOffset = 200.0\n    ) {\n        assert(nearMin > 0);\n        assert(nearFarMultiplier >= 0);\n        assert(farOffset >= 0);\n        this.farMin = nearMin * nearFarMultiplier + farOffset;\n    }\n\n    // tslint:disable-next-line: no-empty\n    set minElevation(elevation: number) {}\n\n    get minElevation(): number {\n        // This evaluator does not support elevation so its always set to 0.\n        return 0;\n    }\n\n    // tslint:disable-next-line: no-empty\n    set maxElevation(elevation: number) {}\n\n    get maxElevation(): number {\n        // This evaluator does not support elevation so its always set to 0.\n        return 0;\n    }\n\n    evaluateClipPlanes(\n        camera: THREE.Camera,\n        projection: Projection,\n        elevationProvider?: ElevationProvider\n    ): ViewRanges {\n        let nearPlane: number = this.nearMin;\n        let farPlane: number = this.farMin;\n        if (projection.type === ProjectionType.Spherical) {\n            // near and far plane for a set up where\n            // the camera is looking at the center of the scene.\n            const r = EarthConstants.EQUATORIAL_RADIUS;\n            const d = camera.position.length();\n            const alpha = Math.asin(r / d);\n            // Extract X, Y, Z axes into tmp vectors array.\n            camera.matrixWorld.extractBasis(\n                this.m_tmpVectors[0],\n                this.m_tmpVectors[1],\n                this.m_tmpVectors[2]\n            );\n            // Setup quaternion based on X axis.\n            this.m_tmpQuaternion.setFromAxisAngle(this.m_tmpVectors[0], alpha);\n            // Acquire forward vector based on Z axis reversed (keep it in tmpVectors[2]).\n            const fwd = this.m_tmpVectors[2].negate();\n            // Apply quaternion rotation to forward vector, store it in tmpVectors[1].\n            const fwdRot = this.m_tmpVectors[1].copy(fwd).applyQuaternion(this.m_tmpQuaternion);\n            // Store camera position tmpVectors[0] and reference it with p.\n            const p = this.m_tmpVectors[0].copy(camera.position);\n            p.addScaledVector(fwdRot, Math.sqrt(d * d - r * r));\n            farPlane = p.sub(camera.position).dot(fwd) + this.farOffset;\n            nearPlane = Math.max(\n                this.nearMin,\n                projection.groundDistance(camera.position) * this.nearMultiplier\n            );\n        } else if (projection.type === ProjectionType.Planar) {\n            const groundDistance = projection.groundDistance(camera.position);\n            nearPlane = Math.max(this.nearMin, groundDistance * this.nearMultiplier);\n            // Will be already clamped to minFar due to clamping above.\n            farPlane = nearPlane * this.nearFarMultiplier + this.farOffset;\n        } else {\n            assert(false, \"Unsupported projection type\");\n        }\n\n        const viewRanges: ViewRanges = {\n            near: nearPlane,\n            far: farPlane,\n            minimum: this.nearMin,\n            maximum: farPlane\n        };\n        return viewRanges;\n    }\n}\n\n/**\n * Abstract evaluator class that adds support for elevation constraints.\n *\n * Classes derived from this should implement algorithms that takes into account rendered\n * features height (elevations), such as ground plane is no more flat (or spherical), but\n * contains geometry that should be overlapped by frustum planes.\n */\nexport abstract class ElevationBasedClipPlanesEvaluator implements ClipPlanesEvaluator {\n    private m_maxElevation: number;\n    private m_minElevation: number;\n\n    constructor(maxElevation: number, minElevation: number) {\n        assert(maxElevation >= minElevation);\n        this.m_minElevation = minElevation;\n        this.m_maxElevation = maxElevation;\n    }\n\n    abstract evaluateClipPlanes(\n        camera: THREE.Camera,\n        projection: Projection,\n        elevationProvider?: ElevationProvider\n    ): ViewRanges;\n\n    /**\n     * Set maximum elevation above sea level to be rendered.\n     *\n     * @param elevation - the elevation (altitude) value in world units (meters).\n     * @note If you set this exactly to the maximum rendered feature height (altitude above\n     * the sea, you may notice some flickering or even polygons disappearing related to rounding\n     * errors or depth buffer precision. In such cases increase [[nearFarMargin]] or add a little\n     * bit offset to your assumed maximum elevation.\n     * @note Reasonable values are in between (-DeadSeeDepression, MtEverestHeight>, both values\n     * are defined in [[EarthConstant]] as [[EarthConstant.MIN_ELEVATION]] and\n     * [[EarthConstant.MAX_ELEVATION]] respectively.\n     * @see minElevation for more information about precision and rounding errors.\n     */\n    set maxElevation(elevation: number) {\n        this.m_maxElevation = elevation;\n        // Min elevation should be at least equal or smaller to max elevation.\n        this.m_minElevation = Math.min(elevation, this.m_minElevation);\n    }\n\n    /**\n     * Get maximum elevation to be covered by camera frustum.\n     */\n    get maxElevation(): number {\n        return this.m_maxElevation;\n    }\n\n    /**\n     * Set minimum elevation to be rendered, values beneath the sea level are negative.\n     *\n     * @param elevation - the minimum elevation (depression) in world units (meters).\n     * @note If you set this parameter to zero you may not see any features rendered if they are\n     * just below the sea level more than half of [[nearFarMargin]] assumed. Similarly if set to\n     * -100m and rendered features lays exactly in such depression, you may notice that problem.\n     * The errors usually come from projection precision loss and depth buffer nature (significant\n     * precision loss closer to far plane). Thus is such cases either increase the margin (if you\n     * are sure features are just at this elevation, or setup bigger offset for [[minElevation]].\n     * Reasonable values are between <-DeadSeaDepression, MtEverestHeight), where the first denotes\n     * lowest depression on the Earth defined as [[EarthConstants.MIN_ELEVATION]] and the second is\n     * the highest point our planet.\n     * @see https://developer.nvidia.com/content/depth-precision-visualized\n     */\n    set minElevation(elevation: number) {\n        this.m_minElevation = elevation;\n        // Max elevation should be at least equal or bigger than min elevation.\n        this.m_maxElevation = Math.max(elevation, this.m_maxElevation);\n    }\n\n    /**\n     * Get minimum elevation to be covered by camera frustum.\n     */\n    get minElevation(): number {\n        return this.m_minElevation;\n    }\n}\n\n/**\n * Top view, clip planes evaluator that computes view ranges based on ground distance and elevation.\n *\n * This evaluator supports both planar and spherical projections, although it behavior is\n * slightly different in each case. General algorithm sets near plane and far plane close\n * to ground level, but taking into account maximum and minimum elevation of features on the ground.\n *\n * @note This evaluator supports only cameras which are always looking down the ground surface\n * (top-down view) along surface normal and does not preserve correct clip planes when\n * modifying camera pitch (tilt) angle. In simple words it is suitable only for top view camera\n * settings.\n */\nexport class TopViewClipPlanesEvaluator extends ElevationBasedClipPlanesEvaluator {\n    /**\n     * Helper for reducing number of objects created at runtime.\n     */\n    protected m_tmpVectors: THREE.Vector3[] = [\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3()\n    ];\n    /**\n     * Helper object for reducing performance impact.\n     */\n    protected m_tmpQuaternion: THREE.Quaternion = new THREE.Quaternion();\n    private m_minimumViewRange: ViewRanges;\n\n    /**\n     * Allows to setup near/far offsets (margins), rendered geometry elevation relative to sea\n     * level as also minimum near plane and maximum far plane distance constraints.\n     * It is strongly recommended to set some reasonable [[nearFarMargin]] (offset) between near\n     * and far planes to avoid flickering.\n     * @param maxElevation - defines near plane offset from the ground in the surface normal\n     * direction, positive values allows to render elevated terrain features (mountains,\n     * buildings). Defaults to Burj Khalifa building height.\n     * @param minElevation - defines far plane offset from the ground surface, negative values moves\n     * far plane below the ground level (use it to render depressions). Default zero - sea level.\n     * @param nearMin - minimum allowable near plane distance from camera, must be bigger than zero.\n     * @param nearFarMarginRatio - minimum distance between near and far plane, as a ratio of\n     * average near/far plane distance, it have to be significantly bigger than zero (especially if\n     * [[maxElevation]] and [[minElevation]] are equal), otherwise you may notice flickering when\n     * rendering, or even render empty scene if frustum planes are almost equal.\n     * @param farMaxRatio - maximum ratio between ground and far plane distance, allows to limit\n     * viewing distance at overall. Have to be bigger than 1.0.\n     * @note Keep in mind that this evaluator does not evaluate terrain (or building) elevation\n     * automatically, to keep such features rendered (between frustum planes) use [[minElevation]],\n     * [[maxElevation]] constraints. You may change this parameters at any time, but it requires\n     * repeating [[evaluatePlanes]] step, if your camera is moving you need to evaluate planes\n     * anyway.\n     * @note You may treat [[minElevation]] and [[maxElevation]] parameters as the maximum and\n     * minimum renderable elevation respectively along the surface normal, when camera is\n     * constantly looking downwards (top-down view). If you need {@link ClipPlanesEvaluator} for\n     * cameras that support tilt or yaw please use {@link TiltViewClipPlanesEvaluator}.\n     * @note [[nearFarMaxRatio]] does not limit far plane when spherical projection is in use,\n     * the algorithm used there estimates distance to point on tangent where line from camera\n     * touches the sphere horizon and there is no reason to clamp it.\n     */\n    constructor(\n        maxElevation: number = EarthConstants.MAX_BUILDING_HEIGHT,\n        minElevation: number = 0,\n        readonly nearMin: number = 1.0,\n        readonly nearFarMarginRatio: number = 0.05,\n        readonly farMaxRatio = 6.0\n    ) {\n        super(maxElevation, minElevation);\n        assert(nearMin > 0);\n        assert(nearFarMarginRatio > epsilon);\n        assert(farMaxRatio > 1.0);\n        const nearFarMargin = nearFarMarginRatio * nearMin;\n        this.m_minimumViewRange = {\n            near: nearMin,\n            far: nearMin + nearFarMargin,\n            minimum: this.nearMin,\n            maximum: Math.max(nearMin * farMaxRatio, nearMin + nearFarMargin)\n        };\n    }\n\n    /** @override */\n    evaluateClipPlanes(\n        camera: THREE.Camera,\n        projection: Projection,\n        elevationProvider?: ElevationProvider\n    ): ViewRanges {\n        if (projection.type === ProjectionType.Spherical) {\n            return this.evaluateDistanceSphericalProj(camera, projection, elevationProvider);\n        } else if (projection.type === ProjectionType.Planar) {\n            return this.evaluateDistancePlanarProj(camera, projection, elevationProvider);\n        }\n        assert(false, \"Unsupported projection type\");\n        return { ...this.minimumViewRange };\n    }\n\n    /**\n     * Get minimum view range that is possible to achieve with current evaluator settings.\n     * @note This value will not change after evaluator is constructed.\n     */\n    protected get minimumViewRange(): ViewRanges {\n        return this.m_minimumViewRange;\n    }\n\n    /**\n     * Calculate camera altitude (closest distance) to ground level in world units.\n     * @param camera -\n     * @param projection -\n     */\n    protected getCameraAltitude(camera: THREE.Camera, projection: Projection): number {\n        return projection.groundDistance(camera.position);\n    }\n\n    protected evaluateDistancePlanarProj(\n        camera: THREE.Camera,\n        projection: Projection,\n        elevationProvider?: ElevationProvider\n    ): ViewRanges {\n        assert(projection.type !== ProjectionType.Spherical);\n\n        let nearPlane: number = this.nearMin;\n        let farPlane: number = this.nearMin * this.farMaxRatio;\n\n        // Calculate distance to closest point on the ground.\n        const groundDistance = this.getCameraAltitude(camera, projection);\n        const farMax = groundDistance * this.farMaxRatio;\n        // We could at least try to keep margins along the eye vector (center of the view) in\n        // tact with pitch angle changes, but this does not solve all tilt angle problems,\n        // rather use more sophisticated evaluator.\n        nearPlane = groundDistance - this.maxElevation;\n        farPlane = groundDistance - this.minElevation;\n\n        // Apply the constraints.\n        nearPlane = Math.max(nearPlane, this.nearMin);\n        farPlane = Math.min(farPlane, farMax);\n        // Apply margins\n        const nearFarMargin = (this.nearFarMarginRatio * (nearPlane + farPlane)) / 2;\n        nearPlane = Math.max(nearPlane - nearFarMargin / 2, this.nearMin);\n        farPlane = Math.max(farPlane + nearFarMargin / 2, nearPlane + nearFarMargin);\n\n        const viewRanges: ViewRanges = {\n            near: nearPlane,\n            far: farPlane,\n            minimum: this.nearMin,\n            maximum: Math.max(farMax, farPlane)\n        };\n        return viewRanges;\n    }\n\n    protected evaluateDistanceSphericalProj(\n        camera: THREE.Camera,\n        projection: Projection,\n        elevationProvider?: ElevationProvider\n    ): ViewRanges {\n        assert(projection.type === ProjectionType.Spherical);\n\n        let nearPlane: number = this.nearMin;\n        let farPlane: number = this.nearMin * this.farMaxRatio;\n\n        // The near plane calculus is quite straight forward and works the same as for planar\n        // projections. We simply search for the closest point of the ground just above\n        // the camera, then we apply margin (elevation) to it along the sphere surface normal:\n        const cameraAltitude = this.getCameraAltitude(camera, projection);\n        nearPlane = cameraAltitude - this.maxElevation;\n\n        // Far plane calculation requires different approaches depending from camera projection:\n        // - perspective\n        // - orthographic\n\n        const r = EarthConstants.EQUATORIAL_RADIUS;\n        let d = camera.position.length();\n        d = d === 0 ? epsilon : d;\n        if (camera.type === \"PerspectiveCamera\") {\n            // This solution computes near and far plane for a set up where\n            // the camera is looking at the center of the scene.\n\n            // The far plane distance calculus requires finding the sphere tangent line that is\n            // co-linear with (goes thru) camera position, such tangent creates right angle\n            // with sphere diameter where it touches its surface (point T). Given that sphere is\n            // always at world origin and camera orbits around it we have (see\n            // #getTangentBasedFarPlane):\n            // angle(OTC) = 90\n            // sin(OCT) = sin(alpha) = r / d\n            // alpha = asin(r / d)\n            const alpha = Math.asin(r / d);\n            // If alpha it bigger than half fov angle, our visibility limit is set by tangent\n            // line, otherwise we need to find top (or right) plane intersection with sphere,\n            // which is definitely closer than the tangent point mentioned above.\n            const cam = camera as THREE.PerspectiveCamera;\n            // Take fov directly if it is vertical, otherwise we translate it using aspect ratio:\n            const aspect = cam.aspect > 1 ? cam.aspect : 1 / cam.aspect;\n            const halfFovAngle = THREE.MathUtils.degToRad((cam.fov * aspect) / 2);\n\n            const farTangent = this.getTangentBasedFarPlane(cam, d, r, alpha);\n            farPlane =\n                halfFovAngle > alpha\n                    ? farTangent\n                    : this.getFovBasedFarPlane(cam, d, r, 2 * halfFovAngle, projection);\n        }\n        // Orthographic camera projection\n        else {\n            farPlane = this.getOrthoBasedFarPlane(d, r);\n        }\n\n        // In extreme cases the largest depression assumed may be further than tangent\n        // based far plane distance, take it into account\n        const farMin = cameraAltitude - this.minElevation;\n        const farMax = cameraAltitude * this.farMaxRatio;\n        // Apply the constraints.\n        nearPlane = Math.max(nearPlane, this.nearMin);\n        farPlane = Math.max(farPlane, farMin);\n        // Apply margins\n        const nearFarMargin = (this.nearFarMarginRatio * (nearPlane + farPlane)) / 2;\n        nearPlane = Math.max(nearPlane - nearFarMargin / 2, this.nearMin);\n        farPlane = Math.max(farPlane + nearFarMargin / 2, nearPlane + nearFarMargin);\n\n        const viewRanges: ViewRanges = {\n            near: nearPlane,\n            far: farPlane,\n            minimum: this.nearMin,\n            maximum: farMax\n        };\n        return viewRanges;\n    }\n\n    /**\n     * Calculate distance from a point to the tangent point of a sphere.\n     *\n     * Returns zero if point is below surface or only very slightly above surface of sphere.\n     * @param d - Distance from point to center of sphere\n     * @param r - Radius of sphere\n     */\n    protected getTangentDistance(d: number, r: number): number {\n        // There may be situations when maximum elevation still remains below sea level\n        // (elevation < 0) or it is negligible (elevation ~ epsilon)\n        if (d - r < epsilon) {\n            return 0;\n        }\n\n        // The distance to tangent point may be described as:\n        // t = sqrt(d^2 - r^2)\n        return Math.sqrt(d * d - r * r);\n    }\n\n    /**\n     * Calculate far plane depending on furthest visible distance from camera position.\n     *\n     * Furthest visible distance is assumed to be distance from camera to horizon\n     * plus distance from elevated geometry to horizon(so that high objects behind horizon\n     * remain visible).\n     * @param camera - The camera of the mapview\n     * @param d - Distance from camera to origin\n     * @param r - Radius of earth\n     * @param alpha - Angle between camera eye vector and tangent\n     */\n    protected getTangentBasedFarPlane(\n        camera: THREE.PerspectiveCamera,\n        d: number,\n        r: number,\n        alpha: number\n    ): number {\n        // Find tangent point intersection distance\n        //         , - ~ ~ ~ - ,\n        //     , '               ' ,        E\n        //   ,           .           ,    . ' far + elev\n        //  ,            .   r + e   , '   /\n        // ,             .     ,  '    ,  /\n        // ,             . O '         , / te\n        // ,             | .           ,/\n        //  ,            |   .  r     ,/\n        //   ,           |      .    ,\n        //     ,         |        , '_____ far\n        //       ' -_, _ | _ ,  ' / T\n        //     near      |      /\n        //               |    / t\n        //             d |  /\n        //               |/\n        //               C\n        const t = this.getTangentDistance(d, r);\n\n        // Because we would like to see elevated geometry that may be visible beyond\n        // the tangent point on ground surface, we need to extend viewing distance along\n        // the tangent line by te (see graph above).\n        const te = this.getTangentDistance(r + this.maxElevation, r);\n\n        // Next step is to project CE vector(length t + te) onto camera eye (forward) vector\n        // to get maximum camera far plane distance.\n        //\n        // Knowing that:\n        // tangentVec.dot(cameraFwdVec) = cos(alpha) * len(tangentVec) * len(cameraFwdVec).\n        // where:\n        // ||cameraFwdVec|| == 1 ^ ||tangentVec|| == t + te\n        // Formula simplifies to:\n        const far = Math.cos(alpha) * (t + te);\n\n        return far;\n    }\n\n    protected getFovBasedFarPlane(\n        camera: THREE.PerspectiveCamera,\n        d: number,\n        r: number,\n        fovAngle: number,\n        projection: Projection\n    ) {\n        // Find intersection point that is closer to tangent point.\n        //\n        //         , - ~ ~ ~ - ,\n        //     , '               ' ,\n        //   ,           .           ,\n        //  ,            .     r     ,' T1\n        // ,             .     ,  '  / ,\n        // ,             . O.'  a   /  ,\n        // ,             | .  `  . /   ,\n        //  ,            |   .  r / TA,\n        //   ,           |    .  /   ,\n        //     ,         |     ./  ,'_____ far\n        //       ' -_, _ | _ , /' T0\n        //     near      |    /\n        //               |   / t\n        //             d | /\n        //               |/\n        //               C\n        //\n        // See:\n        // tslint:disable-next-line: max-line-length\n        // https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection\n\n        // Vector from camera to world center\n        const dVec = camera.position;\n        // Extract camera X, Y, Z orientation axes into tmp vectors array.\n        camera.matrixWorld.extractBasis(\n            this.m_tmpVectors[0],\n            this.m_tmpVectors[1],\n            this.m_tmpVectors[2]\n        );\n        // Setup quaternion (X axis based) for angle between frustum plane and camera eye.\n        this.m_tmpQuaternion.setFromAxisAngle(this.m_tmpVectors[0], fovAngle / 2);\n        // Acquire camera (eye) forward vector from Z axis (keep it in tmpVectors[2]).\n        const cameraFwdVec = this.m_tmpVectors[2];\n        // Apply quaternion to forward vector, creating intersection vector, which is\n        // parallel to top or right frustum plane (depending on the aspect ratio).\n        const tVec = this.m_tmpVectors[1].copy(cameraFwdVec).applyQuaternion(this.m_tmpQuaternion);\n        // Calculate camera to origin vector projection onto frustum plane (top or right).\n        // This gives us the length of CTA segment:\n        const cta = dVec.dot(tVec);\n        // If it is negative, it means that the dVec and the tVec points in\n        // opposite directions - there is no intersection - or intersection could\n        // potentially be behind the intersection ray's origin (camera position).\n        if (cta < 0) {\n            // Intersection points are behind camera, camera looks in wrong direction.\n            const groundDistance = this.getCameraAltitude(camera, projection);\n            // Setup far plane to maximum distance.\n            return groundDistance * this.farMaxRatio;\n        }\n        // Knowing the length of |CTA| we just need to subtract the length of |T0TA|\n        // segment from it to get far plane distance.\n        // In order to calculate |T0TA| we firstly need to use use Pythagorean theorem to\n        // find length of |OTA| = a. Here we use the right triangle formed by O-C-TA points:\n        // |OC|^2 = |CTA|^2 + |OTA|^2, where |OTA| = a, |OC| = d, |CTA| = cta\n        // a^2 = d^2 - cta^2\n        const a2 = dVec.dot(dVec) - cta * cta;\n        // Note that if a is greater than sphere radius the ray misses the sphere and\n        // thus there is no intersection at all.\n        const r2 = r * r;\n        assert(a2 <= r2, \"Please use this evaluator only for top view camera poses.\");\n        // Now to find the length of |T0TA| == |T1TA| we use the second right triangle\n        // formed by O-T0-TA points. Of course we know that |T0TA| segment length is\n        // equal to |T1TA|, and |OT0| segment is simply sphere radius.\n        // In order to find |T0TA| length we again use Pythagorean theorem, which says:\n        // |OT0|^2 = |OTA|^2 + |T0TA|^2, where |OTO| = r, |OTA| = a\n        // |T0TA|^2 = r^2 - a^2\n        const tota = Math.sqrt(r2 - a2);\n        // Finally our far plane (intersection point) is defined as:\n        return cta - tota;\n    }\n\n    protected getOrthoBasedFarPlane(d: number, r: number): number {\n        //         , - ~ ~ ~ - ,\n        //     , '               ' ,     E\n        //   ,            .--------- ,-.'- far + elev\n        // | ,            .   r + e , `, |\n        // |,             .     , '     ,| te\n        // |,             . O '.........,|..\n        // |,             |        r    ,|  far\n        // | ,            |            , |\n        // |  ,           |           ,  | t\n        // |    ,         |        , '   |\n        // |      ' -_, _ | _ ,  '       |\n        // |    near      | \\/___________| near - elev\n        // |              |              |\n        // |            d |              |\n        // |              |              |\n        //                C\n        // The distance to tangent point may be described as:\n        const t = d;\n        // Tangent extension due to terrain elevation behind the horizon may be calculated\n        // based on the right triangle:\n        // (r+maxElev)^2 = r^2 + te^2\n        // te = sqrt((r+maxElev)^2 - r^2)\n        // although we may not calculate it if elevation is negligible:\n        const te =\n            this.maxElevation < epsilon\n                ? 0\n                : Math.sqrt(r + this.maxElevation) * (r + this.maxElevation) - r * r;\n        // Both near and far planes distances are directly applied to frustum, because tangents'\n        // lines are parallel to camera look at vector.\n        // Now far plane distance is constituted with:\n        return t + te;\n    }\n}\n\n/**\n * Evaluates camera clipping planes taking into account ground distance and camera angles.\n *\n * This evaluator provides support for camera with varying tilt (pitch) angle, the angle\n * between camera __look at__ vector and the ground surface normal.\n */\nexport class TiltViewClipPlanesEvaluator extends TopViewClipPlanesEvaluator {\n    /**\n     * Calculate the lengths of frustum planes intersection with the ground plane.\n     * This evaluates distances between eye vector (or eye plane in orthographic projection) and\n     * ground intersections of top and bottom frustum planes.\n     * @note This method assumes the world surface (ground) to be flat and\n     * works only with planar projections.\n     *\n     * @param camera - The [[THREE.Camera]] instance in use,\n     * @param projection - The geo-projection used to convert geographic to world coordinates.\n     */\n    protected getFrustumGroundIntersectionDist(\n        camera: THREE.Camera,\n        projection: Projection\n    ): { top: number; bottom: number } {\n        assert(projection.type !== ProjectionType.Spherical);\n        // This algorithm computes the length of frustum planes before intersecting with a flat\n        // ground surface. Entire computation is split over two projections method and performed\n        // for top and bottom plane, with addition of terrain (ground) elevation which is taken\n        // into account.\n        // The following diagram may help explain the algorithm below.\n        //   \n        //   C\n        //   |\\\n        //   |.\\ .\n        //   | . \\  . t\n        // z |  .  \\   .c2\n        //   |  c1.  \\e ___. max elev\n        //   |     .   \\      .\n        //___|a___D1.____\\E1_____.D2______ g\n        //   C1      .     \\ __. min elev\n        //            .      \\.E2\n        //          b  .    .\n        //              . .\n        //               .\n        // Where:\n        // - C gives the camera position.\n        // - z is the height of the camera above the ground.\n        // - z1 == z2 == z, for perspective camera all planes origin its the same\n        // - a is a right angle.\n        // - e is the look at vector of the camera.\n        // - t and b are the frustum planes of the camera (top and bottom respectively).\n        // - angle between c1 to c2 is the fov.\n        // - c1, c2 - vectors from camera to the ground along frustum planes.\n        // - angles between c1 and e or e and c2 splits fov on equal halves.\n        // - d1 and d2 are the intersection points of the frustum with the world/ground plane.\n        // - angle between z and e is the pitch of the camera.\n        // - angle between g and e is the tilt angle.\n        // - g is the ground/world surface\n        //\n        // The goal is to find distance for top/bottom planes intersections of frustum with ground\n        // plane.\n        // This are the distances from C->D1 and C->D2, and are described as\n        // c1 and c2. Then we may compensate/correct those distances with actual\n        // ground elevations, which is done by simply offsetting camera altitude, as it is\n        // opposite to elevating ground level.\n        const halfPiLimit = Math.PI / 2 - epsilon;\n        const cameraAltitude = this.getCameraAltitude(camera, projection);\n        // tslint:disable-next-line: deprecation\n        const cameraTilt = MapViewUtils.extractCameraTilt(camera, projection);\n        // Angle between z and c2\n        let topAngleRad: number;\n        // Angle between z and c1\n        let bottomAngleRad: number;\n        // Bottom plane origin altitude\n        let z1: number;\n        // Top plane origin altitude\n        let z2: number;\n        // For perspective projection:\n        if (camera.type === \"PerspectiveCamera\") {\n            const cam = (camera as any) as THREE.PerspectiveCamera;\n            // Angle between z and c2, note, the fov is vertical, otherwise we would need to\n            // translate it using aspect ratio:\n            // let aspect = camera.aspect > 1 ? camera.aspect : 1 / camera.aspect;\n            const aspect = 1;\n            // Half fov angle in radians\n            const halfFovAngle = THREE.MathUtils.degToRad((cam.fov * aspect) / 2);\n            topAngleRad = THREE.MathUtils.clamp(\n                cameraTilt + halfFovAngle,\n                -halfPiLimit,\n                halfPiLimit\n            );\n            bottomAngleRad = THREE.MathUtils.clamp(\n                cameraTilt - halfFovAngle,\n                -halfPiLimit,\n                halfPiLimit\n            );\n            z1 = z2 = cameraAltitude;\n        }\n        // For orthographic projection:\n        else {\n            const cam = (camera as any) as THREE.OrthographicCamera;\n            // For orthogonal camera projections we may simply ignore FOV and use 0 for FOV\n            // the top/bottom planes are simply parallel to the eye vector:\n            topAngleRad = bottomAngleRad = cameraTilt;\n            // Although the ray origin is not always the same (eye position) as for\n            // the perspective projections, thus we need to compensate for ortho-cube\n            // dimensions:\n            // sin(tilt) = zc2 / top\n            // sin(tilt) = zc1 / bottom\n            // zc2 = sin(tilt) * top\n            // zc1 = sin(tilt) * bottom\n            const sinBeta = Math.sin(cameraTilt);\n            z2 = cameraAltitude + sinBeta * cam.top;\n            z1 = cameraAltitude - sinBeta * cam.bottom;\n        }\n        // Distance along the top plane to the ground - c2\n        // cos(topAngle) = (z2 - minElev) / |c2|\n        // |c2| = (z2 - minElev) / cos(topAngle)\n        const topDist = (z2 - this.minElevation) / Math.cos(topAngleRad);\n        // Distance along the bottom plane to the ground - c1\n        // cos(bottomAngle) = (z - minElev) / |c1|\n        // |c1| = (z - minElev) / cos(bottomAngle)\n        const bottomDist = (z1 - this.maxElevation) / Math.cos(bottomAngleRad);\n\n        return {\n            top: Math.max(topDist, 0),\n            bottom: Math.max(bottomDist, 0)\n        };\n    }\n\n    /** @override */\n    protected evaluateDistancePlanarProj(\n        camera: THREE.Camera,\n        projection: Projection,\n        elevationProvider?: ElevationProvider\n    ): ViewRanges {\n        assert(projection.type !== ProjectionType.Spherical);\n        const viewRanges = { ...this.minimumViewRange };\n\n        // Generally near/far planes are set to keep top/bottom planes intersection distance.\n        // Then elevations margins are applied. Here margins (min/max elevations) are meant to\n        // be defined as distance along the ground normal vector thus during camera\n        // tilt they may affect near/far planes positions differently.\n        const planesDist = this.getFrustumGroundIntersectionDist(camera, projection);\n\n        // Project clipping plane distances for the top/bottom frustum planes (edges), but\n        // only if we deal with perspective camera type, this step is not required\n        // for orthographic projections, cause all clip planes are parallel to eye vector.\n        if (camera.type === \"PerspectiveCamera\") {\n            const cam = camera as THREE.PerspectiveCamera;\n            // Angle between z and c2, note, the fov is vertical, otherwise we would need to\n            // translate it using aspect ratio:\n            // let aspect = camera.aspect > 1 ? camera.aspect : 1 / camera.aspect;\n            const aspect = 1;\n            // Half fov angle in radians\n            const halfFovAngle = THREE.MathUtils.degToRad((cam.fov * aspect) / 2);\n            const cosHalfFov = Math.cos(halfFovAngle);\n            // cos(halfFov) = near / bottomDist\n            // near = cos(halfFov) * bottomDist\n            viewRanges.near = planesDist.bottom * cosHalfFov;\n            // cos(halfFov) = far / topDist\n            // far = cos(halfFov) * topDist\n            viewRanges.far = planesDist.top * cosHalfFov;\n        }\n        // Orthographic camera projection.\n        else {\n            viewRanges.near = planesDist.bottom;\n            viewRanges.far = planesDist.top;\n        }\n\n        // Compute target (focus) point distance.\n        // tslint:disable-next-line: deprecation\n        const { distance } = MapViewUtils.getTargetAndDistance(\n            projection,\n            camera,\n            elevationProvider\n        );\n        // Clamp values to constraints.\n        const farMax = distance * this.farMaxRatio;\n        viewRanges.near = Math.max(viewRanges.near, this.nearMin);\n        viewRanges.far = Math.min(viewRanges.far, farMax);\n\n        // Apply margins\n        const nearFarMargin = (this.nearFarMarginRatio * (viewRanges.near + viewRanges.far)) / 2;\n        viewRanges.near = Math.max(viewRanges.near - nearFarMargin / 2, this.nearMin);\n        viewRanges.far = Math.max(\n            viewRanges.far + nearFarMargin / 2,\n            viewRanges.near + nearFarMargin\n        );\n        viewRanges.minimum = this.nearMin;\n        viewRanges.maximum = farMax;\n\n        return viewRanges;\n    }\n\n    /** @override */\n    protected evaluateDistanceSphericalProj(\n        camera: THREE.Camera,\n        projection: Projection,\n        elevationProvider?: ElevationProvider\n    ): ViewRanges {\n        assert(projection.type === ProjectionType.Spherical);\n        const viewRanges = { ...this.minimumViewRange };\n\n        // Near plane calculus is pretty straightforward and does not depend on camera tilt:\n        const cameraAltitude = this.getCameraAltitude(camera, projection);\n        viewRanges.near = cameraAltitude - this.maxElevation;\n\n        let halfFovAngle: number = 0;\n        if (camera instanceof THREE.PerspectiveCamera) {\n            // Take fov directly if it is vertical, otherwise we translate it using aspect ratio:\n            const aspect = camera.aspect > 1 ? camera.aspect : 1 / camera.aspect;\n            halfFovAngle = THREE.MathUtils.degToRad((camera.fov * aspect) / 2);\n\n            // Now we need to account for camera tilt and frustum volume, so the longest\n            // frustum edge does not intersects with sphere, it takes the worst case\n            // scenario regardless of camera tilt, so may be improved little bit with more\n            // sophisticated algorithm.\n            viewRanges.near *= Math.cos(halfFovAngle);\n        }\n\n        // Far plane calculation requires different approaches depending from camera projection:\n        // - perspective\n        // - orthographic\n        const cameraToOrigin = this.m_tmpVectors[0].copy(camera.position).negate();\n        const r = EarthConstants.EQUATORIAL_RADIUS;\n        const d = cameraToOrigin.length();\n        let farPlane: number;\n        if (camera instanceof THREE.PerspectiveCamera) {\n            // Step-wise calculate angle between camera eye vector and tangent\n\n            // Calculate angle between surface normal(below camera position) and tangent.\n            const alpha = Math.asin(r / d);\n\n            // Calculate angle between look at and surface normal(below camera position)\n            const cameraPitch = this.getCameraPitch(cameraToOrigin, camera);\n\n            // Calculate angle between camera eye vector and tangent.\n            const modifiedAlpha = Math.abs(alpha - cameraPitch);\n\n            // Use tangent based far plane if horizon is within field of view\n            const farTangent = this.getTangentBasedFarPlane(camera, d, r, modifiedAlpha);\n            farPlane =\n                halfFovAngle >= modifiedAlpha\n                    ? farTangent\n                    : this.getTiltedFovBasedFarPlane(d, r, halfFovAngle, cameraPitch);\n        } else {\n            farPlane = this.getOrthoBasedFarPlane(d, r);\n        }\n        viewRanges.far = farPlane;\n\n        // Compute the focus point (target) distance for current camera and projection setup,\n        // in a same way the MapView component does.\n        // tslint:disable-next-line: deprecation\n        const { distance } = MapViewUtils.getTargetAndDistance(\n            projection,\n            camera,\n            elevationProvider\n        );\n        // Apply the constraints.\n        const farMin = cameraAltitude - this.minElevation;\n        const farMax = distance * this.farMaxRatio;\n        viewRanges.near = Math.max(viewRanges.near, this.nearMin);\n        viewRanges.far = THREE.MathUtils.clamp(viewRanges.far, farMin, farMax);\n\n        // Apply margins.\n        const nearFarMargin = (this.nearFarMarginRatio * (viewRanges.near + viewRanges.far)) / 2;\n        viewRanges.near = Math.max(viewRanges.near - nearFarMargin / 2, this.nearMin);\n        viewRanges.far = Math.max(\n            viewRanges.far + nearFarMargin / 2,\n            viewRanges.near + nearFarMargin\n        );\n\n        // Set minimum and maximum view range.\n        viewRanges.minimum = this.nearMin;\n        viewRanges.maximum = farMax;\n\n        return viewRanges;\n    }\n\n    protected getTiltedFovBasedFarPlane(\n        d: number,\n        r: number,\n        halfFovAngle: number,\n        cameraPitch: number\n    ) {\n        // Find intersection point that is closer to tangent point.\n        //\n        //         , - ~ ~ ~ - ,\n        //     , '               ' ,\n        //   ,           .           ,\n        //  ,            .     r     ,' T1\n        // ,             .     ,  '  / ,\n        // ,             . O.'  a   /  ,\n        // ,             | .  `  . /   ,\n        //  ,            |   .  r / TA,\n        //   ,           |    .  /   ,\n        //     ,         |     ./  ,'_____ far\n        //       ' -_, _ | _ , /' T0\n        //     near      |    /\n        //               |   / t\n        //             d | /\n        //               |/\n        //               C\n        //\n        // See:\n        // tslint:disable-next-line: max-line-length\n        // https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection\n\n        // compute length of t (distance to fov intersection with sphere)\n        // with law of cosines:\n        // r = d + t - 2dt * cos(alpha)\n        // solved for t:\n        // t0 = d * cos(alpha) - sqrt(d*cos(alpha) - d + r)  <-- first intersection\n        // t1 = d * cos(alpha) + sqrt(d*cos(alpha) - d + r)  <-- second intersection\n        // Use first intersection:\n        const cosAlpha = Math.cos(cameraPitch + halfFovAngle);\n        const dSqr = d * d;\n        const t = d * cosAlpha - Math.sqrt(dSqr * cosAlpha * cosAlpha - dSqr + r * r);\n\n        assert(\n            !isNaN(t),\n            \"Field of view does not intersect sphere. Use tangent based far plane instead.\"\n        );\n\n        // project t onto camera fwd vector\n        const far = Math.cos(halfFovAngle) * t;\n\n        return far;\n    }\n\n    private getCameraPitch(cameraToOrigin: THREE.Vector3, camera: THREE.PerspectiveCamera) {\n        cameraToOrigin.normalize();\n        const lookAt = camera.getWorldDirection(this.m_tmpVectors[1]).normalize();\n        const cosAlpha1 = cameraToOrigin.dot(lookAt);\n        const cameraPitch = Math.acos(THREE.MathUtils.clamp(cosAlpha1, -1.0, 1.0));\n\n        return cameraPitch;\n    }\n}\n\n/**\n * Provides the most basic evaluation concept giving fixed values with some constraints.\n */\nexport class FixedClipPlanesEvaluator implements ClipPlanesEvaluator {\n    readonly minFar: number;\n    private m_nearPlane: number;\n    private m_farPlane: number;\n\n    constructor(readonly minNear: number = 1, readonly minFarOffset: number = 10) {\n        this.minFar = minNear + minFarOffset;\n        this.m_nearPlane = minNear;\n        this.m_farPlane = this.minFar;\n    }\n\n    get nearPlane(): number {\n        return this.m_nearPlane;\n    }\n\n    set nearPlane(fixedNear: number) {\n        this.invalidatePlanes(fixedNear, this.m_farPlane);\n    }\n\n    get farPlane(): number {\n        return this.m_farPlane;\n    }\n\n    set farPlane(fixedFar: number) {\n        this.invalidatePlanes(this.m_nearPlane, fixedFar);\n    }\n\n    // tslint:disable-next-line: no-empty\n    set minElevation(elevation: number) {}\n\n    get minElevation(): number {\n        // This evaluator does not support elevation so its always set to 0.\n        return 0;\n    }\n\n    // tslint:disable-next-line: no-empty\n    set maxElevation(elevation: number) {}\n\n    get maxElevation(): number {\n        // This evaluator does not support elevation so its always set to 0.\n        return 0;\n    }\n\n    /** @override */\n    evaluateClipPlanes(\n        camera: THREE.Camera,\n        projection: Projection,\n        elevationProvider?: ElevationProvider\n    ): ViewRanges {\n        // We do not need to perform actual evaluation cause results are precomputed and\n        // kept stable until somebody changes the properties.\n        const viewRanges: ViewRanges = {\n            near: this.m_nearPlane,\n            far: this.m_farPlane,\n            minimum: this.minNear,\n            maximum: this.m_farPlane\n        };\n        return viewRanges;\n    }\n\n    private invalidatePlanes(near: number, far: number) {\n        // When clamping prefer to extend far plane at about minimum distance, giving\n        // near distance setup priority over far.\n        const nearDist: number = Math.max(this.minNear, near);\n        const farDist: number = Math.max(this.minFar, far, nearDist + this.minFarOffset);\n        this.m_nearPlane = nearDist;\n        this.m_farPlane = farDist;\n    }\n}\n\n/**\n * Factory function that creates default {@link ClipPlanesEvaluator}\n * that calculates near plane based\n * on ground distance and camera orientation.\n *\n * Creates {@link TiltViewClipPlanesEvaluator}.\n */\nexport const createDefaultClipPlanesEvaluator = () => new TiltViewClipPlanesEvaluator();\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\n/**\n * Use `ColorCache` to reuse a color specified by name and save allocation as well as\n * setup time.\n *\n * Implemented as a singleton. Do not modify colors after getting them from the `ColorCache`.\n */\nexport class ColorCache {\n    /**\n     * Return instance of `ColorCache`.\n     */\n    static get instance() {\n        return this.m_instance;\n    }\n\n    private static m_instance: ColorCache = new ColorCache();\n    private m_map: Map<string, THREE.Color> = new Map();\n\n    /**\n     * Returns the color for the given `colorCode`. This function may reuse a previously generated\n     * color, so you cannot modify the contents of the color.\n     *\n     * @param colorCode - ThreeJS color code or name. You must provide a valid color code or name,\n     * as this function does not do any validation.\n     */\n    getColor(colorCode: string | number): THREE.Color {\n        if (typeof colorCode === \"number\") {\n            colorCode = \"#\" + colorCode.toString(16).padStart(6, \"0\");\n        }\n\n        let color = this.m_map.get(colorCode);\n        if (color !== undefined) {\n            return color;\n        }\n        color = new THREE.Color(colorCode);\n        this.m_map.set(colorCode, color);\n        return color;\n    }\n\n    /**\n     * Returns the number of elements in the cache.\n     */\n    get size(): number {\n        return this.m_map.size;\n    }\n\n    /**\n     * Clears the cache. Only references to the THREE.Color are removed from the cache.\n     * Consequently, clearing the cache does not cause any negative visual impact.\n     */\n    clear(): void {\n        this.m_map.clear();\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ITileDecoder } from \"@here/harp-datasource-protocol\";\nimport { ConcurrentWorkerSet } from \"./ConcurrentWorkerSet\";\nimport { WorkerBasedDecoder } from \"./WorkerBasedDecoder\";\n\n/**\n * Default concurrent decoder helper.\n *\n * A convenient singleton that maintains a separate [[ConcurrentWorkerSet]] for each bundle\n * requested. Provides easy access to {@link WorkerBasedDecoder}s for data sources.\n */\nexport class ConcurrentDecoderFacade {\n    /**\n     * The URL containing a script to fall back (default) to when looking for worker sets\n     * and decoders.\n     */\n    static defaultScriptUrl: string = \"./decoder.bundle.js\";\n\n    /**\n     * The default number of workers.\n     */\n    static defaultWorkerCount?: number = undefined;\n\n    /**\n     * Returns a {@link WorkerBasedDecoder} instance.\n     *\n     * @param decoderServiceType - The name of the decoder service type.\n     * @param scriptUrl - The optional URL with the workers' script.\n     * @param workerCount - The number of web workers to use.\n     */\n    static getTileDecoder(\n        decoderServiceType: string,\n        scriptUrl?: string,\n        workerCount?: number\n    ): ITileDecoder {\n        const workerSet = this.getWorkerSet(scriptUrl, workerCount);\n\n        return new WorkerBasedDecoder(workerSet, decoderServiceType);\n    }\n\n    /**\n     * Returns a [[ConcurrentWorkerSet]] instance based on the script URL specified.\n     *\n     * @param scriptUrl - The optional URL with the workers' script. If not specified,\n     * the function uses [[defaultScriptUrl]] instead.\n     * @param workerCount - The number of web workers to use.\n     */\n    static getWorkerSet(scriptUrl?: string, workerCount?: number): ConcurrentWorkerSet {\n        if (scriptUrl === undefined) {\n            scriptUrl = this.defaultScriptUrl;\n        }\n\n        let workerSet = this.workerSets[scriptUrl];\n        if (workerSet === undefined) {\n            workerSet = new ConcurrentWorkerSet({\n                scriptUrl,\n                workerCount: workerCount === undefined ? this.defaultWorkerCount : workerCount\n            });\n            this.workerSets[scriptUrl] = workerSet;\n        }\n        return workerSet;\n    }\n\n    /**\n     * Destroys a [[ConcurrentWorkerSet]] instance.\n     *\n     * @param scriptUrl - The worker script URL that was used to create the [[ConcurrentWorkerSet]].\n     */\n    static destroyWorkerSet(scriptUrl: string) {\n        const workerSet = this.workerSets[scriptUrl];\n        if (workerSet !== undefined) {\n            workerSet.destroy();\n            delete this.workerSets[scriptUrl];\n        }\n    }\n\n    /**\n     * Destroys all managed [[ConcurrentWorkerSet]]s.\n     */\n    static destroy() {\n        Object.keys(this.workerSets).forEach(name => {\n            this.workerSets[name].destroy();\n        });\n        this.workerSets = {};\n    }\n\n    /**\n     * The [[ConcurrentWorkerSet]] instances which are stored by the script URL.\n     */\n    private static workerSets: {\n        [bundleUrl: string]: ConcurrentWorkerSet;\n    } = {};\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {\n    Env,\n    Expr,\n    GeometryKind,\n    getFeatureId,\n    getPropertyValue,\n    GradientSky,\n    ImageTexture,\n    IndexedTechnique,\n    Light,\n    MapEnv,\n    PostEffects,\n    Sky,\n    Theme,\n    Value\n} from \"@here/harp-datasource-protocol\";\nimport { ViewRanges } from \"@here/harp-datasource-protocol/lib/ViewRanges\";\nimport {\n    EarthConstants,\n    GeoBox,\n    GeoBoxExtentLike,\n    GeoCoordinates,\n    GeoCoordLike,\n    isGeoBoxExtentLike,\n    isGeoCoordinatesLike,\n    isVector3Like,\n    mercatorProjection,\n    Projection,\n    ProjectionType,\n    TilingScheme,\n    Vector3Like\n} from \"@here/harp-geoutils\";\nimport {\n    assert,\n    getOptionValue,\n    LoggerManager,\n    LogLevel,\n    PerformanceTimer,\n    UriResolver\n} from \"@here/harp-utils\";\nimport * as THREE from \"three\";\nimport { AnimatedExtrusionHandler } from \"./AnimatedExtrusionHandler\";\nimport { BackgroundDataSource } from \"./BackgroundDataSource\";\nimport { CameraMovementDetector } from \"./CameraMovementDetector\";\nimport { ClipPlanesEvaluator, createDefaultClipPlanesEvaluator } from \"./ClipPlanesEvaluator\";\nimport { IMapAntialiasSettings, IMapRenderingManager, MapRenderingManager } from \"./composing\";\nimport { ConcurrentDecoderFacade } from \"./ConcurrentDecoderFacade\";\nimport { CopyrightInfo } from \"./copyrights/CopyrightInfo\";\nimport { DataSource } from \"./DataSource\";\nimport { ElevationProvider } from \"./ElevationProvider\";\nimport { ElevationRangeSource } from \"./ElevationRangeSource\";\nimport { FrustumIntersection } from \"./FrustumIntersection\";\nimport { overlayOnElevation } from \"./geometry/overlayOnElevation\";\nimport { TileGeometryManager } from \"./geometry/TileGeometryManager\";\nimport { MapViewImageCache } from \"./image/MapViewImageCache\";\nimport { MapAnchors } from \"./MapAnchors\";\nimport { MapObjectAdapter } from \"./MapObjectAdapter\";\nimport { MapViewFog } from \"./MapViewFog\";\nimport { PickHandler, PickResult } from \"./PickHandler\";\nimport { PickingRaycaster } from \"./PickingRaycaster\";\nimport { PoiManager } from \"./poi/PoiManager\";\nimport { PoiRendererFactory } from \"./poi/PoiRendererFactory\";\nimport { PoiTableManager } from \"./poi/PoiTableManager\";\nimport { PolarTileDataSource } from \"./PolarTileDataSource\";\nimport { ScreenCollisions, ScreenCollisionsDebug } from \"./ScreenCollisions\";\nimport { ScreenProjector } from \"./ScreenProjector\";\nimport { SkyBackground } from \"./SkyBackground\";\nimport { FrameStats, PerformanceStatistics } from \"./Statistics\";\nimport { FontCatalogLoader } from \"./text/FontCatalogLoader\";\nimport { MapViewState } from \"./text/MapViewState\";\nimport { TextCanvasFactory } from \"./text/TextCanvasFactory\";\nimport { TextElement } from \"./text/TextElement\";\nimport { TextElementsRenderer, ViewUpdateCallback } from \"./text/TextElementsRenderer\";\nimport { TextElementsRendererOptions } from \"./text/TextElementsRendererOptions\";\nimport { createLight } from \"./ThemeHelpers\";\nimport { ThemeLoader } from \"./ThemeLoader\";\nimport { Tile, TileFeatureData, TileObject } from \"./Tile\";\nimport { MapViewUtils } from \"./Utils\";\nimport { ResourceComputationType, VisibleTileSet, VisibleTileSetOptions } from \"./VisibleTileSet\";\n\ndeclare const process: any;\n\n// Cache value, because access to process.env.NODE_ENV is SLOW!\nconst isProduction = process.env.NODE_ENV === \"production\";\nif (isProduction) {\n    // In production: silence logging below error.\n    LoggerManager.instance.setLogLevelForAll(LogLevel.Error);\n} else {\n    // In dev: silence logging below log (silences \"debug\" and \"trace\" levels).\n    LoggerManager.instance.setLogLevelForAll(LogLevel.Log);\n}\n\nexport enum MapViewEventNames {\n    /** Called before this `MapView` starts to render a new frame. */\n    Update = \"update\",\n    /** Called when the WebGL canvas is resized. */\n    Resize = \"resize\",\n    /** Called when the frame is about to be rendered. */\n    Render = \"render\",\n    /** Called after a frame has been rendered. */\n    AfterRender = \"didrender\",\n    /** Called after the first frame has been rendered. */\n    FirstFrame = \"first-render\",\n    /** Called when the first view has all the necessary tiles loaded and rendered. */\n    FrameComplete = \"frame-complete\",\n    /** Called when the theme has been loaded with the internal {@link ThemeLoader}. */\n    ThemeLoaded = \"theme-loaded\",\n    /** Called when the animation mode has started. */\n    AnimationStarted = \"animation-started\",\n    /** Called when the animation mode has stopped. */\n    AnimationFinished = \"animation-finished\",\n    /** Called when a camera interaction has been detected. */\n    MovementStarted = \"movement-started\",\n    /** Called when a camera interaction has been stopped. */\n    MovementFinished = \"movement-finished\",\n    /** Called when a data source has been connected or failed to connect. */\n    DataSourceConnect = \"datasource-connect\",\n    /** Emitted when copyright info of rendered map has been changed. */\n    CopyrightChanged = \"copyright-changed\",\n    /** Called when the WebGL context is lost. */\n    ContextLost = \"webglcontext-lost\",\n    /** Called when the WebGL context is restored. */\n    ContextRestored = \"webglcontext-restored\",\n    /** Called when camera position has been changed. */\n    CameraPositionChanged = \"camera-changed\"\n}\n\nconst logger = LoggerManager.instance.create(\"MapView\");\nconst DEFAULT_CLEAR_COLOR = 0xefe9e1;\nconst DEFAULT_FOV_CALCULATION: FovCalculation = { type: \"dynamic\", fov: 40 };\nconst DEFAULT_CAM_NEAR_PLANE = 0.1;\nconst DEFAULT_CAM_FAR_PLANE = 4000000;\nconst MAX_FIELD_OF_VIEW = 140;\nconst MIN_FIELD_OF_VIEW = 10;\n// All objects in fallback tiles are reduced by this amount.\nexport const FALLBACK_RENDER_ORDER_OFFSET = 20000;\n\nconst DEFAULT_MIN_ZOOM_LEVEL = 1;\n\n/**\n * Default maximum zoom level.\n */\nconst DEFAULT_MAX_ZOOM_LEVEL = 20;\n\n/**\n * Default minimum camera height.\n */\nconst DEFAULT_MIN_CAMERA_HEIGHT = 20;\n\n/**\n * Style set used by {@link PolarTileDataSource} by default.\n */\nconst DEFAULT_POLAR_STYLE_SET_NAME = \"polar\";\n\n/**\n * The type of `RenderEvent`.\n */\nexport interface RenderEvent extends THREE.Event {\n    type:\n        | MapViewEventNames.Render\n        | MapViewEventNames.FirstFrame\n        | MapViewEventNames.FrameComplete\n        | MapViewEventNames.ThemeLoaded\n        | MapViewEventNames.AnimationStarted\n        | MapViewEventNames.AnimationFinished\n        | MapViewEventNames.MovementStarted\n        | MapViewEventNames.MovementFinished\n        | MapViewEventNames.ContextLost\n        | MapViewEventNames.ContextRestored\n        | MapViewEventNames.CopyrightChanged;\n    time?: number;\n}\n\n// Event type: cast needed to workaround wrong THREE.js typings.\nconst UPDATE: RenderEvent = { type: MapViewEventNames.Update } as any;\nconst RENDER_EVENT: RenderEvent = { type: MapViewEventNames.Render } as any;\nconst DID_RENDER_EVENT: RenderEvent = { type: MapViewEventNames.AfterRender } as any;\nconst FIRST_FRAME_EVENT: RenderEvent = { type: MapViewEventNames.FirstFrame } as any;\nconst FRAME_COMPLETE_EVENT: RenderEvent = { type: MapViewEventNames.FrameComplete } as any;\nconst THEME_LOADED_EVENT: RenderEvent = { type: MapViewEventNames.ThemeLoaded } as any;\nconst ANIMATION_STARTED_EVENT: RenderEvent = { type: MapViewEventNames.AnimationStarted } as any;\nconst ANIMATION_FINISHED_EVENT: RenderEvent = { type: MapViewEventNames.AnimationFinished } as any;\nconst MOVEMENT_STARTED_EVENT: RenderEvent = { type: MapViewEventNames.MovementStarted } as any;\nconst MOVEMENT_FINISHED_EVENT: RenderEvent = { type: MapViewEventNames.MovementFinished } as any;\nconst CONTEXT_LOST_EVENT: RenderEvent = { type: MapViewEventNames.ContextLost } as any;\nconst CONTEXT_RESTORED_EVENT: RenderEvent = { type: MapViewEventNames.ContextRestored } as any;\nconst COPYRIGHT_CHANGED_EVENT: RenderEvent = { type: MapViewEventNames.CopyrightChanged } as any;\n\nconst cache = {\n    vector2: [new THREE.Vector2()],\n    vector3: [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()],\n    rayCaster: new THREE.Raycaster(),\n    groundPlane: new THREE.Plane(),\n    groundSphere: new THREE.Sphere(undefined, EarthConstants.EQUATORIAL_RADIUS),\n    frustumPoints: [\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3()\n    ],\n    matrix4: [new THREE.Matrix4(), new THREE.Matrix4()],\n    transform: [\n        {\n            position: new THREE.Vector3(),\n            xAxis: new THREE.Vector3(),\n            yAxis: new THREE.Vector3(),\n            zAxis: new THREE.Vector3()\n        }\n    ]\n};\n\n/**\n * Specifies how the FOV (Field of View) should be calculated.\n */\nexport interface FovCalculation {\n    /**\n     * How to interpret the [[fov]], can be either `fixed` or `dynamic`.\n     *\n     * `fixed` means that the FOV is fixed regardless of the [[viewportHeight]], such that shrinking\n     * the height causes the map to shrink to keep the content in view. The benefit is that,\n     * regardless of any resizes, the field of view is constant, which means there is no change in\n     * the distortion of buildings near the edges. However the trade off is that the zoom level\n     * changes, which means that the map will pull in new tiles, hence causing some flickering.\n     *\n     * `dynamic` means that the focal length is calculated based on the supplied [[fov]] and\n     * [[viewportHeight]], this means that the map doesn't scale (the image is essentially cropped\n     * but not shrunk) when the [[viewportHeight]] or [[viewportWidth]] is changed. The benefit is\n     * that the zoom level is (currently) stable during resize, because the focal length is used,\n     * however the tradeoff is that changing from a small to a big height will cause the fov to\n     * change a lot, and thus introduce distortion.\n     */\n    type: \"fixed\" | \"dynamic\";\n\n    /**\n     * If [[type]] is `fixed` then the supplied [[fov]] is fixed regardless of\n     * [[viewportHeight]] or [[viewportWidth]].\n     *\n     * If [[type]] is `dynamic` then the supplied [[fov]] is applied to the\n     * first frame, and the focal length calculated. Changes to the viewport\n     * height no longer shrink the content because the field of view is updated\n     * dynamically.\n     */\n    fov: number;\n}\n\n/**\n * Hint for the WebGL implementation on which power mode to prefer.\n *\n * @see https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14.12\n */\nexport enum MapViewPowerPreference {\n    /** Default value. */\n    Default = \"default\",\n    /** Lower power mode, used to conserve energy. */\n    LowPower = \"low-power\",\n    /** Maximum performance. */\n    HighPerformance = \"high-performance\"\n}\n\n/**\n * User configuration for the {@link MapView}.\n */\nexport interface MapViewOptions extends TextElementsRendererOptions, Partial<LookAtParams> {\n    /**\n     * The canvas element used to render the scene.\n     */\n    canvas: HTMLCanvasElement;\n\n    /**\n     * Optional WebGL Rendering Context.\n     * (https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext)\n     */\n    context?: WebGLRenderingContext;\n\n    /**\n     * `true` if the canvas contains an alpha (transparency) buffer or not. Default is `false`.\n     */\n    alpha?: boolean;\n\n    /**\n     * If `true`adds a Background Mesh for each tile\n     *\n     * @default `true`\n     */\n    addBackgroundDatasource?: boolean;\n\n    /**\n     * Whether the native WebGL antialiasing should be enabled. It is better to disable it if the\n     * MapView's MSAA is enabled.\n     *\n     * @default `true` for `pixelRatio` < `2.0`, `false` otherwise.\n     */\n    enableNativeWebglAntialias?: boolean;\n\n    /**\n     * Antialias settings for the map rendering. It is better to disable the native antialising if\n     * the custom antialiasing is enabled.\n     */\n    customAntialiasSettings?: IMapAntialiasSettings;\n\n    /**\n     * `Projection` used by the `MapView`.\n     *\n     * The default value is [[mercatorProjection]].\n     */\n    projection?: Projection;\n\n    /**\n     * The URL of the script that the decoder worker runs. The default URL is\n     * `./decoder.bundle.js`.\n     *\n     * Relative URIs are resolved to full URL using the document's base URL\n     * (see: https://www.w3.org/TR/WD-html40-970917/htmlweb.html#h-5.1.2).\n     */\n    decoderUrl?: string;\n\n    /**\n     * The number of Web Workers used to decode data. The default is\n     * CLAMP(`navigator.hardwareConcurrency` - 1, 1, 2).\n     */\n    decoderCount?: number;\n\n    /**\n     * The {@link @here/harp-datasource-protocol#Theme} used by Mapview.\n     *\n     * This Theme can be one of the following:\n     *  - `string` : the URI of the theme file used to style this map\n     *  - `Theme` : the `Theme` object already loaded\n     *  - `Promise<Theme>` : the future `Theme` object\n     *  - `undefined` : the theme is not yet set up, but can be set later. Rendering waits until\n     *     the theme is set.\n     *\n     * **Note:** Layers that use a theme do not render any content until that theme is available.\n     *\n     * Relative URIs are resolved to full URL using the document's base URL\n     * (see: https://www.w3.org/TR/WD-html40-970917/htmlweb.html#h-5.1.2).\n     *\n     * Custom URIs (of theme itself and of resources referenced by theme) may be resolved with help\n     * of [[uriResolver]].\n     *\n     * @see {@link ThemeLoader.load} for details how theme is loaded\n     */\n    theme?: string | Theme | Promise<Theme>;\n\n    /**\n     * Resolve `URI` referenced in `MapView` assets using this resolver.\n     *\n     * Use, to support application/deployment specific `URI`s into actual `URLs` that can be loaded\n     * with `fetch`.\n     *\n     * Example:\n     * ```\n     * uriResolver: new PrefixMapUriResolver({\n     *     \"local://poiMasterList\": \"/assets/poiMasterList.json\",\n     *        // will match only 'local//:poiMasterList' and\n     *        // resolve to `/assets/poiMasterList.json`\n     *     \"local://icons/\": \"/assets/icons/\"\n     *        // will match only 'local//:icons/ANYPATH' (and similar) and\n     *        // resolve to `/assets/icons/ANYPATH`\n     * })\n     * ```\n     *\n     * @see {@link @here/harp-utils#UriResolver}\n     * @See {@link @here/harp-utils#PrefixMapUriResolver}\n     */\n    uriResolver?: UriResolver;\n\n    /**\n     * The minimum zoom level; default is `1`.\n     */\n    minZoomLevel?: number;\n\n    /**\n     * Determines the minimum camera height, in meters.\n     */\n    minCameraHeight?: number;\n\n    /**\n     * The maximum zoom level. The default is `14`.\n     */\n    maxZoomLevel?: number;\n\n    /**\n     * User-defined camera clipping planes distance evaluator.\n     * If not defined, {@link TiltViewClipPlanesEvaluator} will be used by {@link MapView}.\n     *\n     * @default {@link TiltViewClipPlanesEvaluator}\n     */\n    clipPlanesEvaluator?: ClipPlanesEvaluator;\n\n    /**\n     * Set to true to extend the frustum culling. This improves the rejection of some tiles, which\n     * normal frustum culling cannot detect. You can disable this property to measure performance.\n     *\n     * @default true\n     */\n    extendedFrustumCulling?: boolean;\n\n    /**\n     * The maximum number of tiles rendered from one data source at a time.\n     *\n     * @default See [[MapViewDefaults.maxVisibleDataSourceTiles]].\n     */\n    maxVisibleDataSourceTiles?: number;\n\n    /**\n     * Size of a tile cache for one data source.\n     *\n     * @default See [[MapViewDefaults.tileCacheSize]].\n     */\n    tileCacheSize?: number;\n\n    /**\n     * Specify if the cache should be counted in tiles or in megabytes.\n     *\n     * @see [[MapViewDefaults.resourceComputationType]].\n     */\n    resourceComputationType?: ResourceComputationType;\n\n    /**\n     * Limits the number of reduced zoom levels (lower detail)\n     * to be searched for fallback tiles.\n     *\n     * When zooming in, newly elected tiles may have not\n     * yet loaded. {@link MapView} searches through\n     * the tile cache for tiles ready to be displayed in\n     * lower zoom levels. The tiles may be\n     * located shallower in the quadtree.\n     *\n     * To disable a cache search, set the value to `0`.\n     *\n     * @default [[MapViewDefaults.quadTreeSearchDistanceUp]]\n     */\n    quadTreeSearchDistanceUp?: number;\n\n    /**\n     * Limits the number of higher zoom levels (more detailed)\n     * to be searched for fallback tiles.\n     *\n     * When zooming out, newly elected tiles may have not\n     * yet loaded. {@link MapView} searches through\n     * the tile cache for tiles ready to be displayed in\n     * higher zoom levels. These tiles may be\n     * located deeper in the quadtree.\n     *\n     * To disable a cache search, set the value to `0`.\n     *\n     * @default [[MapViewDefaults.quadTreeSearchDistanceDown]]\n     */\n    quadTreeSearchDistanceDown?: number;\n\n    /**\n     * Set to `true` to measure performance statistics.\n     */\n    enableStatistics?: boolean;\n\n    /**\n     * Preserve the buffers until they are cleared manually or overwritten.\n     *\n     * Set to `true` in order to copy {@link MapView} canvas contents\n     * to an image or another canvas.\n     *\n     * @default `false`.\n     * @see https://threejs.org/docs/#api/renderers/WebGLRenderer.preserveDrawingBuffer\n     */\n    preserveDrawingBuffer?: boolean;\n\n    /**\n     * @deprecated Not needed anymore, roads can be picked by default.\n     */\n    enableRoadPicking?: boolean;\n\n    /**\n     * Set to `true` to allow picking of technique information associated with objects.\n     */\n    enablePickTechnique?: boolean;\n\n    /**\n     * An optional canvas element that renders 2D collision debug information.\n     */\n    collisionDebugCanvas?: HTMLCanvasElement;\n\n    /**\n     * Maximum timeout, in milliseconds, before a [[MOVEMENT_FINISHED_EVENT]] is sent after the\n     * latest frame with a camera movement. The default is 300ms.\n     */\n    movementThrottleTimeout?: number;\n\n    /**\n     * How to calculate the Field of View, if not specified, then\n     * [[DEFAULT_FOV_CALCULATION]] is used.\n     */\n    fovCalculation?: FovCalculation;\n\n    /*\n     * An array of ISO 639-1 language codes for data sources.\n     */\n    languages?: string[];\n\n    /**\n     * Sets the data sources to use specific country point of view (political view).\n     *\n     * This option may result in rendering different country borders then commonly accepted for\n     * some regions and it mainly regards to so called __disputed borders__. Although not all\n     * data sources or themes may support it.\n     *\n     * @note Country code should be coded in lower-case ISO 3166-1 alpha-2 standard, if this option\n     * is `undefined` the majority point of view will be used.\n     */\n    politicalView?: string;\n\n    /**\n     * Set fixed pixel ratio for rendering. Useful when rendering on high resolution displays with\n     * low performance GPUs that may be fill-rate limited.\n     * @default `window.devicePixelRatio`\n     */\n    pixelRatio?: number;\n\n    /**\n     * Set fixed pixel ratio for rendering when the camera is moving or an animation is running.\n     * Useful when rendering on high resolution displays with low performance GPUs that may be\n     * fill-rate limited.\n     *\n     * If a value is specified, a low resolution render pass is used to render the scene into a\n     * low resolution render target, before it is copied to the screen.\n     *\n     * A value of `undefined` disables the low res render pass. Values between 0.5 and\n     * `window.devicePixelRatio` can be tried to give  good results. The value should not be larger\n     * than `window.devicePixelRatio`.\n     *\n     * @note Since no anti-aliasing is applied during dynamic rendering with `dynamicPixelRatio`\n     * defined, visual artifacts may occur, especially with thin lines..\n     *\n     * @note The resolution of icons and text labels is not affected.\n     *\n     * @default `undefined`\n     */\n    dynamicPixelRatio?: number;\n\n    /**\n     * Set maximum FPS (Frames Per Second). If VSync in enabled, the specified number may not be\n     * reached, but instead the next smaller number than `maxFps` that is equal to the refresh rate\n     * divided by an integer number.\n     *\n     * E.g.: If the monitors refresh rate is set to 60hz, and if `maxFps` is set to a value of `40`\n     * (60hz/1.5), the actual used FPS may be 30 (60hz/2). For displays that have a refresh rate of\n     * 60hz, good values for `maxFps` are 30, 20, 15, 12, 10, 6, 3 and 1. A value of `0` is ignored.\n     */\n    maxFps?: number;\n\n    /**\n     * Enable map repeat for planar projections.\n     * If `true`, map will be repeated in longitudinal direction continuously.\n     * If `false`, map will end on lon -180 & 180 deg.\n     *\n     * @default `true`\n     */\n    tileWrappingEnabled?: boolean;\n\n    /**\n     * Set tiling scheme for [[BackgroundDataSource]]\n     */\n    backgroundTilingScheme?: TilingScheme;\n\n    /**\n     * Should be the {@link PolarTileDataSource} used on spherical projection.\n     * Default is `true`.\n     */\n    enablePolarDataSource?: boolean;\n\n    /**\n     * The name of the [[StyleSet]] used by {@link PolarTileDataSource}\n     * to evaluate for the decoding.\n     * Default is `\"polar\"`.\n     */\n    polarStyleSetName?: string;\n\n    /**\n     * Storage level offset of regular tiles from reference datasource to align\n     * {@link PolarTileDataSource} tiles to.\n     * Default is `-1`.\n     */\n    polarGeometryLevelOffset?: number;\n\n    /**\n     * Hint for the WebGL implementation on which power mode to prefer.\n     */\n    powerPreference?: MapViewPowerPreference;\n\n    /**\n     * Set to `true` to allow rendering scene synchronously.\n     *\n     * By calling `renderSync()` scene draws immediately, opposite to default case when\n     * `update` method requests redraw and waits for the next animation frame.\n     *\n     * You need to set up your own render loop controller.\n     * Event `MapViewEventNames.Update` fired when {@link MapView} requests for an redraw.\n     * E.g.: When tiles loaded asynchronously and ready for rendering.\n     *\n     * @note Internal `maxFps` will be overridden and may not work properly as `renderSync`\n     * intended to be called from external render loop.\n     *\n     * @default false.\n     */\n    synchronousRendering?: boolean;\n\n    /**\n     * Set true to enable rendering mixed levels of detail (increases rendering performance).\n     * If not set will enable mixed levels of detail for spherical projection\n     * and disable for other projections.\n     *\n     * @default undefined\n     */\n    enableMixedLod?: boolean;\n\n    /**\n     * Enable shadows in the map. Shadows will only be casted on features that use the \"standard\"\n     * or \"extruded-polygon\" technique in the map theme.\n     * @default false\n     */\n    enableShadows?: boolean;\n}\n\n/**\n * Default settings used by {@link MapView} collected in one place.\n * @internal\n */\nconst MapViewDefaults = {\n    projection: mercatorProjection,\n    addBackgroundDatasource: true,\n\n    maxVisibleDataSourceTiles: 100,\n    extendedFrustumCulling: true,\n\n    tileCacheSize: 200,\n    resourceComputationType: ResourceComputationType.EstimationInMb,\n    quadTreeSearchDistanceUp: 3,\n    quadTreeSearchDistanceDown: 2,\n\n    pixelRatio:\n        typeof window !== \"undefined\" && window.devicePixelRatio !== undefined\n            ? window.devicePixelRatio\n            : 1.0,\n    target: new GeoCoordinates(25, 0),\n    zoomLevel: 5,\n    tilt: 0,\n    heading: 0,\n    theme: {}\n};\n\n/**\n * Parameters for {@link (MapView.lookAt:WITH_PARAMS)}.\n */\nexport interface LookAtParams {\n    /**\n     * Target/look at point of the MapView.\n     *\n     * @note If the given point is not on the ground (altitude != 0) {@link MapView} will do a\n     * raycasting internally to find a target on the ground.\n     *\n     * As a consequence {@link MapView.target} and {@link MapView.zoomLevel}\n     * will not match the values\n     * that were passed into the {@link (MapView.lookAt:WITH_PARAMS)} method.\n     * @default `new GeoCoordinates(25, 0)` in {@link MapView.constructor} context.\n     * @default {@link MapView.target} in {@link (MapView.lookAt:WITH_PARAMS)} context.\n     */\n    target: GeoCoordLike;\n\n    /**\n     * Fit MapView to these boundaries.\n     *\n     * If specified, `zoomLevel` and `distance` parameters are ignored and `lookAt` calculates best\n     * `zoomLevel` to fit given bounds.\n     *\n     * * if `bounds` is {@link @here/harp-geoutils#GeoBox}, then `lookAt`\n     *   use {@link LookAtParams.target} or `bounds.target` and\n     *   ensure whole box is visible\n     *\n     * * if `bounds` is {@link @here/harp-geoutils#GeoBoxExtentLike},\n     *   then `lookAt` will use {@link LookAtParams.target} or\n     *   current {@link MapView.target} and ensure whole extents are visible\n     *\n     * * if `bounds` is [[GeoCoordLike]][], then `lookAt` will use {@link LookAtParams.target} or\n     *   calculated `target` as center of world box covering given points and ensure all points are\n     *   visible\n     *\n     * Note in sphere projection some points are not visible if you specify bounds that span more\n     * than 180 degreess in any direction.\n     *\n     * @see {@link (MapView.lookAt:WITH_PARAMS)} for defails how `bounds`\n     *      interact with `target` parameter\n     */\n    bounds: GeoBox | GeoBoxExtentLike | GeoCoordLike[];\n\n    /**\n     * Camera distance to the target point in world units.\n     * @default zoomLevel defaults will be used if not set.\n     */\n    distance: number;\n\n    /**\n     * Zoomlevel of the MapView.\n     * @note Takes precedence over distance.\n     * @default 5 in {@link MapView.constructor} context.\n     * @default {@link MapView.zoomLevel} in {@link (MapView.lookAt:WITH_PARAMS)} context.\n     */\n    zoomLevel: number;\n\n    /**\n     * Tilt angle in degrees. 0 is top down view.\n     * @default 0 in {@link MapView.constructor} context.\n     * @default {@link MapView.tilt} in {@link (MapView.lookAt:WITH_PARAMS)} context.\n     * @note Maximum supported tilt is 89\n     */\n    tilt: number;\n\n    /**\n     * Heading angle in degrees and clockwise. 0 is north-up.\n     * @default 0 in {@link MapView.constructor} context.\n     * @default {@link MapView.heading} in {@link (MapView.lookAt:WITH_PARAMS)} context.\n     */\n    heading: number;\n}\n\n/**\n * The core class of the library to call in order to create a map visualization. It needs to be\n * linked to datasources.\n */\nexport class MapView extends THREE.EventDispatcher {\n    /**\n     * Maximum FPS (Frames Per Second). If VSync in enabled, the specified number may not be\n     * reached, but instead the next smaller number than `maxFps` that is equal to the refresh rate\n     * divided by an integer number.\n     *\n     * E.g.: If the monitors refresh rate is set to 60hz, and if `maxFps` is set to a value of `40`\n     * (60hz/1.5), the actual used FPS may be 30 (60hz/2). For displays that have a refresh rate of\n     * 60hz, good values for `maxFps` are 30, 20, 15, 12, 10, 6, 3 and 1. A value of `0` is ignored.\n     */\n    maxFps: number;\n\n    /**\n     * The instance of {@link MapRenderingManager} managing the rendering of the map. It is a public\n     * property to allow access and modification of some parameters of the rendering process at\n     * runtime.\n     */\n    readonly mapRenderingManager: IMapRenderingManager;\n\n    private m_renderLabels: boolean = true;\n\n    private m_movementFinishedUpdateTimerId?: any;\n    private m_postEffects?: PostEffects;\n\n    private m_skyBackground?: SkyBackground;\n    private m_createdLights?: THREE.Light[];\n    private m_overlayCreatedLights?: THREE.Light[];\n\n    private readonly m_screenProjector: ScreenProjector;\n    private readonly m_screenCollisions:\n        | ScreenCollisions\n        | ScreenCollisionsDebug = new ScreenCollisions();\n\n    private m_visibleTiles: VisibleTileSet;\n\n    private m_elevationSource?: DataSource;\n    private m_elevationRangeSource?: ElevationRangeSource;\n    private m_elevationProvider?: ElevationProvider;\n    private m_visibleTileSetLock: boolean = false;\n    private m_tileGeometryManager: TileGeometryManager;\n\n    private m_tileWrappingEnabled: boolean = true;\n\n    private m_zoomLevel: number = DEFAULT_MIN_ZOOM_LEVEL;\n    private m_minZoomLevel: number = DEFAULT_MIN_ZOOM_LEVEL;\n    private m_maxZoomLevel: number = DEFAULT_MAX_ZOOM_LEVEL;\n    private m_minCameraHeight: number = DEFAULT_MIN_CAMERA_HEIGHT;\n\n    private readonly m_screenCamera = new THREE.OrthographicCamera(-1, 1, 1, -1);\n\n    private readonly m_camera: THREE.PerspectiveCamera;\n\n    /**\n     * Relative to eye camera.\n     *\n     * This camera is internal camera used to improve precision\n     * when rendering geometries.\n     */\n    private readonly m_rteCamera = new THREE.PerspectiveCamera();\n\n    private m_yaw = 0;\n    private m_pitch = 0;\n    private m_roll = 0;\n    private m_focalLength = 0;\n    private m_targetDistance = 0;\n    private m_targetGeoPos = GeoCoordinates.fromObject(MapViewDefaults.target!);\n    // Focus point world coords may be calculated after setting projection, use dummy value here.\n    private m_targetWorldPos = new THREE.Vector3();\n    private readonly m_viewRanges: ViewRanges = {\n        near: DEFAULT_CAM_NEAR_PLANE,\n        far: DEFAULT_CAM_FAR_PLANE,\n        minimum: DEFAULT_CAM_NEAR_PLANE,\n        maximum: DEFAULT_CAM_FAR_PLANE\n    };\n    private m_pointOfView?: THREE.PerspectiveCamera;\n\n    private m_pixelToWorld?: number;\n    private m_pixelRatio?: number;\n\n    /** Default scene for map objects and map anchors */\n    private readonly m_scene: THREE.Scene = new THREE.Scene();\n    /** Separate scene for overlay map anchors */\n    private readonly m_overlayScene: THREE.Scene = new THREE.Scene();\n    private readonly m_fog: MapViewFog = new MapViewFog(this.m_scene);\n    /** Root node of [[m_scene]] that get's cleared every frame. */\n    private readonly m_sceneRoot = new THREE.Object3D();\n    /** Root node of [[m_overlayScene]] that get's cleared every frame. */\n    private readonly m_overlaySceneRoot = new THREE.Object3D();\n\n    private readonly m_mapAnchors: MapAnchors = new MapAnchors();\n\n    private m_animationCount: number = 0;\n    private m_animationFrameHandle: number | undefined;\n    private m_drawing: boolean = false;\n    private m_updatePending: boolean = false;\n    private m_renderer: THREE.WebGLRenderer;\n    private m_frameNumber = 0;\n\n    private m_textElementsRenderer: TextElementsRenderer;\n\n    private m_forceCameraAspect: number | undefined = undefined;\n\n    //\n    // sources\n    //\n    private readonly m_tileDataSources: DataSource[] = [];\n    private readonly m_connectedDataSources = new Set<string>();\n    private readonly m_failedDataSources = new Set<string>();\n    private m_backgroundDataSource?: BackgroundDataSource;\n    private m_polarDataSource?: PolarTileDataSource;\n    private m_enablePolarDataSource: boolean = true;\n\n    // gestures\n    private readonly m_raycaster: PickingRaycaster;\n    private readonly m_plane = new THREE.Plane(new THREE.Vector3(0, 0, 1));\n    private readonly m_sphere = new THREE.Sphere(undefined, EarthConstants.EQUATORIAL_RADIUS);\n\n    private readonly m_options: MapViewOptions;\n    private readonly m_visibleTileSetOptions: VisibleTileSetOptions;\n\n    private m_theme: Theme = {};\n    private m_uriResolver?: UriResolver;\n    private m_themeIsLoading: boolean = false;\n\n    private m_previousFrameTimeStamp?: number;\n    private m_firstFrameRendered = false;\n    private m_firstFrameComplete = false;\n    private m_initialTextPlacementDone = false;\n\n    private handleRequestAnimationFrame: (frameStartTime: number) => void;\n\n    private m_pickHandler: PickHandler;\n\n    private m_imageCache: MapViewImageCache = new MapViewImageCache(this);\n\n    private m_poiManager: PoiManager = new PoiManager(this);\n\n    private m_poiTableManager: PoiTableManager = new PoiTableManager(this);\n\n    private m_collisionDebugCanvas: HTMLCanvasElement | undefined;\n\n    // Detection of camera movement and scene change:\n    private m_movementDetector: CameraMovementDetector;\n\n    private m_thisFrameTilesChanged: boolean | undefined;\n    private m_lastTileIds: string = \"\";\n    private m_languages: string[] | undefined;\n    private m_politicalView: string | undefined;\n    private m_copyrightInfo: CopyrightInfo[] = [];\n    private m_animatedExtrusionHandler: AnimatedExtrusionHandler;\n\n    private m_env: MapEnv = new MapEnv({});\n\n    private m_enableMixedLod: boolean | undefined;\n\n    /**\n     * Constructs a new `MapView` with the given options or canvas element.\n     *\n     * @param options - The `MapView` options or the HTML canvas element used to display the map.\n     */\n    constructor(options: MapViewOptions) {\n        super();\n\n        // make a copy to avoid unwanted changes to the original options.\n        this.m_options = { ...options };\n\n        this.m_uriResolver = this.m_options.uriResolver;\n\n        if (this.m_options.minZoomLevel !== undefined) {\n            this.m_minZoomLevel = this.m_options.minZoomLevel;\n        }\n\n        if (this.m_options.maxZoomLevel !== undefined) {\n            this.m_maxZoomLevel = this.m_options.maxZoomLevel;\n        }\n\n        if (this.m_options.minCameraHeight !== undefined) {\n            this.m_minCameraHeight = this.m_options.minCameraHeight;\n        }\n\n        if (this.m_options.decoderUrl !== undefined) {\n            ConcurrentDecoderFacade.defaultScriptUrl = this.m_uriResolver\n                ? this.m_uriResolver.resolveUri(this.m_options.decoderUrl)\n                : this.m_options.decoderUrl;\n        }\n\n        if (this.m_options.decoderCount !== undefined) {\n            ConcurrentDecoderFacade.defaultWorkerCount = this.m_options.decoderCount;\n        }\n\n        this.m_visibleTileSetOptions = {\n            ...MapViewDefaults,\n            clipPlanesEvaluator:\n                options.clipPlanesEvaluator !== undefined\n                    ? options.clipPlanesEvaluator\n                    : createDefaultClipPlanesEvaluator()\n        };\n\n        if (options.projection !== undefined) {\n            this.m_visibleTileSetOptions.projection = options.projection;\n        }\n\n        if (options.extendedFrustumCulling !== undefined) {\n            this.m_visibleTileSetOptions.extendedFrustumCulling = options.extendedFrustumCulling;\n        }\n\n        if (options.maxVisibleDataSourceTiles !== undefined) {\n            this.m_visibleTileSetOptions.maxVisibleDataSourceTiles =\n                options.maxVisibleDataSourceTiles;\n        }\n\n        if (options.tileCacheSize !== undefined) {\n            this.m_visibleTileSetOptions.tileCacheSize = options.tileCacheSize;\n        }\n\n        if (options.resourceComputationType !== undefined) {\n            this.m_visibleTileSetOptions.resourceComputationType = options.resourceComputationType;\n        }\n\n        if (options.quadTreeSearchDistanceUp !== undefined) {\n            this.m_visibleTileSetOptions.quadTreeSearchDistanceUp =\n                options.quadTreeSearchDistanceUp;\n        }\n\n        if (options.quadTreeSearchDistanceDown !== undefined) {\n            this.m_visibleTileSetOptions.quadTreeSearchDistanceDown =\n                options.quadTreeSearchDistanceDown;\n        }\n\n        if (options.enablePolarDataSource !== undefined) {\n            this.m_enablePolarDataSource = options.enablePolarDataSource;\n        }\n\n        this.m_pixelRatio = options.pixelRatio;\n        this.maxFps = options.maxFps === undefined ? 0 : options.maxFps;\n\n        this.m_options.enableStatistics = this.m_options.enableStatistics === true;\n\n        this.m_languages = this.m_options.languages;\n        this.m_politicalView = this.m_options.politicalView;\n\n        if (\n            this.m_options.collisionDebugCanvas !== undefined &&\n            this.m_options.collisionDebugCanvas !== null\n        ) {\n            this.m_collisionDebugCanvas = this.m_options.collisionDebugCanvas;\n            this.m_screenCollisions = new ScreenCollisionsDebug(this.m_collisionDebugCanvas);\n        }\n\n        this.handleRequestAnimationFrame = this.renderLoop.bind(this);\n        this.m_pickHandler = new PickHandler(\n            this,\n            this.m_rteCamera,\n            this.m_options.enablePickTechnique === true\n        );\n\n        if (this.m_options.tileWrappingEnabled !== undefined) {\n            this.m_tileWrappingEnabled = this.m_options.tileWrappingEnabled;\n        }\n\n        // Initialization of the stats\n        this.setupStats(this.m_options.enableStatistics);\n\n        this.canvas.addEventListener(\"webglcontextlost\", this.onWebGLContextLost);\n        this.canvas.addEventListener(\"webglcontextrestored\", this.onWebGLContextRestored);\n\n        // Initialization of the renderer, enable backward compatibility with three.js <= 0.117\n        this.m_renderer = new ((THREE as any).WebGL1Renderer ?? THREE.WebGLRenderer)({\n            canvas: this.canvas,\n            context: this.m_options.context,\n            antialias: this.nativeWebglAntialiasEnabled,\n            alpha: this.m_options.alpha,\n            preserveDrawingBuffer: this.m_options.preserveDrawingBuffer === true,\n            powerPreference:\n                this.m_options.powerPreference === undefined\n                    ? MapViewPowerPreference.Default\n                    : this.m_options.powerPreference\n        });\n        this.m_renderer.autoClear = false;\n        this.m_renderer.debug.checkShaderErrors = !isProduction;\n\n        // This is detailed at https://threejs.org/docs/#api/renderers/WebGLRenderer.info\n        // When using several WebGLRenderer#render calls per frame, it is the only way to get\n        // correct rendering data from ThreeJS.\n        this.m_renderer.info.autoReset = false;\n\n        this.setupRenderer();\n\n        this.m_options.fovCalculation =\n            this.m_options.fovCalculation === undefined\n                ? DEFAULT_FOV_CALCULATION\n                : this.m_options.fovCalculation;\n        this.m_options.fovCalculation.fov = THREE.MathUtils.clamp(\n            this.m_options.fovCalculation!.fov,\n            MIN_FIELD_OF_VIEW,\n            MAX_FIELD_OF_VIEW\n        );\n        // Initialization of mCamera and mVisibleTiles\n        const { width, height } = this.getCanvasClientSize();\n        const aspect = width / height;\n        this.m_camera = new THREE.PerspectiveCamera(\n            this.m_options.fovCalculation.fov,\n            aspect,\n            DEFAULT_CAM_NEAR_PLANE,\n            DEFAULT_CAM_FAR_PLANE\n        );\n        this.m_camera.up.set(0, 0, 1);\n        this.projection.projectPoint(this.m_targetGeoPos, this.m_targetWorldPos);\n        this.m_scene.add(this.m_camera); // ensure the camera is added to the scene.\n        this.m_screenProjector = new ScreenProjector(this.m_camera);\n        // setup camera with initial position\n\n        this.setupCamera();\n\n        this.m_raycaster = new PickingRaycaster(width, height);\n\n        this.m_movementDetector = new CameraMovementDetector(\n            this.m_options.movementThrottleTimeout,\n            () => this.movementStarted(),\n            () => this.movementFinished()\n        );\n\n        const mapPassAntialiasSettings = this.m_options.customAntialiasSettings;\n        this.mapRenderingManager = new MapRenderingManager(\n            width,\n            height,\n            this.m_options.dynamicPixelRatio,\n            mapPassAntialiasSettings\n        );\n\n        this.m_tileGeometryManager = new TileGeometryManager(this);\n\n        if (options.enableMixedLod !== undefined) {\n            this.m_enableMixedLod = options.enableMixedLod;\n        }\n        this.m_visibleTiles = this.createVisibleTileSet();\n\n        this.m_animatedExtrusionHandler = new AnimatedExtrusionHandler(this);\n\n        if (this.m_options.addBackgroundDatasource !== false) {\n            this.m_backgroundDataSource = new BackgroundDataSource();\n            this.addDataSource(this.m_backgroundDataSource);\n        }\n\n        if (this.m_enablePolarDataSource) {\n            const styleSetName =\n                options.polarStyleSetName !== undefined\n                    ? options.polarStyleSetName\n                    : DEFAULT_POLAR_STYLE_SET_NAME;\n\n            this.m_polarDataSource = new PolarTileDataSource({\n                styleSetName,\n                geometryLevelOffset: options.polarGeometryLevelOffset\n            });\n\n            this.updatePolarDataSource();\n        }\n\n        if (\n            this.m_options.backgroundTilingScheme !== undefined &&\n            this.m_backgroundDataSource !== undefined\n        ) {\n            this.m_backgroundDataSource.setTilingScheme(this.m_options.backgroundTilingScheme);\n        }\n\n        this.initTheme();\n\n        this.m_textElementsRenderer = this.createTextRenderer();\n\n        this.update();\n    }\n\n    /**\n     * @returns The lights configured by the theme, this is just a convenience method, because the\n     * lights can still be accessed by traversing the children of the [[scene]].\n     */\n    get lights(): THREE.Light[] {\n        return this.m_createdLights ?? [];\n    }\n\n    /**\n     * @returns Whether label rendering is enabled.\n     */\n    get renderLabels() {\n        return this.m_renderLabels;\n    }\n\n    /**\n     * Enables or disables rendering of labels.\n     * @param value - `true` to enable labels `false` to disable them.\n     */\n    set renderLabels(value: boolean) {\n        this.m_renderLabels = value;\n    }\n\n    /**\n     * @returns Whether adding of new labels during interaction is enabled.\n     */\n    get delayLabelsUntilMovementFinished() {\n        return this.textElementsRenderer.delayLabelsUntilMovementFinished;\n    }\n\n    /**\n     * Enables or disables adding of  new labels during interaction. Has no influence on already\n     * placed labels\n     * @param value - `true` to enable adding `false` to disable them.\n     */\n    set delayLabelsUntilMovementFinished(value: boolean) {\n        this.textElementsRenderer.delayLabelsUntilMovementFinished = value;\n    }\n\n    /**\n     * @hidden\n     * The {@link TextElementsRenderer} select the visible {@link TextElement}s and renders them.\n     */\n    get textElementsRenderer(): TextElementsRenderer {\n        return this.m_textElementsRenderer;\n    }\n\n    /**\n     * @hidden\n     * The {@link CameraMovementDetector} detects camera movements. Made available for performance\n     * measurements.\n     */\n    get cameraMovementDetector(): CameraMovementDetector {\n        return this.m_movementDetector;\n    }\n\n    /**\n     * The {@link AnimatedExtrusionHandler} controls animated extrusion effect\n     * of the extruded objects in the {@link Tile}\n     */\n    get animatedExtrusionHandler(): AnimatedExtrusionHandler {\n        return this.m_animatedExtrusionHandler;\n    }\n\n    /**\n     * The [[TileGeometryManager]] manages geometry during loading and handles hiding geometry of\n     * specified [[GeometryKind]]s.\n     */\n    get tileGeometryManager(): TileGeometryManager | undefined {\n        return this.m_tileGeometryManager;\n    }\n\n    get enableMixedLod(): boolean | undefined {\n        return this.m_enableMixedLod;\n    }\n\n    set enableMixedLod(enableMixedLod: boolean | undefined) {\n        // Skip unnecessary update\n        if (this.m_enableMixedLod === enableMixedLod) {\n            return;\n        }\n\n        this.m_enableMixedLod = enableMixedLod;\n        this.m_visibleTiles = this.createVisibleTileSet();\n        this.resetTextRenderer();\n        this.update();\n    }\n\n    /**\n     * Disposes this `MapView`.\n     *\n     * This function cleans the resources that are managed manually including those that exist in\n     * shared caches.\n     *\n     * Note: This function does not try to clean objects that can be disposed off easily by\n     * TypeScript's garbage collecting mechanism. Consequently, if you need to perform a full\n     * cleanup, you must ensure that all references to this `MapView` are removed.\n     */\n    dispose() {\n        if (this.m_movementFinishedUpdateTimerId) {\n            clearTimeout(this.m_movementFinishedUpdateTimerId);\n            this.m_movementFinishedUpdateTimerId = undefined;\n        }\n\n        if (this.m_animationFrameHandle !== undefined) {\n            cancelAnimationFrame(this.m_animationFrameHandle);\n            this.m_animationFrameHandle = undefined;\n        }\n\n        this.canvas.removeEventListener(\"webglcontextlost\", this.onWebGLContextLost);\n        this.canvas.removeEventListener(\"webglcontextrestored\", this.onWebGLContextRestored);\n\n        for (const dataSource of this.m_tileDataSources) {\n            dataSource.dispose();\n        }\n        this.m_visibleTiles.clearTileCache();\n        this.m_textElementsRenderer.clearRenderStates();\n        this.m_renderer.dispose();\n        this.m_imageCache.clear();\n\n        this.m_movementDetector.dispose();\n    }\n\n    /**\n     * The way the cache usage is computed, either based on size in MB (mega bytes) or in number of\n     * tiles.\n     */\n    get resourceComputationType(): ResourceComputationType {\n        return this.m_visibleTiles.resourceComputationType;\n    }\n\n    set resourceComputationType(value: ResourceComputationType) {\n        this.m_visibleTiles.resourceComputationType = value;\n    }\n\n    /**\n     * Returns the cache size.\n     */\n    getCacheSize(): number {\n        return this.m_visibleTiles.getDataSourceCacheSize();\n    }\n\n    /**\n     * Sets the cache size in number of tiles.\n     *\n     * @param size - The cache size in tiles.\n     * @param numVisibleTiles - The number of tiles visible, which is size/2 by default.\n     */\n    setCacheSize(size: number, numVisibleTiles?: number): void {\n        this.m_visibleTiles.setDataSourceCacheSize(size);\n        numVisibleTiles = numVisibleTiles !== undefined ? numVisibleTiles : size / 2;\n        this.m_visibleTiles.setNumberOfVisibleTiles(Math.floor(numVisibleTiles));\n        this.updateImages();\n        this.updateLighting();\n\n        this.m_textElementsRenderer.invalidateCache();\n\n        this.updateSkyBackground();\n        this.update();\n    }\n\n    /**\n     * Specfies whether extended frustum culling is enabled or disabled.\n     */\n    get extendedFrustumCulling(): boolean {\n        return this.m_options.extendedFrustumCulling !== undefined\n            ? this.m_visibleTileSetOptions.extendedFrustumCulling\n            : true;\n    }\n\n    /**\n     * Enable of disable extended frustum culling.\n     */\n    set extendedFrustumCulling(value: boolean) {\n        this.m_visibleTileSetOptions.extendedFrustumCulling = value;\n    }\n\n    /**\n     * Returns the status of frustum culling after each update.\n     */\n    get lockVisibleTileSet(): boolean {\n        return this.m_visibleTileSetLock;\n    }\n\n    /**\n     * Enable of disable frustum culling after each update.\n     */\n    set lockVisibleTileSet(value: boolean) {\n        this.m_visibleTileSetLock = value;\n    }\n\n    /**\n     * Gets the optional camera used to render the scene.\n     */\n    get pointOfView(): THREE.PerspectiveCamera | undefined {\n        return this.m_pointOfView;\n    }\n\n    /**\n     * Sets the optional camera used to render the scene.\n     */\n    set pointOfView(pointOfView: THREE.PerspectiveCamera | undefined) {\n        this.m_pointOfView = pointOfView;\n        this.update();\n    }\n\n    /**\n     * Loads a post effects definition file.\n     *\n     * @param postEffectsFile - File URL describing the post effects.\n     */\n    loadPostEffects(postEffectsFile: string) {\n        fetch(postEffectsFile)\n            .then(response => response.json())\n            .then((postEffects: PostEffects) => {\n                this.m_postEffects = postEffects;\n                this.setPostEffects();\n            });\n    }\n\n    /**\n     * The abstraction of the {@link MapRenderingManager} API for post effects.\n     */\n    get postEffects(): PostEffects | undefined {\n        return this.m_postEffects;\n    }\n\n    set postEffects(postEffects: PostEffects | undefined) {\n        this.m_postEffects = postEffects;\n        this.setPostEffects();\n    }\n\n    /**\n     * Gets the current `Theme` used by this `MapView` to style map elements.\n     */\n    get theme(): Theme {\n        return this.m_theme;\n    }\n\n    /**\n     * Changes the `Theme` used by this `MapView` to style map elements.\n     */\n    set theme(theme: Theme) {\n        if (!ThemeLoader.isThemeLoaded(theme)) {\n            this.m_themeIsLoading = true;\n            // If theme is not yet loaded, let's set theme asynchronously\n            ThemeLoader.load(theme, { uriResolver: this.m_uriResolver })\n                .then(loadedTheme => {\n                    this.m_themeIsLoading = false;\n                    this.theme = loadedTheme;\n                })\n                .catch(error => {\n                    this.m_themeIsLoading = false;\n                    logger.error(`failed to set theme: ${error}`, error);\n                });\n            return;\n        }\n\n        // Fog and sky.\n        this.m_theme.fog = theme.fog;\n        this.m_theme.sky = theme.sky;\n        this.updateSkyBackground();\n        this.m_fog.reset(this.m_theme);\n\n        this.m_theme.lights = theme.lights;\n        this.updateLighting();\n\n        // Clear color.\n        this.m_theme.clearColor = theme.clearColor;\n        this.m_theme.clearAlpha = theme.clearAlpha;\n        this.renderer.setClearColor(new THREE.Color(theme.clearColor), theme.clearAlpha);\n        // Images.\n        this.m_theme.images = theme.images;\n        this.m_theme.imageTextures = theme.imageTextures;\n        this.updateImages();\n\n        // POI tables.\n        this.m_theme.poiTables = theme.poiTables;\n        this.loadPoiTables();\n\n        // Text.\n        this.m_theme.textStyles = theme.textStyles;\n        this.m_theme.defaultTextStyle = theme.defaultTextStyle;\n        this.m_theme.fontCatalogs = theme.fontCatalogs;\n\n        this.resetTextRenderer();\n\n        if (Array.isArray(theme.priorities)) {\n            this.m_theme.priorities = theme.priorities;\n        }\n\n        if (Array.isArray(theme.labelPriorities)) {\n            this.m_theme.labelPriorities = theme.labelPriorities;\n        }\n\n        if (this.m_theme.styles === undefined) {\n            this.m_theme.styles = {};\n        }\n        if (this.m_backgroundDataSource) {\n            this.m_backgroundDataSource.setTheme(this.m_theme);\n        }\n        this.m_theme.styles = theme.styles || {};\n        this.m_theme.definitions = theme.definitions;\n\n        for (const dataSource of this.m_tileDataSources) {\n            dataSource.setTheme(this.m_theme);\n        }\n        THEME_LOADED_EVENT.time = Date.now();\n        this.dispatchEvent(THEME_LOADED_EVENT);\n        this.update();\n    }\n\n    /**\n     * {@link @here/harp-utils#UriResolver} used to resolve application/deployment\n     * specific `URI`s into actual `URLs` that can be loaded with `fetch`.\n     */\n    get uriResolver(): UriResolver | undefined {\n        return this.m_uriResolver;\n    }\n\n    /**\n     * Gets the value of the forced custom camera aspect.\n     * Every time a frame is rendered, `MapView` resets the camera aspect.\n     *\n     * You can disable this behavior by setting the value to `undefined`.\n     */\n    get forceCameraAspect(): number | undefined {\n        return this.m_forceCameraAspect;\n    }\n\n    /**\n     * Sets the custom forced camera aspect ratio to use while rendering.\n     */\n    set forceCameraAspect(aspect: number | undefined) {\n        this.m_forceCameraAspect = aspect;\n    }\n\n    /**\n     * Lists the ISO 639-1 language codes for DataSources to use.\n     */\n    get languages(): string[] | undefined {\n        return this.m_languages;\n    }\n\n    /**\n     * Sets the list of ISO 639-1 language codes for DataSources to use.\n     */\n    set languages(languages: string[] | undefined) {\n        this.m_languages = languages;\n        this.m_tileDataSources.forEach((dataSource: DataSource) => {\n            dataSource.setLanguages(this.m_languages);\n        });\n        this.update();\n    }\n\n    /**\n     * Get currently presented political point of view - the country code.\n     *\n     * @note Country code is stored in lower-case ISO 3166-1 alpha-2 standard.\n     * @return Country code or undefined if default\n     * (majorly accepted) point of view is used.\n     */\n    get politicalView(): string | undefined {\n        return this.m_politicalView;\n    }\n\n    /**\n     * Set the political view (country code) to be used when rendering disputed features (borders).\n     *\n     * @note Country code should be encoded in lower-case ISO 3166-1 alpha-2 standard.\n     * @param pov - The code of the country which point of view should be presented,\n     * if `undefined` or empty string is set then \"defacto\" or most widely accepted point of view\n     * will be presented.\n     */\n    set politicalView(pov: string | undefined) {\n        if (this.m_politicalView === pov) {\n            return;\n        }\n        this.m_politicalView = pov;\n        this.m_tileDataSources.forEach((dataSource: DataSource) => {\n            dataSource.setPoliticalView(pov);\n        });\n    }\n\n    get copyrightInfo(): CopyrightInfo[] {\n        return this.m_copyrightInfo;\n    }\n\n    /**\n     * @hidden\n     * Disable all fading animations (for debugging and performance measurement). Defaults to\n     * `false`.\n     */\n    set disableFading(disable: boolean) {\n        this.m_textElementsRenderer.disableFading = disable;\n    }\n\n    get disableFading(): boolean {\n        return this.m_textElementsRenderer.disableFading;\n    }\n\n    /**\n     * @hidden\n     * Return current frame number.\n     */\n    get frameNumber(): number {\n        return this.m_frameNumber;\n    }\n\n    /**\n     * @hidden\n     * Reset the frame number to 0.\n     */\n    resetFrameNumber() {\n        this.m_frameNumber = 0;\n        this.m_previousFrameTimeStamp = undefined;\n    }\n\n    /**\n     * Adds an event listener. There are various events that are sent before or after a new frame\n     * is rendered.\n     *\n     * @see [[MapViewEventNames]].\n     *\n     * @example\n     * ```TypeScript\n     * let frameCount = 0;\n     * mapView.addEventListener(MapViewEventNames.Render, () => {\n     *     ++frameCount;\n     * });\n     * ```\n     *\n     * @param type - One of the [[MapViewEventNames]] strings.\n     * @param listener - The callback invoked when the `MapView` needs to render a new frame.\n     */\n    addEventListener(type: MapViewEventNames, listener: (event: RenderEvent) => void): void;\n\n    // overrides with THREE.js base classes are not recognized by tslint.\n    // tslint:disable-next-line: explicit-override\n    addEventListener(type: string, listener: any): void {\n        super.addEventListener(type, listener);\n    }\n\n    /**\n     * Removes an event listener. There are various events that are sent before or after a new frame\n     * is rendered.\n     *\n     * @see [[MapViewEventNames]].\n     *\n     * @example\n     * ```TypeScript\n     * mapView.removeEventListener(MapViewEventNames.Render, listener);\n     * ```\n     *\n     * @param type - One of the [[MapViewEventNames]] strings.\n     * @param listener - The callback invoked when the `MapView` needs to render a new frame.\n     */\n    removeEventListener(type: MapViewEventNames, listener: (event: RenderEvent) => void): void;\n\n    // overrides with THREE.js base classes are not recognized by tslint.\n    // tslint:disable-next-line: explicit-override\n    removeEventListener(type: string, listener: any): void {\n        super.removeEventListener(type, listener);\n    }\n\n    /**\n     * The HTML canvas element used by this `MapView`.\n     */\n    get canvas(): HTMLCanvasElement {\n        return this.m_options.canvas;\n    }\n\n    /**\n     * The HTML canvas element used by this `MapView`.\n     */\n    get collisionDebugCanvas(): HTMLCanvasElement | undefined {\n        return this.m_collisionDebugCanvas;\n    }\n\n    /**\n     * The THREE.js scene used by this `MapView`.\n     */\n    get scene(): THREE.Scene {\n        return this.m_scene;\n    }\n\n    /**\n     * The THREE.js camera used by this `MapView` to render the main scene.\n     * @note When modifying the camera all derived properties like:\n     * - {@link MapView.target}\n     * - {@link MapView.zoomLevel}\n     * - {@link MapView.tilt}\n     * - {@link MapView.heading}\n     * could change.\n     * These properties are cached internaly and will only be updated in the next animation frame.\n     * FIXME: Unfortunatley THREE.js is not dispatching any events when camera properties change\n     * so we should have an API for enforcing update of cached values.\n     */\n    get camera(): THREE.PerspectiveCamera {\n        return this.m_camera;\n    }\n\n    /**\n     * The THREE.js `WebGLRenderer` used by this scene.\n     */\n    get renderer(): THREE.WebGLRenderer {\n        return this.m_renderer;\n    }\n\n    /**\n     * The color used to clear the view.\n     */\n    get clearColor() {\n        const rendererClearColor = this.m_renderer.getClearColor();\n        return rendererClearColor !== undefined ? rendererClearColor.getHex() : 0;\n    }\n\n    /**\n     * The color used to clear the view.\n     */\n    set clearColor(color: number) {\n        this.m_renderer.setClearColor(color);\n    }\n\n    /**\n     * The alpha used to clear the view.\n     */\n    get clearAlpha() {\n        const rendererClearAlpha = this.m_renderer.getClearAlpha();\n        return rendererClearAlpha !== undefined ? rendererClearAlpha : 0;\n    }\n\n    /**\n     * The alpha used to clear the view.\n     */\n    set clearAlpha(alpha: number) {\n        this.m_renderer.setClearAlpha(alpha);\n    }\n\n    /**\n     * The projection used to project geo coordinates to world coordinates.\n     */\n    get projection(): Projection {\n        return this.m_visibleTileSetOptions.projection;\n    }\n\n    /**\n     * Changes the projection at run time.\n     *\n     * @param projection - The {@link @here/harp-geoutils#Projection} instance to use.\n     */\n    set projection(projection: Projection) {\n        // Remember tilt and heading before setting the projection.\n        const tilt = this.tilt;\n        const heading = this.heading;\n\n        this.m_visibleTileSetOptions.projection = projection;\n        this.updatePolarDataSource();\n        this.clearTileCache();\n        this.textElementsRenderer.clearRenderStates();\n        this.m_visibleTiles = this.createVisibleTileSet();\n\n        this.lookAtImpl({ tilt, heading });\n    }\n\n    /**\n     * Get camera clipping planes evaluator used.\n     */\n    get clipPlanesEvaluator(): ClipPlanesEvaluator {\n        return this.m_visibleTileSetOptions.clipPlanesEvaluator;\n    }\n\n    /**\n     * Changes the clip planes evaluator at run time.\n     */\n    set clipPlanesEvaluator(clipPlanesEvaluator: ClipPlanesEvaluator) {\n        this.m_visibleTileSetOptions.clipPlanesEvaluator = clipPlanesEvaluator;\n    }\n\n    /**\n     * The distance (in pixels) between the screen and the camera.\n     */\n    get focalLength(): number {\n        return this.m_focalLength;\n    }\n\n    /**\n     * Get geo coordinates of camera focus (target) point.\n     * This point is not necessarily on the ground, i.e.:\n     *  - if the tilt is high and projection is [[sphereProjection]]\n     *  - if the camera was modified directly and is not pointing to the ground.\n     * In any case the projection of the target point will be in the center of the screen.\n     *\n     * @returns geo coordinates of the camera focus point.\n     */\n    get target(): GeoCoordinates {\n        return this.m_targetGeoPos;\n    }\n\n    /** @internal\n     * Get world coordinates of camera focus point.\n     *\n     * @note The focus point coordinates are updated with each camera update so you don't need\n     * to re-calculate it, although if the camera started looking to the void, the last focus\n     * point is stored.\n     *\n     * @returns world coordinates of the camera focus point.\n     */\n    get worldTarget(): THREE.Vector3 {\n        return this.m_targetWorldPos;\n    }\n\n    /** @internal\n     * Get distance from camera to the point of focus in world units.\n     *\n     * @note If camera does not point to any ground anymore the last focus point distance is\n     * then returned.\n     *\n     * @returns Last known focus point distance.\n     */\n    get targetDistance(): number {\n        return this.m_targetDistance;\n    }\n\n    /**\n     * Get object describing frustum planes distances and min/max visibility range for actual\n     * camera setup.\n     * Near and far plane distance are self explanatory while minimum and maximum visibility range\n     * describes the extreme near/far planes distances that may be achieved with current camera\n     * settings, meaning at current zoom level (ground distance) and any possible orientation.\n     * @note Visibility is directly related to camera [[ClipPlaneEvaluator]] used and determines\n     * the maximum possible distance of camera far clipping plane regardless of tilt, but may change\n     * whenever zoom level changes. Distance is measured in world units which may be approximately\n     * equal to meters, but this depends on the distortion related to projection type used.\n     * @internal\n     */\n    get viewRanges(): ViewRanges {\n        return this.m_viewRanges;\n    }\n\n    /**\n     * The position in geo coordinates of the center of the scene.\n     * @internal\n     */\n    get geoCenter(): GeoCoordinates {\n        return this.projection.unprojectPoint(this.m_camera.position).normalized();\n    }\n\n    /**\n     * The position in geo coordinates of the center of the scene.\n     * Longitude values outside of -180 and +180 are acceptable.\n     */\n    set geoCenter(geoCenter: GeoCoordinates) {\n        if (geoCenter.altitude !== undefined) {\n            this.projection.projectPoint(geoCenter, this.m_camera.position);\n        } else {\n            // Preserve the current altitude\n            const altitude = this.geoCenter.altitude;\n\n            this.projection.projectPoint(\n                new GeoCoordinates(geoCenter.latitude, geoCenter.longitude, altitude),\n                this.m_camera.position\n            );\n        }\n\n        this.update();\n    }\n\n    /**\n     * The node in this MapView's scene containing the user [[MapAnchor]]s.\n     * All (first level) children of this node will be positioned in world space according to the\n     * [[MapAnchor.geoPosition]].\n     * Deeper level children can be used to position custom objects relative to the anchor node.\n     */\n    get mapAnchors(): MapAnchors {\n        return this.m_mapAnchors;\n    }\n\n    /**\n     * The position in world coordinates of the center of the scene.\n     */\n    get worldCenter(): THREE.Vector3 {\n        return this.m_camera.position;\n    }\n\n    /**\n     * Get the [[PickHandler]] for this `mapView`.\n     */\n    get pickHandler(): PickHandler {\n        return this.m_pickHandler;\n    }\n\n    /**\n     * Get the {@link ImageCache} that belongs to this `MapView`.\n     */\n    get imageCache(): MapViewImageCache {\n        return this.m_imageCache;\n    }\n\n    /**\n     * @hidden\n     * Get the {@link PoiManager} that belongs to this `MapView`.\n     */\n    get poiManager(): PoiManager {\n        return this.m_poiManager;\n    }\n\n    /**\n     * @hidden\n     * Get the array of {@link PoiTableManager} that belongs to this `MapView`.\n     */\n    get poiTableManager(): PoiTableManager {\n        return this.m_poiTableManager;\n    }\n\n    /**\n     * The minimum camera height in meters.\n     */\n    get minCameraHeight(): number {\n        return this.m_minCameraHeight;\n    }\n\n    /**\n     * The minimum zoom level.\n     */\n    get minZoomLevel(): number {\n        return this.m_minZoomLevel;\n    }\n\n    /**\n     * The minimum zoom level.\n     */\n    set minZoomLevel(zoomLevel: number) {\n        this.m_minZoomLevel = zoomLevel;\n        this.update();\n    }\n\n    /**\n     * The maximum zoom level. Default is 14.\n     */\n    get maxZoomLevel(): number {\n        return this.m_maxZoomLevel;\n    }\n\n    /**\n     * The maximum zoom level.\n     */\n    set maxZoomLevel(zoomLevel: number) {\n        this.m_maxZoomLevel = zoomLevel;\n        this.update();\n    }\n\n    /**\n     * Returns the zoom level for the given camera setup.\n     */\n    get zoomLevel(): number {\n        return this.m_zoomLevel;\n    }\n\n    set zoomLevel(zoomLevel: number) {\n        this.lookAtImpl({ zoomLevel });\n    }\n\n    /**\n     * Returns tilt angle in degrees.\n     */\n    get tilt(): number {\n        return THREE.MathUtils.radToDeg(this.m_pitch);\n    }\n\n    /**\n     * Set the tilt angle of the map.\n     * @param tilt -: New tilt angle in degrees.\n     */\n    set tilt(tilt: number) {\n        this.lookAtImpl({ tilt });\n    }\n\n    /**\n     * Returns heading angle in degrees.\n     */\n    get heading(): number {\n        return -THREE.MathUtils.radToDeg(this.m_yaw);\n    }\n\n    /**\n     * Set the heading angle of the map.\n     * @param heading -: New heading angle in degrees.\n     */\n    set heading(heading: number) {\n        this.lookAtImpl({ heading });\n    }\n\n    /**\n     * Environment used to evaluate dynamic scene expressions.\n     */\n    get env(): Env {\n        return this.m_env;\n    }\n\n    /**\n     * Returns the storage level for the given camera setup.\n     * Actual storage level of the rendered data also depends\n     * on {@link DataSource.storageLevelOffset}.\n     */\n    get storageLevel(): number {\n        return THREE.MathUtils.clamp(\n            Math.floor(this.m_zoomLevel),\n            this.m_minZoomLevel,\n            this.m_maxZoomLevel\n        );\n    }\n\n    /**\n     * Returns height of the viewport in pixels.\n     */\n    get viewportHeight(): number {\n        return this.canvas.height;\n    }\n\n    /**\n     * Returns `true` if the native WebGL antialiasing is enabled.\n     *\n     * @default `true` for `pixelRatio` < `2.0`, `false` otherwise.\n     */\n    get nativeWebglAntialiasEnabled(): boolean {\n        return this.m_options.enableNativeWebglAntialias === undefined\n            ? this.pixelRatio < 2.0\n            : this.m_options.enableNativeWebglAntialias;\n    }\n\n    /**\n     * Returns {@link DataSource}s displayed by this `MapView`.\n     */\n    get dataSources(): DataSource[] {\n        return this.m_tileDataSources;\n    }\n\n    /**\n     * Set's the way in which the fov is calculated on the map view. Note, for\n     * this to take visual effect, the map should be rendered after calling this\n     * function.\n     * @param fovCalculation - How the FOV is calculated.\n     */\n    setFovCalculation(fovCalculation: FovCalculation) {\n        this.m_options.fovCalculation = fovCalculation;\n        this.calculateFocalLength(this.m_renderer.getSize(cache.vector2[0]).height);\n        this.updateCameras();\n    }\n\n    /**\n     * Returns the unique {@link DataSource} matching the given name.\n     */\n    getDataSourceByName(dataSourceName: string): DataSource | undefined {\n        return this.m_tileDataSources.find(ds => ds.name === dataSourceName);\n    }\n\n    /**\n     * Returns the array of {@link DataSource}s referring to the same [[StyleSet]].\n     */\n    getDataSourcesByStyleSetName(styleSetName: string): DataSource[] {\n        return this.m_tileDataSources.filter(ds => ds.styleSetName === styleSetName);\n    }\n\n    /**\n     * Returns true if the specified {@link DataSource} is enabled.\n     */\n    isDataSourceEnabled(dataSource: DataSource): boolean {\n        return (\n            dataSource.enabled &&\n            dataSource.ready() &&\n            this.m_connectedDataSources.has(dataSource.name) &&\n            dataSource.isVisible(this.zoomLevel)\n        );\n    }\n\n    /**\n     * Adds a new {@link DataSource} to this `MapView`.\n     * `MapView` needs at least one {@link DataSource} to\n     * display something.\n     *\n     * @param dataSource - The data source.\n     */\n    addDataSource(dataSource: DataSource): Promise<void> {\n        const twinDataSource = this.getDataSourceByName(dataSource.name);\n        if (twinDataSource !== undefined) {\n            throw new Error(\n                `A DataSource with the name \"${dataSource.name}\" already exists in this MapView.`\n            );\n        }\n\n        dataSource.attach(this);\n        dataSource.setEnableElevationOverlay(this.m_elevationProvider !== undefined);\n        this.m_tileDataSources.push(dataSource);\n\n        if (this.m_backgroundDataSource) {\n            this.m_backgroundDataSource.updateStorageLevelOffset();\n        }\n\n        return dataSource\n            .connect()\n            .then(() => {\n                return new Promise(resolve => {\n                    if (this.theme !== undefined && this.theme.styles !== undefined) {\n                        resolve();\n                        return;\n                    }\n\n                    const resolveOnce = () => {\n                        this.removeEventListener(MapViewEventNames.ThemeLoaded, resolveOnce);\n                        resolve();\n                    };\n\n                    this.addEventListener(MapViewEventNames.ThemeLoaded, resolveOnce);\n                });\n            })\n            .then(() => {\n                const alreadyRemoved = this.m_tileDataSources.indexOf(dataSource) === -1;\n                if (alreadyRemoved) {\n                    return;\n                }\n                dataSource.addEventListener(MapViewEventNames.Update, () => {\n                    this.update();\n                });\n\n                dataSource.setTheme(this.m_theme);\n\n                this.m_connectedDataSources.add(dataSource.name);\n\n                this.dispatchEvent({\n                    type: MapViewEventNames.DataSourceConnect,\n                    dataSourceName: dataSource.name\n                });\n\n                this.update();\n            })\n            .catch(error => {\n                logger.error(\n                    `Failed to connect to datasource ${dataSource.name}: ${error.message}`\n                );\n\n                this.m_failedDataSources.add(dataSource.name);\n                this.dispatchEvent({\n                    type: MapViewEventNames.DataSourceConnect,\n                    dataSourceName: dataSource.name,\n                    error\n                });\n            });\n    }\n\n    /**\n     * Removes {@link DataSource} from this `MapView`.\n     *\n     * @param dataSource - The data source to be removed\n     */\n    removeDataSource(dataSource: DataSource) {\n        const dsIndex = this.m_tileDataSources.indexOf(dataSource);\n        if (dsIndex === -1) {\n            return;\n        }\n        dataSource.detach(this);\n\n        this.m_visibleTiles.removeDataSource(dataSource);\n        this.m_tileDataSources.splice(dsIndex, 1);\n        this.m_connectedDataSources.delete(dataSource.name);\n        this.m_failedDataSources.delete(dataSource.name);\n\n        if (this.m_backgroundDataSource) {\n            this.m_backgroundDataSource.updateStorageLevelOffset();\n        }\n\n        this.update();\n    }\n\n    /**\n     * Access the `VisibleTileSet` to get access to all current datasources and their visible tiles.\n     */\n    get visibleTileSet(): VisibleTileSet {\n        return this.m_visibleTiles;\n    }\n\n    /**\n     * Adds new overlay text elements to this `MapView`.\n     *\n     * @param textElements - Array of {@link TextElement} to be added.\n     */\n    addOverlayText(textElements: TextElement[]): void {\n        this.m_textElementsRenderer.addOverlayText(textElements);\n        this.update();\n    }\n\n    /**\n     * Adds new overlay text elements to this `MapView`.\n     *\n     * @param textElements - Array of {@link TextElement} to be added.\n     */\n    clearOverlayText(): void {\n        this.m_textElementsRenderer.clearOverlayText();\n    }\n\n    // tslint:disable: max-line-length\n    /**\n     * Adjusts the camera to look at a given geo coordinate with tilt and heading angles.\n     *\n     * #### Note on `target` and `bounds`\n     *\n     * If `bounds` are specified, `zoomLevel` and `distance` parameters are ignored and `lookAt`\n     * calculates best zoomLevel (and possibly target) to fit given bounds.\n     *\n     * Following table shows how relation between `bounds` and target.\n     *\n     * | `bounds`             | `target`    | actual `target`\n     * | ------               | ------      | --------\n     * | {@link @here/harp-geoutils#GeoBox}           | _defined_   | `params.target` is used\n     * | {@link @here/harp-geoutils#GeoBox}           | `undefined` | `bounds.center` is used as new `target`\n     * | {@link @here/harp-geoutils#GeoBoxExtentLike} | `undefined` | current `MapView.target` is used\n     * | {@link @here/harp-geoutils#GeoBoxExtentLike} | _defined_   | `params.target` is used\n     * | [[GeoCoordLike]][]   | `undefined` | new `target` is calculated as center of world box covering given points\n     * | [[GeoCoordLike]][]   | _defined_   | `params.target` is used and zoomLevel is adjusted to view all given geo points\n     *\n     * In each case, `lookAt` finds minimum `zoomLevel` that covers given extents or geo points.\n     *\n     * With flat projection, if `bounds` represents points on both sides of antimeridian, and\n     * {@link MapViewOptions.tileWrappingEnabled} is used, `lookAt` will use this knowledge and find\n     * minimal view that may cover \"next\" or \"previous\" world.\n     *\n     * With sphere projection if `bounds` represents points on both sides of globe, best effort\n     * method is used to find best `target``.\n     *\n     * #### Examples\n     *\n     * ```\n     * mapView.lookAt({heading: 90})\n     *     // look east retaining current `target`, `zoomLevel` and `tilt`\n     *\n     * mapView.lookAt({lat: 40.707, lng: -74.01})\n     *    // look at Manhattan, New York retaining other view params\n     *\n     * mapView.lookAt(bounds: { latitudeSpan: 10, longitudeSpan: 10})\n     *    // look at current `target`, but extending zoomLevel so we see 10 degrees of lat/long span\n     * ```\n     *\n     * @see More examples in [[LookAtExample]].\n     *\n     * @param params - {@link LookAtParams}\n     *\n     * {@labels WITH_PARAMS}\n     */\n    lookAt(params: Partial<LookAtParams>): void;\n    // tslint:enable: max-line-length\n\n    /**\n     * The method that sets the camera to the desired angle (`tiltDeg`) and `distance` (in meters)\n     * to the `target` location, from a certain heading (`headingAngle`).\n     *\n     * @param target - The location to look at.\n     * @param distance - The distance of the camera to the target in meters.\n     * @param tiltDeg - The camera tilt angle in degrees (0 is vertical), curbed below 89deg\n     *                @default 0\n     * @param headingDeg - The camera heading angle in degrees and clockwise (as opposed to yaw)\n     *                   @default 0\n     * starting north.\n     * @deprecated Use lookAt version with {@link LookAtParams} object parameter.\n     */\n    lookAt(target: GeoCoordLike, distance: number, tiltDeg?: number, headingDeg?: number): void;\n\n    lookAt(\n        targetOrParams: GeoCoordLike | Partial<LookAtParams>,\n        distance?: number,\n        tiltDeg?: number,\n        headingDeg?: number\n    ): void {\n        if (isGeoCoordinatesLike(targetOrParams)) {\n            const zoomLevel =\n                distance !== undefined\n                    ? MapViewUtils.calculateZoomLevelFromDistance(this, distance)\n                    : undefined;\n\n            const params: Partial<LookAtParams> = {\n                target: targetOrParams,\n                zoomLevel,\n                tilt: tiltDeg,\n                heading: headingDeg\n            };\n            this.lookAtImpl(params);\n        } else if (typeof targetOrParams === \"object\") {\n            this.lookAtImpl(targetOrParams as Partial<LookAtParams>);\n        }\n    }\n\n    /**\n     * Moves the camera to the specified {@link @here/harp-geoutils#GeoCoordinates},\n     * sets the desired `zoomLevel` and\n     * adjusts the yaw and pitch. The pitch of the camera is\n     * always curbed so that the camera cannot\n     * look above the horizon. This paradigm is necessary\n     * in {@link @here/harp-map-controls#MapControls}, where the center of\n     * the screen is used for the orbiting interaction (3 fingers / right mouse button).\n     *\n     * @param geoPos - Geolocation to move the camera to.\n     * @param zoomLevel - Desired zoom level.\n     * @param yawDeg - Camera yaw in degrees, counter-clockwise (as opposed to heading), starting\n     * north.\n     * @param pitchDeg - Camera pitch in degrees.\n     * @deprecated Use {@link (MapView.lookAt:WITH_PARAMS)} instead.\n     */\n    setCameraGeolocationAndZoom(\n        geoPos: GeoCoordinates,\n        zoomLevel: number,\n        yawDeg: number = 0,\n        pitchDeg: number = 0\n    ): void {\n        this.geoCenter = geoPos;\n        let limitedPitch = Math.min(MapViewUtils.MAX_TILT_DEG, pitchDeg);\n        if (this.projection.type === ProjectionType.Spherical) {\n            const maxPitchRadWithCurvature = Math.asin(\n                EarthConstants.EQUATORIAL_RADIUS /\n                    (MapViewUtils.calculateDistanceToGroundFromZoomLevel(this, zoomLevel) +\n                        EarthConstants.EQUATORIAL_RADIUS)\n            );\n            const maxPitchDegWithCurvature = THREE.MathUtils.radToDeg(maxPitchRadWithCurvature);\n            limitedPitch = Math.min(limitedPitch, maxPitchDegWithCurvature);\n        }\n        MapViewUtils.zoomOnTargetPosition(this, 0, 0, zoomLevel);\n        MapViewUtils.setRotation(this, yawDeg, limitedPitch);\n        this.update();\n    }\n\n    /**\n     * Updates the value of a dynamic property.\n     *\n     * Property names starting with a `$`-sign are reserved and any attempt to change their value\n     * will result in an error.\n     *\n     * Themes can access dynamic properties using the `Expr` operator `[\"dynamic-properties\"]`,\n     * for example:\n     *\n     *   `[\"get\", \"property name\", [\"dynamic-properties\"]]`\n     *\n     * @param name - The name of the property.\n     * @param value - The value of the property.\n     */\n    setDynamicProperty(name: string, value: Value) {\n        if (name.startsWith(\"$\")) {\n            throw new Error(`failed to update the value of the dynamic property '${name}'`);\n        }\n        this.m_env.entries[name] = value;\n        this.update();\n    }\n\n    /**\n     * Removes the given dynamic property from this {@link MapView}.\n     *\n     * Property names starting with a `$`-sign are reserved and any attempt to change their value\n     * will result in an error.\n     *\n     * @param name - The name of the property to remove.\n     */\n    removeDynamicProperty(name: string) {\n        if (name.startsWith(\"$\")) {\n            throw new Error(`failed to remove the dynamic property '${name}'`);\n        }\n        delete this.m_env.entries[name];\n        this.update();\n    }\n\n    /**\n     * Returns `true` if this `MapView` is constantly redrawing the scene.\n     */\n    get animating(): boolean {\n        return this.m_animationCount > 0;\n    }\n\n    /**\n     * Begin animating the scene.\n     */\n    beginAnimation() {\n        if (this.m_animationCount++ === 0) {\n            this.update();\n            ANIMATION_STARTED_EVENT.time = Date.now();\n            this.dispatchEvent(ANIMATION_STARTED_EVENT);\n        }\n    }\n\n    /**\n     * Stop animating the scene.\n     */\n    endAnimation() {\n        if (this.m_animationCount > 0) {\n            --this.m_animationCount;\n        }\n\n        if (this.m_animationCount === 0) {\n            ANIMATION_FINISHED_EVENT.time = Date.now();\n            this.dispatchEvent(ANIMATION_FINISHED_EVENT);\n        }\n    }\n\n    /**\n     * Returns `true` if the camera moved in the last frame.\n     */\n    get cameraIsMoving() {\n        return this.m_movementDetector.cameraIsMoving;\n    }\n\n    /**\n     * Returns `true` if the current frame will immediately be followed by another frame.\n     */\n    get isDynamicFrame(): boolean {\n        return (\n            this.cameraIsMoving ||\n            this.animating ||\n            this.m_updatePending ||\n            this.m_animatedExtrusionHandler.isAnimating\n        );\n    }\n\n    /**\n     * Returns the ratio between a pixel and a world unit for the current camera (in the center of\n     * the camera projection).\n     */\n    get pixelToWorld(): number {\n        if (this.m_pixelToWorld === undefined) {\n            // At this point fov calculation should be always defined.\n            assert(this.m_options.fovCalculation !== undefined);\n            // NOTE: Look at distance is the distance to camera focus (and pivot) point.\n            // In screen space this point is located in the center of canvas.\n            // Given that zoom level is not modified (clamped by camera pitch), the following\n            // formulas are all equivalent:\n            // lookAtDistance = (EQUATORIAL_CIRCUMFERENCE * focalLength) / (256 * zoomLevel^2);\n            // lookAtDistance = abs(cameraPos.z) / cos(cameraPitch);\n            // Here we may use precalculated target distance (once pre frame):\n            const lookAtDistance = this.m_targetDistance;\n\n            // Find world space object size that corresponds to one pixel on screen.\n            this.m_pixelToWorld = MapViewUtils.calculateWorldSizeByFocalLength(\n                this.m_focalLength,\n                lookAtDistance,\n                1\n            );\n        }\n        return this.m_pixelToWorld;\n    }\n\n    /**\n     * Returns the ratio between a world and a pixel unit for the current camera (in the center of\n     * the camera projection).\n     */\n    get worldToPixel() {\n        return 1.0 / this.pixelToWorld;\n    }\n\n    get pixelRatio(): number {\n        if (this.m_pixelRatio !== undefined) {\n            return this.m_pixelRatio;\n        }\n        return typeof window !== \"undefined\" && window.devicePixelRatio !== undefined\n            ? window.devicePixelRatio\n            : 1.0;\n    }\n\n    /**\n     * PixelRatio in the WebGlRenderer. May contain values > 1.0 for high resolution screens\n     * (HiDPI).\n     *\n     * A value of `undefined` will make the getter return `window.devicePixelRatio`, setting a value\n     * of `1.0` will disable the use of HiDPI on all devices.\n     *\n     * @note Since the current pixelRatio may have been used in some calculations (e.g. the icons)\n     * they may appear in the wrong size now. To ensure proper display of data, a call to\n     * `clearTileCache()` is required if the pixelRatio is changed after tiles have been loaded.\n     *\n     * @memberof MapView\n     */\n    set pixelRatio(pixelRatio: number) {\n        this.m_pixelRatio = pixelRatio;\n        if (this.renderer.getPixelRatio() !== this.pixelRatio) {\n            this.renderer.setPixelRatio(this.pixelRatio);\n        }\n    }\n\n    /**\n     * PixelRatio ratio for rendering when the camera is moving or an animation is running. Useful\n     * when rendering on high resolution displays with low performance GPUs that may be\n     * fill-rate-limited.\n     *\n     * If a value is specified, a low resolution render pass is used to render the scene into a\n     * low resolution render target, before it is copied to the screen.\n     *\n     * A value of `undefined` disables the low res render pass. Values between 0.5 and\n     * `window.devicePixelRatio` can be tried to give  good results. The value should not be larger\n     * than `window.devicePixelRatio`.\n     *\n     * @note Since no anti-aliasing is applied during dynamic rendering with `dynamicPixelRatio`\n     * defined, visual artifacts may occur, especially with thin lines..\n     *\n     * @note The resolution of icons and text labels is not affected.\n     *\n     * @default `undefined`\n     */\n    set dynamicPixelRatio(ratio: number | undefined) {\n        this.mapRenderingManager.lowResPixelRatio = ratio;\n    }\n\n    get dynamicPixelRatio(): number | undefined {\n        return this.mapRenderingManager.lowResPixelRatio;\n    }\n\n    /**\n     * Returns the screen position of the given geo or world position.\n     *\n     * @param pos - The position as a {@link @here/harp-geoutils#GeoCoordLike} or\n     * {@link https://threejs.org/docs/#api/en/math/Vector3 | THREE.Vector3} world position.\n     * @returns The screen position in CSS/client coordinates (no pixel ratio applied) or\n     * `undefined`.\n     */\n    getScreenPosition(pos: GeoCoordLike | THREE.Vector3): THREE.Vector2 | undefined {\n        if (isVector3Like(pos)) {\n            cache.vector3[0].copy(pos);\n        } else {\n            this.projection.projectPoint(GeoCoordinates.fromObject(pos), cache.vector3[0]);\n        }\n        const p = this.m_screenProjector.project(cache.vector3[0]);\n        if (p !== undefined) {\n            const { width, height } = this.getCanvasClientSize();\n            p.x = p.x + width / 2;\n            p.y = height - (p.y + height / 2);\n        }\n        return p;\n    }\n\n    /**\n     * Returns a ray caster using the supplied screen positions.\n     *\n     * @param x - The X position in css/client coordinates (without applied display ratio).\n     * @param y - The Y position in css/client coordinates (without applied display ratio).\n     *\n     * @alpha\n     *\n     * @return Raycaster with origin at the camera and direction based on the supplied x / y screen\n     * points.\n     */\n    raycasterFromScreenPoint(x: number, y: number): THREE.Raycaster {\n        this.m_raycaster.setFromCamera(this.getNormalizedScreenCoordinates(x, y), this.m_rteCamera);\n        return this.m_raycaster;\n    }\n\n    /**\n     * Returns the world space position from the given screen position. The return value can be\n     * `null`, in case the camera is facing the horizon and the given `(x, y)` value is not\n     * intersecting the ground plane.\n     *\n     * @param x - The X position in css/client coordinates (without applied display ratio).\n     * @param y - The Y position in css/client coordinates (without applied display ratio).\n     */\n    getWorldPositionAt(x: number, y: number): THREE.Vector3 | null {\n        this.m_raycaster.setFromCamera(this.getNormalizedScreenCoordinates(x, y), this.m_camera);\n        return this.projection.type === ProjectionType.Spherical\n            ? this.m_raycaster.ray.intersectSphere(this.m_sphere, cache.vector3[0])\n            : this.m_raycaster.ray.intersectPlane(this.m_plane, cache.vector3[0]);\n    }\n\n    /**\n     * Returns the {@link @here/harp-geoutils#GeoCoordinates} from the\n     * given screen position. The return value can be\n     * `null`, in case the camera is facing the horizon and\n     * the given `(x, y)` value is not\n     * intersecting the ground plane.\n     *\n     * @param x - The X position in css/client coordinates (without applied display ratio).\n     * @param y - The Y position in css/client coordinates (without applied display ratio).\n     */\n    getGeoCoordinatesAt(x: number, y: number): GeoCoordinates | null {\n        const worldPosition = this.getWorldPositionAt(x, y);\n        if (!worldPosition) {\n            return null;\n        }\n        return this.projection.unprojectPoint(worldPosition);\n    }\n\n    /**\n     * Returns the normalized screen coordinates from the given pixel position.\n     *\n     * @param x - The X position in css/client coordinates (without applied display ratio).\n     * @param y - The Y position in css/client coordinates (without applied display ratio).\n     */\n    getNormalizedScreenCoordinates(x: number, y: number): THREE.Vector3 {\n        // use clientWidth and clientHeight as it does not apply the pixelRatio and\n        // therefore supports also HiDPI devices\n        const { width, height } = this.getCanvasClientSize();\n        return new THREE.Vector3((x / width) * 2 - 1, -((y / height) * 2) + 1, 0);\n    }\n\n    /**\n     * Do a raycast on all objects in the scene. Useful for picking. Limited to objects that\n     * THREE.js can raycast, the solid lines that get their geometry in the shader cannot be tested\n     * for intersection.\n     *\n     * Note, if a {@link DataSource} adds an [[Object3D]]\n     * to a {@link Tile}, it will be only pickable once\n     * {@link MapView.render} has been called, this is because\n     * {@link MapView.render} method creates the\n     * internal three.js root [[Object3D]] which is used in the [[PickHandler]] internally.\n     * This method will not test for intersection custom objects added to the scene by for\n     * example calling directly the [[scene.add]] method from THREE.\n     *\n     * @param x - The X position in css/client coordinates (without applied display ratio).\n     * @param y - The Y position in css/client coordinates (without applied display ratio).\n     * @returns The list of intersection results.\n     */\n    intersectMapObjects(x: number, y: number): PickResult[] {\n        return this.m_pickHandler.intersectMapObjects(x, y);\n    }\n\n    /**\n     * Resize the HTML canvas element and the THREE.js `WebGLRenderer`.\n     *\n     * @param width - The new width.\n     * @param height - The new height.\n     */\n    resize(width: number, height: number) {\n        this.m_renderer.setSize(width, height, false);\n        if (this.m_renderer.getPixelRatio() !== this.pixelRatio) {\n            this.m_renderer.setPixelRatio(this.pixelRatio);\n        }\n\n        if (this.mapRenderingManager !== undefined) {\n            this.mapRenderingManager.setSize(width, height);\n        }\n\n        if (this.collisionDebugCanvas !== undefined) {\n            this.collisionDebugCanvas.width = width;\n            this.collisionDebugCanvas.height = height;\n        }\n\n        this.updateCameras();\n        this.update();\n\n        this.dispatchEvent({\n            type: MapViewEventNames.Resize,\n            size: {\n                width,\n                height\n            }\n        });\n    }\n\n    /**\n     * Redraws scene immediately\n     *\n     * @note Before using this method, set `synchronousRendering` to `true`\n     * in the {@link MapViewOptions}\n     *\n     * @param frameStartTime - Optional timestamp for start of frame.\n     * Default: [[PerformanceTimer.now()]]\n     */\n    renderSync(frameStartTime?: number) {\n        if (frameStartTime === undefined) {\n            frameStartTime = PerformanceTimer.now();\n        }\n        this.render(frameStartTime);\n    }\n\n    /**\n     * Requests a redraw of the scene.\n     */\n    update() {\n        this.dispatchEvent(UPDATE);\n\n        // Skip if update is already in progress\n        if (this.m_updatePending) {\n            return;\n        }\n\n        // Set update flag\n        this.m_updatePending = true;\n\n        this.startRenderLoop();\n    }\n\n    /**\n     * Returns `true` if an update has already been requested, such that after a currently rendering\n     * frame, the next frame will be rendered immediately.\n     */\n    get updatePending(): boolean {\n        return this.m_updatePending;\n    }\n\n    /**\n     * Requests a redraw of the scene.\n     * @deprecated Use the [[update]] method instead.\n     */\n    requestUpdateIfNeeded() {\n        this.update();\n    }\n\n    /**\n     * Clear the tile cache.\n     *\n     * Remove the {@link Tile} objects created by cacheable\n     * {@link DataSource}s. If a {@link DataSource} name is\n     * provided, this method restricts the eviction the {@link DataSource} with the given name.\n     *\n     * @param dataSourceName - The name of the {@link DataSource}.\n     */\n    clearTileCache(dataSourceName?: string) {\n        if (this.m_visibleTiles === undefined) {\n            // This method is called in the shadowsEnabled function, which is initialized in the\n            // setupRenderer function,\n            return;\n        }\n        if (dataSourceName !== undefined) {\n            const dataSource = this.getDataSourceByName(dataSourceName);\n            if (dataSource) {\n                this.m_visibleTiles.clearTileCache(dataSource);\n                dataSource.clearCache();\n            }\n        } else {\n            this.m_visibleTiles.clearTileCache();\n            this.m_tileDataSources.forEach(dataSource => dataSource.clearCache());\n        }\n\n        if (this.m_elevationProvider !== undefined) {\n            this.m_elevationProvider.clearCache();\n        }\n    }\n\n    /**\n     * Apply visitor to all visible tiles.\n     *\n     * @param fun - Visitor function\n     */\n    forEachVisibleTile(fun: (tile: Tile) => void) {\n        this.m_visibleTiles.forEachVisibleTile(fun);\n    }\n\n    /**\n     * Apply a visitor function to all tiles in the cache.\n     *\n     * @param visitor - Visitor function\n     */\n    forEachCachedTile(visitor: (tile: Tile) => void) {\n        this.m_visibleTiles.forEachCachedTile(visitor);\n    }\n\n    /**\n     * Visit each tile in visible, rendered, and cached sets.\n     *\n     *  * Visible and temporarily rendered tiles will be marked for update and retained.\n     *  * Cached but not rendered/visible will be evicted.\n     *\n     * @param dataSource - If passed, only the tiles from this {@link DataSource} instance\n     * are processed. If `undefined`, tiles from all {@link DataSource}s are processed.\n     */\n    markTilesDirty(dataSource?: DataSource) {\n        this.m_visibleTiles.markTilesDirty(dataSource);\n    }\n\n    /**\n     * Sets the DataSource which contains the elevations, the elevation range source, and the\n     * elevation provider. Only a single elevation source is possible per {@link MapView}\n     *\n     * If the terrain-datasource is merged with this repository, we could internally construct\n     * the {@link ElevationRangeSource} and the {@link ElevationProvider}\n     * and access would be granted to\n     * the application when it asks for it, to simplify the API.\n     *\n     * @param elevationSource - The datasource containing the terrain tiles.\n     * @param elevationRangeSource - Allows access to the elevation min / max per tile.\n     * @param elevationProvider - Allows access to the elevation at a given location or a ray\n     *      from the camera.\n     */\n    async setElevationSource(\n        elevationSource: DataSource,\n        elevationRangeSource: ElevationRangeSource,\n        elevationProvider: ElevationProvider\n    ) {\n        // Remove previous elevation source if present\n        if (this.m_elevationSource && this.m_elevationSource !== elevationSource) {\n            this.removeDataSource(this.m_elevationSource);\n        }\n\n        // Add as datasource if it was not added before\n        const isPresent = this.m_tileDataSources.indexOf(elevationSource) !== -1;\n        if (!isPresent) {\n            await this.addDataSource(elevationSource);\n        }\n        this.m_elevationSource = elevationSource;\n        this.m_elevationRangeSource = elevationRangeSource;\n        if (!this.m_elevationRangeSource.ready()) {\n            await this.m_elevationRangeSource.connect();\n        }\n        this.m_elevationProvider = elevationProvider;\n        this.dataSources.forEach(dataSource => {\n            dataSource.setEnableElevationOverlay(true);\n        });\n        this.m_tileGeometryManager.setTileUpdateCallback((tile: Tile) => {\n            overlayOnElevation(tile);\n        });\n        this.clearTileCache();\n    }\n\n    /**\n     * Clears any elevation sources and provider previously set.\n     * @param elevationSource - The datasource to be cleared.\n     */\n    clearElevationSource(elevationSource: DataSource) {\n        this.removeDataSource(elevationSource);\n        this.m_elevationSource = undefined;\n        this.m_elevationRangeSource = undefined;\n        this.m_elevationProvider = undefined;\n        this.dataSources.forEach(dataSource => {\n            dataSource.setEnableElevationOverlay(false);\n        });\n        this.m_tileGeometryManager.setTileUpdateCallback(undefined);\n        this.clearTileCache();\n    }\n\n    /**\n     * Public access to {@link MapViewFog} allowing to toggle it by setting its `enabled` property.\n     */\n    get fog(): MapViewFog {\n        return this.m_fog;\n    }\n\n    private setPostEffects() {\n        // First clear all the effects, then enable them from what is specified.\n        this.mapRenderingManager.bloom.enabled = false;\n        this.mapRenderingManager.outline.enabled = false;\n        this.mapRenderingManager.vignette.enabled = false;\n        this.mapRenderingManager.sepia.enabled = false;\n\n        if (this.m_postEffects !== undefined) {\n            if (this.m_postEffects.bloom !== undefined) {\n                this.mapRenderingManager.bloom = this.m_postEffects.bloom;\n            }\n            if (this.m_postEffects.outline !== undefined) {\n                this.mapRenderingManager.outline.enabled = this.m_postEffects.outline.enabled;\n                this.mapRenderingManager.updateOutline(this.m_postEffects.outline);\n            }\n            if (this.m_postEffects.vignette !== undefined) {\n                this.mapRenderingManager.vignette = this.m_postEffects.vignette;\n            }\n            if (this.m_postEffects.sepia !== undefined) {\n                this.mapRenderingManager.sepia = this.m_postEffects.sepia;\n            }\n        }\n    }\n\n    /**\n     * Returns the elevation provider.\n     */\n    get elevationProvider(): ElevationProvider | undefined {\n        return this.m_elevationProvider;\n    }\n\n    get shadowsEnabled(): boolean {\n        return this.m_options.enableShadows === true;\n    }\n\n    set shadowsEnabled(enabled: boolean) {\n        // shadowMap is undefined if we are testing (three.js always set it to be defined).\n        if (\n            this.m_renderer.shadowMap === undefined ||\n            enabled === this.m_renderer.shadowMap.enabled\n        ) {\n            return;\n        }\n        this.m_options.enableShadows = enabled;\n        // There is a bug in three.js where this doesn't currently work once enabled.\n        this.m_renderer.shadowMap.enabled = enabled;\n        // TODO: Make this configurable. Note, there is currently issues when using the\n        // VSMShadowMap type, this should be investigated if this type is requested.\n        this.m_renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n        this.clearTileCache();\n    }\n\n    private extractAttitude() {\n        const camera = this.m_camera;\n        const projection = this.projection;\n\n        const cameraPos = cache.vector3[1];\n        const transform = cache.transform[0];\n        const tangentSpaceMatrix = cache.matrix4[1];\n        // 1. Build the matrix of the tangent space of the camera.\n        cameraPos.setFromMatrixPosition(camera.matrixWorld); // Ensure using world position.\n        projection.localTangentSpace(this.m_targetGeoPos, transform);\n        tangentSpaceMatrix.makeBasis(transform.xAxis, transform.yAxis, transform.zAxis);\n\n        // 2. Change the basis of matrixWorld to the tangent space to get the new base axes.\n        cache.matrix4[0].getInverse(tangentSpaceMatrix).multiply(camera.matrixWorld);\n        transform.xAxis.setFromMatrixColumn(cache.matrix4[0], 0);\n        transform.yAxis.setFromMatrixColumn(cache.matrix4[0], 1);\n        transform.zAxis.setFromMatrixColumn(cache.matrix4[0], 2);\n\n        // 3. Deduce orientation from the base axes.\n        let yaw = 0;\n        let pitch = 0;\n        let roll = 0;\n\n        // Decompose rotation matrix into Z0 X Z1 Euler angles.\n        const epsilon = 1e-10;\n        const d = transform.zAxis.dot(cameraPos.set(0, 0, 1));\n        if (d < 1.0 - epsilon) {\n            if (d > -1.0 + epsilon) {\n                yaw = Math.atan2(transform.zAxis.x, -transform.zAxis.y);\n                pitch = Math.acos(transform.zAxis.z);\n                roll = Math.atan2(transform.xAxis.x, transform.yAxis.z);\n            } else {\n                // Looking bottom-up with space.z.z == -1.0\n                yaw = -Math.atan2(-transform.yAxis.x, transform.xAxis.x);\n                pitch = 180;\n                roll = 0;\n            }\n        } else {\n            // Looking top-down with space.z.z == 1.0\n            yaw = Math.atan2(-transform.yAxis.x, transform.xAxis.x);\n            pitch = 0.0;\n            roll = 0.0;\n        }\n\n        return {\n            yaw,\n            pitch,\n            roll\n        };\n    }\n\n    private lookAtImpl(params: Partial<LookAtParams>): void {\n        const tilt = Math.min(getOptionValue(params.tilt, this.tilt), MapViewUtils.MAX_TILT_DEG);\n        const heading = getOptionValue(params.heading, this.heading);\n\n        let target: GeoCoordinates | undefined;\n        if (params.bounds !== undefined) {\n            let geoPoints: GeoCoordLike[];\n\n            if (params.bounds instanceof GeoBox) {\n                target = params.target\n                    ? GeoCoordinates.fromObject(params.target)\n                    : params.bounds.center;\n                geoPoints = MapViewUtils.geoBoxToGeoPoints(params.bounds);\n            } else if (isGeoBoxExtentLike(params.bounds)) {\n                target = params.target ? GeoCoordinates.fromObject(params.target) : this.target;\n                const box = GeoBox.fromCenterAndExtents(target, params.bounds);\n                geoPoints = MapViewUtils.geoBoxToGeoPoints(box);\n            } else if (Array.isArray(params.bounds)) {\n                geoPoints = params.bounds;\n                if (params.target !== undefined) {\n                    target = GeoCoordinates.fromObject(params.target);\n                }\n            } else {\n                throw Error(\"#lookAt: Invalid 'bounds' value\");\n            }\n            if (this.m_tileWrappingEnabled && this.projection.type === ProjectionType.Planar) {\n                // In flat projection, with wrap around enabled, we should detect clusters of\n                // points around  antimeridian and possible move some points to sibling worlds.\n                //\n                // Here, we fit points into minimal geo box taking world wrapping into account.\n                geoPoints = MapViewUtils.wrapGeoPointsToScreen(geoPoints, target!);\n            }\n            const worldPoints = geoPoints.map(point =>\n                this.projection.projectPoint(GeoCoordinates.fromObject(point), new THREE.Vector3())\n            );\n            const worldTarget = new THREE.Vector3();\n            if (target! === undefined) {\n                const box = new THREE.Box3().setFromPoints(worldPoints);\n                box.getCenter(worldTarget);\n                this.projection.scalePointToSurface(worldTarget);\n                target = this.projection.unprojectPoint(worldTarget);\n            } else {\n                this.projection.projectPoint(target, worldTarget);\n            }\n            return this.lookAtImpl(\n                MapViewUtils.getFitBoundsLookAtParams(target, worldTarget, worldPoints, {\n                    tilt,\n                    heading,\n                    minDistance: MapViewUtils.calculateDistanceFromZoomLevel(\n                        this,\n                        this.maxZoomLevel\n                    ),\n                    projection: this.projection,\n                    camera: this.camera\n                })\n            );\n        }\n        target =\n            params.target !== undefined ? GeoCoordinates.fromObject(params.target) : this.target;\n\n        const distance =\n            params.zoomLevel !== undefined\n                ? MapViewUtils.calculateDistanceFromZoomLevel(\n                      this,\n                      THREE.MathUtils.clamp(\n                          params.zoomLevel,\n                          this.m_minZoomLevel,\n                          this.m_maxZoomLevel\n                      )\n                  )\n                : params.distance !== undefined\n                ? params.distance\n                : this.m_targetDistance;\n\n        // MapViewUtils#setRotation uses pitch, not tilt, which is different in sphere projection.\n        // But in sphere, in the tangent space of the target of the camera, pitch = tilt. So, put\n        // the camera on the target, so the tilt can be passed to getRotation as a pitch.\n        MapViewUtils.getCameraRotationAtTarget(\n            this.projection,\n            target,\n            -heading,\n            tilt,\n            this.camera.quaternion\n        );\n        MapViewUtils.getCameraPositionFromTargetCoordinates(\n            target,\n            distance,\n            -heading,\n            tilt,\n            this.projection,\n            this.camera.position\n        );\n        this.camera.updateMatrixWorld(true);\n\n        // Make sure to update all properties that are accessable via API (e.g. zoomlevel) b/c\n        // otherwise they would be updated as recently as in the next animation frame.\n        this.updateLookAtSettings();\n        this.update();\n    }\n\n    /**\n     * Plug-in PolarTileDataSource for spherical projection and plug-out otherwise\n     */\n    private updatePolarDataSource() {\n        const dataSource = this.m_polarDataSource;\n        if (this.m_enablePolarDataSource === true && dataSource !== undefined) {\n            const twinDataSource = this.getDataSourceByName(dataSource.name);\n\n            if (this.projection.type === ProjectionType.Spherical) {\n                if (twinDataSource === undefined) {\n                    this.addDataSource(dataSource);\n                }\n            } else {\n                if (twinDataSource !== undefined) {\n                    this.removeDataSource(dataSource);\n                }\n            }\n        }\n    }\n\n    /**\n     * Updates the camera and the projections and resets the screen collisions,\n     * note, setupCamera must be called before this is called.\n     * @param viewRanges - optional parameter that supplies new view ranges, most importantly\n     * near/far clipping planes distance. If parameter is not provided view ranges will be\n     * calculated from [[ClipPlaneEvaluator]] used in {@link VisibleTileSet}.\n     */\n    private updateCameras(viewRanges?: ViewRanges) {\n        // Update look at settings first, so that other components (e.g. ClipPlanesEvaluator) get\n        // the up to date tilt, targetDistance, ...\n        this.m_camera.updateMatrixWorld(false);\n        this.updateLookAtSettings();\n\n        const { width, height } = this.m_renderer.getSize(cache.vector2[0]);\n        this.m_camera.aspect =\n            this.m_forceCameraAspect !== undefined ? this.m_forceCameraAspect : width / height;\n        this.setFovOnCamera(this.m_options.fovCalculation!, height);\n\n        // When calculating clip planes account for the highest building on the earth,\n        // multiplying its height by projection scaling factor. This approach assumes\n        // constantHeight property of extruded polygon technique is set as default false,\n        // otherwise the near plane margins will be bigger then required, but still correct.\n        const projectionScale = this.projection.getScaleFactor(this.camera.position);\n        const maxGeometryHeightScaled =\n            projectionScale *\n            this.m_tileDataSources.reduce((r, ds) => Math.max(r, ds.maxGeometryHeight), 0);\n\n        // Copy all properties from new view ranges to our readonly object.\n        // This allows to keep all view ranges references valid and keeps up-to-date\n        // information within them. Works the same as copping all properties one-by-one.\n        Object.assign(\n            this.m_viewRanges,\n            viewRanges === undefined\n                ? this.m_visibleTiles.updateClipPlanes(maxGeometryHeightScaled)\n                : viewRanges\n        );\n        this.m_camera.near = this.m_viewRanges.near;\n        this.m_camera.far = this.m_viewRanges.far;\n\n        this.m_camera.updateProjectionMatrix();\n\n        // Update the \"relative to eye\" camera. Copy the public camera parameters\n        // and place the \"relative to eye\" at the world's origin.\n        this.m_rteCamera.copy(this.m_camera);\n        this.m_rteCamera.position.setScalar(0);\n        this.m_rteCamera.updateMatrixWorld(true);\n\n        this.m_screenCamera.left = width / -2;\n        this.m_screenCamera.right = width / 2;\n        this.m_screenCamera.bottom = height / -2;\n        this.m_screenCamera.top = height / 2;\n        this.m_screenCamera.updateProjectionMatrix();\n        this.m_screenCamera.updateMatrixWorld(false);\n\n        this.m_screenProjector.update(this.camera, width, height);\n        this.m_screenCollisions.update(width, height);\n\n        this.m_pixelToWorld = undefined;\n        this.m_fog.update(this, this.m_viewRanges.maximum);\n    }\n\n    /**\n     * Derive the look at settings (i.e. target, zoom, ...) from the current camera.\n     */\n    private updateLookAtSettings() {\n        // tslint:disable-next-line: deprecation\n        const { target, distance } = MapViewUtils.getTargetAndDistance(\n            this.projection,\n            this.camera,\n            this.elevationProvider\n        );\n\n        this.m_targetWorldPos.copy(target);\n        this.m_targetGeoPos = this.projection.unprojectPoint(this.m_targetWorldPos);\n        this.m_targetDistance = distance;\n        this.m_zoomLevel = MapViewUtils.calculateZoomLevelFromDistance(this, this.m_targetDistance);\n\n        const { yaw, pitch, roll } = this.extractAttitude();\n        this.m_yaw = yaw;\n        this.m_pitch = pitch;\n        this.m_roll = roll;\n    }\n\n    /**\n     * Update `Env` instance used for style `Expr` evaluations.\n     */\n    private updateEnv() {\n        this.m_env.entries.$zoom = this.m_zoomLevel;\n\n        // This one introduces unnecessary calculation of pixelToWorld, even if it's barely\n        // used in our styles.\n        this.m_env.entries.$pixelToMeters = this.pixelToWorld;\n\n        this.m_env.entries.$frameNumber = this.m_frameNumber;\n    }\n\n    /**\n     * Transfer the NDC point to view space.\n     * @param vector - Vector to transform.\n     * @param result - Result to place calculation.\n     */\n    private ndcToView(vector: Vector3Like, result: THREE.Vector3): THREE.Vector3 {\n        result\n            .set(vector.x, vector.y, vector.z)\n            .applyMatrix4(this.camera.projectionMatrixInverse)\n            // Make sure to apply rotation, hence use the rte camera\n            .applyMatrix4(this.m_rteCamera.matrixWorld);\n        return result;\n    }\n\n    /**\n     * Transfer from view space to camera space.\n     * @param viewPos - position in view space, result is stored here.\n     */\n    private viewToLightSpace(viewPos: THREE.Vector3, camera: THREE.Camera): THREE.Vector3 {\n        return viewPos.applyMatrix4(camera.matrixWorldInverse);\n    }\n\n    /**\n     * Update the directional light camera. Note, this requires the cameras to first be updated.\n     */\n    private updateLights() {\n        // TODO: HARP-9479 Globe doesn't support shadows.\n        if (\n            !this.shadowsEnabled ||\n            this.projection.type === ProjectionType.Spherical ||\n            this.m_createdLights === undefined ||\n            this.m_createdLights.length === 0\n        ) {\n            return;\n        }\n\n        const points: Vector3Like[] = [\n            // near plane points\n            { x: -1, y: -1, z: -1 },\n            { x: 1, y: -1, z: -1 },\n            { x: -1, y: 1, z: -1 },\n            { x: 1, y: 1, z: -1 },\n\n            // far planes points\n            { x: -1, y: -1, z: 1 },\n            { x: 1, y: -1, z: 1 },\n            { x: -1, y: 1, z: 1 },\n            { x: 1, y: 1, z: 1 }\n        ];\n        const transformedPoints = points.map((p, i) => this.ndcToView(p, cache.frustumPoints[i]));\n\n        this.m_createdLights.forEach(element => {\n            const directionalLight = element as THREE.DirectionalLight;\n            if (directionalLight.isDirectionalLight === true) {\n                const lightDirection = cache.vector3[0];\n                lightDirection.copy(directionalLight.target.position);\n                lightDirection.sub(directionalLight.position);\n                lightDirection.normalize();\n\n                const normal = cache.vector3[1];\n                if (this.projection.type === ProjectionType.Planar) {\n                    // -Z points to the camera, we can't use Projection.surfaceNormal, because\n                    // webmercator and mercator give different results.\n                    normal.set(0, 0, -1);\n                } else {\n                    // Enable shadows for globe...\n                    //this.projection.surfaceNormal(target, normal);\n                }\n\n                // The camera of the shadow has the same height as the map camera, and the target is\n                // also the same. The position is then calculated based on the light direction and\n                // the height\n                // using basic trigonometry.\n                const tilt = this.m_pitch;\n                const cameraHeight = this.targetDistance * Math.cos(tilt);\n                const lightPosHyp = cameraHeight / normal.dot(lightDirection);\n\n                directionalLight.target.position.copy(this.worldTarget).sub(this.camera.position);\n                directionalLight.position.copy(this.worldTarget);\n                directionalLight.position.addScaledVector(lightDirection, -lightPosHyp);\n                directionalLight.position.sub(this.camera.position);\n                directionalLight.updateMatrixWorld();\n                directionalLight.shadow.updateMatrices(directionalLight);\n\n                const camera = directionalLight.shadow.camera;\n                const pointsInLightSpace = transformedPoints.map(p =>\n                    this.viewToLightSpace(p.clone(), camera)\n                );\n\n                const box = new THREE.Box3();\n                pointsInLightSpace.forEach(point => {\n                    box.expandByPoint(point);\n                });\n                camera.left = box.min.x;\n                camera.right = box.max.x;\n                camera.top = box.max.y;\n                camera.bottom = box.min.y;\n                // Moving back to the light the near plane in order to catch high buildings, that\n                // are not visible by the camera, but existing on the scene.\n                camera.near = -box.max.z * 0.95;\n                camera.far = -box.min.z;\n                camera.updateProjectionMatrix();\n            }\n        });\n    }\n\n    /**\n     * Render loop callback that should only be called by [[requestAnimationFrame]].\n     * Will trigger [[requestAnimationFrame]] again if updates are pending or  animation is running.\n     * @param frameStartTime - The start time of the current frame\n     */\n    private renderLoop(frameStartTime: number) {\n        // Render loop shouldn't run when synchronous rendering is enabled\n        if (this.m_options.synchronousRendering) {\n            return;\n        }\n\n        if (this.maxFps === 0) {\n            // Render with max fps\n            this.render(frameStartTime);\n        } else {\n            // Limit fps by skipping frames\n\n            // Magic ingredient to compensate time flux.\n            const fudgeTimeInMs = 3;\n            const frameInterval = 1000 / this.maxFps;\n            const previousFrameTime =\n                this.m_previousFrameTimeStamp === undefined ? 0 : this.m_previousFrameTimeStamp;\n            const targetTime = previousFrameTime + frameInterval - fudgeTimeInMs;\n\n            if (frameStartTime >= targetTime) {\n                this.render(frameStartTime);\n            }\n        }\n\n        // Continue rendering if update is pending or animation is running\n        // tslint:disable-next-line: prefer-conditional-expression\n        if (this.m_updatePending || this.animating) {\n            this.m_animationFrameHandle = requestAnimationFrame(this.handleRequestAnimationFrame);\n        } else {\n            // Stop rendering if no update is pending\n            this.m_animationFrameHandle = undefined;\n        }\n    }\n\n    /**\n     * Start render loop if not already running.\n     */\n    private startRenderLoop() {\n        if (this.m_animationFrameHandle !== undefined || this.m_options.synchronousRendering) {\n            return;\n        }\n\n        this.m_animationFrameHandle = requestAnimationFrame(this.handleRequestAnimationFrame);\n    }\n\n    /**\n     * Returns the list of the enabled data sources.\n     */\n    private getEnabledTileDataSources(): DataSource[] {\n        // ### build this list once decoders && datasources are ready\n\n        const enabledDataSources: DataSource[] = [];\n\n        for (const dataSource of this.m_tileDataSources) {\n            if (this.isDataSourceEnabled(dataSource)) {\n                enabledDataSources.push(dataSource);\n            }\n        }\n\n        return enabledDataSources;\n    }\n\n    /**\n     * Renders the current frame.\n     */\n    private render(frameStartTime: number): void {\n        if (this.m_drawing) {\n            return;\n        }\n\n        RENDER_EVENT.time = frameStartTime;\n        this.dispatchEvent(RENDER_EVENT);\n\n        ++this.m_frameNumber;\n\n        let currentFrameEvent: FrameStats | undefined;\n        const stats = PerformanceStatistics.instance;\n        const gatherStatistics: boolean = stats.enabled;\n        if (gatherStatistics) {\n            currentFrameEvent = stats.currentFrame;\n\n            if (this.m_previousFrameTimeStamp !== undefined) {\n                // In contrast to fullFrameTime we also measure the application code\n                // for the FPS. This means FPS != 1000 / fullFrameTime.\n                const timeSincePreviousFrame = frameStartTime - this.m_previousFrameTimeStamp;\n                currentFrameEvent.setValue(\"render.fps\", 1000 / timeSincePreviousFrame);\n            }\n\n            // We store the last frame statistics at the beginning of the next frame b/c additional\n            // work (i.e. geometry creation) is done outside of the animation frame but still needs\n            // to be added to the `fullFrameTime` (see [[TileGeometryLoader]]).\n            stats.storeAndClearFrameInfo();\n\n            currentFrameEvent = currentFrameEvent as FrameStats;\n            currentFrameEvent.setValue(\"renderCount.frameNumber\", this.m_frameNumber);\n        }\n\n        this.m_previousFrameTimeStamp = frameStartTime;\n\n        let setupTime: number | undefined;\n        let cullTime: number | undefined;\n        let textPlacementTime: number | undefined;\n        let drawTime: number | undefined;\n        let textDrawTime: number | undefined;\n        let endTime: number | undefined;\n\n        this.m_renderer.info.reset();\n\n        this.m_updatePending = false;\n        this.m_thisFrameTilesChanged = undefined;\n\n        this.m_drawing = true;\n\n        if (this.m_renderer.getPixelRatio() !== this.pixelRatio) {\n            this.m_renderer.setPixelRatio(this.pixelRatio);\n        }\n\n        this.updateCameras();\n        this.updateEnv();\n        this.updateLights();\n\n        this.m_renderer.clear();\n\n        // clear the scenes\n        this.m_sceneRoot.children.length = 0;\n        this.m_overlaySceneRoot.children.length = 0;\n\n        if (gatherStatistics) {\n            setupTime = PerformanceTimer.now();\n        }\n\n        // TBD: Update renderList only any of its params (camera, etc...) has changed.\n        if (!this.lockVisibleTileSet) {\n            const viewRangesStatus = this.m_visibleTiles.updateRenderList(\n                this.storageLevel,\n                Math.floor(this.zoomLevel),\n                this.getEnabledTileDataSources(),\n                this.m_elevationRangeSource\n            );\n            // View ranges has changed due to features (with elevation) that affects clip planes\n            // positioning, update cameras with new clip planes positions.\n            if (viewRangesStatus.viewRangesChanged) {\n                this.updateCameras(viewRangesStatus.viewRanges);\n            }\n        }\n\n        if (gatherStatistics) {\n            cullTime = PerformanceTimer.now();\n        }\n\n        const renderList = this.m_visibleTiles.dataSourceTileList;\n\n        // no need to check everything if we're not going to create text renderer.\n        renderList.forEach(({ zoomLevel, renderedTiles }) => {\n            renderedTiles.forEach(tile => {\n                this.renderTileObjects(tile, zoomLevel);\n\n                //We know that rendered tiles are visible (in the view frustum), so we update the\n                //frame number, note we don't do this for the visibleTiles because some may still be\n                //loading (and therefore aren't visible in the sense of being seen on the screen).\n                //Note also, this number isn't currently used anywhere so should be considered to be\n                //removed in the future (though could be good for debugging purposes).\n                tile.frameNumLastVisible = this.m_frameNumber;\n            });\n        });\n\n        // Check if this is the time to place the labels for the first time. Pretty much everything\n        // should have been loaded, and no animation should be running.\n        if (\n            !this.m_initialTextPlacementDone &&\n            !this.m_firstFrameComplete &&\n            !this.isDynamicFrame &&\n            !this.m_themeIsLoading &&\n            this.m_poiTableManager.finishedLoading &&\n            this.m_visibleTiles.allVisibleTilesLoaded &&\n            this.m_connectedDataSources.size + this.m_failedDataSources.size ===\n                this.m_tileDataSources.length &&\n            !this.m_textElementsRenderer.initializing &&\n            !this.m_textElementsRenderer.loading\n        ) {\n            this.m_initialTextPlacementDone = true;\n        }\n\n        this.m_mapAnchors.update(\n            this.projection,\n            this.camera.position,\n            this.m_sceneRoot,\n            this.m_overlaySceneRoot,\n            this.m_theme.priorities\n        );\n\n        this.m_animatedExtrusionHandler.update(this.zoomLevel);\n\n        if (currentFrameEvent !== undefined) {\n            // Make sure the counters all have a value.\n            currentFrameEvent.addValue(\"renderCount.numTilesRendered\", 0);\n            currentFrameEvent.addValue(\"renderCount.numTilesVisible\", 0);\n            currentFrameEvent.addValue(\"renderCount.numTilesLoading\", 0);\n\n            // Increment the counters for all data sources.\n            renderList.forEach(({ zoomLevel, renderedTiles, visibleTiles, numTilesLoading }) => {\n                currentFrameEvent!.addValue(\"renderCount.numTilesRendered\", renderedTiles.size);\n                currentFrameEvent!.addValue(\"renderCount.numTilesVisible\", visibleTiles.length);\n                currentFrameEvent!.addValue(\"renderCount.numTilesLoading\", numTilesLoading);\n            });\n        }\n\n        if (this.m_movementDetector.checkCameraMoved(this, frameStartTime)) {\n            //FIXME: Shouldn't we use target here?\n            const { latitude, longitude, altitude } = this.geoCenter;\n            this.dispatchEvent({\n                type: MapViewEventNames.CameraPositionChanged,\n                latitude,\n                longitude,\n                altitude,\n                // FIXME: Can we remove yaw, pitch and roll\n                yaw: this.m_yaw,\n                pitch: this.m_pitch,\n                roll: this.m_roll,\n                tilt: this.tilt,\n                heading: this.heading,\n                zoom: this.zoomLevel\n            });\n        }\n\n        // The camera used to render the scene.\n        const camera = this.m_pointOfView !== undefined ? this.m_pointOfView : this.m_rteCamera;\n\n        if (this.renderLabels) {\n            this.prepareRenderTextElements(frameStartTime);\n        }\n\n        if (gatherStatistics) {\n            textPlacementTime = PerformanceTimer.now();\n        }\n        if (this.m_skyBackground !== undefined && this.projection.type === ProjectionType.Planar) {\n            this.m_skyBackground.updateCamera(this.m_camera);\n        }\n\n        this.mapRenderingManager.render(\n            this.m_renderer,\n            this.m_scene,\n            camera,\n            !this.isDynamicFrame\n        );\n\n        if (gatherStatistics) {\n            drawTime = PerformanceTimer.now();\n        }\n\n        if (this.renderLabels) {\n            this.finishRenderTextElements();\n        }\n\n        if (this.m_overlaySceneRoot.children.length > 0) {\n            this.m_renderer.render(this.m_overlayScene, camera);\n        }\n\n        if (gatherStatistics) {\n            textDrawTime = PerformanceTimer.now();\n        }\n\n        if (!this.m_firstFrameRendered) {\n            this.m_firstFrameRendered = true;\n\n            if (gatherStatistics) {\n                stats.appResults.set(\"firstFrame\", frameStartTime);\n            }\n\n            FIRST_FRAME_EVENT.time = frameStartTime;\n            this.dispatchEvent(FIRST_FRAME_EVENT);\n        }\n\n        this.m_visibleTiles.disposePendingTiles();\n\n        this.m_drawing = false;\n\n        this.checkCopyrightUpdates();\n\n        if (currentFrameEvent !== undefined) {\n            endTime = PerformanceTimer.now();\n\n            const frameRenderTime = endTime - frameStartTime;\n\n            currentFrameEvent.setValue(\"render.setupTime\", setupTime! - frameStartTime);\n            currentFrameEvent.setValue(\"render.cullTime\", cullTime! - setupTime!);\n            currentFrameEvent.setValue(\"render.textPlacementTime\", textPlacementTime! - cullTime!);\n            currentFrameEvent.setValue(\"render.drawTime\", drawTime! - textPlacementTime!);\n            currentFrameEvent.setValue(\"render.textDrawTime\", textDrawTime! - drawTime!);\n            currentFrameEvent.setValue(\"render.cleanupTime\", endTime - textDrawTime!);\n            currentFrameEvent.setValue(\"render.frameRenderTime\", frameRenderTime);\n\n            // Initialize the fullFrameTime with the frameRenderTime If we also create geometry in\n            // this frame, this number will be increased in the TileGeometryLoader.\n            currentFrameEvent.setValue(\"render.fullFrameTime\", frameRenderTime);\n            currentFrameEvent.setValue(\"render.geometryCreationTime\", 0);\n\n            // Add THREE.js statistics\n            stats.addWebGLInfo(this.m_renderer.info);\n\n            // Add memory statistics\n            // FIXME:\n            // This will only measure the memory of the rendering and not of the geometry creation.\n            // Assuming the garbage collector is not kicking in immediately we will at least see\n            // the geometry creation memory consumption acounted in the next frame.\n            stats.addMemoryInfo();\n        }\n\n        DID_RENDER_EVENT.time = frameStartTime;\n        this.dispatchEvent(DID_RENDER_EVENT);\n\n        // After completely rendering this frame, it is checked if this frame was the first complete\n        // frame, with no more tiles, geometry and labels waiting to be added, and no animation\n        // running. The initial placement of text in this render call may have changed the loading\n        // state of the TextElementsRenderer, so this has to be checked again.\n        if (\n            !this.m_firstFrameComplete &&\n            this.m_initialTextPlacementDone &&\n            !this.isDynamicFrame &&\n            !this.textElementsRenderer.loading\n        ) {\n            this.m_firstFrameComplete = true;\n\n            if (gatherStatistics) {\n                stats.appResults.set(\"firstFrameComplete\", frameStartTime);\n            }\n\n            FRAME_COMPLETE_EVENT.time = frameStartTime;\n            this.dispatchEvent(FRAME_COMPLETE_EVENT);\n        }\n    }\n\n    private renderTileObjects(tile: Tile, zoomLevel: number) {\n        const worldOffsetX = tile.computeWorldOffsetX();\n        if (tile.willRender(zoomLevel)) {\n            for (const object of tile.objects) {\n                const mapObjectAdapter = MapObjectAdapter.get(object);\n                if (!this.processTileObject(tile, object, mapObjectAdapter)) {\n                    continue;\n                }\n                object.position.copy(tile.center);\n                if (object.displacement !== undefined) {\n                    object.position.add(object.displacement);\n                }\n                object.position.x += worldOffsetX;\n                object.position.sub(this.m_camera.position);\n                if (tile.localTangentSpace) {\n                    object.setRotationFromMatrix(tile.boundingBox.getRotationMatrix());\n                }\n                object.frustumCulled = false;\n                if (object._backupRenderOrder === undefined) {\n                    object._backupRenderOrder = object.renderOrder;\n                }\n\n                const isBuilding = mapObjectAdapter?.kind?.includes(GeometryKind.Building);\n\n                // When falling back to a parent tile (i.e. tile.levelOffset < 0) there will\n                // be overlaps with the already loaded tiles. Therefore all (flat) objects\n                // in a fallback tile must be shifted, such that their renderOrder is less\n                // than the groundPlane that each neighbouring Tile has (it has a renderOrder\n                // of -10000, see addGroundPlane in TileGeometryCreator), only then can we be\n                // sure that nothing of the parent will be rendered on top of the children,\n                // as such, we shift using the FALLBACK_RENDER_ORDER_OFFSET.\n                // This does not apply to buildings b/c they are 3d and the overlaps\n                // are resolved with a depth prepass. Note we set this always to ensure that if\n                // the Tile is used as a fallback, and then used normally, that we have the correct\n                // renderOrder.\n                object.renderOrder =\n                    object._backupRenderOrder +\n                    (!isBuilding && tile.levelOffset < 0\n                        ? FALLBACK_RENDER_ORDER_OFFSET * tile.levelOffset\n                        : 0);\n\n                this.m_sceneRoot.add(object);\n            }\n            tile.didRender();\n        }\n    }\n\n    /**\n     * Process dynamic updates of [[TileObject]]'s style.\n     *\n     * @returns `true` if object shall be used in scene, `false` otherwise\n     */\n    private processTileObject(tile: Tile, object: TileObject, mapObjectAdapter?: MapObjectAdapter) {\n        if (!object.visible) {\n            return false;\n        }\n        if (!this.processTileObjectFeatures(tile, object)) {\n            return false;\n        }\n\n        if (mapObjectAdapter) {\n            mapObjectAdapter.ensureUpdated(this);\n            if (!mapObjectAdapter.isVisible()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Process the features owned by the given [[TileObject]].\n     *\n     * @param tile - The {@link Tile} owning the [[TileObject]]'s features.\n     * @param object - The [[TileObject]] to process.\n     * @returns `false` if the given [[TileObject]] should not be added to the scene.\n     */\n    private processTileObjectFeatures(tile: Tile, object: TileObject): boolean {\n        const technique: IndexedTechnique = object.userData.technique;\n\n        if (!technique || technique.enabled === undefined) {\n            // Nothing to do, there's no technique.\n            return true;\n        }\n\n        const feature: TileFeatureData = object.userData.feature;\n\n        if (!feature || !Expr.isExpr(technique.enabled)) {\n            return Boolean(getPropertyValue(technique.enabled, this.m_env));\n        }\n\n        const { starts, objInfos } = feature;\n\n        if (!Array.isArray(objInfos) || !Array.isArray(starts)) {\n            // Nothing to do, the object is missing feature ids and their position\n            // in the index buffer.\n            return true;\n        }\n\n        const geometry: THREE.BufferGeometry | undefined = (object as any).geometry;\n\n        if (!geometry || !geometry.isBufferGeometry) {\n            // Nothing to do, the geometry is not a [[THREE.BufferGeometry]]\n            // and we can't generate groups.\n            return true;\n        }\n\n        const index = geometry.getIndex()!;\n\n        // clear the groups.\n        geometry.clearGroups();\n\n        // The offset in the index buffer of the end of the last\n        // pushed group.\n        let endOfLastGroup: number | undefined;\n\n        objInfos.forEach((properties, featureIndex) => {\n            // the id of the current feature.\n            const featureId = getFeatureId(properties);\n\n            let enabled = true;\n\n            if (Expr.isExpr(technique.enabled)) {\n                // the state of current feature.\n                const featureState = tile.dataSource.getFeatureState(featureId);\n\n                // create a new {@link @here/harp-datasource-protocol#Env} that can be used\n                // to evaluate expressions that access the feature state.\n                const $state = featureState ? new MapEnv(featureState) : null;\n\n                const parentEnv =\n                    typeof properties === \"object\"\n                        ? new MapEnv(properties, this.m_env)\n                        : this.m_env;\n\n                const env = new MapEnv({ $state }, parentEnv);\n\n                enabled = Boolean(getPropertyValue(technique.enabled, env));\n            }\n\n            if (!enabled) {\n                // skip this feature, it was disabled.\n                return;\n            }\n\n            const start = starts[featureIndex];\n            const end = starts[featureIndex + 1] ?? index.count;\n            const count = end - start;\n\n            if (start === endOfLastGroup) {\n                // extend the last group\n                geometry.groups[geometry.groups.length - 1].count += count;\n            } else {\n                geometry.addGroup(start, count);\n            }\n\n            endOfLastGroup = start + count;\n        });\n\n        return geometry.groups.length > 0;\n    }\n\n    private prepareRenderTextElements(time: number) {\n        // Disable rendering of text elements for debug camera. TextElements are rendered using an\n        // orthographic camera that covers the entire available screen space. Unfortunately, this\n        // particular camera set up is not compatible with the debug camera.\n        const debugCameraActive = this.m_pointOfView !== undefined;\n\n        if (debugCameraActive) {\n            return;\n        }\n\n        this.m_textElementsRenderer.placeText(this.m_visibleTiles.dataSourceTileList, time);\n    }\n\n    private finishRenderTextElements() {\n        const canRenderTextElements = this.m_pointOfView === undefined;\n\n        if (canRenderTextElements) {\n            // copy far value from scene camera, as the distance to the POIs matter now.\n            this.m_screenCamera.far = this.m_viewRanges.maximum;\n            this.m_textElementsRenderer.renderText(this.m_screenCamera);\n        }\n    }\n\n    private initTheme() {\n        const theme = getOptionValue(this.m_options.theme, MapViewDefaults.theme);\n\n        this.m_themeIsLoading = true;\n        Promise.resolve<string | Theme>(theme)\n            // tslint:disable-next-line: no-shadowed-variable\n            .then(theme => ThemeLoader.load(theme, { uriResolver: this.m_uriResolver }))\n            // tslint:disable-next-line: no-shadowed-variable\n            .then(theme => {\n                this.m_themeIsLoading = false;\n                this.theme = theme;\n            })\n            .catch(error => {\n                this.m_themeIsLoading = false;\n                const themeName =\n                    typeof this.m_options.theme === \"string\" ? ` from ${this.m_options.theme}` : \"\";\n                logger.error(`Failed to load theme${themeName}: ${error}`, error);\n            });\n    }\n\n    private setupCamera() {\n        const { width, height } = this.getCanvasClientSize();\n\n        this.calculateFocalLength(height);\n        this.m_visibleTiles = this.createVisibleTileSet();\n\n        this.m_options.target = GeoCoordinates.fromObject(\n            getOptionValue(this.m_options.target, MapViewDefaults.target)\n        );\n        // ensure that look at target has height of 0\n        (this.m_options.target as GeoCoordinates).altitude = 0;\n        this.m_options.tilt = getOptionValue(this.m_options.tilt, MapViewDefaults.tilt);\n\n        this.m_options.heading = getOptionValue(this.m_options.heading, MapViewDefaults.heading);\n\n        this.m_options.zoomLevel = getOptionValue(\n            this.m_options.zoomLevel,\n            MapViewDefaults.zoomLevel\n        );\n\n        this.lookAtImpl(this.m_options);\n\n        // ### move & customize\n        this.resize(width, height);\n\n        this.m_screenCamera.position.z = 1;\n        this.m_screenCamera.near = 0;\n    }\n\n    private createVisibleTileSet(): VisibleTileSet {\n        const enableMixedLod =\n            this.m_enableMixedLod === undefined\n                ? this.projection.type === ProjectionType.Spherical\n                : this.m_enableMixedLod;\n\n        return new VisibleTileSet(\n            new FrustumIntersection(\n                this.m_camera,\n                this,\n                this.m_visibleTileSetOptions.extendedFrustumCulling,\n                this.m_tileWrappingEnabled,\n                enableMixedLod\n            ),\n            this.m_tileGeometryManager,\n            this.m_visibleTileSetOptions\n        );\n    }\n\n    private updateSkyBackground() {\n        if (this.m_theme === undefined) {\n            return;\n        }\n        const theme = this.m_theme;\n        if (this.m_skyBackground instanceof SkyBackground && theme.sky !== undefined) {\n            // there is a sky in the view and there is a sky option in the theme. Update the colors\n            this.updateSkyBackgroundColors(theme.sky, theme.clearColor);\n        } else if (this.m_skyBackground === undefined && theme.sky !== undefined) {\n            // there is no sky in the view but there is a sky option in the theme\n            this.addNewSkyBackground(theme.sky, theme.clearColor);\n            return;\n        } else if (this.m_skyBackground instanceof SkyBackground && theme.sky === undefined) {\n            // there is a sky in the view, but not in the theme\n            this.removeSkyBackGround();\n        }\n    }\n\n    private addNewSkyBackground(sky: Sky, clearColor: string | undefined) {\n        if (sky.type === \"gradient\" && (sky as GradientSky).groundColor === undefined) {\n            sky.groundColor = getOptionValue(clearColor, \"#000000\");\n        }\n        this.m_skyBackground = new SkyBackground(sky, this.projection.type, this.m_camera);\n        this.m_scene.background = this.m_skyBackground.texture;\n    }\n\n    private removeSkyBackGround() {\n        this.m_scene.background = null;\n        if (this.m_skyBackground !== undefined) {\n            this.m_skyBackground.dispose();\n            this.m_skyBackground = undefined;\n        }\n    }\n\n    private updateSkyBackgroundColors(sky: Sky, clearColor: string | undefined) {\n        if (sky.type === \"gradient\" && (sky as GradientSky).groundColor === undefined) {\n            sky.groundColor = getOptionValue(clearColor, \"#000000\");\n        }\n        if (this.m_skyBackground !== undefined) {\n            this.m_skyBackground.updateTexture(sky, this.projection.type);\n        }\n    }\n\n    private updateLighting() {\n        if (!this.m_theme) {\n            return;\n        }\n\n        const theme = this.m_theme as Theme;\n        if (theme.clearColor !== undefined) {\n            this.m_renderer.setClearColor(new THREE.Color(theme.clearColor));\n        }\n\n        if (this.m_createdLights) {\n            this.m_createdLights.forEach((light: THREE.Light) => {\n                this.m_scene.remove(light);\n            });\n        }\n\n        this.m_overlayCreatedLights?.forEach(light => {\n            this.m_overlayScene.remove(light);\n            if (light instanceof THREE.DirectionalLight) {\n                this.m_overlayScene.remove(light.target);\n            }\n        });\n\n        if (theme.lights !== undefined) {\n            this.m_createdLights = [];\n            this.m_overlayCreatedLights = [];\n\n            theme.lights.forEach((lightDescription: Light) => {\n                const light = createLight(lightDescription);\n                if (!light) {\n                    logger.warn(\n                        // tslint:disable-next-line: max-line-length\n                        `MapView: failed to create light ${lightDescription.name} of type ${lightDescription.type}`\n                    );\n                    return;\n                }\n                this.m_scene.add(light);\n\n                if ((light as any).isDirectionalLight) {\n                    const directionalLight = light as THREE.DirectionalLight;\n                    // This is needed so that the target is updated automatically, see:\n                    // https://threejs.org/docs/#api/en/lights/DirectionalLight.target\n                    this.m_scene.add(directionalLight.target);\n                }\n                this.m_createdLights!.push(light);\n\n                const clonedLight: THREE.Light = light.clone();\n                this.m_overlayScene.add(clonedLight);\n                if (clonedLight instanceof THREE.DirectionalLight) {\n                    this.m_overlayScene.add(clonedLight.target.clone());\n                }\n            });\n        }\n    }\n\n    private movementStarted() {\n        this.m_textElementsRenderer.movementStarted();\n\n        MOVEMENT_STARTED_EVENT.time = Date.now();\n        this.dispatchEvent(MOVEMENT_STARTED_EVENT);\n    }\n\n    private movementFinished() {\n        this.m_textElementsRenderer.movementFinished();\n\n        MOVEMENT_FINISHED_EVENT.time = Date.now();\n        this.dispatchEvent(MOVEMENT_FINISHED_EVENT);\n\n        // render at the next possible time.\n        if (!this.animating) {\n            if (this.m_movementFinishedUpdateTimerId !== undefined) {\n                clearTimeout(this.m_movementFinishedUpdateTimerId);\n            }\n            this.m_movementFinishedUpdateTimerId = setTimeout(() => {\n                this.m_movementFinishedUpdateTimerId = undefined;\n                this.update();\n            }, 0);\n        }\n    }\n\n    /**\n     * Check if the set of visible tiles changed since the last frame.\n     *\n     * May be called multiple times per frame.\n     *\n     * Equality is computed by creating a string containing the IDs of the tiles.\n     */\n    private checkIfTilesChanged() {\n        if (this.m_thisFrameTilesChanged !== undefined) {\n            return this.m_thisFrameTilesChanged;\n        }\n        const renderList = this.m_visibleTiles.dataSourceTileList;\n\n        const tileIdList: string[] = [];\n\n        tileIdList.length = 0;\n\n        renderList.forEach(({ dataSource, renderedTiles }) => {\n            renderedTiles.forEach(tile => {\n                tileIdList.push(dataSource.name + \"-\" + tile.tileKey.mortonCode());\n            });\n        });\n\n        tileIdList.sort();\n\n        const newTileIds = tileIdList.join(\"#\");\n\n        if (newTileIds !== this.m_lastTileIds) {\n            this.m_lastTileIds = newTileIds;\n            this.m_thisFrameTilesChanged = true;\n        } else {\n            this.m_thisFrameTilesChanged = false;\n        }\n\n        return this.m_thisFrameTilesChanged;\n    }\n\n    private checkCopyrightUpdates() {\n        if (!this.checkIfTilesChanged()) {\n            return;\n        }\n\n        const newCopyrightInfo = this.getRenderedTilesCopyrightInfo();\n        if (newCopyrightInfo === this.m_copyrightInfo) {\n            return;\n        }\n        if (newCopyrightInfo.length === this.m_copyrightInfo.length) {\n            let allEqual = true;\n            for (let i = 0; i < newCopyrightInfo.length; i++) {\n                const a = newCopyrightInfo[i];\n                const b = this.m_copyrightInfo[i];\n                if (a.label !== b.label) {\n                    allEqual = false;\n                    break;\n                }\n            }\n            if (allEqual) {\n                return;\n            }\n        }\n        this.m_copyrightInfo = newCopyrightInfo;\n        this.dispatchEvent(COPYRIGHT_CHANGED_EVENT);\n    }\n\n    private getRenderedTilesCopyrightInfo(): CopyrightInfo[] {\n        let result: CopyrightInfo[] = [];\n        for (const tileList of this.m_visibleTiles.dataSourceTileList) {\n            for (const tile of tileList.renderedTiles.values()) {\n                const tileCopyrightInfo = tile.copyrightInfo;\n                if (tileCopyrightInfo === undefined || tileCopyrightInfo.length === 0) {\n                    continue;\n                }\n                result = CopyrightInfo.mergeArrays(result, tileCopyrightInfo);\n            }\n        }\n        return result;\n    }\n\n    private updateImages() {\n        if (!this.m_theme) {\n            return;\n        }\n\n        const theme = this.m_theme as Theme;\n\n        this.m_imageCache.clear();\n        this.poiManager.clear();\n\n        if (theme.images !== undefined) {\n            for (const name of Object.keys(theme.images)) {\n                const image = theme.images[name];\n                this.m_imageCache.addImage(name, image.url, image.preload === true);\n                if (typeof image.atlas === \"string\") {\n                    this.poiManager.addTextureAtlas(name, image.atlas);\n                }\n            }\n        }\n\n        if (theme.imageTextures !== undefined) {\n            theme.imageTextures.forEach((imageTexture: ImageTexture) => {\n                this.poiManager.addImageTexture(imageTexture);\n            });\n        }\n    }\n\n    private loadPoiTables() {\n        if (this.m_theme === undefined) {\n            return;\n        }\n\n        this.poiTableManager.clear();\n\n        // Add the POI tables defined in the theme.\n        this.poiTableManager\n            .loadPoiTables(this.m_theme as Theme)\n            .then(() => this.update())\n            .catch(() => this.update());\n    }\n\n    private setupStats(enable: boolean) {\n        // tslint:disable-next-line:no-unused-expression\n        new PerformanceStatistics(enable, 1000);\n    }\n\n    private setupRenderer() {\n        this.m_renderer.setClearColor(DEFAULT_CLEAR_COLOR);\n\n        this.m_scene.add(this.m_sceneRoot);\n        this.m_overlayScene.add(this.m_overlaySceneRoot);\n\n        this.shadowsEnabled = this.m_options.enableShadows ?? false;\n    }\n\n    private createTextRenderer(): TextElementsRenderer {\n        const updateCallback: ViewUpdateCallback = () => {\n            this.update();\n        };\n\n        return new TextElementsRenderer(\n            new MapViewState(this, this.checkIfTilesChanged.bind(this)),\n            this.m_camera,\n            updateCallback,\n            this.m_screenCollisions,\n            this.m_screenProjector,\n            new TextCanvasFactory(this.m_renderer),\n            this.m_poiManager,\n            new PoiRendererFactory(this),\n            new FontCatalogLoader(this.m_theme),\n            this.m_theme,\n            this.m_options\n        );\n    }\n\n    private resetTextRenderer(): void {\n        const overlayText = this.m_textElementsRenderer.overlayText;\n        this.m_textElementsRenderer = this.createTextRenderer();\n        if (overlayText !== undefined) {\n            this.m_textElementsRenderer.addOverlayText(overlayText);\n        }\n    }\n\n    /**\n     * Default handler for webglcontextlost event.\n     *\n     * Note: The renderer `this.m_renderer` may not be initialized when this function is called.\n     */\n    private onWebGLContextLost = (event: Event) => {\n        this.dispatchEvent(CONTEXT_LOST_EVENT);\n        logger.warn(\"WebGL context lost\", event);\n    };\n\n    /**\n     * Default handler for webglcontextrestored event.\n     *\n     * Note: The renderer `this.m_renderer` may not be initialized when this function is called.\n     */\n    private onWebGLContextRestored = (event: Event) => {\n        this.dispatchEvent(CONTEXT_RESTORED_EVENT);\n        if (this.m_renderer !== undefined) {\n            if (this.m_theme !== undefined && this.m_theme.clearColor !== undefined) {\n                this.m_renderer.setClearColor(new THREE.Color(this.m_theme.clearColor));\n            } else {\n                this.m_renderer.setClearColor(DEFAULT_CLEAR_COLOR);\n            }\n            this.update();\n        }\n        logger.warn(\"WebGL context restored\", event);\n    };\n\n    private limitFov(fov: number, aspect: number): number {\n        fov = THREE.MathUtils.clamp(fov, MIN_FIELD_OF_VIEW, MAX_FIELD_OF_VIEW);\n\n        let hFov = THREE.MathUtils.radToDeg(\n            MapViewUtils.calculateHorizontalFovByVerticalFov(THREE.MathUtils.degToRad(fov), aspect)\n        );\n\n        if (hFov > MAX_FIELD_OF_VIEW || hFov < MIN_FIELD_OF_VIEW) {\n            hFov = THREE.MathUtils.clamp(hFov, MIN_FIELD_OF_VIEW, MAX_FIELD_OF_VIEW);\n            fov = THREE.MathUtils.radToDeg(\n                MapViewUtils.calculateVerticalFovByHorizontalFov(\n                    THREE.MathUtils.degToRad(hFov),\n                    aspect\n                )\n            );\n        }\n        return fov as number;\n    }\n\n    /**\n     * Sets the field of view calculation, and applies it immediately to the camera.\n     *\n     * @param type - How to calculate the FOV\n     */\n    private setFovOnCamera(fovCalculation: FovCalculation, height: number) {\n        let fov = 0;\n        if (fovCalculation.type === \"fixed\") {\n            this.calculateFocalLength(height);\n            fov = fovCalculation.fov;\n        } else {\n            assert(this.m_focalLength !== 0);\n            fov = MapViewUtils.calculateFovByFocalLength(this.m_focalLength, height);\n        }\n        this.m_camera.fov = this.limitFov(fov, this.m_camera.aspect);\n    }\n\n    /**\n     * Sets the focal length based on the supplied fov and the height of the canvas. This must be\n     * called at least once. This is necessary to be recalled when the [[FovCalculation]]'s type is\n     * fixed. In such cases, when the height changes, the focal length must be readjusted whereas\n     * the FOV stays the same. The opposite is true for the dynamic case, where the focal length is\n     * fixed but the FOV changes.\n     * @param height - Height of the canvas in css / client pixels.\n     */\n    private calculateFocalLength(height: number) {\n        assert(this.m_options.fovCalculation !== undefined);\n        this.m_focalLength = MapViewUtils.calculateFocalLengthByVerticalFov(\n            THREE.MathUtils.degToRad(this.m_options.fovCalculation!.fov),\n            height\n        );\n    }\n\n    /**\n     * Get canvas client size in css/client pixels.\n     *\n     * Supports canvases not attached to DOM, which have 0 as `clientWidth` and `clientHeight` by\n     * calculating it from actual canvas size and current pixel ratio.\n     */\n    private getCanvasClientSize(): { width: number; height: number } {\n        const { clientWidth, clientHeight } = this.canvas;\n        if (\n            clientWidth === 0 ||\n            clientHeight === 0 ||\n            typeof clientWidth !== \"number\" ||\n            typeof clientHeight !== \"number\"\n        ) {\n            const pixelRatio = this.m_renderer.getPixelRatio();\n            return {\n                width: Math.round(this.canvas.width / pixelRatio),\n                height: Math.round(this.canvas.height / pixelRatio)\n            };\n        } else {\n            return { width: clientWidth, height: clientHeight };\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { Definitions, StyleSet, Theme, ValueMap } from \"@here/harp-datasource-protocol\";\nimport { ExprPool } from \"@here/harp-datasource-protocol/lib/ExprPool\";\nimport { Projection, TileKey, TilingScheme } from \"@here/harp-geoutils\";\nimport { assert, LoggerManager } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\nimport { MapView } from \"./MapView\";\nimport { Tile } from \"./Tile\";\n\nconst logger = LoggerManager.instance.create(\"DataSource\");\nconst UPDATE_EVENT = { type: \"update\" };\n\n/**\n * Options for a {@link DataSource}.\n */\nexport interface DataSourceOptions {\n    /**\n     * The unique name of a {@link DataSource} instance.\n     */\n    name?: string;\n    /**\n     * The name of the [[StyleSet]] to evaluate for the decoding.\n     */\n    styleSetName?: string;\n    /**\n     * The minimum zoom level at which data is available or displayed at\n     * (depending on {@link DataSource} subclass).\n     * @deprecated Use [[minDataLevel]] and [[minDisplayLevel]] instead.\n     */\n    minZoomLevel?: number;\n    /**\n     * The maximum zoom level at which data is available or displayed at\n     * (depending on {@link DataSource} subclass).\n     * @deprecated Use [[maxDataLevel]] and [[maxDisplayLevel]] instead.\n     */\n    maxZoomLevel?: number;\n    /**\n     * The minimum zoom level at which data is available.\n     */\n    minDataLevel?: number;\n    /**\n     * The maximum zoom level at which data is available.\n     */\n    maxDataLevel?: number;\n    /**\n     * The minimum zoom level at which {@link DataSource} is displayed.\n     */\n    minDisplayLevel?: number;\n    /**\n     * The maximum zoom level at which {@link DataSource} is displayed.\n     */\n    maxDisplayLevel?: number;\n    /**\n     * Storage level offset applied to this `DataSource`.\n     */\n    storageLevelOffset?: number;\n    /**\n     * Whether the datasource can overlap tiles. Such overlapping is necessary when zooming out and\n     * waiting for the tiles to load, in this case, we use cached tiles to fill the missing gaps if\n     * available (and in some cases, the tiles can overlap, i.e. for example when a child is next\n     * to a parent, the parent is rendered beneath the child), however for some datasources (those\n     * that produce transparent tiles for example), this gives bad results, and as such, it should\n     * be disabled to reduce flickening. Another way to put it is that loading tiles are replaced\n     * with cached tiles and we then fall (back/forward) to the next appropriate zoom level.\n     * @default true\n     */\n    allowOverlappingTiles?: boolean;\n}\n\n/**\n * Derive a class from `DataSource` to contribute data and geometries to the {@link MapView}.\n */\nexport abstract class DataSource extends THREE.EventDispatcher {\n    /**\n     * A counter to generate unique names for each `DataSource`, if no name is provided in the\n     * constructor.\n     */\n    private static uniqueNameCounter: number = 0;\n\n    /**\n     * Set to `true` if this `DataSource` is enabled; `false` otherwise.\n     */\n    enabled: boolean = true;\n\n    /**\n     * Set to `true` if the {@link MapView} can cache tiles produced by this `DataSource`.\n     */\n    cacheable: boolean = false;\n\n    /**\n     * Set to `true` if the loader should be used to get the tile contents.\n     */\n    useGeometryLoader: boolean = false;\n\n    /**\n     * The unique name of a `DataSource` instance.\n     */\n    name: string;\n\n    /**\n     * Whether the datasource should have a ground plane (this plane covers the tile entirely and\n     * has the minimum possible renderOrder), this can be required in some cases when fallback\n     * parent tiles need to be covered by the children, otherwise the content will overlap.\n     * Default is false\n     */\n    addGroundPlane: boolean = false;\n\n    /**\n     * The minimum zoom level at which data is available.\n     */\n    minDataLevel: number = 1;\n\n    /**\n     * The maximum zoom level at which data is available.\n     */\n    maxDataLevel: number = 20;\n\n    /**\n     * The minimum zoom level at which {@link DataSource} is displayed.\n     */\n    minDisplayLevel: number = 1;\n\n    /**\n     * The maximum zoom level at which {@link DataSource} is displayed.\n     */\n    maxDisplayLevel: number = 20;\n\n    allowOverlappingTiles: boolean = true;\n    /**\n     * @internal\n     * @hidden\n     */\n    readonly exprPool = new ExprPool();\n\n    /**\n     * The {@link MapView} instance holding a reference to this `DataSource`.\n     */\n    private m_mapView?: MapView;\n\n    /**\n     * The name of the [[StyleSet]] to evaluate for the decoding.\n     */\n    private m_styleSetName?: string;\n\n    /**\n     * Current value of [[maxGeometryHeight]] property.\n     */\n    private m_maxGeometryHeight = 0;\n\n    /**\n     * Storage level offset applied to this `DataSource`.\n     */\n    private m_storageLevelOffset: number = 0;\n\n    private readonly m_featureStateMap = new Map<number, ValueMap>();\n\n    /**\n     * Constructs a new `DataSource`.\n     *\n     * @param options - The options to create the data source.\n     */\n    constructor(options: DataSourceOptions = {}) {\n        super();\n        let { name } = options;\n        const {\n            styleSetName,\n            // tslint:disable-next-line: deprecation\n            minZoomLevel,\n            // tslint:disable-next-line: deprecation\n            maxZoomLevel,\n            minDataLevel,\n            maxDataLevel,\n            minDisplayLevel,\n            maxDisplayLevel,\n            storageLevelOffset,\n            allowOverlappingTiles\n        } = options;\n        if (name === undefined || name.length === 0) {\n            name = `anonymous-datasource#${++DataSource.uniqueNameCounter}`;\n        }\n        this.name = name;\n\n        this.styleSetName = styleSetName;\n\n        if (minDataLevel !== undefined) {\n            this.minDataLevel = minDataLevel;\n        }\n        if (maxDataLevel !== undefined) {\n            this.maxDataLevel = maxDataLevel;\n        }\n        if (minZoomLevel !== undefined) {\n            // tslint:disable-next-line: deprecation\n            this.minZoomLevel = minZoomLevel;\n        }\n        if (maxZoomLevel !== undefined) {\n            // tslint:disable-next-line: deprecation\n            this.maxZoomLevel = maxZoomLevel;\n        }\n        if (minDisplayLevel !== undefined) {\n            this.minDisplayLevel = minDisplayLevel;\n        }\n        if (maxDisplayLevel !== undefined) {\n            this.maxDisplayLevel = maxDisplayLevel;\n        }\n        if (storageLevelOffset !== undefined) {\n            this.m_storageLevelOffset = storageLevelOffset;\n        }\n        if (allowOverlappingTiles !== undefined) {\n            this.allowOverlappingTiles = allowOverlappingTiles;\n        }\n    }\n\n    /**\n     * Gets the state of the given feature id.\n     *\n     * @param featureId - The id of the feature.\n     */\n    getFeatureState(featureId: number): ValueMap | undefined {\n        return this.m_featureStateMap.get(featureId);\n    }\n\n    /**\n     * Clears the state of all the features of this {@link DataSource}.\n     */\n    clearFeatureState() {\n        this.m_featureStateMap.clear();\n    }\n\n    /**\n     * Sets the state of the given feature id.\n     *\n     * ```typescript\n     * dataSource.setFeatureState(featureId, { enabled: true });\n     * ```\n     *\n     * @param featureId - The id of the feature.\n     * @param state - The new state of the feature.\n     */\n    setFeatureState(featureId: number, state: ValueMap) {\n        this.m_featureStateMap.set(featureId, state);\n    }\n\n    /**\n     * Removes the state associated to the given feature.\n     *\n     * @param featureId - The id of the feature.\n     */\n    removeFeatureState(featureId: number) {\n        this.m_featureStateMap.delete(featureId);\n    }\n\n    /**\n     * Returns the name of the [[StyleSet]] to use for the decoding.\n     */\n    get styleSetName(): string | undefined {\n        return this.m_styleSetName;\n    }\n\n    /**\n     * Sets the name of the [[StyleSet]] to use for the decoding.\n     * If this {@link DataSource} is already\n     * attached to a {@link MapView}, this setter then reapplies\n     * [[StyleSet]] with this name found in\n     * {@link MapView}s theme.\n     */\n    set styleSetName(styleSetName: string | undefined) {\n        this.m_styleSetName = styleSetName;\n        if (this.m_mapView !== undefined && styleSetName !== undefined) {\n            this.setTheme(this.m_mapView.theme);\n        }\n    }\n\n    /**\n     * Destroys this `DataSource`.\n     */\n    dispose() {\n        // to be overloaded by subclasses\n    }\n\n    /**\n     * Purges all the caching done by this `DataSource`\n     */\n    clearCache() {\n        // to be overloaded by subclasses\n    }\n\n    /**\n     * Boolean which says whether a {@link DataSource} produces\n     * tiles that fully cover the tile, i.e.\n     * tiles underneath are completely hidden. Must be\n     * overriden for {@link DataSource}'s that don't\n     * have a ground plane, but which still fully\n     * cover the tile, e.g. web tiles.\n     */\n    isFullyCovering(): boolean {\n        return this.addGroundPlane;\n    }\n\n    /**\n     * Returns `true` if this `DataSource` is ready\n     * and the {@link MapView} can invoke `getTile()` to\n     * start requesting data.\n     */\n    ready(): boolean {\n        return true;\n    }\n\n    /**\n     * The {@link MapView} that is holding this `DataSource`.\n     */\n    get mapView(): MapView {\n        if (this.m_mapView === undefined) {\n            throw new Error(\"This DataSource was not added to MapView\");\n        }\n\n        return this.m_mapView;\n    }\n\n    /**\n     * The {@link @here/harp-geoutils#Projection} used by\n     * the {@link MapView} that is holding this `DataSource`.\n     *\n     * An `Error` is thrown if you call this method\n     * before this `DataSource` has been added\n     * to a {@link MapView}.\n     */\n    get projection(): Projection {\n        return this.mapView.projection;\n    }\n\n    /**\n     * This method is called when the `DataSource` is added to a {@link MapView}. Reimplement this\n     * method to provide any custom initialization, such as, to establish a network connection,\n     * or to initialize complex data structures.\n     */\n    async connect(): Promise<void> {\n        // to be overloaded by subclasses\n    }\n\n    /**\n     * Returns the {@link @here/harp-geoutils#TilingScheme} used by this `DataSource`.\n     */\n    abstract getTilingScheme(): TilingScheme;\n\n    /**\n     * This method is called when this `DataSource` is added to a {@link MapView}.\n     *\n     * Reimplementations of this method must invoke the definition of the super class.\n     *\n     * @param mapView - The instance of the {@link MapView}.\n     */\n    attach(mapView: MapView): void {\n        this.m_mapView = mapView;\n    }\n\n    /**\n     * This method is called when this `DataSource` is removed from a {@link MapView}.\n     *\n     * Reimplementations of this method must invoke the definition of the super class.\n     *\n     * @param mapView - The instance of the {@link MapView}.\n     */\n    detach(mapView: MapView) {\n        assert(this.m_mapView === mapView);\n        this.m_mapView = undefined;\n    }\n\n    /**\n     * Invoked by {@link MapView} to notify when the\n     * {@link @here/harp-datasource-protocol#Theme} has been changed.\n     *\n     * @remarks\n     * If `DataSource` depends on a `styleSet` or `languages`, it must update its tiles' geometry.\n     *\n     * @deprecated Use [[setTheme]].\n     *\n     * @param styleSet - The new theme that {@link MapView} uses.\n     * @param languages - An optional list of languages for the `DataSource`.\n     */\n    // tslint:disable-next-line:no-unused-variable\n    setStyleSet(styleSet?: StyleSet, definitions?: Definitions, languages?: string[]): void {\n        // to be overwritten by subclasses\n    }\n\n    /**\n     * Apply the {@link @here/harp-datasource-protocol#Theme} to this data source.\n     *\n     * If `DataSource` depends on a `styleSet` defined by this theme or `languages`, it must update\n     * its tiles' geometry.\n     *\n     * @param languages -\n     */\n    setTheme(theme: Theme, languages?: string[]): void {\n        // to be overwritten by subclasses\n    }\n\n    /**\n     * Used to configure the languages used by the `DataSource` according to priority;\n     * the first language in the array has the highest priority.\n     *\n     * @param languages - An array of ISO 639-1 language codes.\n     */\n    setLanguages(languages?: string[]): void {\n        // to be overloaded by subclasses\n    }\n\n    /**\n     * Used to express different country point of view (political view).\n     *\n     * @note Set to `undefined` (or empty string) if you want to reset to default point of view.\n     * @param pov - The country code which point of view should be presented in lower-case\n     * ISO 3166-1 alpha-2 format.\n     */\n    setPoliticalView(pov?: string): void {\n        // to be overloaded by subclasses\n    }\n\n    /**\n     * This method is called when {@link MapView} needs to visualize or preload the content of a\n     * {@link @here/harp-geoutils#TileKey}.\n     *\n     * @param tileKey - The unique identifier for a map tile.\n     */\n    abstract getTile(tileKey: TileKey): Tile | undefined;\n\n    /**\n     * This method is called by {@link MapView} before the\n     * tile needs to be updated, for example after\n     * a theme change.\n     *\n     * @param tile - The {@link Tile} to update.\n     */\n    // tslint:disable-next-line:no-unused-variable\n    updateTile(tile: Tile) {\n        // to be overloaded by subclasses\n    }\n\n    /**\n     * This method is called by the {@link MapView} to determine if the content of the surrounding\n     * tiles must be preloaded.\n     *\n     * @returns `true` if the {@link MapView} should try to preload tiles surrounding the visible\n     * tiles; `false` otherwise. The default is `false`.\n     */\n    shouldPreloadTiles(): boolean {\n        return false;\n    }\n\n    /**\n     * The minimum zoom level at which data is available or displayed at\n     * (depending on {@link DataSource} subclass).\n     * @deprecated Use [[minDataLevel]] and [[minDisplayLevel]] instead.\n     */\n    get minZoomLevel(): number {\n        logger.warn(\n            \"DataSource.minZoomLevel is deprecated. Use minDataLevel and maxDataLevel instead.\"\n        );\n        return this.minDataLevel;\n    }\n\n    set minZoomLevel(level: number) {\n        logger.warn(\n            \"DataSource.minZoomLevel is deprecated. Use minDataLevel and minDisplayLevel instead.\"\n        );\n        this.minDataLevel = level;\n    }\n\n    /**\n     * The maximum zoom level at which data is available or displayed at\n     * (depending on {@link DataSource} subclass).\n     * @deprecated Use [[maxDataLevel]] and [[maxDisplayLevel]] instead.\n     */\n    get maxZoomLevel(): number {\n        logger.warn(\n            \"DataSource.maxZoomLevel is deprecated. Use maxDataLevel and maxDisplayLevel instead.\"\n        );\n        return this.maxDataLevel;\n    }\n\n    set maxZoomLevel(level: number) {\n        logger.warn(\n            \"DataSource.maxZoomLevel is deprecated. Use maxDataLevel and maxDisplayLevel instead.\"\n        );\n        this.maxDataLevel = level;\n    }\n\n    /**\n     * Maximum geometry height above ground level this `DataSource` can produce.\n     *\n     * Used in first stage of frustum culling before\n     * {@link Tile.maxGeometryHeight} data is available.\n     *\n     * @default 0.\n     */\n    get maxGeometryHeight() {\n        return this.m_maxGeometryHeight;\n    }\n    set maxGeometryHeight(value: number) {\n        this.m_maxGeometryHeight = value;\n    }\n\n    /**\n     * The difference between storage level and display level of tile.\n     *\n     * Storage level offset is a value applied (added) to current zoom level giving\n     * a final tile level being displayed. This way we may differentate current\n     * zoom level from the storage level that is displayed, giving fine grained\n     * control over the tiles being decoded an displayed.\n     */\n    get storageLevelOffset() {\n        return this.m_storageLevelOffset;\n    }\n\n    /**\n     * Setup the relative offset between storage level and display level of tile.\n     *\n     * @param levelOffset - Difference between zoom level and display level.\n     */\n    set storageLevelOffset(levelOffset: number) {\n        this.m_storageLevelOffset = levelOffset;\n    }\n\n    /**\n     * Enables or disables overlay of geometry on elevation. It must be overloaded by data sources\n     * supporting this feature.\n     *\n     * @param value - True to enable, false to disable.\n     */\n    setEnableElevationOverlay(enable: boolean) {\n        // to be overloaded by subclasses\n    }\n\n    /**\n     * Computes the data zoom level to use.\n     *\n     * @param zoomLevel - The zoom level of the {@link MapView}.\n     * @returns The data zoom level to use.\n     */\n    getDataZoomLevel(zoomLevel: number): number {\n        return THREE.MathUtils.clamp(\n            zoomLevel + this.m_storageLevelOffset,\n            this.minDataLevel,\n            this.maxDataLevel\n        );\n    }\n\n    /**\n     * Returns `true` if {@link DataSource} should be displayed for the zoom level.\n     * @param zoomLevel - The zoom level of the {@link MapView}.\n     */\n    isVisible(zoomLevel: number): boolean {\n        return zoomLevel >= this.minDisplayLevel && zoomLevel <= this.maxDisplayLevel;\n    }\n\n    /**\n     * Returns `true` if {@link DataSource} can load tile with\n     * given {@link @here/harp-geoutils#TileKey} and zoom level.\n     *\n     * @param zoomLevel - The zoom level of the {@link MapView}.\n     * @param tileKey - The unique identifier for a map tile.\n     * @returns `true` if the tile for the given {@link @here/harp-geoutils#TileKey} can be loaded.\n     */\n    canGetTile(zoomLevel: number, tileKey: TileKey): boolean {\n        return tileKey.level <= zoomLevel;\n    }\n\n    /**\n     * Returns `true` if {@link MapView} should traverse tiles\n     * further with given {@link @here/harp-geoutils#TileKey} and\n     * zoom level.\n     *\n     * @param zoomLevel - The zoom level of the {@link MapView}.\n     * @param tileKey - The unique identifier for a map tile.\n     * @returns `true` if the subtiles of the given {@link @here/harp-geoutils#TileKey} should be\n     * checked for collisions.\n     */\n    shouldSubdivide(zoomLevel: number, tileKey: TileKey): boolean {\n        return tileKey.level <= zoomLevel;\n    }\n\n    /**\n     * Returns `true` if {@link MapView} should render the text\n     * elements with the given {@link @here/harp-geoutils#TileKey} and\n     * zoom level.\n     *\n     * @remarks\n     * This is an additional check for the tiles that are already selected for rendering so the\n     * default implementation returns `true`.\n     *\n     * @param zoomLevel - The zoom level.\n     * @param tileKey - The unique identifier for a map tile.\n     * @returns `true` if the text elements created for the\n     *          given {@link @here/harp-geoutils#TileKey} should be rendered.\n     */\n    // tslint:disable-next-line:no-unused-variable\n    shouldRenderText(zoomLevel: number, tileKey: TileKey): boolean {\n        return true;\n    }\n\n    /**\n     * Sends a request to the {@link MapView} to redraw the scene.\n     */\n    requestUpdate() {\n        this.dispatchEvent(UPDATE_EVENT);\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {\n    Attachment,\n    BaseTechniqueParams,\n    BufferAttribute,\n    CallExpr,\n    DecodedTile,\n    Env,\n    Expr,\n    ExtrudedPolygonTechnique,\n    FillTechnique,\n    Geometry,\n    GeometryKind,\n    GeometryKindSet,\n    getArrayConstructor,\n    getFeatureId,\n    getPropertyValue,\n    IndexedTechnique,\n    InterleavedBufferAttribute,\n    isCirclesTechnique,\n    isExtrudedLineTechnique,\n    isExtrudedPolygonTechnique,\n    isFillTechnique,\n    isJsonExpr,\n    isLineMarkerTechnique,\n    isLineTechnique,\n    isPoiTechnique,\n    isSegmentsTechnique,\n    isSolidLineTechnique,\n    isSquaresTechnique,\n    isStandardTechnique,\n    isTerrainTechnique,\n    isTextTechnique,\n    MakeTechniqueAttrs,\n    MapEnv,\n    needsVertexNormals,\n    SolidLineTechnique,\n    StandardExtrudedLineTechnique,\n    Technique,\n    TerrainTechnique,\n    TextPathGeometry,\n    Value\n} from \"@here/harp-datasource-protocol\";\nimport {\n    ExprEvaluatorContext,\n    OperatorDescriptor\n} from \"@here/harp-datasource-protocol/lib/ExprEvaluator\";\n// tslint:disable:max-line-length\nimport {\n    EdgeLengthGeometrySubdivisionModifier,\n    SubdivisionMode\n} from \"@here/harp-geometry/lib/EdgeLengthGeometrySubdivisionModifier\";\nimport { SphericalGeometrySubdivisionModifier } from \"@here/harp-geometry/lib/SphericalGeometrySubdivisionModifier\";\nimport { EarthConstants, GeoCoordinates, ProjectionType } from \"@here/harp-geoutils\";\nimport {\n    EdgeMaterial,\n    EdgeMaterialParameters,\n    ExtrusionFeature,\n    FadingFeature,\n    hasExtrusionFeature,\n    isHighPrecisionLineMaterial,\n    MapMeshBasicMaterial,\n    MapMeshDepthMaterial,\n    MapMeshStandardMaterial,\n    setShaderMaterialDefine,\n    SolidLineMaterial\n} from \"@here/harp-materials\";\nimport { ContextualArabicConverter } from \"@here/harp-text-canvas\";\nimport { assert, LoggerManager } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\nimport {\n    applyBaseColorToMaterial,\n    buildMetricValueEvaluator,\n    buildObject,\n    createMaterial,\n    getBufferAttribute,\n    usesObject3D\n} from \"../DecodedTileHelpers\";\nimport {\n    createDepthPrePassMesh,\n    isRenderDepthPrePassEnabled,\n    setDepthPrePassStencil\n} from \"../DepthPrePass\";\nimport { DisplacementMap, TileDisplacementMap } from \"../DisplacementMap\";\nimport { MapAdapterUpdateEnv, MapMaterialAdapter } from \"../MapMaterialAdapter\";\nimport { MapObjectAdapter, MapObjectAdapterParams } from \"../MapObjectAdapter\";\nimport { FALLBACK_RENDER_ORDER_OFFSET } from \"../MapView\";\nimport { MapViewPoints } from \"../MapViewPoints\";\nimport { PathBlockingElement } from \"../PathBlockingElement\";\nimport { TextElement } from \"../text/TextElement\";\nimport { DEFAULT_TEXT_DISTANCE_SCALE } from \"../text/TextElementsRenderer\";\nimport { Tile, TileFeatureData } from \"../Tile\";\nimport { LodMesh } from \"./LodMesh\";\n\nconst logger = LoggerManager.instance.create(\"TileGeometryCreator\");\n\nconst tmpVector3 = new THREE.Vector3();\nconst tmpVector2 = new THREE.Vector2();\n\nclass AttachmentCache {\n    readonly bufferAttributes = new Map<BufferAttribute, THREE.BufferAttribute>();\n\n    readonly interleavedAttributes = new Map<\n        InterleavedBufferAttribute,\n        Array<{ name: string; attribute: THREE.InterleavedBufferAttribute }>\n    >();\n}\n\nclass MemoCallExpr extends CallExpr implements OperatorDescriptor {\n    private readonly m_deps: string[];\n    private readonly m_cachedProperties: Array<Value | undefined> = [];\n    private m_cachedValue?: Value;\n\n    constructor(expr: Expr) {\n        super(\"memo\", [expr]);\n        this.m_deps = Array.from(expr.dependencies().properties);\n        this.descriptor = this;\n    }\n\n    call(context: ExprEvaluatorContext): Value {\n        let changed = false;\n\n        this.m_deps.forEach((d, i) => {\n            const newValue = context.env.lookup(d);\n            if (!changed && newValue !== this.m_cachedProperties[i]) {\n                changed = true;\n            }\n            if (changed) {\n                this.m_cachedProperties[i] = newValue;\n            }\n        });\n\n        if (changed || this.m_cachedValue === undefined) {\n            this.m_cachedValue = context.evaluate(this.args[0]);\n        }\n\n        return this.m_cachedValue;\n    }\n}\n\nclass AttachmentInfo {\n    constructor(\n        readonly geometry: Geometry,\n        readonly info: Attachment,\n        readonly cache: AttachmentCache\n    ) {}\n\n    getBufferAttribute(description: BufferAttribute): THREE.BufferAttribute {\n        if (this.cache.bufferAttributes.has(description)) {\n            return this.cache.bufferAttributes.get(description)!;\n        }\n        const attribute = getBufferAttribute(description);\n        this.cache.bufferAttributes.set(description, attribute);\n        return attribute;\n    }\n\n    getInterleavedBufferAttributes(description: InterleavedBufferAttribute) {\n        const interleavedAttributes = this.cache.interleavedAttributes.get(description);\n\n        if (interleavedAttributes) {\n            return interleavedAttributes;\n        }\n\n        const ArrayCtor = getArrayConstructor(description.type);\n        const buffer = new ArrayCtor(description.buffer);\n        const interleavedBuffer = new THREE.InterleavedBuffer(buffer, description.stride);\n\n        const attrs = description.attributes.map(interleavedAttr => {\n            const attribute = new THREE.InterleavedBufferAttribute(\n                interleavedBuffer,\n                interleavedAttr.itemSize,\n                interleavedAttr.offset,\n                false\n            );\n            const name = interleavedAttr.name;\n            return { name, attribute };\n        });\n\n        this.cache.interleavedAttributes.set(description, attrs);\n        return attrs;\n    }\n}\n\nfunction addToExtrudedMaterials(\n    material: THREE.Material | THREE.Material[],\n    extrudedMaterials: ExtrusionFeature[]\n) {\n    if (Array.isArray(material)) {\n        const materials = material as ExtrusionFeature[];\n        extrudedMaterials.push(...materials);\n    } else {\n        extrudedMaterials.push(material as ExtrusionFeature);\n    }\n}\n\n/**\n * Parameters that control fading.\n */\nexport interface FadingParameters {\n    fadeNear?: number;\n    fadeFar?: number;\n}\n\n/**\n * Parameters that control fading for extruded buildings with fading edges.\n */\nexport interface PolygonFadingParameters extends FadingParameters {\n    color?: string | number;\n    colorMix?: number;\n    lineFadeNear?: number;\n    lineFadeFar?: number;\n}\n\n/**\n * Support class to create geometry for a {@link Tile} from a {@link @here/harp-datasource-protocol#DecodedTile}.\n */\nexport class TileGeometryCreator {\n    private static m_instance: TileGeometryCreator;\n\n    /**\n     * The `instance` of the `TileGeometryCreator`.\n     *\n     * @returns TileGeometryCreator\n     */\n    static get instance(): TileGeometryCreator {\n        return this.m_instance || (this.m_instance = new TileGeometryCreator());\n    }\n\n    /**\n     *  Creates an instance of TileGeometryCreator. Access is allowed only through `instance`.\n     */\n    private constructor() {\n        //\n    }\n\n    /**\n     * Apply `enabledKinds` and `disabledKinds` to all techniques in the `decodedTile`. If a\n     * technique is identified as disabled, its property `enabled` is set to `false`.\n     *\n     * @param decodedTile - The decodedTile containing the actual tile map data.\n     * @param enabledKinds - Optional [[GeometryKindSet]] used to specify which object kinds should be\n     *      created.\n     * @param disabledKinds - Optional [[GeometryKindSet]] used to filter objects that should not be\n     *      created.\n     */\n    initDecodedTile(\n        decodedTile: DecodedTile,\n        enabledKinds?: GeometryKindSet | undefined,\n        disabledKinds?: GeometryKindSet | undefined\n    ) {\n        for (const technique of decodedTile.techniques) {\n            // tslint:disable-next-line: deprecation\n            const kind = technique.kind;\n\n            // No info about kind, no way to filter it.\n            if (kind === undefined || (kind instanceof Set && kind.size === 0)) {\n                technique._kindState = true;\n                continue;\n            }\n\n            // Technique is enabled only if enabledKinds is defined and technique belongs to that set or\n            // if that's not the case, disabledKinds must be undefined or technique does not belong to it.\n            technique._kindState =\n                !(disabledKinds !== undefined && disabledKinds.hasOrIntersects(kind)) ||\n                (enabledKinds !== undefined && enabledKinds.hasOrIntersects(kind));\n        }\n\n        for (const srcGeometry of decodedTile.geometries) {\n            for (const group of srcGeometry.groups) {\n                group.createdOffsets = [];\n            }\n        }\n    }\n\n    /**\n     * Called after the `Tile` has been decoded. It is required to call `initDecodedTile` before\n     * calling this method.\n     *\n     * @see [[TileGeometryCreator#initDecodedTile]]\n     *\n     * @param tile - The {@link Tile} to process.\n     * @param decodedTile - The decodedTile containing the actual tile map data.\n     */\n    createAllGeometries(tile: Tile, decodedTile: DecodedTile) {\n        const filter = (technique: IndexedTechnique): boolean => {\n            return technique._kindState !== false;\n        };\n\n        this.createObjects(tile, decodedTile, filter);\n\n        this.preparePois(tile, decodedTile);\n\n        // TextElements do not get their geometry created by Tile, but are managed on a\n        // higher level.\n        const textFilter = (technique: IndexedTechnique): boolean => {\n            if (\n                !isPoiTechnique(technique) &&\n                !isLineMarkerTechnique(technique) &&\n                !isTextTechnique(technique)\n            ) {\n                return false;\n            }\n            return filter(technique);\n        };\n        this.createTextElements(tile, decodedTile, textFilter);\n\n        this.createLabelRejectionElements(tile, decodedTile);\n\n        // HARP-7899, disable ground plane for globe\n        if (tile.dataSource.addGroundPlane && tile.projection.type === ProjectionType.Planar) {\n            // The ground plane is required for when we change the zoom back and we fall back to the\n            // parent, in that case we reduce the renderOrder of the parent tile and this ground\n            // place ensures that parent doesn't come through. This value must be above the\n            // renderOrder of all objects in the fallback tile, otherwise there won't be a proper\n            // covering of the parent tile by the children, hence dividing by 2. To put a bit more\n            // concretely, we assume all objects are rendered with a renderOrder between 0 and\n            // FALLBACK_RENDER_ORDER_OFFSET / 2, i.e. 10000. The ground plane is put at -10000, and\n            // the fallback tiles have their renderOrder set between -20000 and -10000\n            TileGeometryCreator.instance.addGroundPlane(tile, -FALLBACK_RENDER_ORDER_OFFSET / 2);\n        }\n    }\n\n    createLabelRejectionElements(tile: Tile, decodedTile: DecodedTile) {\n        if (decodedTile.pathGeometries === undefined) {\n            return;\n        }\n        for (const path of decodedTile.pathGeometries) {\n            tile.addBlockingElement(new PathBlockingElement(path.path));\n        }\n    }\n\n    /**\n     * Processes the given tile and assign default values for geometry kinds,\n     * render orders and label priorities.\n     *\n     * @param {Tile} tile\n     * @param {(GeometryKindSet | undefined)} enabledKinds\n     * @param {(GeometryKindSet | undefined)} disabledKinds\n     */\n    processTechniques(\n        tile: Tile,\n        enabledKinds: GeometryKindSet | undefined,\n        disabledKinds: GeometryKindSet | undefined\n    ): void {\n        const decodedTile = tile.decodedTile;\n\n        if (decodedTile === undefined) {\n            return;\n        }\n\n        this.processPriorities(tile);\n\n        // Speedup and simplify following code: Test all techniques if they intersect with\n        // enabledKinds and disabledKinds, in which case they are flagged. The disabledKinds can be\n        // ignored hereafter.\n        this.initDecodedTile(decodedTile, enabledKinds, disabledKinds);\n\n        // compile the dynamic expressions.\n        const exprPool = tile.dataSource.exprPool;\n        decodedTile.techniques.forEach((technique: any) => {\n            for (const propertyName in technique) {\n                if (!technique.hasOwnProperty(propertyName)) {\n                    continue;\n                }\n                const value = technique[propertyName];\n                if (isJsonExpr(value) && propertyName !== \"kind\") {\n                    // \"kind\" is reserved.\n                    try {\n                        let expr = Expr.fromJSON(value);\n                        if (expr.dependencies().volatile !== true) {\n                            expr = new MemoCallExpr(Expr.fromJSON(value));\n                        }\n                        technique[propertyName] = expr.intern(exprPool);\n                    } catch (error) {\n                        logger.error(\"Failed to compile expression:\", error);\n                    }\n                }\n            }\n        });\n    }\n\n    /**\n     * Adds a THREE object to the root of the tile and register [[MapObjectAdapter]].\n     *\n     * Sets the owning tiles datasource.name and the `tileKey` in the `userData` property of the\n     * object, such that the tile it belongs to can be identified during picking.\n     *\n     * @param tile - The {@link Tile} to add the object to.\n     * @param object - The object to add to the root of the tile.\n     * @param geometryKind - The kind of object. Can be used for filtering.\n     * @param custom - additional parameters for [[MapObjectAdapter]]\n     */\n    registerTileObject(\n        tile: Tile,\n        object: THREE.Object3D,\n        geometryKind: GeometryKind | GeometryKindSet | undefined,\n        mapAdapterParams?: MapObjectAdapterParams\n    ) {\n        const kind =\n            geometryKind instanceof Set\n                ? Array.from((geometryKind as GeometryKindSet).values())\n                : Array.isArray(geometryKind)\n                ? geometryKind\n                : [geometryKind];\n\n        MapObjectAdapter.create(object, {\n            kind,\n            ...mapAdapterParams\n        });\n\n        // TODO legacy fields, encoded directly in `userData to be removed\n        if (object.userData === undefined) {\n            object.userData = {};\n        }\n\n        const userData = object.userData;\n        userData.tileKey = tile.tileKey;\n        userData.dataSource = tile.dataSource.name;\n\n        userData.kind = kind;\n\n        // Force a visibility check of all objects.\n        tile.resetVisibilityCounter();\n    }\n\n    /**\n     * Splits the text paths that contain sharp corners.\n     *\n     * @param tile - The {@link Tile} to process paths on.\n     * @param textPathGeometries - The original path geometries that may have defects.\n     * @param textFilter -: Optional filter. Should return true for any text technique that is\n     *      applicable.\n     */\n    prepareTextPaths(\n        textPathGeometries: TextPathGeometry[],\n        decodedTile: DecodedTile,\n        textFilter?: (technique: IndexedTechnique) => boolean\n    ): TextPathGeometry[] {\n        const processedPaths = new Array<TextPathGeometry>();\n        const newPaths = textPathGeometries.slice();\n\n        while (newPaths.length > 0) {\n            const textPath = newPaths.pop();\n\n            if (textPath === undefined) {\n                break;\n            }\n\n            const technique = decodedTile.techniques[textPath.technique];\n            if (\n                !isTextTechnique(technique) ||\n                (textFilter !== undefined && !textFilter(technique))\n            ) {\n                continue;\n            }\n\n            processedPaths.push(textPath);\n        }\n        return processedPaths;\n    }\n\n    /**\n     * Creates {@link TextElement} objects from the decoded tile and list of materials specified. The\n     * priorities of the {@link TextElement}s are updated to simplify label placement.\n     *\n     * @param tile - The {@link Tile} to create the testElements on.\n     * @param decodedTile - The {@link @here/harp-datasource-protocol#DecodedTile}.\n     * @param textFilter -: Optional filter. Should return true for any text technique that is\n     *      applicable.\n     */\n    createTextElements(\n        tile: Tile,\n        decodedTile: DecodedTile,\n        textFilter?: (technique: IndexedTechnique) => boolean\n    ) {\n        const mapView = tile.mapView;\n        const textStyleCache = tile.textStyleCache;\n        const worldOffsetX = tile.computeWorldOffsetX();\n\n        const discreteZoomLevel = Math.floor(mapView.zoomLevel);\n        const discreteZoomEnv = new MapEnv({ $zoom: discreteZoomLevel }, mapView.env);\n\n        if (decodedTile.textPathGeometries !== undefined) {\n            const textPathGeometries = this.prepareTextPaths(\n                decodedTile.textPathGeometries,\n                decodedTile,\n                textFilter\n            );\n\n            for (const textPath of textPathGeometries) {\n                const technique = decodedTile.techniques[textPath.technique];\n\n                if (\n                    technique._kindState === false ||\n                    !isTextTechnique(technique) ||\n                    (textFilter !== undefined && !textFilter(technique))\n                ) {\n                    continue;\n                }\n\n                const path: THREE.Vector3[] = [];\n                for (let i = 0; i < textPath.path.length; i += 3) {\n                    path.push(\n                        new THREE.Vector3(\n                            textPath.path[i] + worldOffsetX,\n                            textPath.path[i + 1],\n                            textPath.path[i + 2]\n                        )\n                    );\n                }\n\n                // Make sorting stable.\n                const priority =\n                    technique.priority !== undefined\n                        ? getPropertyValue(technique.priority, discreteZoomEnv)\n                        : 0;\n                const fadeNear =\n                    technique.fadeNear !== undefined\n                        ? getPropertyValue(technique.fadeNear, discreteZoomEnv)\n                        : technique.fadeNear;\n                const fadeFar =\n                    technique.fadeFar !== undefined\n                        ? getPropertyValue(technique.fadeFar, discreteZoomEnv)\n                        : technique.fadeFar;\n                const userData = textPath.objInfos;\n                const featureId = getFeatureId(userData);\n                const textElement = new TextElement(\n                    ContextualArabicConverter.instance.convert(textPath.text),\n                    path,\n                    textStyleCache.getRenderStyle(technique),\n                    textStyleCache.getLayoutStyle(technique),\n                    priority,\n                    technique.xOffset !== undefined ? technique.xOffset : 0.0,\n                    technique.yOffset !== undefined ? technique.yOffset : 0.0,\n                    featureId,\n                    technique.style,\n                    fadeNear,\n                    fadeFar,\n                    tile.offset\n                );\n                textElement.pathLengthSqr = textPath.pathLengthSqr;\n                textElement.minZoomLevel =\n                    technique.minZoomLevel !== undefined\n                        ? technique.minZoomLevel\n                        : mapView.minZoomLevel;\n                textElement.maxZoomLevel =\n                    technique.maxZoomLevel !== undefined\n                        ? technique.maxZoomLevel\n                        : mapView.maxZoomLevel;\n                textElement.distanceScale =\n                    technique.distanceScale !== undefined\n                        ? technique.distanceScale\n                        : DEFAULT_TEXT_DISTANCE_SCALE;\n                textElement.mayOverlap = technique.mayOverlap === true;\n                textElement.reserveSpace = technique.reserveSpace !== false;\n                // tslint:disable-next-line: deprecation\n                textElement.kind = technique.kind;\n                // Get the userData for text element picking.\n                textElement.userData = textPath.objInfos;\n                textElement.textFadeTime = technique.textFadeTime;\n\n                tile.addTextElement(textElement);\n            }\n        }\n\n        if (decodedTile.textGeometries !== undefined) {\n            for (const text of decodedTile.textGeometries) {\n                if (text.technique === undefined || text.stringCatalog === undefined) {\n                    continue;\n                }\n\n                const technique = decodedTile.techniques[text.technique];\n\n                if (\n                    technique._kindState === false ||\n                    !isTextTechnique(technique) ||\n                    (textFilter !== undefined && !textFilter(technique))\n                ) {\n                    continue;\n                }\n\n                const positions = new THREE.BufferAttribute(\n                    new Float32Array(text.positions.buffer),\n                    text.positions.itemCount\n                );\n\n                const numPositions = positions.count;\n                if (numPositions < 1) {\n                    continue;\n                }\n\n                const priority =\n                    technique.priority !== undefined\n                        ? getPropertyValue(technique.priority, discreteZoomEnv)\n                        : 0;\n                const fadeNear =\n                    technique.fadeNear !== undefined\n                        ? getPropertyValue(technique.fadeNear, discreteZoomEnv)\n                        : technique.fadeNear;\n                const fadeFar =\n                    technique.fadeFar !== undefined\n                        ? getPropertyValue(technique.fadeFar, discreteZoomEnv)\n                        : technique.fadeFar;\n\n                for (let i = 0; i < numPositions; ++i) {\n                    const x = positions.getX(i) + worldOffsetX;\n                    const y = positions.getY(i);\n                    const z = positions.getZ(i);\n                    const label = text.stringCatalog[text.texts[i]];\n                    if (label === undefined) {\n                        // skip missing labels\n                        continue;\n                    }\n\n                    const userData = text.objInfos !== undefined ? text.objInfos[i] : undefined;\n                    const featureId = getFeatureId(userData);\n\n                    const textElement = new TextElement(\n                        ContextualArabicConverter.instance.convert(label!),\n                        new THREE.Vector3(x, y, z),\n                        textStyleCache.getRenderStyle(technique),\n                        textStyleCache.getLayoutStyle(technique),\n                        priority,\n                        technique.xOffset || 0.0,\n                        technique.yOffset || 0.0,\n                        featureId,\n                        technique.style,\n                        undefined,\n                        undefined,\n                        tile.offset\n                    );\n\n                    textElement.minZoomLevel =\n                        technique.minZoomLevel !== undefined\n                            ? technique.minZoomLevel\n                            : mapView.minZoomLevel;\n                    textElement.maxZoomLevel =\n                        technique.maxZoomLevel !== undefined\n                            ? technique.maxZoomLevel\n                            : mapView.maxZoomLevel;\n                    textElement.mayOverlap = technique.mayOverlap === true;\n                    textElement.reserveSpace = technique.reserveSpace !== false;\n                    // tslint:disable-next-line: deprecation\n                    textElement.kind = technique.kind;\n\n                    textElement.fadeNear = fadeNear;\n                    textElement.fadeFar = fadeFar;\n                    textElement.textFadeTime = technique.textFadeTime;\n\n                    // Get the userData for text element picking.\n                    textElement.userData = userData;\n                    tile.addTextElement(textElement);\n                }\n            }\n        }\n    }\n\n    /**\n     * Creates `Tile` objects from the decoded tile and list of materials specified.\n     *\n     * @param tile - The {@link Tile} to create the geometry on.\n     * @param decodedTile - The {@link @here/harp-datasource-protocol#DecodedTile}.\n     * @param techniqueFilter -: Optional filter. Should return true for any technique that is\n     *      applicable.\n     */\n    createObjects(\n        tile: Tile,\n        decodedTile: DecodedTile,\n        techniqueFilter?: (technique: IndexedTechnique) => boolean\n    ) {\n        const mapView = tile.mapView;\n        const materials: THREE.Material[] = [];\n        const extrudedMaterials: THREE.Material[] = [];\n        const animatedExtrusionHandler = mapView.animatedExtrusionHandler;\n        const dataSource = tile.dataSource;\n        const discreteZoomLevel = Math.floor(mapView.zoomLevel);\n        const discreteZoomEnv = new MapEnv({ $zoom: discreteZoomLevel }, mapView.env);\n        const objects = tile.objects;\n        const viewRanges = mapView.viewRanges;\n        const elevationEnabled = mapView.elevationProvider !== undefined;\n\n        for (const attachment of this.getAttachments(decodedTile)) {\n            const srcGeometry = attachment.geometry;\n            const groups = attachment.info.groups;\n            const groupCount = groups.length;\n\n            for (let groupIndex = 0; groupIndex < groupCount; ) {\n                const group = groups[groupIndex++];\n                const start = group.start;\n                const techniqueIndex = group.technique;\n                const technique = decodedTile.techniques[techniqueIndex];\n\n                if (group.createdOffsets === undefined) {\n                    group.createdOffsets = [];\n                }\n\n                if (\n                    group.createdOffsets!.indexOf(tile.offset) !== -1 ||\n                    technique._kindState === false ||\n                    (techniqueFilter !== undefined && !techniqueFilter(technique))\n                ) {\n                    continue;\n                }\n\n                let count = group.count;\n                group.createdOffsets!.push(tile.offset);\n\n                // compress consecutive groups\n                for (\n                    ;\n                    groupIndex < groupCount && groups[groupIndex].technique === techniqueIndex;\n                    ++groupIndex\n                ) {\n                    if (start + count !== groups[groupIndex].start) {\n                        break;\n                    }\n\n                    count += groups[groupIndex].count;\n\n                    // Mark this group as created, so it does not get processed again.\n                    groups[groupIndex].createdOffsets!.push(tile.offset);\n                }\n\n                if (!usesObject3D(technique)) {\n                    continue;\n                }\n                const extrusionAnimationEnabled: boolean =\n                    animatedExtrusionHandler?.setAnimationProperties(technique, discreteZoomEnv) ??\n                    false;\n\n                let material: THREE.Material | undefined = materials[techniqueIndex];\n\n                if (material === undefined) {\n                    const onMaterialUpdated = (texture: THREE.Texture) => {\n                        dataSource.requestUpdate();\n                        if (texture !== undefined) {\n                            tile.addOwnedTexture(texture);\n                        }\n                    };\n                    material = createMaterial(\n                        {\n                            technique,\n                            env: mapView.env,\n                            fog: mapView.scene.fog !== null,\n                            shadowsEnabled: mapView.shadowsEnabled\n                        },\n                        onMaterialUpdated\n                    );\n                    if (material === undefined) {\n                        continue;\n                    }\n                    if (extrusionAnimationEnabled && hasExtrusionFeature(material)) {\n                        addToExtrudedMaterials(material, extrudedMaterials);\n                    }\n                    materials[techniqueIndex] = material;\n                }\n\n                // tslint:disable-next-line: deprecation\n                const techniqueKind = technique.kind;\n\n                // Modify the standard textured shader to support height-based coloring.\n                if (isTerrainTechnique(technique)) {\n                    this.setupTerrainMaterial(technique, material, tile.mapView.clearColor);\n                }\n\n                const bufferGeometry = new THREE.BufferGeometry();\n\n                srcGeometry.vertexAttributes?.forEach(vertexAttribute => {\n                    const buffer = attachment.getBufferAttribute(vertexAttribute);\n                    bufferGeometry.setAttribute(vertexAttribute.name, buffer);\n                });\n\n                srcGeometry.interleavedVertexAttributes?.forEach(attr => {\n                    attachment\n                        .getInterleavedBufferAttributes(attr)\n                        .forEach(({ name, attribute }) =>\n                            bufferGeometry.setAttribute(name, attribute)\n                        );\n                });\n\n                const index = attachment.info.index ?? srcGeometry.index;\n                if (index) {\n                    bufferGeometry.setIndex(attachment.getBufferAttribute(index));\n                }\n\n                // Geometry with edges are typically buildings. If they are buildings, the outline\n                // effect may be applied to it, which needs the normals.\n                const isBuilding =\n                    isExtrudedPolygonTechnique(technique) &&\n                    attachment.info.edgeIndex !== undefined;\n\n                if (\n                    !bufferGeometry.getAttribute(\"normal\") &&\n                    (isBuilding || needsVertexNormals(technique))\n                ) {\n                    bufferGeometry.computeVertexNormals();\n                }\n\n                bufferGeometry.addGroup(start, count);\n\n                if (isSolidLineTechnique(technique)) {\n                    // TODO: Unify access to shader defines via SolidLineMaterial setters\n                    assert(!isHighPrecisionLineMaterial(material));\n                    const lineMaterial = material as SolidLineMaterial;\n                    if (\n                        technique.clipping !== false &&\n                        tile.projection.type === ProjectionType.Planar\n                    ) {\n                        tile.boundingBox.getSize(tmpVector3);\n                        tmpVector2.set(tmpVector3.x, tmpVector3.y);\n                        lineMaterial.clipTileSize = tmpVector2;\n                    }\n\n                    if (bufferGeometry.getAttribute(\"color\")) {\n                        setShaderMaterialDefine(lineMaterial, \"USE_COLOR\", true);\n                    }\n                }\n\n                // Add the solid line outlines as a separate object.\n                const hasSolidLinesOutlines: boolean =\n                    isSolidLineTechnique(technique) && technique.secondaryWidth !== undefined;\n\n                // When the source geometry is split in groups, we\n                // should create objects with an array of materials.\n                const hasFeatureGroups =\n                    Expr.isExpr(technique.enabled) &&\n                    srcGeometry.featureStarts &&\n                    srcGeometry.featureStarts.length > 0;\n\n                const object = buildObject(\n                    technique,\n                    bufferGeometry,\n                    hasFeatureGroups ? [material] : material,\n                    tile,\n                    elevationEnabled\n                );\n\n                object.renderOrder = getPropertyValue(technique.renderOrder, mapView.env);\n\n                if (attachment.info.uuid !== undefined) {\n                    object.uuid = attachment.info.uuid;\n                    object.userData.geometryId = attachment.info.uuid;\n                }\n\n                if (\n                    (isCirclesTechnique(technique) || isSquaresTechnique(technique)) &&\n                    technique.enablePicking !== undefined\n                ) {\n                    // tslint:disable-next-line:max-line-length\n                    (object as MapViewPoints).enableRayTesting = technique.enablePicking!;\n                }\n\n                if (isLineTechnique(technique) || isSegmentsTechnique(technique)) {\n                    const fadingParams = this.getFadingParams(discreteZoomEnv, technique);\n                    FadingFeature.addRenderHelper(\n                        object,\n                        viewRanges,\n                        fadingParams.fadeNear,\n                        fadingParams.fadeFar,\n                        false\n                    );\n                }\n\n                if (isSolidLineTechnique(technique)) {\n                    const fadingParams = this.getFadingParams(discreteZoomEnv, technique);\n\n                    FadingFeature.addRenderHelper(\n                        object,\n                        viewRanges,\n                        fadingParams.fadeNear,\n                        fadingParams.fadeFar,\n                        false\n                    );\n                }\n\n                if (isExtrudedLineTechnique(technique)) {\n                    // extruded lines are normal meshes, and need transparency only when fading or\n                    // dynamic properties is defined.\n                    if (technique.fadeFar !== undefined) {\n                        const fadingParams = this.getFadingParams(\n                            mapView.env,\n                            technique as StandardExtrudedLineTechnique\n                        );\n\n                        FadingFeature.addRenderHelper(\n                            object,\n                            viewRanges,\n                            fadingParams.fadeNear,\n                            fadingParams.fadeFar,\n                            true\n                        );\n                    }\n                }\n\n                this.addUserData(tile, srcGeometry, technique, object);\n\n                if (isExtrudedPolygonTechnique(technique)) {\n                    object.castShadow = mapView.shadowsEnabled;\n                    object.receiveShadow = mapView.shadowsEnabled;\n                } else if (isStandardTechnique(technique) || isFillTechnique(technique)) {\n                    object.receiveShadow = mapView.shadowsEnabled;\n                }\n\n                if (\n                    isExtrudedPolygonTechnique(technique) ||\n                    isStandardTechnique(technique) ||\n                    isFillTechnique(technique)\n                ) {\n                    // filled polygons are normal meshes, and need transparency only when fading or\n                    // dynamic properties is defined.\n\n                    if (technique.fadeFar !== undefined) {\n                        const fadingParams = this.getFadingParams(discreteZoomEnv, technique);\n                        FadingFeature.addRenderHelper(\n                            object,\n                            viewRanges,\n                            fadingParams.fadeNear,\n                            fadingParams.fadeFar,\n                            true\n                        );\n                    }\n                }\n\n                const renderDepthPrePass =\n                    isExtrudedPolygonTechnique(technique) &&\n                    isRenderDepthPrePassEnabled(technique, discreteZoomEnv);\n\n                if (renderDepthPrePass) {\n                    const depthPassMesh = createDepthPrePassMesh(object as THREE.Mesh);\n                    // Set geometry kind for depth pass mesh so that it gets the displacement map\n                    // for elevation overlay.\n                    this.registerTileObject(tile, depthPassMesh, techniqueKind, {\n                        technique\n                    });\n                    objects.push(depthPassMesh);\n\n                    if (extrusionAnimationEnabled) {\n                        addToExtrudedMaterials(depthPassMesh.material, extrudedMaterials);\n                    }\n\n                    setDepthPrePassStencil(depthPassMesh, object as THREE.Mesh);\n                }\n\n                this.registerTileObject(tile, object, techniqueKind, {\n                    technique\n                });\n                objects.push(object);\n\n                // Add the extruded building edges as a separate geometry.\n                if (isBuilding) {\n                    const buildingTechnique = technique as ExtrudedPolygonTechnique;\n                    const edgeGeometry = new THREE.BufferGeometry();\n                    edgeGeometry.setAttribute(\"position\", bufferGeometry.getAttribute(\"position\"));\n\n                    const colorAttribute = bufferGeometry.getAttribute(\"color\");\n                    if (colorAttribute !== undefined) {\n                        edgeGeometry.setAttribute(\"color\", colorAttribute);\n                    }\n\n                    const extrusionAttribute = bufferGeometry.getAttribute(\"extrusionAxis\");\n                    if (extrusionAttribute !== undefined) {\n                        edgeGeometry.setAttribute(\"extrusionAxis\", extrusionAttribute);\n                    }\n\n                    const normalAttribute = bufferGeometry.getAttribute(\"normal\");\n                    if (normalAttribute !== undefined) {\n                        edgeGeometry.setAttribute(\"normal\", normalAttribute);\n                    }\n\n                    const uvAttribute = bufferGeometry.getAttribute(\"uv\");\n                    if (uvAttribute !== undefined) {\n                        edgeGeometry.setAttribute(\"uv\", uvAttribute);\n                    }\n\n                    edgeGeometry.setIndex(\n                        attachment.getBufferAttribute(attachment.info.edgeIndex!)\n                    );\n\n                    // Read the uniforms from the technique values (and apply the default values).\n                    const extrudedPolygonTechnique = technique as ExtrudedPolygonTechnique;\n\n                    const fadingParams = this.getPolygonFadingParams(\n                        discreteZoomEnv,\n                        extrudedPolygonTechnique\n                    );\n\n                    // Configure the edge material based on the theme values.\n                    const materialParams: EdgeMaterialParameters = {\n                        color: fadingParams.color,\n                        colorMix: fadingParams.colorMix,\n                        fadeNear: fadingParams.lineFadeNear,\n                        fadeFar: fadingParams.lineFadeFar,\n                        extrusionRatio: extrusionAnimationEnabled ? 0 : undefined\n                    };\n                    const edgeMaterial = new EdgeMaterial(materialParams);\n                    const edgeObj = new THREE.LineSegments(edgeGeometry, edgeMaterial);\n\n                    // Set the correct render order.\n                    edgeObj.renderOrder = object.renderOrder + 0.1;\n\n                    FadingFeature.addRenderHelper(\n                        edgeObj,\n                        viewRanges,\n                        fadingParams.lineFadeNear,\n                        fadingParams.lineFadeFar,\n                        false\n                    );\n\n                    if (extrusionAnimationEnabled) {\n                        addToExtrudedMaterials(edgeObj.material, extrudedMaterials);\n                    }\n\n                    this.registerTileObject(tile, edgeObj, techniqueKind, {\n                        technique\n                    });\n                    MapMaterialAdapter.create(edgeMaterial, {\n                        color: buildingTechnique.lineColor,\n                        opacity: buildingTechnique.opacity\n                    });\n                    objects.push(edgeObj);\n                }\n\n                // animate the extrusion of buildings\n                if (isExtrudedPolygonTechnique(technique) && extrusionAnimationEnabled) {\n                    object.customDepthMaterial = new MapMeshDepthMaterial({\n                        depthPacking: THREE.RGBADepthPacking\n                    });\n                    addToExtrudedMaterials(object.customDepthMaterial, extrudedMaterials);\n                }\n\n                // Add the fill area edges as a separate geometry.\n\n                if (isFillTechnique(technique) && attachment.info.edgeIndex) {\n                    const outlineGeometry = new THREE.BufferGeometry();\n                    outlineGeometry.setAttribute(\n                        \"position\",\n                        bufferGeometry.getAttribute(\"position\")\n                    );\n                    outlineGeometry.setIndex(\n                        attachment.getBufferAttribute(attachment.info.edgeIndex!)\n                    );\n\n                    const fillTechnique = technique as FillTechnique;\n\n                    const fadingParams = this.getPolygonFadingParams(mapView.env, fillTechnique);\n\n                    // Configure the edge material based on the theme values.\n                    const materialParams: EdgeMaterialParameters = {\n                        color: fadingParams.color,\n                        colorMix: fadingParams.colorMix,\n                        fadeNear: fadingParams.lineFadeNear,\n                        fadeFar: fadingParams.lineFadeFar\n                    };\n                    const outlineMaterial = new EdgeMaterial(materialParams);\n                    const outlineObj = new THREE.LineSegments(outlineGeometry, outlineMaterial);\n                    outlineObj.renderOrder = object.renderOrder + 0.1;\n\n                    FadingFeature.addRenderHelper(\n                        outlineObj,\n                        viewRanges,\n                        fadingParams.lineFadeNear,\n                        fadingParams.lineFadeFar,\n                        false\n                    );\n\n                    this.registerTileObject(tile, outlineObj, techniqueKind, {\n                        technique\n                    });\n                    MapMaterialAdapter.create(outlineMaterial, {\n                        color: fillTechnique.lineColor,\n                        opacity: fillTechnique.opacity\n                    });\n                    objects.push(outlineObj);\n                }\n\n                // Add the fill area edges as a separate geometry.\n                if (hasSolidLinesOutlines) {\n                    const outlineTechnique = technique as SolidLineTechnique;\n                    const outlineMaterial = material.clone() as SolidLineMaterial;\n                    applyBaseColorToMaterial(\n                        outlineMaterial,\n                        outlineMaterial.color,\n                        outlineTechnique,\n                        outlineTechnique.secondaryColor ?? 0x000000,\n                        discreteZoomEnv\n                    );\n\n                    if (outlineTechnique.secondaryCaps !== undefined) {\n                        outlineMaterial.caps = getPropertyValue(\n                            outlineTechnique.secondaryCaps,\n                            mapView.env\n                        );\n                    }\n                    const outlineObj = buildObject(\n                        technique,\n                        bufferGeometry,\n                        outlineMaterial,\n                        tile,\n                        elevationEnabled\n                    );\n\n                    outlineObj.renderOrder =\n                        (getPropertyValue(outlineTechnique.secondaryRenderOrder, mapView.env) ??\n                            0) - 0.0000001;\n\n                    this.addUserData(tile, srcGeometry, technique, outlineObj);\n\n                    const fadingParams = this.getFadingParams(discreteZoomEnv, technique);\n                    FadingFeature.addRenderHelper(\n                        outlineObj,\n                        viewRanges,\n                        fadingParams.fadeNear,\n                        fadingParams.fadeFar,\n                        false\n                    );\n\n                    const secondaryWidth = buildMetricValueEvaluator(\n                        outlineTechnique.secondaryWidth,\n                        // tslint:disable-next-line: deprecation\n                        outlineTechnique.metricUnit\n                    );\n                    this.registerTileObject(tile, outlineObj, techniqueKind, { technique });\n                    const mainMaterialAdapter = MapMaterialAdapter.get(material);\n\n                    const outlineMaterialAdapter = MapMaterialAdapter.create(outlineMaterial, {\n                        color: outlineTechnique.secondaryColor,\n                        opacity: outlineTechnique.opacity,\n                        caps: outlineTechnique.secondaryCaps,\n                        // Still handled above\n                        lineWidth: (frameMapView: MapAdapterUpdateEnv) => {\n                            if (!mainMaterialAdapter) {\n                                return;\n                            }\n                            mainMaterialAdapter.ensureUpdated(frameMapView);\n                            const mainLineWidth =\n                                mainMaterialAdapter.currentStyledProperties.lineWidth;\n\n                            const secondaryLineWidth = getPropertyValue(\n                                secondaryWidth,\n                                mapView.env\n                            );\n                            const opacity = outlineMaterialAdapter.currentStyledProperties\n                                .opacity as number | null;\n                            if (\n                                typeof mainLineWidth === \"number\" &&\n                                typeof secondaryLineWidth === \"number\"\n                            ) {\n                                if (\n                                    secondaryLineWidth <= mainLineWidth &&\n                                    (opacity === null || opacity === undefined || opacity === 1)\n                                ) {\n                                    // We could mark object as invisible somehow, not sure how\n                                    // objectAdapter.markInvisible();\n                                    return 0;\n                                } else {\n                                    return secondaryLineWidth;\n                                }\n                            } else {\n                                return 0;\n                            }\n                        }\n                    });\n                    objects.push(outlineObj);\n                }\n            }\n        }\n        if (extrudedMaterials.length > 0) {\n            mapView.animatedExtrusionHandler.add(tile, extrudedMaterials);\n        }\n    }\n\n    /**\n     * Prepare the {@link Tile}s pois. Uses the {@link PoiManager} in {@link MapView}.\n     */\n    preparePois(tile: Tile, decodedTile: DecodedTile) {\n        if (decodedTile.poiGeometries !== undefined) {\n            tile.mapView.poiManager.addPois(tile, decodedTile);\n        }\n    }\n\n    /**\n     * Create a ground plane mesh for a tile\n     * @param tile - Tile\n     * @param material - Material\n     * @param createTexCoords - Enable creation of texture coordinates\n     */\n    createGroundPlane(\n        tile: Tile,\n        material: THREE.Material | THREE.Material[],\n        createTexCoords: boolean,\n        shadowsEnabled?: boolean\n    ): THREE.Mesh {\n        const { dataSource, projection, mapView } = tile;\n        const sourceProjection = dataSource.getTilingScheme().projection;\n        const shouldSubdivide = projection.type === ProjectionType.Spherical;\n        const tmpV = new THREE.Vector3();\n\n        function moveTileCenter(geom: THREE.BufferGeometry) {\n            const attr = geom.getAttribute(\"position\") as THREE.BufferAttribute;\n            const posArray = attr.array as Float32Array;\n            for (let i = 0; i < posArray.length; i += 3) {\n                tmpV.set(posArray[i], posArray[i + 1], posArray[i + 2]);\n                projection.reprojectPoint(sourceProjection, tmpV, tmpV);\n                tmpV.sub(tile.center);\n                posArray[i] = tmpV.x;\n                posArray[i + 1] = tmpV.y;\n                posArray[i + 2] = tmpV.z;\n            }\n            attr.needsUpdate = true;\n        }\n\n        // Create plane\n        const { east, west, north, south } = tile.geoBox;\n        const geometry = new THREE.BufferGeometry();\n        const sw = sourceProjection.projectPoint(\n            new GeoCoordinates(south, west),\n            new THREE.Vector3()\n        );\n        const se = sourceProjection.projectPoint(\n            new GeoCoordinates(south, east),\n            new THREE.Vector3()\n        );\n        const nw = sourceProjection.projectPoint(\n            new GeoCoordinates(north, west),\n            new THREE.Vector3()\n        );\n        const ne = sourceProjection.projectPoint(\n            new GeoCoordinates(north, east),\n            new THREE.Vector3()\n        );\n        const posAttr = new THREE.BufferAttribute(\n            new Float32Array([...sw.toArray(), ...se.toArray(), ...nw.toArray(), ...ne.toArray()]),\n            3\n        );\n        geometry.setAttribute(\"position\", posAttr);\n        if (shadowsEnabled === true) {\n            sourceProjection.surfaceNormal(sw, tmpV);\n            // Webmercator needs to have it negated to work correctly.\n            tmpV.negate();\n            const normAttr = new THREE.BufferAttribute(\n                new Float32Array([\n                    ...tmpV.toArray(),\n                    ...tmpV.toArray(),\n                    ...tmpV.toArray(),\n                    ...tmpV.toArray()\n                ]),\n                3\n            );\n            geometry.setAttribute(\"normal\", normAttr);\n        }\n        geometry.setIndex(new THREE.BufferAttribute(new Uint16Array([0, 1, 2, 2, 1, 3]), 1));\n\n        if (createTexCoords) {\n            const uvAttr = new THREE.BufferAttribute(new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), 2);\n            geometry.setAttribute(\"uv\", uvAttr);\n        }\n\n        if (shouldSubdivide) {\n            const geometries: THREE.BufferGeometry[] = [];\n            const sphericalModifier = new SphericalGeometrySubdivisionModifier(\n                THREE.MathUtils.degToRad(10),\n                sourceProjection\n            );\n            const enableMixedLod = mapView.enableMixedLod || mapView.enableMixedLod === undefined;\n\n            if (enableMixedLod) {\n                // Use a [[LodMesh]] to adapt tesselation of tile depending on zoom level\n                for (let zoomLevelOffset = 0; zoomLevelOffset < 4; ++zoomLevelOffset) {\n                    const subdivision = Math.pow(2, zoomLevelOffset);\n                    const zoomLevelGeometry = geometry.clone();\n                    if (subdivision > 1) {\n                        const edgeModifier = new EdgeLengthGeometrySubdivisionModifier(\n                            subdivision,\n                            tile.geoBox,\n                            SubdivisionMode.All,\n                            sourceProjection\n                        );\n                        edgeModifier.modify(zoomLevelGeometry);\n                    }\n                    sphericalModifier.modify(zoomLevelGeometry);\n                    moveTileCenter(zoomLevelGeometry);\n                    geometries.push(zoomLevelGeometry);\n                }\n                return new LodMesh(geometries, material);\n            } else {\n                // Use static mesh if mixed LOD is disabled\n                sphericalModifier.modify(geometry);\n                moveTileCenter(geometry);\n\n                return new THREE.Mesh(geometry, material);\n            }\n        } else {\n            // Use static mesh for planar projection\n            moveTileCenter(geometry);\n            return new THREE.Mesh(geometry, material);\n        }\n    }\n\n    /**\n     * Creates and add a background plane for the tile.\n     * @param tile - Tile\n     * @param renderOrder - Render order of the tile\n     */\n    addGroundPlane(tile: Tile, renderOrder: number) {\n        const shadowsEnabled = tile.mapView.shadowsEnabled;\n        const material = this.createGroundPlaneMaterial(\n            new THREE.Color(tile.mapView.clearColor),\n            tile.mapView.shadowsEnabled,\n            tile.mapView.projection.type === ProjectionType.Spherical\n        );\n        const mesh = this.createGroundPlane(tile, material, false, shadowsEnabled);\n        mesh.receiveShadow = shadowsEnabled;\n        mesh.renderOrder = renderOrder;\n        this.registerTileObject(tile, mesh, GeometryKind.Background);\n        tile.objects.push(mesh);\n    }\n\n    private createGroundPlaneMaterial(\n        color: THREE.Color,\n        shadowsEnabled: boolean,\n        depthWrite: boolean\n    ): THREE.Material {\n        if (shadowsEnabled) {\n            return new MapMeshStandardMaterial({\n                color,\n                visible: true,\n                depthWrite,\n                removeDiffuseLight: true\n            });\n        } else {\n            return new MapMeshBasicMaterial({\n                color,\n                visible: true,\n                depthWrite\n            });\n        }\n    }\n\n    /**\n     * Gets the attachments of the given {@link @here/harp-datasource-protocol#DecodedTile}.\n     *\n     * @param decodedTile - The {@link @here/harp-datasource-protocol#DecodedTile}.\n     */\n    private *getAttachments(decodedTile: DecodedTile): Generator<AttachmentInfo> {\n        const cache = new AttachmentCache();\n\n        for (const geometry of decodedTile.geometries) {\n            // the main attachment\n\n            const mainAttachment: Attachment = {\n                index: geometry.index,\n                edgeIndex: geometry.edgeIndex,\n                uuid: geometry.uuid,\n                groups: geometry.groups\n            };\n\n            yield new AttachmentInfo(geometry, mainAttachment, cache);\n\n            if (geometry.attachments) {\n                // the additional attachments\n                for (const info of geometry.attachments) {\n                    yield new AttachmentInfo(geometry, info, cache);\n                }\n            }\n        }\n    }\n\n    /**\n     * Process the given {@link Tile} and assign default values to render orders\n     * and label priorities.\n     *\n     * @param tile - The {@link Tile} to process.\n     */\n    private processPriorities(tile: Tile) {\n        const decodedTile = tile.decodedTile;\n\n        if (decodedTile === undefined) {\n            return;\n        }\n\n        const theme = tile.mapView;\n\n        if (!theme) {\n            return;\n        }\n\n        const { priorities, labelPriorities } = tile.mapView.theme;\n\n        decodedTile.techniques.forEach(technique => {\n            if (\n                isTextTechnique(technique) ||\n                isPoiTechnique(technique) ||\n                isLineMarkerTechnique(technique)\n            ) {\n                // for screen-space techniques the `category` is used to assign\n                // priorities.\n                if (labelPriorities && typeof technique._category === \"string\") {\n                    // override the `priority` when the technique uses `category`.\n                    const priority = labelPriorities.indexOf(technique._category);\n                    if (priority !== -1) {\n                        technique.priority = labelPriorities.length - priority;\n                    }\n                }\n            } else if (priorities && technique._styleSet !== undefined) {\n                // Compute the render order based on the style category and styleSet.\n                const computeRenderOrder = (category: string): number | undefined => {\n                    const priority = priorities?.findIndex(\n                        entry => entry.group === technique._styleSet && entry.category === category\n                    );\n\n                    return priority !== undefined && priority !== -1\n                        ? (priority + 1) * 10\n                        : undefined;\n                };\n\n                if (typeof technique._category === \"string\") {\n                    // override the renderOrder when the technique is using categories.\n                    const renderOrder = computeRenderOrder(technique._category);\n\n                    if (renderOrder !== undefined) {\n                        technique.renderOrder = renderOrder;\n                    }\n                }\n\n                if (typeof technique._secondaryCategory === \"string\") {\n                    // override the secondaryRenderOrder when the technique is using categories.\n                    const secondaryRenderOrder = computeRenderOrder(technique._secondaryCategory);\n\n                    if (secondaryRenderOrder !== undefined) {\n                        (technique as any).secondaryRenderOrder = secondaryRenderOrder;\n                    }\n                }\n            }\n        });\n    }\n\n    private setupTerrainMaterial(\n        technique: TerrainTechnique,\n        material: THREE.Material,\n        terrainColor: number\n    ) {\n        if (technique.displacementMap === undefined) {\n            // Render terrain using the given color.\n            const stdMaterial = material as MapMeshStandardMaterial;\n            stdMaterial.color.set(terrainColor);\n            return;\n        }\n\n        // Render terrain using height-based colors.\n        (material as any).onBeforeCompile = (shader: THREE.Shader) => {\n            shader.fragmentShader = shader.fragmentShader.replace(\n                \"#include <map_pars_fragment>\",\n                `#include <map_pars_fragment>\n    uniform sampler2D displacementMap;\n    uniform float displacementScale;\n    uniform float displacementBias;`\n            );\n            shader.fragmentShader = shader.fragmentShader.replace(\n                \"#include <map_fragment>\",\n                `#ifdef USE_MAP\n    float minElevation = ${EarthConstants.MIN_ELEVATION.toFixed(1)};\n    float maxElevation = ${EarthConstants.MAX_ELEVATION.toFixed(1)};\n    float elevationRange = maxElevation - minElevation;\n\n    float disp = texture2D( displacementMap, vUv ).x * displacementScale + displacementBias;\n    vec4 texelColor = texture2D( map, vec2((disp - minElevation) / elevationRange, 0.0) );\n    texelColor = mapTexelToLinear( texelColor );\n    diffuseColor *= texelColor;\n#endif`\n            );\n            // We remove the displacement map from manipulating the vertices, it is\n            // however still required for the pixel shader, so it can't be directly\n            // removed.\n            shader.vertexShader = shader.vertexShader.replace(\n                \"#include <displacementmap_vertex>\",\n                \"\"\n            );\n        };\n        (material as MapMeshStandardMaterial).displacementMap!.needsUpdate = true;\n    }\n\n    private addUserData(\n        tile: Tile,\n        srcGeometry: Geometry,\n        technique: Technique,\n        object: THREE.Object3D\n    ) {\n        if (isTerrainTechnique(technique)) {\n            assert(\n                Object.keys(object.userData).length === 0,\n                \"Unexpected user data in terrain object\"\n            );\n\n            assert(\n                typeof srcGeometry.objInfos![0] === \"object\",\n                \"Wrong attribute map type for terrain geometry\"\n            );\n\n            const displacementMap = (srcGeometry.objInfos as DisplacementMap[])[0];\n            const tileDisplacementMap: TileDisplacementMap = {\n                tileKey: tile.tileKey,\n                texture: new THREE.DataTexture(\n                    displacementMap.buffer,\n                    displacementMap.xCountVertices,\n                    displacementMap.yCountVertices,\n                    THREE.LuminanceFormat,\n                    THREE.FloatType\n                ),\n                displacementMap,\n                geoBox: tile.geoBox\n            };\n            object.userData = tileDisplacementMap;\n        } else {\n            // Set the feature data for picking with `MapView.intersectMapObjects()` except for\n            // solid-line which uses tile-based picking.\n            const featureData: TileFeatureData = {\n                geometryType: srcGeometry.type,\n                starts: srcGeometry.featureStarts,\n                objInfos: srcGeometry.objInfos\n            };\n            object.userData.feature = featureData;\n            object.userData.technique = technique;\n        }\n    }\n\n    /**\n     * Gets the fading parameters for several kinds of objects.\n     */\n    private getFadingParams(\n        env: Env,\n        technique: MakeTechniqueAttrs<BaseTechniqueParams>\n    ): FadingParameters {\n        const fadeNear =\n            technique.fadeNear !== undefined\n                ? getPropertyValue(technique.fadeNear, env)\n                : FadingFeature.DEFAULT_FADE_NEAR;\n        const fadeFar =\n            technique.fadeFar !== undefined\n                ? getPropertyValue(technique.fadeFar, env)\n                : FadingFeature.DEFAULT_FADE_FAR;\n        return {\n            fadeNear,\n            fadeFar\n        };\n    }\n\n    /**\n     * Gets the fading parameters for several kinds of objects.\n     */\n    private getPolygonFadingParams(\n        env: Env,\n        technique: FillTechnique | ExtrudedPolygonTechnique\n    ): PolygonFadingParameters {\n        let color: string | number | undefined;\n        let colorMix = EdgeMaterial.DEFAULT_COLOR_MIX;\n\n        if (technique.lineColor !== undefined) {\n            color = getPropertyValue(technique.lineColor, env);\n            if (isExtrudedPolygonTechnique(technique)) {\n                const extrudedPolygonTechnique = technique as ExtrudedPolygonTechnique;\n                colorMix =\n                    extrudedPolygonTechnique.lineColorMix !== undefined\n                        ? extrudedPolygonTechnique.lineColorMix\n                        : EdgeMaterial.DEFAULT_COLOR_MIX;\n            }\n        }\n\n        const fadeNear =\n            technique.fadeNear !== undefined\n                ? getPropertyValue(technique.fadeNear, env)\n                : FadingFeature.DEFAULT_FADE_NEAR;\n        const fadeFar =\n            technique.fadeFar !== undefined\n                ? getPropertyValue(technique.fadeFar, env)\n                : FadingFeature.DEFAULT_FADE_FAR;\n\n        const lineFadeNear =\n            technique.lineFadeNear !== undefined\n                ? getPropertyValue(technique.lineFadeNear, env)\n                : fadeNear;\n        const lineFadeFar =\n            technique.lineFadeFar !== undefined\n                ? getPropertyValue(technique.lineFadeFar, env)\n                : fadeFar;\n\n        if (color === undefined) {\n            color = EdgeMaterial.DEFAULT_COLOR;\n        }\n\n        return {\n            color,\n            colorMix,\n            fadeNear,\n            fadeFar,\n            lineFadeNear,\n            lineFadeFar\n        };\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { ColorUtils, Expr, getPropertyValue, Value } from \"@here/harp-datasource-protocol\";\nimport { disableBlending, enableBlending } from \"@here/harp-materials\";\nimport { evaluateColorProperty } from \"./DecodedTileHelpers\";\nimport { MapView } from \"./MapView\";\n\n/**\n * @hidden\n *\n * Pick of {@link MapView} properties required to update materials used [[MapMaterialAdapter]].\n */\nexport type MapAdapterUpdateEnv = Pick<MapView, \"env\" | \"frameNumber\">;\n\n/**\n * @hidden\n *\n * Custom, callback based property evaluator used by [[MapObjectAdapter]] to evaluate dynamic\n * properties of object/material.\n */\nexport type StylePropertyEvaluator = (context: MapAdapterUpdateEnv) => Value;\n\n/**\n * @hidden\n *\n * Styled properties of material managed by [[MapMaterialAdapter]].\n */\nexport interface StyledProperties {\n    [name: string]: Expr | StylePropertyEvaluator | Value | undefined;\n}\n\n/**\n * @hidden\n *\n * {@link MapView} specific data assigned to `THREE.Material` instance in installed in `userData`.\n *\n * [[MapMaterialAdapter]] is registered in `usedData.mapAdapter` property of `THREE.Material`.\n */\nexport class MapMaterialAdapter {\n    /**\n     * Resolve `MapMaterialAdapter` associated with `material`.\n     */\n    static get(material: THREE.Material): MapMaterialAdapter | undefined {\n        const mapAdapter = material.userData?.mapAdapter;\n        if (mapAdapter instanceof MapMaterialAdapter) {\n            return mapAdapter;\n        } else if (mapAdapter !== undefined) {\n            // NOTE: we can rebuild MapMaterialAdapter here if userData.mapAdapter contains\n            // stylesed etc, this can be done to rebuild previously saved scene\n            return undefined;\n        } else {\n            return undefined;\n        }\n    }\n\n    static install(objData: MapMaterialAdapter): MapMaterialAdapter {\n        if (!objData.material.userData) {\n            objData.material.userData = {};\n        }\n        return (objData.material.userData.mapAdapter = objData);\n    }\n\n    static create(\n        material: THREE.Material,\n        styledProperties: StyledProperties\n    ): MapMaterialAdapter {\n        return MapMaterialAdapter.install(new MapMaterialAdapter(material, styledProperties));\n    }\n\n    static ensureUpdated(material: THREE.Material, context: MapAdapterUpdateEnv): boolean {\n        return MapMaterialAdapter.get(material)?.ensureUpdated(context) ?? false;\n    }\n\n    /**\n     * Associated material object.\n     */\n    readonly material: THREE.Material;\n\n    /**\n     * Styled material properties.\n     *\n     * Usually pick from [[Technique]] attributes that constitute material properties managed\n     * by this adapter.\n     */\n    readonly styledProperties: StyledProperties;\n\n    /**\n     * Current values of styled material properties.\n     *\n     * Actual values valid for scope of one frame updated in [[ensureUpdated]].\n     */\n    readonly currentStyledProperties: { [name: string]: Value | undefined };\n\n    private m_lastUpdateFrameNumber = -1;\n    private m_dynamicProperties: Array<[string, Expr | StylePropertyEvaluator]>;\n\n    constructor(material: THREE.Material, styledProperties: StyledProperties) {\n        this.material = material;\n        this.styledProperties = styledProperties;\n\n        this.currentStyledProperties = {};\n        this.m_dynamicProperties = [];\n        for (const propName in styledProperties) {\n            if (!styledProperties.hasOwnProperty(propName)) {\n                continue;\n            }\n            const propDefinition = styledProperties![propName];\n            if (Expr.isExpr(propDefinition) || typeof propDefinition === \"function\") {\n                this.m_dynamicProperties.push([propName, propDefinition as any]);\n            } else {\n                this.currentStyledProperties[propName] = propDefinition;\n            }\n        }\n        this.setupStaticProperties();\n    }\n\n    /**\n     * Serialize contents.\n     *\n     * `THREE.Material.userData` is serialized during `clone`/`toJSON`, so we need to ensure that\n     * we emit only \"data\" set of this object.\n     */\n    toJSON() {\n        return { styledProperties: this.styledProperties };\n    }\n\n    /**\n     * Ensure that underlying object is updated to current state of {@link MapView}.\n     *\n     * Updates dynamically styled properties of material by evaluating scene dependent expressions.\n     *\n     * Executes updates only once per frame basing on [[MapView.frameNumber]].\n     *\n     * @returns `true` if object performed some kind of update, `false` if no update was needed.\n     */\n    ensureUpdated(context: MapAdapterUpdateEnv) {\n        if (this.m_lastUpdateFrameNumber === context.frameNumber) {\n            return false;\n        }\n        this.m_lastUpdateFrameNumber = context.frameNumber;\n\n        return this.updateDynamicProperties(context);\n    }\n\n    /**\n     * Applies static properties to target material.\n     */\n    private setupStaticProperties() {\n        let updateBaseColor = false;\n        for (const propName in this.styledProperties) {\n            if (!this.styledProperties.hasOwnProperty(propName)) {\n                continue;\n            }\n            const currentValue = this.currentStyledProperties[propName];\n            if (currentValue === undefined || currentValue === null) {\n                continue;\n            }\n            if (propName === \"color\" || propName === \"opacity\") {\n                updateBaseColor = true;\n            } else {\n                this.applyMaterialGenericProp(propName, currentValue);\n            }\n        }\n        if (updateBaseColor) {\n            const color = (this.currentStyledProperties.color as number) ?? 0xff0000;\n            const opacity = (this.currentStyledProperties.opacity as number) ?? 1;\n            this.applyMaterialBaseColor(color, opacity);\n        }\n    }\n\n    /**\n     * Applies static properties to target material.\n     */\n    private updateDynamicProperties(context: MapAdapterUpdateEnv) {\n        let somethingChanged = false;\n        if (this.m_dynamicProperties.length > 0) {\n            let updateBaseColor = false;\n\n            for (const [propName, propDefinition] of this.m_dynamicProperties) {\n                const newValue = Expr.isExpr(propDefinition)\n                    ? getPropertyValue(propDefinition, context.env)\n                    : propDefinition(context);\n                if (newValue === this.currentStyledProperties[propName]) {\n                    continue;\n                }\n                this.currentStyledProperties[propName] = newValue;\n\n                // `color` and `opacity` are special properties to support RGBA\n                if (propName === \"color\" || propName === \"opacity\") {\n                    updateBaseColor = true;\n                } else {\n                    this.applyMaterialGenericProp(propName, newValue);\n                    somethingChanged = true;\n                }\n            }\n\n            if (updateBaseColor) {\n                const color = this.currentStyledProperties.color ?? 0xff0000;\n                const opacity = (this.currentStyledProperties.opacity as number) ?? 1;\n                this.applyMaterialBaseColor(color, opacity);\n                somethingChanged = true;\n            }\n        }\n        return somethingChanged;\n    }\n\n    private applyMaterialGenericProp(propName: string, value: Value) {\n        const m = this.material as any;\n        if (m[propName] instanceof THREE.Color) {\n            let colorValue = value;\n            if (typeof colorValue !== \"number\") {\n                const parsed = evaluateColorProperty(colorValue);\n                if (parsed === undefined) {\n                    return;\n                }\n                colorValue = parsed;\n            }\n            const rgbValue = ColorUtils.removeAlphaFromHex(colorValue);\n            m[propName].set(rgbValue);\n        } else {\n            m[propName] = value;\n        }\n    }\n\n    private applyMaterialBaseColor(color: Value, opacity: number | undefined) {\n        if (typeof color !== \"number\") {\n            const parsed = evaluateColorProperty(color);\n            if (parsed === undefined) {\n                return;\n            }\n            color = parsed;\n        }\n        const { r, g, b, a } = ColorUtils.getRgbaFromHex(color ?? 0xff0000);\n        const actualOpacity = a * THREE.MathUtils.clamp(opacity ?? 1, 0, 1);\n        this.material.opacity = actualOpacity;\n        (this.material as any).color.setRGB(r, g, b);\n\n        const opaque = actualOpacity >= 1.0;\n        if (!opaque) {\n            enableBlending(this.material);\n        } else {\n            disableBlending(this.material);\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\nimport { PickingRaycaster } from \"./PickingRaycaster\";\n\n/**\n * `MapViewPoints` is a class to extend for the `\"circles\"` and `\"squares\"` [[Technique]]s to\n * implement raycasting of [[THREE.Points]] as expected in\n * {@link MapView}, that are in screen space.\n * It copies the behaviour of the `raycast` method in [[THREE.Points]] and dispatches it to its\n * children classes, {@link Circles} and {@link Squares}, who hold the intersection testing in the\n * `testPoint` method. This class also has the ability to dismiss the testing via the\n * `enableRayTesting` flag.\n *\n * Its main motivation is to handle the point styles of XYZ projects.\n *\n * @see https://github.com/mrdoob/three.js/blob/master/src/objects/Points.js\n */\nexport abstract class MapViewPoints extends THREE.Points {\n    /**\n     * This allows to discard the ray testing.\n     */\n    enableRayTesting: boolean = true;\n\n    /**\n     * Implements the intersection testing in screen space between the drawn points and the ray.\n     *\n     * @remarks The drawing of the points being different between {@link Circles}\n     * and {@link Squares}, this method is implemented in these child classes.\n     *\n     * @param point - The point to test.\n     * @param screenPosition - The point position on screen.\n     * @param pickCoordinates - The picking position on screen.\n     * @param index - The index of the point in the [[THREE.Geometry]].\n     * @param distance - The distance between the point and the ray origin.\n     * @param intersects - The results array.\n     */\n    abstract testPoint(\n        point: THREE.Vector3,\n        screenPosition: THREE.Vector2,\n        pickCoordinates: THREE.Vector2,\n        index: number,\n        distance: number,\n        intersects: THREE.Intersection[]\n    ): void;\n\n    /**\n     * This method is similar to the original method `raycast` in [[THREE.Points]] except that it\n     * then calls the tailored `testPoint` method in the children classes to test intersections\n     * depending on whether the points are circles or squares, which [[THREE.Points]] cannot do.\n     *\n     * @param raycaster - The raycaster.\n     * @param intersects - The array to fill with the results.\n     */\n    raycast(raycaster: PickingRaycaster, intersects: THREE.Intersection[]) {\n        if (!this.enableRayTesting) {\n            return;\n        }\n\n        const geometry = this.geometry;\n        const matrixWorld = this.matrixWorld;\n        const screenCoords = raycaster.ray.origin\n            .clone()\n            .add(raycaster.ray.direction)\n            .project(raycaster.camera);\n        const mouseCoords = new THREE.Vector2(\n            Math.ceil(((screenCoords.x + 1) / 2) * raycaster.width),\n            Math.ceil(((1 - screenCoords.y) / 2) * raycaster.height)\n        );\n\n        if (geometry instanceof THREE.BufferGeometry) {\n            const point = new THREE.Vector3();\n            const index = geometry.index;\n            const attributes = geometry.attributes;\n            const positions = attributes.position.array;\n            if (index !== null) {\n                const indices = index.array;\n                for (let i = 0, il = indices.length; i < il; i++) {\n                    const a = indices[i];\n                    point.fromArray(positions as number[], a * 3);\n                    const pointInfo = getPointInfo(point, matrixWorld, raycaster);\n                    if (pointInfo.pointIsOnScreen) {\n                        this.testPoint(\n                            point,\n                            pointInfo.absoluteScreenPosition!,\n                            mouseCoords,\n                            i,\n                            pointInfo.distance!,\n                            intersects\n                        );\n                    }\n                }\n            } else {\n                for (let i = 0, l = positions.length / 3; i < l; i++) {\n                    point.fromArray(positions as number[], i * 3);\n                    const pointInfo = getPointInfo(point, matrixWorld, raycaster);\n                    if (pointInfo.pointIsOnScreen) {\n                        this.testPoint(\n                            point,\n                            pointInfo.absoluteScreenPosition!,\n                            mouseCoords,\n                            i,\n                            pointInfo.distance!,\n                            intersects\n                        );\n                    }\n                }\n            }\n        } else {\n            const vertices = geometry.vertices;\n            for (let index = 0; index < vertices.length; index++) {\n                const point = vertices[index];\n                const pointInfo = getPointInfo(point, matrixWorld, raycaster);\n                if (pointInfo.pointIsOnScreen) {\n                    this.testPoint(\n                        point,\n                        pointInfo.absoluteScreenPosition!,\n                        mouseCoords,\n                        index,\n                        pointInfo.distance!,\n                        intersects\n                    );\n                }\n            }\n        }\n    }\n}\n\nfunction getPointInfo(\n    point: THREE.Vector3,\n    matrixWorld: THREE.Matrix4,\n    raycaster: PickingRaycaster\n): {\n    pointIsOnScreen: boolean;\n    absoluteScreenPosition?: THREE.Vector2;\n    distance?: number;\n} {\n    const worldPosition = point.clone();\n    worldPosition.applyMatrix4(matrixWorld);\n    const distance = worldPosition.distanceTo(raycaster.ray.origin);\n    worldPosition.project(raycaster.camera);\n    const relativeScreenPosition = new THREE.Vector2(worldPosition.x, worldPosition.y);\n    const pointIsOnScreen =\n        relativeScreenPosition.x < 1 &&\n        relativeScreenPosition.x > -1 &&\n        relativeScreenPosition.y < 1 &&\n        relativeScreenPosition.y > -1;\n    if (pointIsOnScreen) {\n        worldPosition.x = ((worldPosition.x + 1) / 2) * raycaster.width;\n        worldPosition.y = ((1 - worldPosition.y) / 2) * raycaster.height;\n        const absoluteScreenPosition = new THREE.Vector2(worldPosition.x, worldPosition.y);\n        return {\n            absoluteScreenPosition,\n            pointIsOnScreen,\n            distance\n        };\n    }\n    return {\n        pointIsOnScreen\n    };\n}\n\n/**\n * Point object that implements the raycasting of circles in screen space.\n */\nexport class Circles extends MapViewPoints {\n    /** @override */\n    testPoint(\n        point: THREE.Vector3,\n        screenPosition: THREE.Vector2,\n        pickCoordinates: THREE.Vector2,\n        index: number,\n        distance: number,\n        intersects: THREE.Intersection[]\n    ) {\n        const dx = screenPosition.x - pickCoordinates.x;\n        const dy = screenPosition.y - pickCoordinates.y;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n        const radius = (this.material as THREE.PointsMaterial).size / 2;\n\n        if (dist <= radius) {\n            intersects.push({\n                point,\n                distance,\n                index,\n                object: this\n            });\n        }\n    }\n}\n\n/**\n * Point object that implements the raycasting of squares in screen space.\n */\nexport class Squares extends MapViewPoints {\n    /** @override */\n    testPoint(\n        point: THREE.Vector3,\n        screenPosition: THREE.Vector2,\n        pickCoordinates: THREE.Vector2,\n        index: number,\n        distance: number,\n        intersects: THREE.Intersection[]\n    ) {\n        const dx = screenPosition.x - pickCoordinates.x;\n        const dy = screenPosition.y - pickCoordinates.y;\n        const halfSize = (this.material as THREE.PointsMaterial).size / 2;\n\n        if (Math.abs(dx) <= halfSize && Math.abs(dy) <= halfSize) {\n            intersects.push({\n                point,\n                distance,\n                index,\n                object: this\n            });\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\n/**\n * Usage in Modules:\n *\n * import { DebugContext, debugContext } from \"../lib/DebugContext\";\n *\n * Declare a debug option:\n * debugContext.settings.setOption(\"MY_DBG_OPT\", \"default\");\n *\n * Access an option:\n * if (debugContext.settings.option(\"MY_DBG_OPT\")) {\n *     ...\n * }\n *\n *\n * Access in browser console:\n *\n * window.__debugContext.settings.addEventListener(\"MY_DBG_OPT\", function(event) {\n *  console.log(\"name:\", event.type, \"value:\", event.value)});\n *\n */\n\n/**\n * Allows access to the global `window` object here. The constructor of [[DebugContext]] adds the\n * instance to `window`, so it is available from the browser console.\n */\n\ninterface DebugInfo {\n    __debugContext?: DebugContext;\n}\n\nconst isNode = typeof window === \"undefined\";\n\n/**\n * A `DebugOption` is a pair that consists of an option value and an array of change listeners.\n * Listeners are called up when setting the option's value.\n */\nclass DebugOption extends THREE.EventDispatcher {\n    static SET_EVENT_TYPE: string = \"set\";\n\n    /**\n     * Constructs the `DebugOption`.\n     *\n     * @param value - The value of the option.\n     */\n    constructor(public value: any) {\n        super();\n    }\n\n    /**\n     * Updates the value of a given option.\n     *\n     * @param value - The new value for the option.\n     * @param name - The name of the option to set.\n     */\n    set(value: any, name: string) {\n        this.value = value;\n        this.dispatchEvent({ type: DebugOption.SET_EVENT_TYPE, name, value });\n    }\n}\n\n/**\n * Maintains a map of [[DebugOption]]s. You can add listeners to debug options by passing their\n * names.\n */\nexport class DebugContext {\n    private m_optionsMap: Map<string, DebugOption>;\n\n    /**\n     * Builds a `DebugContext`.\n     */\n    constructor() {\n        this.m_optionsMap = new Map<string, DebugOption>();\n\n        // If we have a `window` object, we store the context in it to make it available in the\n        // console.\n        if (!isNode && typeof window !== \"undefined\" && window) {\n            const debugInfo = window as DebugInfo;\n            debugInfo.__debugContext = this;\n        }\n    }\n\n    /**\n     * Sets the value of an option. Calls change listeners of that option, even if the value has\n     * not been changed. The change listeners provided here are not called during this set\n     * operation.\n     *\n     * @param name - Name of the option.\n     * @param value - Value of the option.\n     */\n    setValue(name: string, value: any): void {\n        let opt = this.m_optionsMap.get(name);\n        if (!opt) {\n            opt = new DebugOption(value);\n            this.m_optionsMap.set(name, opt);\n        } else {\n            opt.set(value, name);\n        }\n    }\n\n    /**\n     * Gets the option value.\n     *\n     * @param name - Name of option.\n     */\n    getValue(name: string): any {\n        const opt = this.m_optionsMap.get(name);\n        return opt ? opt.value : undefined;\n    }\n\n    /**\n     * Determines if the option is registered.\n     *\n     * @param name - Name of option.\n     */\n    hasOption(name: string): boolean {\n        return this.m_optionsMap.get(name) !== undefined;\n    }\n\n    /**\n     * Adds a listener to a debug option.\n     *\n     * @param name - Name of the option that requires a listener.\n     * @param listener - The listener function to add.\n     */\n    addEventListener(name: string, listener: (event: THREE.Event) => void) {\n        const opt = this.m_optionsMap.get(name);\n        if (opt) {\n            opt.addEventListener(DebugOption.SET_EVENT_TYPE, listener);\n        } else {\n            throw Error(\"Unknown option: \" + name);\n        }\n    }\n\n    /**\n     * Checks for a listener in a debug option.\n     *\n     * @param name - Name of the option to check for.\n     * @param listener - The listener function to check for.\n     */\n    hasEventListener(name: string, listener: (event: THREE.Event) => void) {\n        const opt = this.m_optionsMap.get(name);\n        if (opt) {\n            return opt.hasEventListener(DebugOption.SET_EVENT_TYPE, listener);\n        } else {\n            throw Error(\"Unknown option: \" + name);\n        }\n    }\n\n    /**\n     * Removes a listener from a debug option.\n     *\n     * @param name - Name of the option from which to remove a listener.\n     * @param listener - The listener function to remove.\n     */\n    removeEventListener(name: string, listener: (event: THREE.Event) => void) {\n        const opt = this.m_optionsMap.get(name);\n        if (opt) {\n            opt.removeEventListener(DebugOption.SET_EVENT_TYPE, listener);\n        } else {\n            throw Error(\"Unknown option: \" + name);\n        }\n    }\n\n    /**\n     * Provides access to the options map. This method is useful for creating an automatic\n     * browser GUI.\n     */\n    get options(): Map<string, any> {\n        return this.m_optionsMap;\n    }\n\n    /**\n     * Clears away all debug options. Currently, `THREE.EventDispatcher` does not provide an API\n     * to remove all event listeners.\n     */\n    clear() {\n        this.m_optionsMap.forEach(option => {\n            option.set(undefined, \"\");\n        });\n    }\n}\n\nexport const debugContext = new DebugContext();\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeometryType, getFeatureId, Technique } from \"@here/harp-datasource-protocol\";\nimport * as THREE from \"three\";\n\nimport { OrientedBox3 } from \"@here/harp-geoutils\";\nimport { MapView } from \"./MapView\";\nimport { MapViewPoints } from \"./MapViewPoints\";\nimport { TileFeatureData } from \"./Tile\";\n\n/**\n * Describes the general type of a picked object.\n */\nexport enum PickObjectType {\n    /**\n     * Unspecified.\n     */\n    Unspecified = 0,\n\n    /**\n     * A point object.\n     */\n    Point,\n\n    /**\n     * A line object.\n     */\n    Line,\n\n    /**\n     * An area object.\n     */\n    Area,\n\n    /**\n     * The text part of a {@link TextElement}\n     */\n    Text,\n\n    /**\n     * The Icon of a {@link TextElement}.\n     */\n    Icon,\n\n    /**\n     * Any general 3D object, for example, a landmark.\n     */\n    Object3D\n}\n\n/**\n * A general pick result. You can access the details of a picked geometry from the property\n * `intersection`, which is available if a geometry was hit. If a road was hit, a [[RoadPickResult]]\n * is returned, which has additional information, but no `intersection`.\n */\nexport interface PickResult {\n    /**\n     * General type of object.\n     */\n    type: PickObjectType;\n\n    /**\n     * A 2D point in screen coordinates, or a 3D point in world coordinates.\n     */\n    point: THREE.Vector2 | THREE.Vector3;\n\n    /**\n     * Distance from the camera to the picking point; used to determine the closest object.\n     */\n    distance: number;\n\n    /**\n     * An optional feature ID of the picked object; typically applies to the Optimized Map\n     * Vector (OMV) format.\n     */\n    featureId?: number;\n\n    /**\n     * Defined for geometry only.\n     */\n    intersection?: THREE.Intersection;\n\n    /**\n     * Defined for roads or if `enableTechniqueInfo` option is enabled.\n     */\n    technique?: Technique;\n\n    /**\n     * Optional user data that has been defined in the picked object.\n     *\n     * @remarks\n     * This object points directly to\n     * information contained in the original {@link TileFeatureData}\n     * stored in {@link MapView}, and should\n     * not be modified.\n     */\n    userData?: any;\n}\n\nconst tmpOBB = new OrientedBox3();\n\n/**\n * Handles the picking of scene geometry and roads.\n * @internal\n */\nexport class PickHandler {\n    constructor(\n        readonly mapView: MapView,\n        readonly camera: THREE.Camera,\n        public enablePickTechnique = false\n    ) {}\n\n    /**\n     * Does a raycast on all objects in the scene; useful for picking. This function is Limited to\n     * objects that THREE.js can raycast. However, any solid lines that have their geometry in the\n     * shader cannot be tested for intersection.\n     *\n     * @param x - The X position in CSS/client coordinates, without the applied display ratio.\n     * @param y - The Y position in CSS/client coordinates, without the applied display ratio.\n     * @returns the list of intersection results.\n     */\n    intersectMapObjects(x: number, y: number): PickResult[] {\n        const worldPos = this.mapView.getNormalizedScreenCoordinates(x, y);\n        const rayCaster = this.mapView.raycasterFromScreenPoint(x, y);\n        const pickResults: PickResult[] = [];\n\n        if (this.mapView.textElementsRenderer !== undefined) {\n            const { clientWidth, clientHeight } = this.mapView.canvas;\n            const screenX = worldPos.x * clientWidth * 0.5;\n            const screenY = worldPos.y * clientHeight * 0.5;\n            const scenePosition = new THREE.Vector2(screenX, screenY);\n            this.mapView.textElementsRenderer.pickTextElements(scenePosition, pickResults);\n        }\n\n        const intersects: THREE.Intersection[] = [];\n        const tileList = this.mapView.visibleTileSet.dataSourceTileList;\n        tileList.forEach(dataSourceTileList => {\n            dataSourceTileList.renderedTiles.forEach(tile => {\n                tmpOBB.copy(tile.boundingBox);\n                tmpOBB.position.sub(this.mapView.worldCenter);\n                // This offset shifts the box by the given tile offset, see renderTileObjects in\n                // MapView\n                const worldOffsetX = tile.computeWorldOffsetX();\n                tmpOBB.position.x += worldOffsetX;\n\n                if (tmpOBB.intersectsRay(rayCaster.ray) !== undefined) {\n                    rayCaster.intersectObjects(tile.objects, true, intersects);\n                }\n            });\n        });\n\n        for (const intersect of intersects) {\n            const pickResult: PickResult = {\n                type: PickObjectType.Unspecified,\n                point: intersect.point,\n                distance: intersect.distance,\n                intersection: intersect\n            };\n\n            if (\n                intersect.object.userData === undefined ||\n                intersect.object.userData.feature === undefined\n            ) {\n                pickResults.push(pickResult);\n                continue;\n            }\n\n            const featureData: TileFeatureData = intersect.object.userData.feature;\n            if (this.enablePickTechnique) {\n                pickResult.technique = intersect.object.userData.technique;\n            }\n\n            this.addObjInfo(featureData, intersect, pickResult);\n\n            if (featureData.objInfos !== undefined) {\n                const featureId =\n                    featureData.objInfos.length === 1\n                        ? getFeatureId(featureData.objInfos[0])\n                        : undefined;\n                pickResult.featureId = featureId;\n            }\n\n            let pickObjectType: PickObjectType;\n\n            switch (featureData.geometryType) {\n                case GeometryType.Point:\n                case GeometryType.Text:\n                    pickObjectType = PickObjectType.Point;\n                    break;\n                case GeometryType.Line:\n                case GeometryType.ExtrudedLine:\n                case GeometryType.SolidLine:\n                case GeometryType.TextPath:\n                    pickObjectType = PickObjectType.Line;\n                    break;\n                case GeometryType.Polygon:\n                case GeometryType.ExtrudedPolygon:\n                    pickObjectType = PickObjectType.Area;\n                    break;\n                case GeometryType.Object3D:\n                    pickObjectType = PickObjectType.Object3D;\n                    break;\n                default:\n                    pickObjectType = PickObjectType.Unspecified;\n            }\n\n            pickResult.type = pickObjectType;\n            pickResults.push(pickResult);\n        }\n\n        pickResults.sort((a: PickResult, b: PickResult) => {\n            return a.distance - b.distance;\n        });\n\n        return pickResults;\n    }\n\n    private addObjInfo(\n        featureData: TileFeatureData,\n        intersect: THREE.Intersection,\n        pickResult: PickResult\n    ) {\n        if (featureData.objInfos === undefined) {\n            return;\n        }\n\n        if (pickResult.intersection!.object instanceof MapViewPoints) {\n            pickResult.userData = featureData.objInfos[intersect.index!];\n            return;\n        }\n\n        if (\n            featureData.starts === undefined ||\n            featureData.starts.length === 0 ||\n            (intersect.faceIndex === undefined && intersect.index === undefined)\n        ) {\n            return;\n        }\n\n        if (featureData.starts.length === 1) {\n            pickResult.userData = featureData.objInfos[0];\n            return;\n        }\n\n        const intersectIndex =\n            intersect.faceIndex !== undefined ? intersect.faceIndex * 3 : intersect.index!;\n\n        // TODO: Implement binary search.\n        let objInfosIndex = 0;\n        for (const featureStartIndex of featureData.starts) {\n            if (featureStartIndex > intersectIndex) {\n                break;\n            }\n            objInfosIndex++;\n        }\n        pickResult.userData = featureData.objInfos[objInfosIndex - 1];\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { getOptionValue, MathUtils } from \"@here/harp-utils\";\n\n/**\n * Copyright info attached to data displayed on map. Provided by {@link DataSource} and attached\n * to {@link Tile}s.\n *\n * In most cases, an application should display this information on {@link MapView} to conform with\n * licencing terms of its map data providers.\n *\n * @see {@link CopyrightElementHandler}\n */\nexport interface CopyrightInfo {\n    /**\n     * Unique id of the copyright holder.\n     *\n     * @remarks\n     * `id`s should be unique. It is recommended to build them from unique identifiers like\n     * registered domain names.\n     *\n     * Examples:\n     *\n     *  * `openstreetmap.org` - for data originating from OpenStreetMap project\n     *  * `naturalearthdata.com` - for data originating from Natural Earth dataset\n     *\n     * Note: {@link DataSource} may return {@link CopyrightInfo}\n     * with only `id`, thus defining only holder\n     * of copyright, however, valid attribution may require proper `label` and `link`.\n     *\n     * Entries with same `id` are deduplicated by {@link CopyrightInfo.mergeArrays}.\n     */\n    id: string;\n\n    /**\n     * Copyright text to display after the copyright symbol on the map.\n     *\n     * If undefined, `id` is used as text label.\n     * Set it to empty string to not render a copyright info.\n     */\n    label?: string;\n\n    /**\n     * Optional URL pointing to further copyright information.\n     */\n    link?: string;\n\n    /**\n     * Optional, copyright notice year.\n     */\n    year?: number;\n}\n\nexport namespace CopyrightInfo {\n    /**\n     * Merge {@link CopyrightInfo} arrays, removing duplicates.\n     *\n     * `id` and `label` are considered keys in deduplication algorithm.\n     *\n     * @param sources - non-duplicate elements from this array are added to `target`\n     * @returns merge of all copyright infos in `sources`\n     */\n    export function mergeArrays(a: CopyrightInfo[], b?: CopyrightInfo[]): CopyrightInfo[] {\n        const result: CopyrightInfo[] = [];\n        for (const source of [a, b]) {\n            if (source === undefined) {\n                continue;\n            }\n\n            for (const sourceInfo of source) {\n                const existingInfo = result.find(\n                    findItem =>\n                        findItem.id === sourceInfo.id ||\n                        (findItem.label !== undefined && findItem.label === sourceInfo.label)\n                );\n\n                if (existingInfo === undefined) {\n                    result.push({ ...sourceInfo });\n                } else {\n                    existingInfo.year = MathUtils.max2(sourceInfo.year, existingInfo.year);\n                    existingInfo.label = getOptionValue(sourceInfo.label, existingInfo.label);\n                    existingInfo.link = getOptionValue(sourceInfo.link, existingInfo.link);\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Format copyright information to a HTML string that can be displayed in the UI.\n     *\n     * * Empty list returns empty string.\n     * * Entries with empty (but defined) labels are skipped.\n     *\n     * @param copyrightInfo - Array of copyrights to format.\n     */\n    export function formatAsHtml(copyrightInfo: CopyrightInfo[]): string {\n        if (copyrightInfo.length === 0) {\n            return \"\";\n        }\n\n        const filtered = copyrightInfo.filter(entry => entry.label !== \"\");\n        if (filtered.length === 0) {\n            return \"\";\n        }\n\n        return (\n            \" \" +\n            filtered\n                .map(entry => {\n                    const label = entry.label ?? entry.id;\n                    const text = entry.year !== undefined ? `${entry.year} ${label}` : label;\n                    const link = entry.link;\n                    return link\n                        ? `<a href=\"${link}\" target=\"_blank\" rel=\"noreferrer noopener\">${text}</a>`\n                        : `${text}`;\n                })\n                .join(\", \")\n        );\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    HighPrecisionLineMaterial,\n    HighPrecisionPointMaterial,\n    isHighPrecisionPointMaterial\n} from \"@here/harp-materials\";\nimport {\n    BufferAttribute,\n    BufferGeometry,\n    Camera,\n    Color,\n    Float32BufferAttribute,\n    InterleavedBuffer,\n    InterleavedBufferAttribute,\n    Matrix4,\n    PointsMaterialParameters,\n    ShaderMaterial,\n    ShaderMaterialParameters,\n    Vector3\n} from \"three\";\n\nimport * as HPL from \"./HighPrecisionLines\";\nimport * as HPP from \"./HighPrecisionPoints\";\nimport { triangulateLine } from \"./TriangulateLines\";\n\nexport namespace HighPrecisionUtils {\n    /**\n     * Extract the `float` parts of all vector members, Making this a `Vector3` of `float`.\n     * precision.\n     *\n     * @param v -\n     */\n    export function doubleToFloatVec(v: Vector3): Vector3 {\n        return new Vector3(Math.fround(v.x), Math.fround(v.y), Math.fround(v.z));\n    }\n\n    /**\n     * Convert a `Vector3` to `float` (in place!) Returns the minor float vector, which is the\n     * difference of the double elements and their float counterparts.\n     *\n     * @param v - Vector3 to convert to float IN-PLACE!\n     */\n    export function makeFloatVec(v: Vector3): Vector3 {\n        const majorX = Math.fround(v.x);\n        const majorY = Math.fround(v.y);\n        const majorZ = Math.fround(v.z);\n\n        const minorVec = new Vector3(v.x - majorX, v.y - majorY, v.z - majorZ);\n\n        v.x = Math.fround(majorX);\n        v.y = Math.fround(majorY);\n        v.z = Math.fround(majorZ);\n\n        return minorVec;\n    }\n\n    /**\n     * Describes addtional postion data needed to render high-precision vertices. Created by\n     * [[createHighPrecisionCameraPos]].\n     */\n    export interface HighPrecisionCameraInfo {\n        /**\n         * View Projection matrix of this high-precision camera.\n         */\n        viewProjection: Matrix4;\n\n        /**\n         * Low-order bits of the high-precision camera's position.\n         */\n        eyePosLo: Vector3;\n\n        /**\n         * High-order bits of the high-precision camera's position.\n         */\n        eyePosHi: Vector3;\n    }\n\n    /**\n     * Describes different properties used when creating a [[HighPrecisionLine]] or\n     * a [[HighPrecisionWireFrameLine]].\n     */\n    export interface HighPrecisionLineParams extends ShaderMaterialParameters {\n        /**\n         * Color of the rendered line.\n         */\n        color?: number | string | Color;\n\n        /**\n         * Width of the rendered line (specified in world units).\n         */\n        lineWidth?: number;\n\n        /**\n         * Add rounded caps to the extremes of the line if set to `true`.\n         */\n        addCircles?: boolean;\n\n        /**\n         * Opacity of the rendered line.\n         */\n        opacity?: number;\n\n        /**\n         * Renders a wireframe line if set to `true`.\n         */\n        wireFrame?: boolean;\n    }\n\n    /**\n     * Calculate high-precision camera position used in vertex shader of high-precision materials.\n     *\n     * @param camera - Camera used to get the high-precision position.\n     * @param objectInverseWorldMatrix - Inverse World Matrix of the rendered\n     *                                   [[HighPrecisionObject]].\n     */\n    export function createHighPrecisionCameraPos(\n        camera: Camera,\n        objectInverseWorldMatrix: Matrix4\n    ): HighPrecisionCameraInfo {\n        const _projScreenMatrix = new Matrix4().copy(camera.projectionMatrix);\n        const mvp = _projScreenMatrix.multiply(camera.matrixWorldInverse);\n        const eyePos = new Vector3(0, 0, 0).applyMatrix4(objectInverseWorldMatrix);\n\n        // split the double float vector into hi and lo parts\n        const eyePosFloat = doubleToFloatVec(eyePos);\n\n        const eyePosLo = doubleToFloatVec(eyePos.sub(eyePosFloat));\n\n        return {\n            viewProjection: mvp,\n            eyePosHi: eyePosFloat,\n            eyePosLo\n        };\n    }\n\n    /**\n     * Updates the high-precision uniform data of a material used to render a\n     * [[HighPrecisionObject]].\n     *\n     * @param object - [[HighPrecisionObject]] used for rendering.\n     * @param camera - Camera used to get the high-precision position.\n     * @param shaderMaterial - Material which uniforms will be updated.\n     */\n    export function updateHpUniforms(\n        object: HPL.HighPrecisionObject,\n        camera: Camera,\n        shaderMaterial: ShaderMaterial\n    ): void {\n        const highPrecisionCameraInfo = createHighPrecisionCameraPos(\n            camera,\n            object.matrixWorldInverse\n        );\n        const mvp = highPrecisionCameraInfo.viewProjection;\n\n        if (shaderMaterial !== undefined && shaderMaterial.isMaterial) {\n            if (\n                shaderMaterial.uniforms &&\n                shaderMaterial.uniforms.u_mvp &&\n                shaderMaterial.uniforms.u_eyepos &&\n                shaderMaterial.uniforms.u_eyepos_lowpart\n            ) {\n                shaderMaterial.uniforms.u_mvp.value = new Float32Array(mvp.elements);\n                shaderMaterial.uniforms.u_eyepos.value = new Float32Array(\n                    highPrecisionCameraInfo.eyePosHi.toArray()\n                );\n                shaderMaterial.uniforms.u_eyepos_lowpart.value = new Float32Array(\n                    highPrecisionCameraInfo.eyePosLo.toArray()\n                );\n            } else {\n                throw Error(\"High pecision material has missing uniforms\");\n            }\n        } else {\n            throw Error(\"High pecision line has no high precision material\");\n        }\n    }\n\n    /**\n     * Assembles the necessary attribute buffers needed to render [[HighPrecisionObject]].\n     *\n     * @param positions - Array of positions.\n     */\n    export function createAttributes(\n        positions: ArrayLike<number> | ArrayLike<Vector3>\n    ): {\n        positionHigh: BufferAttribute;\n        positionLow: BufferAttribute;\n    } {\n        if (positions.length > 0) {\n            const v = positions[0];\n\n            if (v === undefined || v === null) {\n                throw Error(\"Empty element in positions\");\n            }\n\n            const positionVec = new Array<number>();\n            const positionVecLow = new Array<number>();\n\n            const addHPValue = (...values: number[]) => {\n                for (const value of values) {\n                    const major = Math.fround(value);\n                    positionVecLow.push(value - major);\n                    positionVec.push(major);\n                }\n            };\n\n            const addHPVector = (vec: Vector3) => {\n                addHPValue(vec.x, vec.y, vec.z);\n            };\n\n            const vAny = v as any;\n            if (vAny.z !== undefined) {\n                (positions as Vector3[]).forEach(vec => {\n                    addHPVector(vec);\n                });\n            } else {\n                if (positionVec.length % 3 !== 0) {\n                    throw Error(\"Positions must be 3D, not 2D\");\n                }\n                (positions as number[]).forEach((n: number): void => {\n                    addHPValue(n);\n                });\n            }\n\n            return {\n                positionHigh: new Float32BufferAttribute(positionVec, 3),\n                positionLow: new Float32BufferAttribute(positionVecLow, 3)\n            };\n        } else {\n            return {\n                positionHigh: new Float32BufferAttribute([], 3),\n                positionLow: new Float32BufferAttribute([], 3)\n            };\n        }\n    }\n\n    /**\n     * Assembles an interleaved buffer containing the position attribute data for a\n     * [[HighPrecisionObject]].\n     *\n     * @param positions - Array of positions.\n     * @param stride - Stride of the elements in the `positions` array.\n     * @param positionOffset - Offset into the `positions` array.\n     */\n    export function addInterleavedAttributes3(\n        positions: ArrayLike<number>,\n        stride: number,\n        positionOffset = 0\n    ): ArrayLike<number> {\n        const newPositions = new Array<number>();\n\n        const end = positions.length;\n\n        for (let i = 0; i < end; i += stride) {\n            for (let j = 0; j < positionOffset; j++) {\n                newPositions.push(positions[i + j]);\n            }\n\n            const x = positions[i + positionOffset];\n            const y = positions[i + positionOffset + 1];\n            const z = positions[i + positionOffset + 2];\n            const majorX = Math.fround(x);\n            const minorX = x - majorX;\n            const majorY = Math.fround(y);\n            const minorY = y - majorY;\n            const majorZ = Math.fround(z);\n            const minorZ = z - majorZ;\n\n            // insert values in interleaved buffer\n            newPositions.push(majorX, majorY, majorZ, minorX, minorY, minorZ);\n\n            for (let j = positionOffset + 3; j < stride; j++) {\n                newPositions.push(positions[i + j]);\n            }\n        }\n\n        return newPositions;\n    }\n\n    /**\n     * Adds the high-precision position attribute data to a [[HighPrecisionObject]].\n     *\n     * @param object - [[HighPrecisionObject]] which position attribute will be set.\n     * @param positions - Array of positions.\n     */\n    export function setPositions(\n        object: HPL.HighPrecisionObject,\n        positions: ArrayLike<number> | ArrayLike<Vector3>\n    ): number {\n        const attributes = createAttributes(positions);\n\n        object.bufferGeometry.setAttribute(\"position\", attributes.positionHigh);\n        object.bufferGeometry.setAttribute(\"positionLow\", attributes.positionLow);\n\n        return attributes.positionHigh.itemSize;\n    }\n\n    /**\n     * Convert positions from `Array<Vector3>` to `Array<number>`.\n     *\n     * @param positions - Array of positions.\n     */\n    export function convertPositions(\n        positions: ArrayLike<number> | ArrayLike<Vector3>\n    ): { positions: number[] } {\n        if (positions.length <= 0) {\n            return { positions: [] };\n        }\n\n        const v = positions[0];\n\n        if (v === undefined || v === null) {\n            throw Error(\"Empty element in positions\");\n        }\n\n        const vAny = v as any;\n        if (vAny.y === undefined && vAny.z === undefined) {\n            return { positions: positions as number[] };\n        }\n\n        const returnPositions = new Array<number>();\n        (positions as Vector3[]).forEach(vec => {\n            returnPositions.push(vec.x, vec.y, vec.z);\n        });\n\n        return { positions: returnPositions };\n    }\n\n    /**\n     * Creates a [[HighPrecisionLine]] or [[HighPrecisionWireFrameLine]] object.\n     *\n     * @param linePositions - Array of 2D/3D positions.\n     * @param params - Parameters used to configure the created [[HighPrecisionObject]].\n     */\n    export function createLine(\n        linePositions: ArrayLike<number>,\n        params: HighPrecisionLineParams\n    ): HPL.HighPrecisionLine | HPL.HighPrecisionWireFrameLine {\n        const lineWidth = params.lineWidth !== undefined ? params.lineWidth : 5;\n        const addCircles = params.addCircles !== undefined ? params.addCircles : false;\n        const wireFrame = params.wireFrame !== undefined ? params.wireFrame : false;\n\n        const positions: number[] = [];\n        const indices: number[] = [];\n\n        triangulateLine(linePositions, lineWidth, positions, indices, addCircles);\n\n        const hpLineGeometry = new BufferGeometry();\n        const hpPositions = addInterleavedAttributes3(positions, 3);\n        const buffer = new InterleavedBuffer(new Float32Array(hpPositions), 6);\n\n        const positionAttribute = new InterleavedBufferAttribute(buffer, 3, 0, false);\n        const positionLowAttribute = new InterleavedBufferAttribute(buffer, 3, 3, false);\n\n        hpLineGeometry.setAttribute(\"position\", positionAttribute);\n        hpLineGeometry.setAttribute(\"positionLow\", positionLowAttribute);\n        hpLineGeometry.setIndex(new BufferAttribute(new Uint32Array(indices), 1));\n\n        const hpSolidMaterial = new HighPrecisionLineMaterial(params);\n\n        const lineObject = wireFrame\n            ? new HPL.HighPrecisionWireFrameLine(hpLineGeometry, hpSolidMaterial)\n            : new HPL.HighPrecisionLine(hpLineGeometry, hpSolidMaterial);\n\n        lineObject.setupForRendering();\n\n        return lineObject;\n    }\n\n    /**\n     * Creates a group of [[HighPrecisionPoints]].\n     *\n     * @param pointPositions - Array of 2D/3D positions.\n     * @param materialParameters - Parameters used to configure the material used to render the\n     * created [[HighPrecisionPoints]].\n     */\n    export function createPoints(\n        pointPositions: ArrayLike<number>,\n        materialParameters?: PointsMaterialParameters | HighPrecisionPointMaterial\n    ): HPP.HighPrecisionPoints {\n        const indices: number[] = [];\n\n        // tslint:disable-next-line:prefer-for-of - pointPositions doesn't have iterable interface\n        for (let i = 0; i < pointPositions.length; i++) {\n            indices.push(indices.length / 3);\n        }\n\n        const hpPointsGeometry = new BufferGeometry();\n\n        const hpPointsMaterial = isHighPrecisionPointMaterial(materialParameters)\n            ? materialParameters\n            : new HighPrecisionPointMaterial(materialParameters);\n\n        const pointsObject = new HPP.HighPrecisionPoints(hpPointsGeometry, hpPointsMaterial);\n\n        setPositions(pointsObject, pointPositions);\n\n        pointsObject.setupForRendering();\n\n        return pointsObject;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { Value } from \"@here/harp-datasource-protocol/index-decoder\";\n\n/**\n * Feature Modifier ids to choose which OmvFeatureModifer should be used in OmvDecoder.\n */\nexport enum FeatureModifierId {\n    /**\n     * Generic feature modifier used when no other modifiers are defined.\n     *\n     * @note You do not need to specify it in [[OmvDataSourceParameters]] as it is added by default\n     * if no other feature modifier is used.\n     */\n    default,\n    /**\n     * Identifier to use the OmvTomTomFeatureModifier in the OmvDecoder.\n     */\n    tomTom\n}\n\n/**\n * Definition of a filter.\n */\nexport interface OmvFilterString {\n    /**  String value */\n    value: string;\n    /** Match condition */\n    match: OmvFilterString.StringMatch;\n}\n\n/**\n * Adding the match condition type and the matching function to the namespace of `OmvFilterString`.\n */\nexport namespace OmvFilterString {\n    /**\n     * Match condition.\n     */\n    export enum StringMatch {\n        /** Matches any. */\n        Any,\n        /** Exact match. */\n        Match,\n        /** Matches if a test string starts with a filter string. */\n        StartsWith,\n        /** Matches if a test string contains a filter string. */\n        Contains,\n        /** Matches if a test string ends with a filter string. */\n        EndsWith\n    }\n\n    /**\n     * Check for a string against a filter.\n     *\n     * @param str - The string to check against a filter.\n     * @param filterString - The filter containing the match condition.\n     * @returns `true` if the match condition is satisfied.\n     */\n    export function matchString(str: string, filterString: OmvFilterString): boolean {\n        switch (filterString.match) {\n            case OmvFilterString.StringMatch.Any:\n                return true;\n            case OmvFilterString.StringMatch.Match:\n                return str === filterString.value;\n            case OmvFilterString.StringMatch.StartsWith:\n                return filterString.value.startsWith(str);\n            case OmvFilterString.StringMatch.EndsWith:\n                return filterString.value.endsWith(str);\n            default:\n                return str.indexOf(filterString.value) >= 0;\n        }\n    }\n}\n\n/**\n * Definition of a filter for a feature attribute\n */\nexport interface OmvFilterFeatureAttribute {\n    key: string;\n    value: Value;\n}\n\nexport enum OmvGeometryType {\n    UNKNOWN = 0,\n    POINT = 1,\n    LINESTRING = 2,\n    POLYGON = 3\n}\n\n/**\n * Internal type of a layer filter description, Should not be publicly available.\n *\n * @hidden\n */\nexport interface OmvLayerFilterDescription {\n    name: OmvFilterString;\n    minLevel: number;\n    maxLevel: number;\n}\n\n/**\n * Internal type of a single filter description, Should not be publicly available.\n *\n * @hidden\n */\nexport interface OmvFilterDescription {\n    layerName: OmvFilterString;\n    geometryTypes?: OmvGeometryType[];\n    classes?: OmvFilterString[];\n    minLevel: number;\n    maxLevel: number;\n    featureAttribute?: OmvFilterFeatureAttribute;\n}\n\n/**\n * Internal type of a complete [[OmvFeatureFilter]] description, should not be publicly available.\n *\n * @hidden\n */\nexport interface OmvFeatureFilterDescription {\n    processLayersDefault: boolean;\n    processPointsDefault: boolean;\n    processLinesDefault: boolean;\n    processPolygonsDefault: boolean;\n\n    layersToProcess: OmvLayerFilterDescription[];\n    layersToIgnore: OmvLayerFilterDescription[];\n    pointsToProcess: OmvFilterDescription[];\n    pointsToIgnore: OmvFilterDescription[];\n    linesToProcess: OmvFilterDescription[];\n    linesToIgnore: OmvFilterDescription[];\n    polygonsToProcess: OmvFilterDescription[];\n    polygonsToIgnore: OmvFilterDescription[];\n\n    // enabledKinds and disabledKinds\n    kindsToProcess: string[];\n    kindsToIgnore: string[];\n}\n\n/**\n * Internal interface for options passed from the [[OmvDataSource]] to the decoder.\n *\n * @hidden\n */\nexport interface OmvDecoderOptions {\n    /**\n     * If true, features that have no technique in the theme will be printed to the console (can be\n     * excessive!).\n     */\n    showMissingTechniques?: boolean;\n\n    /**\n     * Gather feature attributes from [[OmvData]]. Defaults to false.\n     */\n    gatherFeatureAttributes?: boolean;\n\n    /**\n     * @deprecated Tile info is not decoded anymore. The same information can be generated\n     * implementing a [[IGeometryProcessor]] and using [[OmvProtobufDataAdapter]] to decode OMV\n     * data.\n     */\n    createTileInfo?: boolean;\n\n    /**\n     * @deprecated Tile info is not decoded anymore. The same information can be generated\n     * implementing a [[IGeometryProcessor]] and using [[OmvProtobufDataAdapter]] to decode OMV\n     * data.\n     */\n    gatherRoadSegments?: boolean;\n\n    /**\n     * Optional storage level offset for [[Tile]]s. Default is -2.\n     */\n    storageLevelOffset?: number;\n\n    /**\n     * If not set to `false` very short text labels will be skipped during decoding based on a\n     * heuristic.\n     */\n    skipShortLabels?: boolean;\n\n    /**\n     * A description for the feature filter which can be safely passed down to the web workers.\n     * It has to be generated with the help of the [[OmvFeatureFilterDescriptionBuilder]] (to\n     * guarantee the correctness).\n     */\n    filterDescription?: OmvFeatureFilterDescription | null;\n\n    // NOTE: Consider using OmvFeatureModifiers objects already instead of ids, this way we could\n    // get rid of politicalView property as properly configured feature modifier (with country\n    // code), would be already defined here.\n    /**\n     * List of user specified [[OmvFeatureModifier]]s, list order declares the order of processing.\n     *\n     * Each identifier is used to choose corresponding OmvFeatureModifier, if undefined at least\n     * [[OmvGenericFeatureModifier]] is added to decoder.\n     */\n    featureModifiers?: FeatureModifierId[];\n\n    /**\n     * Country code (lower-case ISO 3166-1 alpha-2) defining optional point of view to be used.\n     * Set to empty string (\"\") if you want to use default (widely accepted) point of view.\n     * If set to `undefined` leaves current political view decoder configuration.\n     */\n    politicalView?: string;\n\n    enableElevationOverlay?: boolean;\n}\n\n/**\n * Default OMV tile decoder service type.\n *\n * Used for requesting decoder services using [[WorkerServiceManager]].\n */\nexport const OMV_TILE_DECODER_SERVICE_TYPE = \"omv-tile-decoder\";\n\n/**\n * Default OMV tiler service type.\n *\n * Used for requesting tiler services using [[WorkerServiceManager]].\n */\nexport const OMV_TILER_SERVICE_TYPE = \"omv-tiler\";\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { TileKey } from \"@here/harp-geoutils\";\nimport { DataSource, Tile } from \"@here/harp-mapview\";\n\nexport class OmvTile extends Tile {\n    constructor(dataSource: DataSource, tileKey: TileKey) {\n        super(dataSource, tileKey);\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * An [[Array]] following the order longitude, latitude, altitude.\n */\nexport type GeoPointLike = [number, number, number?];\n\n/**\n * Type guard to assert that `object` conforms to [[GeoPointLike]] interface.\n */\nexport function isGeoPointLike(geoPoint: any): geoPoint is GeoPointLike {\n    if (Array.isArray(geoPoint)) {\n        const [longitude, latitude, altitude] = geoPoint;\n        return (\n            typeof longitude === \"number\" &&\n            typeof latitude === \"number\" &&\n            (altitude === undefined || typeof altitude === \"number\")\n        );\n    }\n    return false;\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Represents an object with `LatLng` like interface.\n */\nexport interface LatLngLike {\n    /** The latitude in degrees. */\n    lat: number;\n\n    /** The longitude in degrees. */\n    lng: number;\n}\n\n/**\n * Type guard to assert that `object` conforms to {@link LatLngLike} interface.\n */\nexport function isLatLngLike(object: any): object is LatLngLike {\n    return object && typeof object.lat === \"number\" && typeof object.lng === \"number\";\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeoBox } from \"../coordinates/GeoBox\";\nimport { GeoCoordinates } from \"../coordinates/GeoCoordinates\";\nimport { GeoCoordinatesLike } from \"../coordinates/GeoCoordinatesLike\";\nimport { Box3Like, isBox3Like } from \"../math/Box3Like\";\nimport { MathUtils } from \"../math/MathUtils\";\nimport { isOrientedBox3Like, OrientedBox3Like } from \"../math/OrientedBox3Like\";\nimport { Vector3Like } from \"../math/Vector3Like\";\nimport { EarthConstants } from \"./EarthConstants\";\nimport { Projection, ProjectionType } from \"./Projection\";\n\nimport * as THREE from \"three\";\n\nclass EquirectangularProjection extends Projection {\n    static geoToWorldScale: number = 1.0 / (2.0 * Math.PI);\n    static worldToGeoScale: number = (2.0 * Math.PI) / 1.0;\n\n    /** @override */\n    readonly type: ProjectionType = ProjectionType.Planar;\n\n    /** @override */\n    getScaleFactor(_worldPoint: Vector3Like): number {\n        return 1;\n    }\n\n    /** @override */\n    worldExtent<WorldBoundingBox extends Box3Like>(\n        minAltitude: number,\n        maxAltitude: number,\n        result?: WorldBoundingBox\n    ): WorldBoundingBox {\n        if (!result) {\n            result = (new THREE.Box3() as Box3Like) as WorldBoundingBox;\n        }\n        result.min.x = 0.0;\n        result.min.y = 0.0;\n        result.min.z = minAltitude;\n        result.max.x = this.unitScale;\n        result.max.y = this.unitScale / 2;\n        result.max.z = maxAltitude;\n        return result;\n    }\n\n    /** @override */\n    projectPoint<WorldCoordinates extends Vector3Like>(\n        geoPoint: GeoCoordinatesLike,\n        result?: WorldCoordinates\n    ): WorldCoordinates {\n        if (result === undefined) {\n            /*\n             * The following tslint:disable is due to the fact that the [[WorldCoordinates]]\n             * might be a concrete class which is not available at runtime.\n             * Consider the following example:\n             *\n             *  const x: THREE.Vector3 = new THREE.Vector3(0,0,0);\n             *  const result = EquirectangularProjection.projectPoint<THREE.Vector3>(x);\n             *\n             * Note: type of `result` is Vector3Like and not as expected: THREE.Vector3!\n             */\n            // tslint:disable-next-line:no-object-literal-type-assertion\n            result = { x: 0, y: 0, z: 0 } as WorldCoordinates;\n        }\n        result.x =\n            (THREE.MathUtils.degToRad(geoPoint.longitude) + Math.PI) *\n            EquirectangularProjection.geoToWorldScale *\n            this.unitScale;\n        result.y =\n            (THREE.MathUtils.degToRad(geoPoint.latitude) + Math.PI * 0.5) *\n            EquirectangularProjection.geoToWorldScale *\n            this.unitScale;\n        result.z = geoPoint.altitude || 0;\n        return result;\n    }\n\n    /** @override */\n    unprojectPoint(worldPoint: Vector3Like): GeoCoordinates {\n        const geoPoint = GeoCoordinates.fromRadians(\n            (worldPoint.y * EquirectangularProjection.worldToGeoScale) / this.unitScale -\n                Math.PI * 0.5,\n            (worldPoint.x * EquirectangularProjection.worldToGeoScale) / this.unitScale - Math.PI,\n            worldPoint.z\n        );\n        return geoPoint;\n    }\n\n    /** @override */\n    unprojectAltitude(worldPoint: Vector3Like): number {\n        return worldPoint.z;\n    }\n\n    /** @override */\n    projectBox<WorldBoundingBox extends Box3Like | OrientedBox3Like>(\n        geoBox: GeoBox,\n        result?: WorldBoundingBox\n    ): WorldBoundingBox {\n        const worldCenter = this.projectPoint(\n            new GeoCoordinates(geoBox.center.latitude, geoBox.center.longitude, 0)\n        );\n        const { latitudeSpanInRadians, longitudeSpanInRadians, altitudeSpan } = geoBox;\n        const sizeX = longitudeSpanInRadians * EquirectangularProjection.geoToWorldScale;\n        const sizeY = latitudeSpanInRadians * EquirectangularProjection.geoToWorldScale;\n        if (!result) {\n            result = (new THREE.Box3() as Box3Like) as WorldBoundingBox;\n        }\n        if (isBox3Like(result)) {\n            result.min.x = worldCenter.x - sizeX * 0.5 * this.unitScale;\n            result.min.y = worldCenter.y - sizeY * 0.5 * this.unitScale;\n            result.max.x = worldCenter.x + sizeX * 0.5 * this.unitScale;\n            result.max.y = worldCenter.y + sizeY * 0.5 * this.unitScale;\n            if (altitudeSpan !== undefined) {\n                result.min.z = worldCenter.z - altitudeSpan * 0.5;\n                result.max.z = worldCenter.z + altitudeSpan * 0.5;\n            } else {\n                result.min.z = 0;\n                result.max.z = 0;\n            }\n        } else if (isOrientedBox3Like(result)) {\n            MathUtils.newVector3(1, 0, 0, result.xAxis);\n            MathUtils.newVector3(0, 1, 0, result.yAxis);\n            MathUtils.newVector3(0, 0, 1, result.zAxis);\n            result.position.x = worldCenter.x;\n            result.position.y = worldCenter.y;\n            result.position.z = worldCenter.z;\n            result.extents.x = sizeX * 0.5 * this.unitScale;\n            result.extents.y = sizeY * 0.5 * this.unitScale;\n            result.extents.z = Math.max(Number.EPSILON, (altitudeSpan || 0) * 0.5);\n        }\n        return result;\n    }\n\n    /** @override */\n    unprojectBox(worldBox: Box3Like): GeoBox {\n        const minGeo = this.unprojectPoint(worldBox.min);\n        const maxGeo = this.unprojectPoint(worldBox.max);\n        return GeoBox.fromCoordinates(minGeo, maxGeo);\n    }\n\n    /** @override */\n    groundDistance(worldPoint: Vector3Like): number {\n        return worldPoint.z;\n    }\n\n    /** @override */\n    scalePointToSurface(worldPoint: Vector3Like): Vector3Like {\n        worldPoint.z = 0;\n        return worldPoint;\n    }\n\n    /** @override */\n    surfaceNormal(_worldPoint: Vector3Like, normal?: Vector3Like) {\n        if (normal === undefined) {\n            normal = { x: 0, y: 0, z: 1 };\n        } else {\n            normal.x = 0;\n            normal.y = 0;\n            normal.z = 1;\n        }\n        return normal;\n    }\n}\n\n/**\n * Equirectangular {@link Projection} used to convert geo coordinates to unit coordinates and vice\n * versa.\n */\nexport const normalizedEquirectangularProjection: Projection = new EquirectangularProjection(1);\n\n/**\n * Equirectangular {@link Projection} used to convert geo coordinates to world coordinates and vice\n * versa.\n */\nexport const equirectangularProjection: Projection = new EquirectangularProjection(\n    EarthConstants.EQUATORIAL_CIRCUMFERENCE\n);\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeoBox } from \"../coordinates/GeoBox\";\nimport { GeoCoordinates } from \"../coordinates/GeoCoordinates\";\nimport { GeoCoordinatesLike } from \"../coordinates/GeoCoordinatesLike\";\nimport { Box3Like, isBox3Like } from \"../math/Box3Like\";\nimport { MathUtils } from \"../math/MathUtils\";\nimport { isOrientedBox3Like, OrientedBox3Like } from \"../math/OrientedBox3Like\";\nimport { Vector3Like } from \"../math/Vector3Like\";\nimport { EarthConstants } from \"./EarthConstants\";\nimport { Projection, ProjectionType } from \"./Projection\";\n\nimport * as THREE from \"three\";\n\n/**\n *\n * https://en.wikipedia.org/wiki/Transverse_Mercator_projection\n * http://mathworld.wolfram.com/MercatorProjection.html\n *\n */\nclass TransverseMercatorProjection extends Projection {\n    /**\n     * Like in regular Mercator projection, there are two points on sphere\n     * with radius about 5 degrees, that is out of projected space.\n     *\n     *\n     * in regular Mercator these points are:\n     *     (90, any), (-90, any)\n     *\n     * and in transverse Mercator:\n     *     (0, 90), (0, -90)\n     *\n     * So, in transverse we need to compute distnce to poles, and clamp if\n     * radius is exceeded\n     */\n    static clampGeoPoint(geoPoint: GeoCoordinatesLike, _unitScale: number) {\n        const lat = geoPoint.latitude;\n        const lon = geoPoint.longitude;\n\n        const r = TransverseMercatorUtils.POLE_RADIUS;\n        const rsq = TransverseMercatorUtils.POLE_RADIUS_SQ;\n\n        const nearestQuarter = Math.round(lon / 90);\n        const deltaLon = nearestQuarter * 90 - lon;\n        if (nearestQuarter % 2 === 0 || Math.abs(deltaLon) > r) {\n            return geoPoint;\n        }\n\n        const deltaLat = lat - 0;\n        const distanceToPoleSq = deltaLon * deltaLon + deltaLat * deltaLat;\n        if (distanceToPoleSq < rsq) {\n            const distanceToPole = Math.sqrt(distanceToPoleSq);\n            const scale = (r - distanceToPole) / distanceToPole;\n            // const quarter = ((nearestQuarter % 4) + 4) % 4;\n            // const dir = quarter === 1 ? -1 : quarter === 3 ? 1 : 0;\n            const dir = 1;\n            const offsetLon = deltaLon === 0 && deltaLat === 0 ? r * dir : deltaLon;\n            return new GeoCoordinates(lat + deltaLat * scale, lon + offsetLon * scale);\n        }\n\n        return geoPoint;\n    }\n\n    /** @override */\n    readonly type: ProjectionType = ProjectionType.Planar;\n\n    private m_phi0: number = 0;\n    private m_lambda0: number = 0;\n\n    constructor(readonly unitScale: number) {\n        super(unitScale);\n    }\n\n    /** @override */\n    getScaleFactor(worldPoint: Vector3Like): number {\n        return Math.cosh((worldPoint.x / this.unitScale - 0.5) * 2 * Math.PI);\n    }\n\n    /** @override */\n    worldExtent<WorldBoundingBox extends Box3Like>(\n        minAltitude: number,\n        maxAltitude: number,\n        result?: WorldBoundingBox\n    ): WorldBoundingBox {\n        if (!result) {\n            result = (new THREE.Box3() as Box3Like) as WorldBoundingBox;\n        }\n        result.min.x = 0;\n        result.min.y = 0;\n        result.min.z = minAltitude;\n        result.max.x = this.unitScale;\n        result.max.y = this.unitScale;\n        result.max.z = maxAltitude;\n        return result;\n    }\n\n    /** @override */\n    projectPoint<WorldCoordinates extends Vector3Like>(\n        geoPoint: GeoCoordinatesLike,\n        result?: WorldCoordinates\n    ): WorldCoordinates {\n        if (!result) {\n            // tslint:disable-next-line:no-object-literal-type-assertion\n            result = { x: 0, y: 0, z: 0 } as WorldCoordinates;\n        }\n\n        const clamped = TransverseMercatorProjection.clampGeoPoint(geoPoint, this.unitScale);\n        const normalLon = clamped.longitude / 360 + 0.5;\n        const offset = normalLon === 1 ? 0 : Math.floor(normalLon);\n        const phi = THREE.MathUtils.degToRad(clamped.latitude);\n        const lambda = THREE.MathUtils.degToRad(clamped.longitude - offset * 360) - this.m_lambda0;\n\n        const B = Math.cos(phi) * Math.sin(lambda);\n        // result.x = 1/2 * Math.log((1 + B) / (1 - B));\n        result.x = Math.atanh(B);\n        result.y = Math.atan2(Math.tan(phi), Math.cos(lambda)) - this.m_phi0;\n\n        const outScale = 0.5 / Math.PI;\n        result.x =\n            this.unitScale * (THREE.MathUtils.clamp(result.x * outScale + 0.5, 0, 1) + offset);\n        result.y = this.unitScale * THREE.MathUtils.clamp(result.y * outScale + 0.5, 0, 1);\n\n        result.z = geoPoint.altitude || 0;\n        return result;\n    }\n\n    /** @override */\n    unprojectPoint(worldPoint: Vector3Like): GeoCoordinates {\n        const tau = Math.PI * 2;\n        const nx = worldPoint.x / this.unitScale;\n        const ny = worldPoint.y / this.unitScale;\n        const offset = nx === 1 ? 0 : Math.floor(nx);\n        const x = tau * (nx - 0.5 - offset);\n        const y = tau * (ny - 0.5);\n        const z = worldPoint.z || 0;\n\n        const D = y + this.m_phi0;\n\n        const phi = Math.asin(Math.sin(D) / Math.cosh(x));\n        const lambda = this.m_lambda0 + Math.atan2(Math.sinh(x), Math.cos(D)) + offset * tau;\n\n        const geoPoint = GeoCoordinates.fromRadians(phi, lambda, z);\n        return geoPoint;\n    }\n\n    /** @override */\n    projectBox<WorldBoundingBox extends Box3Like | OrientedBox3Like>(\n        geoBox: GeoBox,\n        result?: WorldBoundingBox\n    ): WorldBoundingBox {\n        const { north, south, east, west } = geoBox;\n\n        const pointsToCheck = [\n            geoBox.center,\n            geoBox.northEast,\n            geoBox.southWest,\n            new GeoCoordinates(south, east),\n            new GeoCoordinates(north, west)\n        ];\n\n        const E = TransverseMercatorUtils.POLE_EDGE_DEG;\n\n        const containsWestCut = west < -90 && east > -90;\n        const containsEastCut = west < 90 && east > 90;\n        const containsCenterX = west < 0 && east > 0;\n        const containsCenterY = west < E && east > -E && north > 0 && south < 0;\n\n        if (containsWestCut) {\n            pointsToCheck.push(new GeoCoordinates(north, -90));\n            pointsToCheck.push(new GeoCoordinates(south, -90));\n        }\n\n        if (containsEastCut) {\n            pointsToCheck.push(new GeoCoordinates(north, 90));\n            pointsToCheck.push(new GeoCoordinates(south, 90));\n        }\n\n        if (containsCenterX) {\n            pointsToCheck.push(new GeoCoordinates(north, 0));\n            pointsToCheck.push(new GeoCoordinates(south, 0));\n        }\n\n        if (containsCenterY) {\n            pointsToCheck.push(new GeoCoordinates(0, west));\n            pointsToCheck.push(new GeoCoordinates(0, east));\n        }\n\n        TransverseMercatorUtils.alignLatitude(pointsToCheck, pointsToCheck[0]);\n\n        const projected = pointsToCheck.map(p => this.projectPoint(p));\n        const vx = projected.map(p => p.x);\n        const vy = projected.map(p => p.y);\n        const vz = projected.map(p => p.z);\n\n        const minX = Math.min(...vx);\n        const minY = Math.min(...vy);\n        const minZ = Math.min(...vz);\n        const maxX = Math.max(...vx);\n        const maxY = Math.max(...vy);\n        const maxZ = Math.max(...vz);\n\n        if (!result) {\n            result = (new THREE.Box3() as Box3Like) as WorldBoundingBox;\n        }\n        if (isBox3Like(result)) {\n            result.min.x = minX;\n            result.min.y = minY;\n            result.min.z = minZ;\n            result.max.x = maxX;\n            result.max.y = maxY;\n            result.max.z = maxZ;\n        } else if (isOrientedBox3Like(result)) {\n            MathUtils.newVector3(1, 0, 0, result.xAxis);\n            MathUtils.newVector3(0, 1, 0, result.yAxis);\n            MathUtils.newVector3(0, 0, 1, result.zAxis);\n            result.position.x = (minX + maxX) / 2;\n            result.position.y = (minY + maxY) / 2;\n            result.position.z = (minZ + maxZ) / 2;\n            result.extents.x = (maxX - minX) / 2;\n            result.extents.y = (maxY - minY) / 2;\n            result.extents.z = (maxZ - minZ) / 2;\n        } else {\n            throw new Error(\"invalid bounding box\");\n        }\n        return result;\n    }\n\n    /**\n     * There are 8 sub-regions on entire projection space\n     * where both longitude and latitude preserve direction.\n     * If bounding box hits more than one region, it should be splitted\n     * into sub-boxes by regions, (un)projected and then united again.\n     *\n     *\n     * directions in form [latitude / longitude]:\n     *    1 |\n     *       dr / dl | dl / ul \n     * 0.75 ----------|----------\n     *       ur / dr | ul / ur \n     * 0.5  ----------|----------\n     *       ul / ur | ur / dr \n     * 0.25 ----------|----------\n     *       dl / ul | dr / dl \n     *      |\n     *     0         0.5        1\n     *     @override\n     */\n    unprojectBox(worldBox: Box3Like): GeoBox {\n        const s = this.unitScale;\n\n        const min = worldBox.min;\n        const max = worldBox.max;\n        const pointsToCheck = [\n            { x: (min.x + max.x) / 2, y: (min.y + max.y) / 2, z: 0 },\n            min,\n            max,\n            { x: min.x, y: max.y, z: 0 },\n            { x: max.x, y: min.y, z: 0 }\n        ];\n\n        const center = 0.5 * s;\n        const lowerQ = 0.25 * s;\n        const upperQ = 0.75 * s;\n\n        const containsCenterX = min.x < center && max.x > center;\n        const containsCenterY = min.y < center && max.y > center;\n        const containsLowerQY = min.y < lowerQ && max.y > lowerQ;\n        const containsUpperQY = min.y < upperQ && max.y > upperQ;\n\n        if (containsCenterY) {\n            pointsToCheck.push({ x: min.x, y: center, z: 0 });\n            pointsToCheck.push({ x: max.x, y: center, z: 0 });\n\n            if (containsCenterX) {\n                pointsToCheck.push({ x: center, y: center, z: 0 });\n            }\n        }\n        if (containsLowerQY) {\n            pointsToCheck.push({ x: min.x, y: lowerQ, z: 0 });\n            pointsToCheck.push({ x: max.x, y: lowerQ, z: 0 });\n\n            if (containsCenterX) {\n                pointsToCheck.push({ x: center, y: lowerQ, z: 0 });\n            }\n        }\n        if (containsUpperQY) {\n            pointsToCheck.push({ x: min.x, y: upperQ, z: 0 });\n            pointsToCheck.push({ x: max.x, y: upperQ, z: 0 });\n\n            if (containsCenterX) {\n                pointsToCheck.push({ x: center, y: upperQ, z: 0 });\n            }\n        }\n\n        const geoPoints = pointsToCheck.map(p => this.unprojectPoint(p));\n        TransverseMercatorUtils.alignLongitude(geoPoints, geoPoints[0]);\n\n        const latitudes = geoPoints.map(g => g.latitude);\n        const longitudes = geoPoints.filter(g => Math.abs(g.latitude) < 90).map(g => g.longitude);\n        const altitudes = geoPoints.map(g => g.altitude || 0);\n\n        const minGeo = new GeoCoordinates(\n            Math.min(...latitudes),\n            Math.min(...longitudes),\n            Math.min(...altitudes)\n        );\n\n        const maxGeo = new GeoCoordinates(\n            Math.max(...latitudes),\n            Math.max(...longitudes),\n            Math.max(...altitudes)\n        );\n\n        const geoBox = GeoBox.fromCoordinates(minGeo, maxGeo);\n        return geoBox;\n    }\n\n    /** @override */\n    unprojectAltitude(worldPoint: Vector3Like): number {\n        return worldPoint.z;\n    }\n\n    /** @override */\n    groundDistance(worldPoint: Vector3Like): number {\n        return worldPoint.z;\n    }\n\n    /** @override */\n    scalePointToSurface(worldPoint: Vector3Like): Vector3Like {\n        worldPoint.z = 0;\n        return worldPoint;\n    }\n\n    /** @override */\n    surfaceNormal(_worldPoint: Vector3Like, normal?: Vector3Like) {\n        if (normal === undefined) {\n            normal = { x: 0, y: 0, z: -1 };\n        } else {\n            normal.x = 0;\n            normal.y = 0;\n            normal.z = -1;\n        }\n        return normal;\n    }\n}\n\nexport class TransverseMercatorUtils {\n    static POLE_EDGE: number = 1.4844222297453323;\n    static POLE_EDGE_DEG: number = THREE.MathUtils.radToDeg(TransverseMercatorUtils.POLE_EDGE);\n    static POLE_RADIUS: number = 90 - TransverseMercatorUtils.POLE_EDGE_DEG;\n    static POLE_RADIUS_SQ: number = Math.pow(TransverseMercatorUtils.POLE_RADIUS, 2);\n\n    /**\n     * There are two regions on projected space that have same geo coordinates,\n     * it's the entire lines   { x: [0..1], y: 0 } and { x: [0..1], y: 1 }\n     * they both have geo coordinates of   (0, [-90..+90])\n     * and should be aligned somehow to fall into first or second region\n     * to make proper bounding boxes, tile bounds, etc.\n     */\n    static alignLatitude(points: GeoCoordinatesLike[], referencePoint: GeoCoordinatesLike): void {\n        const EPSILON = 1e-9;\n\n        for (const point of points) {\n            if (point.latitude === 0) {\n                point.latitude = referencePoint.latitude * EPSILON;\n            }\n        }\n    }\n\n    /**\n     * There are two regions on projected plane,\n     * { x: 0.5, y: [0..0.25] }    and    { x: 0.5, y: [0.75..1] }\n     * that represent longitude edge where -180 and +180 met.\n     * Points falling in this regions should be aligned to get proper boxes etc.\n     */\n    static alignLongitude(points: GeoCoordinatesLike[], referencePoint: GeoCoordinatesLike): void {\n        const bad = referencePoint.longitude < 0 ? 180 : -180;\n        const good = referencePoint.longitude < 0 ? -180 : 180;\n\n        for (const point of points) {\n            if (point.longitude === bad) {\n                point.longitude = good;\n            }\n        }\n    }\n}\n\n/**\n * Transverse Mercator {@link Projection} used to convert geo coordinates to world coordinates\n * and vice versa.\n */\nexport const transverseMercatorProjection: Projection = new TransverseMercatorProjection(\n    EarthConstants.EQUATORIAL_CIRCUMFERENCE\n);\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeoBox } from \"../coordinates/GeoBox\";\nimport { Box3Like } from \"../math/Box3Like\";\nimport { Vector3Like } from \"../math/Vector3Like\";\nimport { Projection } from \"../projection/Projection\";\nimport { SubdivisionScheme } from \"./SubdivisionScheme\";\nimport { TileKey } from \"./TileKey\";\nimport { TilingScheme } from \"./TilingScheme\";\n\nimport * as THREE from \"three\";\n\n/**\n * `FlatTileBoundingBoxGenerator` generates bounding boxes in world and geo coordinates for a given\n * TilingScheme.\n */\nexport class FlatTileBoundingBoxGenerator {\n    private readonly m_tilingScheme: TilingScheme;\n    private readonly m_worldDimensions: Vector3Like;\n    private readonly m_worldBox: Box3Like;\n    /**\n     * Creates a new `FlatTileBoundingBoxGenerator` that can generate bounding boxes for the given\n     * TilingScheme.\n     *\n     * @param tilingScheme - The {@link TilingScheme} used to compute bounding boxes.\n     * @param minElevation - The minimum elevation in meters.\n     * @param maxElevation - The maximum elevation in meters.\n     */\n    constructor(\n        readonly tilingScheme: TilingScheme,\n        readonly minElevation: number = 0,\n        readonly maxElevation: number = 0\n    ) {\n        this.m_tilingScheme = tilingScheme;\n        this.m_worldBox = tilingScheme.projection.worldExtent(minElevation, maxElevation);\n        const { min, max } = this.m_worldBox;\n        this.m_worldDimensions = { x: max.x - min.x, y: max.y - min.y, z: max.z - min.z };\n    }\n\n    /**\n     * Returns the {@link Projection} of the {@link TilingScheme}.\n     */\n    get projection(): Projection {\n        return this.m_tilingScheme.projection;\n    }\n\n    /**\n     * Returns the {@link SubdivisionScheme} of the {@link TilingScheme}.\n     */\n    get subdivisionScheme(): SubdivisionScheme {\n        return this.m_tilingScheme.subdivisionScheme;\n    }\n\n    /**\n     * Returns the bounding box in world coordinates of the given {@link TileKey}.\n     *\n     * Example:\n     * ```typescript\n     * const worldBounds = new THREE.Box3();\n     * generator.getWorldBox(geoBox, worldBounds);\n     * console.log(worldBounds.getCenter());\n     * ```\n     *\n     * @param tileKey - The TileKey.\n     * @param result - The optional object used to store the resulting bounding box in world\n     * coordinates.\n     */\n    getWorldBox(tileKey: TileKey, result?: Box3Like): Box3Like {\n        const level = tileKey.level;\n        const levelDimensionX = this.subdivisionScheme.getLevelDimensionX(level);\n        const levelDimensionY = this.subdivisionScheme.getLevelDimensionY(level);\n        const sizeX = this.m_worldDimensions.x / levelDimensionX;\n        const sizeY = this.m_worldDimensions.y / levelDimensionY;\n        const originX = this.m_worldBox.min.x + sizeX * tileKey.column;\n        const originY = this.m_worldBox.min.y + sizeY * tileKey.row;\n\n        if (!result) {\n            result = new THREE.Box3();\n        }\n\n        result.min.x = originX;\n        result.min.y = originY;\n        result.min.z = this.m_worldBox.min.z;\n        result.max.x = originX + sizeX;\n        result.max.y = originY + sizeY;\n        result.max.z = this.m_worldBox.max.z;\n        return result;\n    }\n\n    /**\n     * Returns the bounding box in geo coordinates for the given {@link TileKey}.\n     *\n     * Example:\n     * ```typescript\n     * const geoBox = generator.getGeoBox(worldBounds);\n     * console.log(geoBox.center);\n     * ```\n     *\n     * @param tileKey - The {@link TileKey}.\n     */\n    getGeoBox(tileKey: TileKey): GeoBox {\n        const worldBox = this.getWorldBox(tileKey);\n        return this.projection.unprojectBox(worldBox);\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { SubdivisionScheme } from \"./SubdivisionScheme\";\n\nclass HalfQuadTreeSubdivisionScheme implements SubdivisionScheme {\n    getSubdivisionX(): number {\n        return 2;\n    }\n    getSubdivisionY(level: number): number {\n        return level === 0 ? 1 : 2;\n    }\n    getLevelDimensionX(level: number): number {\n        // tslint:disable-next-line:no-bitwise\n        return 1 << level;\n    }\n    getLevelDimensionY(level: number): number {\n        // tslint:disable-next-line:no-bitwise\n        return level !== 0 ? 1 << (level - 1) : 1;\n    }\n}\n\n/**\n * A {@link SubdivisionScheme} used to represent half quadtrees.\n * This particular subdivision scheme is\n * used by the HERE tiling scheme.\n */\nexport const halfQuadTreeSubdivisionScheme: SubdivisionScheme = new HalfQuadTreeSubdivisionScheme();\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { TileKey } from \"./TileKey\";\n\nexport class SubTiles implements Iterable<TileKey> {\n    constructor(public tileKey: TileKey, public sizeX: number, public sizeY: number) {}\n\n    [Symbol.iterator](): Iterator<TileKey> {\n        return this.sizeX === 2 && this.sizeY === 2\n            ? SubTiles.ZCurveIterator(this.tileKey)\n            : SubTiles.RowColumnIterator(this.tileKey, this.sizeX, this.sizeY);\n    }\n}\n\nexport namespace SubTiles {\n    export function* RowColumnIterator(\n        parentKey: TileKey,\n        sizeX: number,\n        sizeY: number\n    ): Iterator<TileKey> {\n        for (let y = 0; y < sizeY; y++) {\n            for (let x = 0; x < sizeX; x++) {\n                yield TileKey.fromRowColumnLevel(\n                    parentKey.row * sizeY + y,\n                    parentKey.column * sizeX + x,\n                    parentKey.level + 1\n                );\n            }\n        }\n    }\n\n    export function* ZCurveIterator(parentKey: TileKey): Iterator<TileKey> {\n        // tslint:disable:no-bitwise\n        for (let i = 0; i < 4; i++) {\n            yield TileKey.fromRowColumnLevel(\n                (parentKey.row << 1) | (i >> 1),\n                (parentKey.column << 1) | (i & 1),\n                parentKey.level + 1\n            );\n        }\n        // tslint:enableno-bitwise\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeoBox } from \"../coordinates/GeoBox\";\nimport { GeoCoordinates } from \"../coordinates/GeoCoordinates\";\nimport { GeoCoordinatesLike } from \"../coordinates/GeoCoordinatesLike\";\nimport { Vector3Like } from \"../math/Vector3Like\";\nimport { TileKey } from \"./TileKey\";\nimport { TilingScheme } from \"./TilingScheme\";\n\nexport class TileKeyUtils {\n    static geoCoordinatesToTileKey(\n        tilingScheme: TilingScheme,\n        geoPoint: GeoCoordinatesLike,\n        level: number\n    ): TileKey | null {\n        const projection = tilingScheme.projection;\n        const worldPoint = projection.projectPoint(geoPoint);\n\n        return this.worldCoordinatesToTileKey(tilingScheme, worldPoint, level);\n    }\n\n    static worldCoordinatesToTileKey(\n        tilingScheme: TilingScheme,\n        worldPoint: Vector3Like,\n        level: number\n    ): TileKey | null {\n        const projection = tilingScheme.projection;\n        const subdivisionScheme = tilingScheme.subdivisionScheme;\n\n        const cx = subdivisionScheme.getLevelDimensionX(level);\n        const cy = subdivisionScheme.getLevelDimensionY(level);\n\n        const { min, max } = projection.worldExtent(0, 0);\n        const worldSizeX = max.x - min.x;\n        const worldSizeY = max.y - min.y;\n\n        if (worldPoint.x < min.x || worldPoint.x > max.x) {\n            return null;\n        }\n\n        if (worldPoint.y < min.y || worldPoint.y > max.y) {\n            return null;\n        }\n\n        const column = Math.min(cx - 1, Math.floor((cx * (worldPoint.x - min.x)) / worldSizeX));\n        const row = Math.min(cy - 1, Math.floor((cy * (worldPoint.y - min.y)) / worldSizeY));\n\n        return TileKey.fromRowColumnLevel(row, column, level);\n    }\n\n    static geoRectangleToTileKeys(\n        tilingScheme: TilingScheme,\n        geoBox: GeoBox,\n        level: number\n    ): TileKey[] {\n        const wrap = (value: number, lower: number, upper: number) => {\n            if (value < lower) {\n                return upper - ((lower - value) % (upper - lower));\n            }\n\n            return lower + ((value - lower) % (upper - lower));\n        };\n\n        const clamp = (x: number, minVal: number, maxVal: number) => {\n            return Math.min(Math.max(x, minVal), maxVal);\n        };\n\n        // Clamp at the poles and wrap around the international date line.\n        const southWestLongitude = wrap(geoBox.southWest.longitudeInRadians, -Math.PI, Math.PI);\n        const southWestLatitude = clamp(\n            geoBox.southWest.latitudeInRadians,\n            -(Math.PI * 0.5),\n            Math.PI * 0.5\n        );\n        const northEastLongitude = wrap(geoBox.northEast.longitudeInRadians, -Math.PI, Math.PI);\n        const northEastLatitude = clamp(\n            geoBox.northEast.latitudeInRadians,\n            -(Math.PI * 0.5),\n            Math.PI * 0.5\n        );\n        const minTileKey = TileKeyUtils.geoCoordinatesToTileKey(\n            tilingScheme,\n            GeoCoordinates.fromRadians(southWestLatitude, southWestLongitude),\n            level\n        );\n        const maxTileKey = TileKeyUtils.geoCoordinatesToTileKey(\n            tilingScheme,\n            GeoCoordinates.fromRadians(northEastLatitude, northEastLongitude),\n            level\n        );\n        const columnCount = tilingScheme.subdivisionScheme.getLevelDimensionX(level);\n\n        if (!minTileKey || !maxTileKey) {\n            throw new Error(\"Invalid coordinates\");\n        }\n\n        const minColumn = minTileKey.column;\n        let maxColumn = maxTileKey.column;\n\n        // wrap around case\n        if (southWestLongitude > northEastLongitude) {\n            if (maxColumn !== minColumn) {\n                maxColumn += columnCount;\n            } else {\n                // do not duplicate\n                maxColumn += columnCount - 1;\n            }\n        }\n\n        const minRow = Math.min(minTileKey.row, maxTileKey.row);\n        const maxRow = Math.max(minTileKey.row, maxTileKey.row);\n\n        const keys = new Array<TileKey>();\n\n        for (let row = minRow; row <= maxRow; ++row) {\n            for (let column = minColumn; column <= maxColumn; ++column) {\n                keys.push(TileKey.fromRowColumnLevel(row, column % columnCount, level));\n            }\n        }\n\n        return keys;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { SubdivisionScheme } from \"./SubdivisionScheme\";\nimport { SubTiles } from \"./SubTiles\";\nimport { TileKey } from \"./TileKey\";\n\nexport class TileTreeTraverse {\n    private m_subdivisionScheme: SubdivisionScheme;\n\n    constructor(subdivisionScheme: SubdivisionScheme) {\n        this.m_subdivisionScheme = subdivisionScheme;\n    }\n\n    subTiles(tileKey: TileKey): Iterable<TileKey> {\n        const divX = this.m_subdivisionScheme.getSubdivisionX(tileKey.level);\n        const divY = this.m_subdivisionScheme.getSubdivisionY(tileKey.level);\n\n        return new SubTiles(tileKey, divX, divY);\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    getPropertyValue,\n    isExtrudedPolygonTechnique,\n    MapEnv,\n    Technique\n} from \"@here/harp-datasource-protocol\";\nimport { TileKey } from \"@here/harp-geoutils\";\nimport { ExtrusionFeature, ExtrusionFeatureDefs } from \"@here/harp-materials\";\nimport { MathUtils } from \"@here/harp-utils\";\nimport { MapView } from \"./MapView\";\nimport { Tile } from \"./Tile\";\n\n/**\n * Animation states for extrusion effect\n */\nexport enum AnimatedExtrusionState {\n    None,\n    Started,\n    Finished\n}\n\nconst DEFAULT_EXTRUSION_DURATION = 750; // milliseconds\nconst DEFAULT_MIN_ZOOM_LEVEL = 16;\n\ninterface TileExtrusionState {\n    materials: ExtrusionFeature[];\n    animated: boolean;\n}\n\n/**\n * Handles animated extrusion effect of the buildings in {@link MapView}.\n */\nexport class AnimatedExtrusionHandler {\n    /**\n     * Animate the extrusion of the buildings if set to `true`.\n     */\n    enabled: boolean = true;\n    /**\n     * Duration of the building's extrusion in milliseconds\n     */\n    duration: number = DEFAULT_EXTRUSION_DURATION;\n\n    private m_minZoomLevel: number = DEFAULT_MIN_ZOOM_LEVEL;\n    private m_forceEnabled: boolean = false;\n\n    // key is tile's morton code.\n    private m_tileMap: Map<number, TileExtrusionState> = new Map();\n    private m_state: AnimatedExtrusionState = AnimatedExtrusionState.None;\n    private m_startTime: number = -1;\n\n    /**\n     * Creates an {@link AnimatedExtrusionHandler} in {@link MapView}.\n     *\n     * @param m_mapView - Instance of {@link MapView} on which the animation will run.\n     */\n    constructor(private m_mapView: MapView) {}\n\n    /**\n     * Returns whether the extrusion animation is force enabled or not.\n     */\n    get forceEnabled(): boolean {\n        return this.m_forceEnabled;\n    }\n\n    /**\n     * If `forceEnabled` is set to `true` then `animateExtrusion` and `animateExtrusionDuration`\n     * values from [[extrudedPolygonTechnique]] will be ignored and\n     * `AnimatedExtrusionHandler.enabled` with `AnimatedExtrusionHandler.duration` will be used\n     */\n    set forceEnabled(force: boolean) {\n        this.m_forceEnabled = force;\n        this.duration = DEFAULT_EXTRUSION_DURATION;\n    }\n\n    /**\n     * Gets min zoom level at which extruded animation is enabled.\n     */\n    get minZoomLevel() {\n        return this.m_minZoomLevel;\n    }\n\n    /**\n     * Sets the extrusion animation properties obtained from a given technique.\n     * @internal\n     * @param technique - The technique where the extrusion animation properties are defined.\n     * @param env - The environment used to evaluate technique properties.\n     * @returns True if the technique has animation enabled (or animation is forced), false\n     * otherwise.\n     */\n    setAnimationProperties(technique: Technique, env: MapEnv) {\n        if (!isExtrudedPolygonTechnique(technique)) {\n            return false;\n        }\n\n        if (\"minZoomLevel\" in technique) {\n            this.m_minZoomLevel = (technique as any).minZoomLevel;\n        }\n\n        if (this.forceEnabled) {\n            return this.enabled;\n        }\n\n        if (technique.animateExtrusionDuration !== undefined) {\n            this.duration = technique.animateExtrusionDuration;\n        }\n\n        const animateExtrusionValue = getPropertyValue(technique.animateExtrusion, env);\n\n        if (animateExtrusionValue === null) {\n            return this.enabled;\n        }\n\n        return typeof animateExtrusionValue === \"boolean\"\n            ? animateExtrusionValue\n            : typeof animateExtrusionValue === \"number\"\n            ? animateExtrusionValue !== 0\n            : false;\n    }\n\n    /**\n     * Updates the extrusion animation for every frame.\n     * @internal\n     */\n    update(zoomLevel: number) {\n        const extrusionVisible = this.m_tileMap.size > 0 && zoomLevel >= this.m_minZoomLevel;\n\n        if (this.m_state === AnimatedExtrusionState.None && extrusionVisible) {\n            this.m_state = AnimatedExtrusionState.Started;\n        } else if (this.m_state !== AnimatedExtrusionState.None && !extrusionVisible) {\n            this.resetAnimation(true);\n        }\n\n        this.animateExtrusion();\n    }\n\n    /**\n     * Adds a tile to be animated.\n     * @internal\n     * @param tile - The tile to be animated.\n     * @param materials - Extruded materials belonging to the tile.\n     */\n    add(tile: Tile, materials: ExtrusionFeature[]): void {\n        tile.addDisposeCallback(this.removeTile.bind(this));\n        let animated = false;\n\n        if (this.m_state !== AnimatedExtrusionState.None) {\n            animated = this.skipAnimation(tile);\n            if (animated) {\n                // Set extrusion ratio to 1 if the tile skips the animation.\n                this.setTileExtrusionRatio(materials, 1);\n            } else if (this.m_state === AnimatedExtrusionState.Finished) {\n                // Otherwise, if animation was finished, restart animation but leave already\n                //  animated tiles untouched.\n                this.resetAnimation(false);\n            }\n        }\n        this.m_tileMap.set(tile.tileKey.mortonCode(), { materials, animated });\n    }\n\n    /**\n     * Is `true` if there's any extrusion animation ongoing.\n     */\n    get isAnimating(): boolean {\n        return (\n            this.m_state !== AnimatedExtrusionState.Finished &&\n            this.m_state !== AnimatedExtrusionState.None\n        );\n    }\n\n    private skipAnimation(tile: Tile): boolean {\n        return this.wasAnyAncestorAnimated(tile) || this.wasAnyDescendantAnimated(tile);\n    }\n\n    private wasAnyAncestorAnimated(tile: Tile): boolean {\n        const minLevel = tile.dataSource.getDataZoomLevel(this.m_minZoomLevel);\n        const distanceToMinLevel = Math.max(0, tile.tileKey.level - minLevel);\n        const levelsUp = Math.min(\n            distanceToMinLevel,\n            this.m_mapView.visibleTileSet.options.quadTreeSearchDistanceUp\n        );\n\n        let lastTileKey = tile.tileKey;\n        for (let deltaUp = 1; deltaUp <= levelsUp; ++deltaUp) {\n            lastTileKey = lastTileKey.parent();\n            if (this.m_tileMap.get(lastTileKey.mortonCode())?.animated ?? false) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private wasAnyDescendantAnimated(tile: Tile): boolean {\n        const distanceToMaxLevel = tile.dataSource.maxDataLevel - tile.tileKey.level;\n        const levelsDown = Math.min(\n            distanceToMaxLevel,\n            this.m_mapView.visibleTileSet.options.quadTreeSearchDistanceDown\n        );\n\n        const tilingScheme = tile.dataSource.getTilingScheme();\n        let nextTileKeys = [tile.tileKey];\n        let childTileKeys: TileKey[] = [];\n        for (let deltaDown = 1; deltaDown <= levelsDown; ++deltaDown) {\n            childTileKeys.length = 0;\n            for (const tileKey of nextTileKeys) {\n                for (const childTileKey of tilingScheme.getSubTileKeys(tileKey)) {\n                    if (this.m_tileMap.get(childTileKey.mortonCode())?.animated ?? false) {\n                        return true;\n                    }\n                    childTileKeys.push(childTileKey);\n                }\n            }\n            // swap\n            [nextTileKeys, childTileKeys] = [childTileKeys, nextTileKeys];\n        }\n\n        return false;\n    }\n\n    private removeTile(tile: Tile): void {\n        this.m_tileMap.delete(tile.tileKey.mortonCode());\n    }\n\n    private animateExtrusion() {\n        if (this.m_state !== AnimatedExtrusionState.Started) {\n            return;\n        }\n\n        const currentTime = Date.now();\n        if (this.m_startTime < 0) {\n            this.m_startTime = currentTime;\n        }\n\n        const duration = this.duration;\n        const timeProgress = Math.min(currentTime - this.m_startTime, duration);\n\n        const extrusionRatio = MathUtils.easeInOutCubic(\n            ExtrusionFeatureDefs.DEFAULT_RATIO_MIN,\n            ExtrusionFeatureDefs.DEFAULT_RATIO_MAX,\n            timeProgress / duration\n        );\n        this.setExtrusionRatio(extrusionRatio);\n\n        if (timeProgress >= duration) {\n            this.m_state = AnimatedExtrusionState.Finished;\n        }\n\n        this.m_mapView.update();\n    }\n\n    private resetAnimation(resetTiles: boolean) {\n        this.m_state = AnimatedExtrusionState.None;\n        this.m_startTime = -1;\n        if (resetTiles) {\n            this.m_tileMap.forEach(state => {\n                state.animated = false;\n            });\n        }\n    }\n    private setExtrusionRatio(value: number) {\n        this.m_tileMap.forEach(state => {\n            if (!state.animated) {\n                this.setTileExtrusionRatio(state.materials, value);\n                if (value >= 1) {\n                    state.animated = true;\n                }\n            }\n        });\n    }\n\n    private setTileExtrusionRatio(materials: ExtrusionFeature[], value: number) {\n        materials.forEach(material => {\n            material.extrusionRatio = value;\n        });\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { IChannel } from \"./IChannel\";\n\n/**\n * Class for the default console channel.\n */\n\nexport class ConsoleChannel implements IChannel {\n    error(message?: any, ...optionalParams: any[]) {\n        // tslint:disable-next-line:no-console\n        console.error(message, ...optionalParams);\n    }\n\n    debug(message?: any, ...optionalParams: any[]) {\n        // tslint:disable-next-line:no-console\n        console.debug(message, ...optionalParams);\n    }\n\n    info(message?: any, ...optionalParams: any[]) {\n        // tslint:disable-next-line:no-console\n        console.info(message, ...optionalParams);\n    }\n\n    log(message?: any, ...optionalParams: any[]) {\n        // tslint:disable-next-line:no-console\n        console.log(message, ...optionalParams);\n    }\n\n    trace(message?: any, ...optionalParams: any[]) {\n        // tslint:disable-next-line:no-console\n        console.trace(message, ...optionalParams);\n    }\n\n    warn(message?: any, ...optionalParams: any[]) {\n        // tslint:disable-next-line:no-console\n        console.warn(message, ...optionalParams);\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { IChannel } from \"./IChannel\";\nimport { ILogger, LoggerOptions, LogLevel } from \"./ILogger\";\n\n/**\n * Logger class.\n */\nexport class Logger implements ILogger {\n    enabled: boolean = true;\n    level: LogLevel = LogLevel.Trace;\n\n    constructor(readonly name: string, private m_channel: IChannel, options?: LoggerOptions) {\n        if (options !== undefined) {\n            this.update(options);\n        }\n    }\n\n    error(message?: any, ...optionalParams: any[]) {\n        if (this.enabled && this.level <= LogLevel.Error) {\n            this.m_channel.error(this.prefix, message, ...optionalParams);\n        }\n    }\n\n    debug(message?: any, ...optionalParams: any[]) {\n        if (this.enabled && this.level <= LogLevel.Debug) {\n            this.m_channel.debug(this.prefix, message, ...optionalParams);\n        }\n    }\n\n    info(message?: any, ...optionalParams: any[]) {\n        if (this.enabled && this.level <= LogLevel.Info) {\n            this.m_channel.info(this.prefix, message, ...optionalParams);\n        }\n    }\n\n    log(message?: any, ...optionalParams: any[]) {\n        if (this.enabled && this.level <= LogLevel.Log) {\n            this.m_channel.log(this.prefix, message, ...optionalParams);\n        }\n    }\n\n    trace(message?: any, ...optionalParams: any[]) {\n        if (this.enabled && this.level <= LogLevel.Trace) {\n            this.m_channel.trace(this.prefix, message, ...optionalParams);\n        }\n    }\n\n    warn(message?: any, ...optionalParams: any[]) {\n        if (this.enabled && this.level <= LogLevel.Warn) {\n            this.m_channel.warn(this.prefix, message, ...optionalParams);\n        }\n    }\n\n    update(options: LoggerOptions) {\n        this.enabled = options.enabled === undefined ? this.enabled : options.enabled;\n        this.level = options.level === undefined ? this.level : options.level;\n    }\n\n    private get prefix(): string {\n        return this.name + \":\";\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { IChannel } from \"./IChannel\";\nimport { LogLevel } from \"./ILogger\";\n\ndeclare let self: Worker;\n\nexport const WORKERCHANNEL_MSG_TYPE = \"worker-channel-message\";\n\n/**\n * The interface for the messages of the WorkerChannel.\n */\nexport interface IWorkerChannelMessage {\n    message: any[];\n    type: \"worker-channel-message\";\n    level: LogLevel;\n}\n\n/**\n * The class for the worker channel.\n */\nexport class WorkerChannel implements IChannel {\n    error(message?: any, ...optionalParams: any[]) {\n        const workerMessage: IWorkerChannelMessage = {\n            message: [message, ...optionalParams],\n            type: WORKERCHANNEL_MSG_TYPE,\n            level: LogLevel.Error\n        };\n        self.postMessage(workerMessage);\n    }\n\n    debug(message?: any, ...optionalParams: any[]) {\n        const workerMessage: IWorkerChannelMessage = {\n            message: [message, ...optionalParams],\n            type: WORKERCHANNEL_MSG_TYPE,\n            level: LogLevel.Debug\n        };\n        self.postMessage(workerMessage);\n    }\n\n    info(message?: any, ...optionalParams: any[]) {\n        const workerMessage: IWorkerChannelMessage = {\n            message: [message, ...optionalParams],\n            type: WORKERCHANNEL_MSG_TYPE,\n            level: LogLevel.Info\n        };\n        self.postMessage(workerMessage);\n    }\n\n    log(message?: any, ...optionalParams: any[]) {\n        const workerMessage: IWorkerChannelMessage = {\n            message: [message, ...optionalParams],\n            type: WORKERCHANNEL_MSG_TYPE,\n            level: LogLevel.Log\n        };\n        self.postMessage(workerMessage);\n    }\n\n    trace(message?: any, ...optionalParams: any[]) {\n        const workerMessage: IWorkerChannelMessage = {\n            message: [message, ...optionalParams],\n            type: WORKERCHANNEL_MSG_TYPE,\n            level: LogLevel.Trace\n        };\n        self.postMessage(workerMessage);\n    }\n\n    warn(message?: any, ...optionalParams: any[]) {\n        const workerMessage: IWorkerChannelMessage = {\n            message: [message, ...optionalParams],\n            type: WORKERCHANNEL_MSG_TYPE,\n            level: LogLevel.Warn\n        };\n        self.postMessage(workerMessage);\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { JsonExpr } from \"./Expr\";\nimport { InterpolatedPropertyDefinition } from \"./InterpolatedPropertyDefs\";\n\n/**\n * Available line caps types(`\"None\"`, `\"Round\"`, `\"Square\"`, `\"TriangleOut\"`, `\"TriangleIn\"`).\n * Default is `\"Round\"`.\n */\nexport type LineCaps = \"Square\" | \"Round\" | \"None\" | \"TriangleOut\" | \"TriangleIn\";\n\n/**\n * Available line dash types(`\"Round\"`, `\"Square\"`, `\"Diamond\"`).\n * Default is `\"Square\"`.\n */\nexport type LineDashes = \"Square\" | \"Round\" | \"Diamond\";\n\n/**\n * Standard kinds of geometry.\n */\nexport enum StandardGeometryKind {\n    /**\n     * Used in the enabledKinds/disabledKinds filter to match any kind.\n     */\n    All = \"_all_\",\n\n    /**\n     * Background geometry.\n     */\n    Background = \"background\",\n\n    /**\n     * Terrain geometry.\n     */\n    Terrain = \"terrain\",\n\n    /**\n     * Default value for the FillTechnique.\n     */\n    Area = \"area\",\n\n    /**\n     * Default value for all line techniques.\n     */\n    Line = \"line\",\n\n    /**\n     * Default value for the FillTechnique.\n     */\n    Water = \"water\",\n\n    /**\n     * Political borders.\n     */\n    Border = \"border\",\n\n    /**\n     * Basis for all roads.\n     */\n    Road = \"road\",\n\n    /**\n     * Default value for the ExtrudedPolygonTechnique.\n     */\n    Building = \"building\",\n\n    /**\n     * Default value for the TextTechnique, LineMarkerTechnique and the PoiTechnique.\n     */\n    Label = \"label\",\n\n    /**\n     * Anything that may show up last.\n     */\n    Detail = \"detail\"\n}\n\n/**\n * Geometry kind used for use by [[BaseTechniqueParams.kind]].\n *\n * @remarks\n * The kind of geometry is used to group objects together,\n * allowing the group to be hidden or displayed.\n *\n * Any string can be used to specify the kind of the technique in a style in the theme file. Is is\n * suggested to specify multiple kinds for specific types of data. For a highway, the following list\n * of kinds is suggested:\n *```json\n *    [\"line\", \"road\", \"road:highway\"]\n *```\n * If it is a tunnel for a highway:\n *```json\n *    [\"line\", \"road\", \"road:highway\", \"tunnel\", \"road:tunnel\", \"road:highway:tunnel\"]\n *```\n * If specified in this way, specific types of data (here: highway roads) can be enabled and/or\n * disabled.\n */\nexport type GeometryKind = string | StandardGeometryKind;\n\nexport const GeometryKind = StandardGeometryKind;\n\n/**\n * Decorate property type with possible dynamic variants.\n */\nexport type DynamicProperty<T> = T | JsonExpr | InterpolatedPropertyDefinition<T>;\n\n/**\n * Length literals.\n *\n * @remarks\n * Description of length units inside a style. Supports literal values (interpreted as `m`), `m` and\n * `px`(i.e. `80`, `14px`, `0.6m`, etc.).\n */\nexport type StyleLength = string | number;\n\n/**\n * Color literals.\n *\n * @remarks\n * Description of colors inside a style. Supports hex values as well as CSS hex, rgb and hsl values\n * (i.e. `0xffffff`, `#f00fab`, `#aaa`, `rgb(255, 0 120)`, `hsl(360, 100%, 100%)`, etc.).\n */\nexport type StyleColor = string | number;\n\n/**\n * A set of [[GeometryKind]]s.\n */\nexport class GeometryKindSet extends Set {\n    /**\n     * Return `true` if the Set is a superset of the set 'subset'.\n     */\n    isSuperset(subset: Set<any>): boolean {\n        for (const elem of subset) {\n            if (!this.has(elem)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Return `true` if the Set intersects Set 'set'.\n     */\n    hasIntersection(set: any) {\n        for (const elem of set) {\n            if (this.has(elem)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return `true` if the Set either intersects Set 'set' (if set is a Set), of has element 'set'\n     * if set is not a Set.\n     */\n    hasOrIntersects(set: any) {\n        if (set instanceof Set) {\n            return this.hasIntersection(set);\n        }\n        return this.has(set);\n    }\n\n    /**\n     * Return `true` if this set and the array of elements share at least a single element.\n     */\n    hasOrIntersectsArray(subset: any[]) {\n        for (const elem of subset) {\n            if (this.has(elem)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n/**\n * Common attributes or all [[Technique]]s.\n */\nexport interface BaseTechniqueParams {\n    /**\n     * The name used to identify materials created from this technique.\n     */\n    id?: string;\n\n    /**\n     * The render order of the objects created using this technique.\n     *\n     * If not specified in style file, [[StyleSetEvaluator]] will assign monotonically increasing\n     * values according to style position in file.\n     */\n    renderOrder?: DynamicProperty<number>;\n\n    /**\n     * The category of this technique.\n     *\n     * The category is used in conjunction with [[Theme.priorities]]\n     * to assign render orders to the objects created by this [[Style]].\n     */\n    category?: DynamicProperty<string>;\n\n    /**\n     * Optional. If `true`, no IDs will be saved for the geometry this technique creates.\n     */\n    transient?: boolean;\n\n    /**\n     * Distance to the camera (0.0 = camera position, 1.0 = farPlane) at which the object start\n     * fading out (opacity decreases).\n     */\n    fadeNear?: DynamicProperty<number>;\n\n    /**\n     * Distance to the camera (0.0 = camera position, 1.0 = farPlane) at which the object has zero\n     * opacity and stops fading out. An undefined value disables fading.\n     */\n    fadeFar?: DynamicProperty<number>;\n\n    /**\n     * Specified kind of geometry. One kind is set as default in the technique, and can be\n     * overridden in the style.\n     *\n     * @deprecated Use [[enabled]] with expressions based on `['dynamic-properties']` operator.\n     */\n    kind?: GeometryKind | GeometryKindSet;\n\n    /**\n     * Runtime filtering of techniques.\n     *\n     * Use with `['dynamic-properties']` operator for dynamic feature highlight, highlighig etc.\n     *\n     * @see Picking example - [[PickingExample]]\n     */\n    enabled?: DynamicProperty<boolean>;\n}\n\nexport enum TextureCoordinateType {\n    /**\n     * Texture coordinates are in tile space.\n     * SW of the tile will have (0,0) and NE will have (1,1).\n     */\n    TileSpace = \"tile-space\",\n\n    /**\n     * Texture coordinates are in equirectangular space.\n     * (u, v) = ( (longitude+180) / 360, (latitude+90) / 180).\n     */\n    EquirectangularSpace = \"equirectangular-space\",\n\n    /**\n     * Texture coordinates in feature space.\n     *\n     * To compute texture coordinates in feature space,\n     * the feature must have a property named `bbox` with value\n     * the tuple `[west, south, east, north]`.\n     */\n    FeatureSpace = \"feature-space\"\n}\n\n/**\n * Standard technique parameters.\n */\nexport interface StandardTechniqueParams extends BaseTechniqueParams {\n    /**\n     * Color of the feature in hexadecimal or CSS-style notation, for example: `\"#e4e9ec\"`,\n     * `\"#fff\"`, `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * See https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.color.\n     * @format color-hex\n     */\n    color?: DynamicProperty<StyleColor>;\n    /**\n     * A value of `true` creates a wireframe geometry. (May not be supported with all techniques).\n     * See https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.wireframe.\n     */\n    wireframe?: boolean;\n    /**\n     * If `vertexColors` is `true`, every vertex has color information, which is interpolated\n     * between vertices.\n     * See https://threejs.org/docs/#api/en/materials/Material.vertexColors.\n     */\n    vertexColors?: boolean;\n    /**\n     * How rough the material appears. `0.0` means a smooth mirror reflection. `1.0` means fully\n     * diffuse. Default is `1.0`.\n     * See https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.roughness.\n     */\n    roughness?: DynamicProperty<number>;\n    /**\n     * How much the material is like a metal. Nonmetallic materials such as wood or stone use `0.0`,\n     * metallic ones use `1.0`, with nothing (usually) in between. Default is `0.0`. A value between\n     * `0.0` and `1.0` can be used for a rusty metal look. If `metalnessMap` is also provided, both\n     * values are multiplied.\n     * See https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.metalness.\n     */\n    metalness?: DynamicProperty<number>;\n    /**\n     * The material will not be rendered if the opacity is lower than this value.\n     * See https://threejs.org/docs/#api/en/materials/Material.alphaTest.\n     */\n    alphaTest?: DynamicProperty<number>;\n    /**\n     * Skip rendering clobbered pixels.\n     * See https://threejs.org/docs/#api/en/materials/Material.depthTest.\n     */\n    depthTest?: boolean;\n    /**\n     * Set to 'true' if line should appear transparent. Rendering transparent lines may come with a\n     * slight performance impact.\n     * See https://threejs.org/docs/#api/en/materials/Material.transparent.\n     */\n    transparent?: boolean;\n    /**\n     * For transparent lines, set a value between 0.0 for totally transparent, to 1.0 for totally\n     * opaque.\n     * See https://threejs.org/docs/#api/en/materials/Material.opacity.\n     */\n    opacity?: DynamicProperty<number>;\n    /**\n     * Emissive (light) color of the material, essentially a solid color unaffected by other\n     * lighting. Default is black.\n     * See https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.emissive.\n     * @format color-hex\n     */\n    emissive?: DynamicProperty<StyleColor>;\n    /**\n     * Intensity of the emissive light. Modulates the emissive color. Default is `1`.\n     * See https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.emissiveIntensity.\n     */\n    emissiveIntensity?: DynamicProperty<number>;\n    /**\n     * The index of refraction (IOR) of air (approximately 1) divided by the index of refraction of\n     * the material. It is used with environment mapping modes `THREE.CubeRefractionMapping` and\n     * `THREE.EquirectangularRefractionMapping`. The refraction ratio should not exceed `1`. Default\n     *  is `0.98`.\n     * See https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.refractionRatio.\n     */\n    refractionRatio?: DynamicProperty<number>;\n\n    /**\n     * Whether and how texture coordinates should be generated. No texture coordinates are\n     * generated if `undefined`.\n     * Should be set if any texture assigned (e.g. `map`, `normalMap`, ...).\n     */\n    textureCoordinateType?: TextureCoordinateType;\n\n    /*\n     * URL or texture buffer that should be used as color map. See:\n     * https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.map\n     */\n    map?: string | TextureBuffer;\n    mapProperties?: TextureProperties;\n\n    /**\n     * URL or texture buffer that should be used as normal map. See:\n     * https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.normalMap\n     */\n    normalMap?: string | TextureBuffer;\n    normalMapType?: number;\n    normalMapProperties?: TextureProperties;\n\n    /**\n     * URL or texture buffer that should be used as displacement map. See:\n     * https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.displacementMap\n     */\n    displacementMap?: string | TextureBuffer;\n    displacementMapProperties?: TextureProperties;\n\n    /**\n     * URL or texture buffer that should be used as roughness map. See:\n     * https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.roughnessMap\n     */\n    roughnessMap?: string | TextureBuffer;\n    roughnessMapProperties?: TextureProperties;\n\n    /**\n     * URL or texture buffer that should be used as emissive map. See:\n     * https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.emissiveMap\n     */\n    emissiveMap?: string | TextureBuffer;\n    emissiveMapProperties?: TextureProperties;\n\n    /**\n     * URL or texture buffer that should be used as bump map. See:\n     * https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.bumpMap\n     */\n    bumpMap?: string | TextureBuffer;\n    bumpMapProperties?: TextureProperties;\n\n    /**\n     * URL or texture buffer that should be used as metalness map. See:\n     * https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.metalnessMap\n     */\n    metalnessMap?: string | TextureBuffer;\n    metalnessMapProperties?: TextureProperties;\n\n    /**\n     * URL or texture buffer that should be used as alpha map. See:\n     * https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.alphaMap\n     */\n    alphaMap?: string | TextureBuffer;\n    alphaMapProperties?: TextureProperties;\n}\n\n/**\n * Possible parameters of [[PointTechnique]].\n */\nexport interface PointTechniqueParams extends BaseTechniqueParams {\n    /**\n     * Color of a point in hexadecimal or CSS-style notation, for example: `\"#e4e9ec\"`, `\"#fff\"`,\n     * `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    color?: DynamicProperty<StyleColor>;\n    /**\n     * URL of a texture image to be loaded.\n     */\n    texture?: string;\n    /**\n     * Set to `true` if line should appear transparent. Rendering transparent lines may come with a\n     * slight performance impact.\n     */\n    transparent?: boolean;\n    /**\n     * For transparent lines, set a value between 0.0 for totally transparent, to 1.0 for totally\n     * opaque.\n     */\n    opacity?: DynamicProperty<number>;\n    /**\n     * Size of point in pixels.\n     */\n    size?: number;\n    /**\n     * Whether to enable picking on these points.\n     */\n    enablePicking?: boolean;\n}\n\n/**\n * Define the stacking option. Enum values for theme file are in \"kebab-case\".\n */\nexport enum PoiStackMode {\n    /**\n     * Show in a stack.\n     */\n    Show = \"show-in-stack\",\n    /**\n     * Do not show in a stack.\n     */\n    Hide = \"hide-in-stack\",\n    /**\n     * Show category parent in the stack.\n     */\n    ShowParent = \"show-parent\"\n}\n\n/**\n * Defines options (tokens) supported for text placements defined via [[placements]] attribute.\n *\n * @remarks\n * Possible values are defined as vertical placement letter and horizontal letter, where\n * one of the axis may be ignored and then assumed centered. Moving clock-wise, we have:\n * `TL` (top-left), `T` (top-center), `TR` (top-right), `R` (center-right), `BR` (bottom-right),\n * `B` (bottom-center), `BL` (bottom-left), `L` (left), `C` (center-center).\n * Alternatively instead of `T`, `B`, `L`, `R` geographic directions may be used accordingly:\n * `NW` (north-west), `N` (north), `NE` (north-east), `E` (east), `SE` (south-east), `S` (south),\n * `SW` (south-west), `W` (west).\n */\nexport enum PlacementToken {\n    TopLeft = \"TL\",\n    Top = \"T\",\n    TopRight = \"TR\",\n    Right = \"R\",\n    BottomRight = \"BR\",\n    Bottom = \"B\",\n    BottomLeft = \"BL\",\n    Left = \"L\",\n    Center = \"C\",\n    NorthWest = \"NW\",\n    North = \"N\",\n    NorthEast = \"NE\",\n    East = \"E\",\n    SouthEast = \"SE\",\n    South = \"S\",\n    SouthWest = \"SW\",\n    West = \"W\"\n}\n\n/**\n * Technique that describes icons with labels. Used in [[PoiTechnique]] and [[LineMarkerTechnique]]\n * (for road shields).\n */\nexport interface MarkerTechniqueParams extends BaseTechniqueParams {\n    /**\n     * Text to be displayed for feature.\n     *\n     * Defaults to first defined:\n     *  - feature property `label` if present in technique (deprecated)\n     *  - `[\"get\", \"name:short\"]` is `useAbbreviation` is true\n     *  - `[\"get\", \"iso_code\"]` is `useIsoCode` is true\n     *  - `[\"get\", \"name:$LANGUAGE\"]` for each specified language\n     *  - `[\"get\", \"name\"]`\n     *\n     * See [[ExtendedTileInfo.getFeatureText]]\n     */\n    text?: DynamicProperty<string>;\n\n    /**\n     * Field name of object containing the text to be rendered.\n     *\n     * @deprecated Use `[\"get\", \"FIELD\"]`.\n     */\n    label?: string;\n    /**\n     * If `true`, the abbreviation (field `name:short`) of the elements is used as text.\n     *\n     * @deprecated Use proper expression with [`get`, `name:short`] for this purpose.\n     */\n    useAbbreviation?: boolean;\n    /**\n     * If `true`, the iso code (field 'iso_code') of the elements is used as text.\n     * The `iso_code` field contains the ISO 3166-1 2-letter country code.\n     *\n     * @deprecated Use proper expression with [`get`, `iso_code`] for this purpose.\n     */\n    useIsoCode?: boolean;\n    /**\n     * Priority of marker, defaults to `0`. Markers with highest priority get placed first.\n     */\n    priority?: DynamicProperty<number>;\n    /**\n     * Minimum zoomLevel at which to display the label text. No default.\n     */\n    textMinZoomLevel?: number;\n    /**\n     * Maximum zoomLevel at which to display the label text. No default.\n     */\n    textMaxZoomLevel?: number;\n    /**\n     * Minimum zoomLevel at which to display the label icon. No default.\n     */\n    iconMinZoomLevel?: number;\n    /**\n     * Maximum zoomLevel at which to display the label icon. No default.\n     */\n    iconMaxZoomLevel?: number;\n\n    /**\n     * Icon color.\n     *\n     * If specified, combined using multiplication with color value read from icon texture.\n     *\n     * Works best for grayscale or monochromatic textures.\n     */\n    iconColor?: StyleColor;\n\n    /**\n     * Icon brightness.\n     *\n     * Factor that multiplies a color on top of the icon texture (and `iconColor`) with `0` being\n     * fully black as final output, `1` being the original rgb colors of the texture.\n     *\n     * @default `1`\n     */\n    iconBrightness?: number;\n\n    /**\n     * Scaling factor of icon. Defaults to 0.5, reducing the size ot 50% in the distance.\n     */\n    distanceScale?: number;\n    /**\n     * If `false`, text may overlap markers.\n     * @default `false`\n     */\n    textMayOverlap?: boolean;\n    /**\n     * If `false`, the icon may overlap text and other icons of lower priority. If not defined, the\n     * property value from `textMayOverlap` will be used.\n     * @default `false`\n     */\n    iconMayOverlap?: boolean;\n    /**\n     * If `false`, text will not reserve screen space, other markers will be able to overlap.\n     * @default `true`\n     */\n    textReserveSpace?: boolean;\n    /**\n     * If `false`, icon will not reserve screen space, other markers will be able to overlap. If not\n     * defined, the property value from `iconReserveSpace` will be used.\n     * @default `true`\n     */\n    iconReserveSpace?: boolean;\n    /**\n     * If `false`, text will not be rendered during animations. Defaults to `true`.\n     */\n    renderTextDuringMovements?: boolean;\n    /**\n     * If `true`, the label will always be rendered on top. If overlapping with other labels with\n     * this flag set, the render order is undefined.\n     * @default `false`\n     */\n    alwaysOnTop?: boolean;\n    /**\n     * If `true`, icon will appear even if the text part is blocked by other labels. Defaults to\n     * `false`.\n     */\n    textIsOptional?: boolean;\n    /**\n     * Should be displayed on map or not. Defaults to `true`.\n     */\n    showOnMap?: boolean;\n    /**\n     * Specify stack mode. Defaults to `ShowInStack`.\n     */\n    stackMode?: PoiStackMode;\n    /**\n     * Minimal distance between markers in screen pixels.\n     */\n    minDistance?: number;\n    /**\n     * If true, the text will appear even if the icon cannot be rendered because of missing icon\n     * graphics. Defaults to `true`.\n     */\n    iconIsOptional?: boolean;\n    /**\n     * Fading time for labels in seconds.\n     */\n    textFadeTime?: number;\n    /**\n     * Fading time for icons in seconds.\n     */\n    iconFadeTime?: number;\n    /**\n     * Horizontal offset (to the right) in screen pixels.\n     */\n    xOffset?: DynamicProperty<number>;\n    /**\n     * Vertical offset (up) in screen pixels.\n     */\n    yOffset?: DynamicProperty<number>;\n    /**\n     * Horizontal offset (to the right) in screen pixels.\n     */\n    iconXOffset?: DynamicProperty<number>;\n    /**\n     * Vertical offset (up) in screen pixels.\n     */\n    iconYOffset?: DynamicProperty<number>;\n    /**\n     * Scaling factor of icon.\n     */\n    iconScale?: number;\n    /**\n     * Vertical height in pixels, controls vertical scaling. Overrides `iconScale`.\n     */\n    screenHeight?: DynamicProperty<number>;\n    /**\n     * Horizontal height in pixels, controls horizontal scaling. Overrides `iconScale`.\n     */\n    screenWidth?: DynamicProperty<number>;\n    /**\n     * Name of the POI table which should be used for this POI.\n     */\n    poiTable?: string;\n    /**\n     * Fixed name to identify POI options in the POI table. If `poiName` has a value, this value\n     * supersedes any value read from the field referenced in `poiNameField`.\n     */\n    poiName?: string;\n    /**\n     * Name of the field to evaluate to get the name of the POI options in the POI table.\n     */\n    poiNameField?: string;\n    /**\n     * Name of [[ImageTexture]] definition to use.\n     */\n    imageTexture?: DynamicProperty<string>;\n    /**\n     * Field name to extract imageTexture content from.\n     */\n    imageTextureField?: string;\n    /**\n     * Prefix for `imageTexture` if `imageTextureField` is used.\n     */\n    imageTexturePrefix?: string;\n    /**\n     * Postfix for `imageTexture` if `imageTextureField` is used.\n     */\n    imageTexturePostfix?: string;\n    /**\n     * Name of the text style.\n     */\n    style?: string;\n    /**\n     * Name of the preferred [[Font]] to be used when rendering.\n     */\n    fontName?: string;\n    /**\n     * Size of the text (pixels).\n     */\n    size?: DynamicProperty<number>;\n    /**\n     * Size of the text background (pixels).\n     */\n    backgroundSize?: DynamicProperty<number>;\n    /**\n     * Glyph style to apply for the currently active [[Font]].\n     */\n    fontStyle?: \"Regular\" | \"Bold\" | \"Italic\" | \"BoldItalic\";\n    /**\n     * Glyph variant to apply for the currently active [[Font]].\n     */\n    fontVariant?: \"Regular\" | \"AllCaps\" | \"SmallCaps\";\n    /**\n     * Glyph local rotation (radians).\n     */\n    rotation?: number;\n    /**\n     * Text color in hexadecimal or CSS-style notation, for example: `\"#e4e9ec\"`, `\"#fff\"`,\n     * `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    color?: DynamicProperty<StyleColor>;\n    /**\n     * Text background color in hexadecimal or CSS-style notation, for example: `\"#e4e9ec\"`,\n     * `\"#fff\"`, `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    backgroundColor?: DynamicProperty<StyleColor>;\n    /**\n     * For transparent text, set a value between 0.0 for totally transparent, to 1.0 for totally\n     * opaque.\n     */\n    opacity?: DynamicProperty<number>;\n    /**\n     * Background text opacity value.\n     */\n    backgroundOpacity?: DynamicProperty<number>;\n    /**\n     * Inter-glyph spacing (pixels). Scaled by `size`.\n     */\n    tracking?: DynamicProperty<number>;\n    /**\n     * Inter-line spacing (pixels). Scaled by `size`.\n     */\n    leading?: DynamicProperty<number>;\n    /**\n     * Maximum number of lines for this label.\n     */\n    maxLines?: DynamicProperty<number>;\n    /**\n     * Maximum line width (pixels).\n     */\n    lineWidth?: DynamicProperty<number>;\n    /**\n     * [[TextCanvas]] rotation (radians).\n     */\n    canvasRotation?: DynamicProperty<number>;\n    /**\n     * Line typesetting rotation (radians).\n     */\n    lineRotation?: DynamicProperty<number>;\n    /**\n     * Wrapping (line-breaking) mode.\n     */\n    wrappingMode?: DynamicProperty<\"None\" | \"Character\" | \"Word\">;\n    /**\n     * Text position regarding the baseline.\n     *\n     * @note The [[placements]] attribute may override the alignment settings.\n     */\n    hAlignment?: DynamicProperty<\"Left\" | \"Center\" | \"Right\">;\n    /**\n     * Text position inside a line.\n     *\n     * @note The [[placements]] attribute may supersede it.\n     */\n    vAlignment?: DynamicProperty<\"Above\" | \"Center\" | \"Below\">;\n    /**\n     * Text label positions relative to the label central position (anchor point).\n     *\n     * This attribute defines a comma separated tokens of possible text placements\n     * relative to label central position (anchor), for example: \"TL, TR, C\".\n     * Keep in mind that horizontal placement defines text position in opposite way to\n     * the alignment, so the text `R` placed (located on the **right side** of label position)\n     * will be the same as `Left` aligned by deduction. On other side vertical placement is quite\n     * similar to vertical alignment so `T` placement corresponds with `Above` alignment.\n     *\n     * @note This attribute may override [[hAlignment]] and [[vAlignment]] if defined.\n     */\n    placements?: string;\n\n    /**\n     * World space offset in meters applied to the icon. Valid only for icons which have the\n     * \"offset_direction\" property as an attribute of the data.\n     */\n    worldOffset?: DynamicProperty<number>;\n}\n\nexport interface LineTechniqueParams extends BaseTechniqueParams {\n    /**\n     * Color of a line in hexadecimal or CSS-style notation, for example: `\"#e4e9ec\"`, `\"#fff\"`,\n     * `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    color: DynamicProperty<StyleColor>;\n    /**\n     * Set to true if line should appear transparent. Rendering transparent lines may come with a\n     * slight performance impact.\n     */\n    transparent?: boolean;\n    /**\n     * For transparent lines, set a value between 0.0 for totally transparent, to 1.0 for totally\n     * opaque.\n     */\n    opacity?: DynamicProperty<number>;\n    /**\n     * Width of line in pixels. WebGL implementations will normally render all lines with 1 pixel\n     * width, and ignore this value.\n     */\n    lineWidth: DynamicProperty<number>;\n}\n\n/**\n * Declares a geometry as a segment.\n */\nexport interface SegmentsTechniqueParams extends BaseTechniqueParams {\n    /**\n     * Color of segments in a hexadecimal notation, for example: `\"#e4e9ec\"` or `\"#fff\"`.\n     * @format color-hex\n     */\n    color: DynamicProperty<StyleColor>;\n    /**\n     * Set to `true` if line should appear transparent. Rendering transparent lines may come with a\n     * slight performance impact.\n     */\n    transparent?: boolean;\n    /**\n     * For transparent lines, set a value between `0.0` for fully transparent, to `1.0` for fully\n     * opaque.\n     */\n    opacity?: DynamicProperty<number>;\n    /**\n     * Width of a line in meters.\n     */\n    lineWidth: DynamicProperty<number>;\n}\n\n/**\n * Declares a a geometry as a polygon.\n */\nexport interface PolygonalTechniqueParams {\n    /**\n     * Whether to use polygon offset. Default is false. This corresponds to the\n     * GL_POLYGON_OFFSET_FILL WebGL feature.\n     *\n     * PolygonOffset is used to raise the geometry towards the geometry (for depth calculation\n     * only). Default is false.\n     *\n     * See here: https://sites.google.com/site/threejstuts/home/polygon_offset\n     *\n     * To activate polygonOffset these values have to be set to pull the line \"forwards\":\n     *\n     * transparent: true\n     *\n     * polygonOffset: true\n     *\n     * polygonOffsetFactor : -1.0, (as an example, see link above)\n     *\n     * polygonOffsetUnits: -1 (as an example, see link above)\n     */\n    polygonOffset?: boolean;\n\n    /**\n     * Sets the polygon offset factor. Default is 0.\n     */\n    polygonOffsetFactor?: DynamicProperty<number>;\n\n    /**\n     * Sets the polygon offset units. Default is 0.\n     */\n    polygonOffsetUnits?: DynamicProperty<number>;\n\n    /**\n     * Sets the polygon outline color.\n     * @format color-hex\n     */\n    lineColor?: DynamicProperty<StyleColor>;\n\n    /**\n     * Distance to the camera (0.0 = nearPlane, 1.0 = farPlane) at which the object edges start\n     * fading out.\n     */\n    lineFadeNear?: DynamicProperty<number>;\n\n    /**\n     * Distance to the camera (0.0 = nearPlane, 1.0 = farPlane) at which the object edges become\n     * transparent. A value of <= 0.0 disables fading.\n     */\n    lineFadeFar?: DynamicProperty<number>;\n}\n\n/**\n * Declares a a geometry as a basic extruded line.\n */\nexport interface BasicExtrudedLineTechniqueParams\n    extends BaseTechniqueParams,\n        PolygonalTechniqueParams {\n    /**\n     * A value determining the shading technique. Valid values are \"Basic\" and \"Standard\". Default\n     * is \"Basic\".\n     *\n     * `\"basic\"`   : Simple shading, faster to render. Only simple color and opacity are effective.\n     * `\"standard\"`: Elaborate shading, with metalness, and roughness.\n     *\n     * TODO: is this TechniqueParams or Style prop ?\n     */\n    shading?: \"basic\";\n    /**\n     * Color of a line in hexadecimal or CSS-style notation, for example: `\"#e4e9ec\"`, `\"#fff\"`,\n     * `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    color: DynamicProperty<StyleColor>;\n    /**\n     * Set to `true` if line should appear transparent. Rendering transparent lines may come with a\n     * slight performance impact.\n     */\n    transparent?: boolean;\n    /**\n     * For transparent lines, set a value between 0.0 for totally transparent, to 1.0 for totally\n     * opaque.\n     */\n    opacity?: DynamicProperty<number>;\n    /**\n     * Width of line in meters for different zoom levels.\n     */\n    lineWidth: DynamicProperty<number>;\n    /**\n     * A value of `true` creates a wireframe geometry. (May not be supported with all techniques).\n     */\n    wireframe?: boolean;\n    /**\n     * Style of both end caps. Possible values: `\"None\"`, `\"Circle\"`. A value of undefined maps to\n     * `\"Circle\"`.\n     */\n    caps?: DynamicProperty<\"None\" | \"Circle\">;\n}\n\n/**\n * Declares a a geometry as a standard extruded line.\n */\nexport interface StandardExtrudedLineTechniqueParams\n    extends StandardTechniqueParams,\n        PolygonalTechniqueParams {\n    /**\n     * A value determining the shading technique. Valid values are `\"basic\"` and `\"standard\"`.\n     * Default is `\"basic\"`.\n     *\n     * `\"basic\"` : Simple shading, faster to render. Only simple color and opacity are effective.\n     * `\"standard\"` : Elaborate shading, with metalness, and roughness.\n     */\n    shading: \"standard\";\n    /**\n     * Width of a line in meters for different zoom levels.\n     */\n    lineWidth: DynamicProperty<number>;\n    /**\n     * Style of both end caps. Possible values: `\"None\"`, `\"Circle\"`. A value of undefined maps to\n     * `\"Circle\"`.\n     */\n    caps?: DynamicProperty<\"None\" | \"Circle\">;\n}\n\n/**\n * Declares a a geometry as a solid line.\n */\nexport interface SolidLineTechniqueParams extends BaseTechniqueParams, PolygonalTechniqueParams {\n    /**\n     * Color of a line in hexadecimal or CSS-style notation, for example: `\"#e4e9ec\"`, `\"#fff\"`,\n     * `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    color: DynamicProperty<StyleColor>;\n    /**\n     * Color of a line outline in hexadecimal or CSS-style notation,\n     * for example: `\"#e4e9ec\"`, `\"#fff\"`, `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    outlineColor?: DynamicProperty<StyleColor>;\n    /**\n     * Set to `true` if line should appear transparent. Rendering transparent lines may come with a\n     * slight performance impact.\n     */\n    transparent?: boolean;\n    /**\n     * For transparent lines, set a value between `0.0` for fully transparent, to `1.0` for fully\n     * opaque.\n     */\n    opacity?: DynamicProperty<number>;\n    // TODO: Make pixel units default.\n    /**\n     * @deprecated Specify metrics units as part of the value instead.\n     * Units in which different size properties are specified. Either `Meter` (default) or `Pixel`.\n     */\n    metricUnit?: string;\n    /**\n     * Width of a line in `metricUnit` for different zoom levels.\n     */\n    lineWidth: DynamicProperty<StyleLength>;\n    /**\n     * Outline width of a line in `metricUnit`s for different zoom levels.\n     */\n    outlineWidth?: DynamicProperty<StyleLength>;\n    /**\n     * Clip the line outside the tile if `true`.\n     */\n    clipping?: DynamicProperty<boolean>;\n    /**\n     * Describes line caps type (`\"None\"`, `\"Round\"`, `\"Square\"`, `\"TriangleOut\"`, `\"TriangleIn\"`).\n     * Default is `\"Round\"`.\n     */\n    caps?: DynamicProperty<LineCaps>;\n    /**\n     * Color of secondary line geometry in hexadecimal or CSS-style notation, for example:\n     * `\"#e4e9ec\"`, `\"#fff\"`, `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    secondaryColor?: DynamicProperty<StyleColor>;\n    /**\n     * Width of secondary line geometry in `metricUnit`s for different zoom levels.\n     */\n    secondaryWidth?: DynamicProperty<StyleLength>;\n    /**\n     * The render order of the secondary line geometry object created using this technique.\n     */\n    secondaryRenderOrder?: DynamicProperty<number>;\n    /**\n     * Describes secondary line caps type (`\"None\"`, `\"Round\"`, `\"Square\"`, `\"TriangleOut\"`,\n     * `\"TriangleIn\"`).\n     * Default is `\"Round\"`.\n     */\n    secondaryCaps?: DynamicProperty<LineCaps>;\n    /**\n     * Describes the category of the secondary geometry object created using this technique.\n     */\n    secondaryCategory?: DynamicProperty<string>;\n    /**\n     * Describes the starting drawing position for the line (in the range [0...1]).\n     * Default is `0.0`.\n     */\n    drawRangeStart?: number;\n    /**\n     * Describes the ending drawing position for the line (in the range [0...1]).\n     * Default is `1.0`.\n     */\n    drawRangeEnd?: number;\n    /**\n     * Describes line dash type (`\"Round\"`, `\"Square\"`, `\"Diamond\"`).\n     * Default is `\"Square\"`.\n     */\n    dashes?: DynamicProperty<LineDashes>;\n    /**\n     * Color of a line dashes in hexadecimal or CSS-style notation,\n     * for example: `\"#e4e9ec\"`, `\"#fff\"`, `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    dashColor?: DynamicProperty<StyleColor>;\n    /**\n     * Length of a line in meters for different zoom levels.\n     */\n    dashSize?: DynamicProperty<StyleLength>;\n    /**\n     * Size of a gap between lines in meters for different zoom levels.\n     */\n    gapSize?: DynamicProperty<StyleLength>;\n    /**\n     * Size in world units how far to offset the line perpendicular to its direction.\n     */\n    offset?: DynamicProperty<number>;\n}\n\n/**\n * Technique used to draw filled polygons.\n */\nexport interface FillTechniqueParams extends BaseTechniqueParams, PolygonalTechniqueParams {\n    /**\n     * Fill color in hexadecimal or CSS-style notation, for example: `\"#e4e9ec\"`, `\"#fff\"`,\n     * `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    color?: DynamicProperty<StyleColor>;\n    /**\n     * Set to `true` if line should appear transparent. Rendering transparent lines may come with a\n     * slight performance impact.\n     */\n    transparent?: boolean;\n    /**\n     * For transparent lines, set a value between `0.0` for fully transparent, to `1.0` for fully\n     * opaque.\n     */\n    opacity?: DynamicProperty<number>;\n    /**\n     * A value of `true` creates a wireframe geometry. (May not be supported with all techniques).\n     */\n    wireframe?: boolean;\n    /**\n     * Width of the lines. Currently limited to the [0, 1] range.\n     */\n    lineWidth?: DynamicProperty<number>;\n}\n\n/**\n * Technique used to draw a geometry as an extruded polygon, for example extruded buildings.\n */\nexport interface ExtrudedPolygonTechniqueParams extends StandardTechniqueParams {\n    /**\n     * Renders the footprint lines if set to 'true'.\n     */\n    footprint?: boolean;\n    /**\n     * Set to a negative value to remove all the vertical lines, and to a value between 0.0 and 1.0\n     * to modulate the amount of vertical lines rendered.\n     */\n    maxSlope?: number;\n    /**\n     * Width of the lines. Currently limited to the [0, 1] range.\n     */\n    lineWidth: DynamicProperty<number>;\n    /**\n     * Fill color in hexadecimal or CSS-style notation, for example: `\"#e4e9ec\"`, `\"#fff\"`,\n     * `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    lineColor?: DynamicProperty<StyleColor>;\n    /**\n     * Mix value between the lineColor(0.0) and the geometry's vertex colors(1.0).\n     */\n    lineColorMix?: number;\n\n    /**\n     * Distance to the camera (0.0 = nearPlane, 1.0 = farPlane) at which the object edges start\n     * fading out.\n     */\n    lineFadeNear?: DynamicProperty<number>;\n    /**\n     * Distance to the camera (0.0 = nearPlane, 1.0 = farPlane) at which the object edges become\n     * transparent. A value of <= 0.0 disables fading.\n     */\n    lineFadeFar?: DynamicProperty<number>;\n\n    /**\n     * Height above ground in world units of extruded polygon.\n     *\n     * Usually, unique per feature, so defaults to `[\"get\", \"height\"]`.\n     */\n    height?: DynamicProperty<number>;\n\n    /**\n     * Height of \"floor\" of extruded polygon in world units of extruded polygon.\n     *\n     * Usually, unique per feature, so defaults to `[\"number\", [\"get\", \"min_height\"], 0]`.\n     */\n    floorHeight?: DynamicProperty<number>;\n\n    /**\n     * In some data sources, for example Tilezen, building extrusion information might be missing.\n     * This attribute allows to define a default height of an extruded polygon in the theme.\n     *\n     * @deprecated use [[height]]\n     */\n    defaultHeight?: number;\n\n    /**\n     * Default color used if feature doesn't provide color attribute\n     * and [[MapEnv]] did not return it too.\n     * @format color-hex\n     */\n    defaultColor?: DynamicProperty<StyleColor>;\n\n    /**\n     * If `true`, the height of the extruded buildings will not be modified by the mercator\n     * projection distortion that happens around the poles.\n     *\n     * @default `false`\n     */\n    constantHeight?: boolean;\n\n    /**\n     * If `true`, wall geometry will is added along the tile boundaries. Note, this causes artifacts\n     * when used with shadows, so it should be known in advance that shadows won't be enabled.\n     * @default `false`\n     */\n    boundaryWalls?: boolean;\n\n    /**\n     * Animate the extrusion of the buildings if set to `true`.\n     */\n    animateExtrusion?: DynamicProperty<boolean>;\n\n    /**\n     * Duration of the building's extrusion in milliseconds\n     */\n    animateExtrusionDuration?: number;\n\n    /**\n     * Control rendering of depth prepass before the actual geometry.\n     *\n     * Depth prepass is a method to render translucent meshes, hence only the visible front faces of\n     * a mesh are actually rendered, removing artifacts caused by blending with internal faces of\n     * the mesh. This method is used for drawing translucent buildings over map background.\n     *\n     * By default, each [[DataSource]] determines how/if enable the depth pre-pass. A value of\n     * `false` forcefully disables depth prepass.\n     */\n    enableDepthPrePass?: boolean;\n}\n\nexport interface ShaderTechniqueMaterialParameters {\n    [name: string]: any;\n}\n\n/**\n * Special technique for user-defined shaders. See\n * https://threejs.org/docs/#api/harp-materials/ShaderMaterial for details.\n */\nexport interface ShaderTechniqueParams extends BaseTechniqueParams {\n    /**\n     * Parameters for shader. See `THREE.ShaderMaterialParameters`.\n     */\n    params: ShaderTechniqueMaterialParameters;\n\n    /**\n     * Type of primitive for the shader technique. Valid values are \"point\" | \"line\" | \"segments\" |\n     * \"mesh\"\n     */\n    primitive: \"point\" | \"line\" | \"segments\" | \"mesh\";\n\n    /**\n     * Set to 'true' if line should appear transparent. Rendering transparent lines may come with a\n     * slight performance impact.\n     * See https://threejs.org/docs/#api/en/materials/Material.transparent.\n     */\n    transparent?: boolean;\n\n    [name: string]: any;\n}\n\n/**\n * Technique used to render a terrain geometry with a texture.\n * When using this technique, the datasource will produce texture coordinates in\n * local tile space (i.e. [0,0] at south-west and [1,1] at north-east tile corner).\n */\nexport interface TerrainTechniqueParams extends StandardTechniqueParams {\n    /**\n     * Colors to be applied at different heights (as a results of a `displacementMap`).\n     */\n    heightBasedColors?: HeightBasedColors;\n\n    /**\n     * If `heightBasedColors` is defined, this value defines the interpolation method used to\n     * generate the height-based gradient texture (defaults to `Discrete`).\n     */\n    heightGradientInterpolation?: \"Discrete\" | \"Linear\" | \"Cubic\";\n\n    /**\n     * If `heightBasedColors` is defined, this value defines the width (in pixels) of the generated\n     * gradient texture (defaults to `128`).\n     */\n    heightGradientWidth?: number;\n}\n\n/**\n * Render geometry as a text.\n */\nexport interface TextTechniqueParams extends BaseTechniqueParams {\n    /**\n     * Text to be displayed for feature.\n     *\n     * Defaults to first defined:\n     *  - feature property `label` if present in technique (depreacted);\n     *  - `[\"get\", \"name:short\"]` is `useAbbreviation` is true;\n     *  - `[\"get\", \"iso_code\"]` is `useIsoCode` is true;\n     *  - `[\"get\", \"name:$LANGUAGE\"]` for each specified language;\n     *  - `[\"get\", \"name\"]`.\n     *\n     * See [[ExtendedTileInfo.getFeatureText]].\n     */\n    text?: DynamicProperty<string>;\n\n    /**\n     * Field name of object containing the text to be rendered.\n     *\n     * @deprecated Use `[\"get\", \"FIELD\"]`.\n     */\n    label?: string;\n    /**\n     * If `true`, the abbreviation (field `name:short`) of the elements is used as text.\n     *\n     * @deprecated Use proper expression with [`get`, `name:short`] for this purpose.\n     */\n    useAbbreviation?: boolean;\n    /**\n     * If `true`, the iso code (field 'iso_code') of the elements is used as text.\n     * The `iso_code` field contains the ISO 3166-1 2-letter country code.\n     *\n     * @deprecated Use proper expression with [`get`, `iso_code`] for this purpose.\n     */\n    useIsoCode?: boolean;\n    /**\n     * Priority of text, defaults to `0`. Elements with highest priority get placed first.\n     */\n    priority?: DynamicProperty<number>;\n    /**\n     * Minimal zoom level. If the current zoom level is smaller, the technique will not be used.\n     */\n    minZoomLevel?: number;\n    /**\n     * Maximum zoom level. If the current zoom level is larger, the technique will not be used.\n     */\n    maxZoomLevel?: number;\n    /**\n     * Scaling factor of the text. Defaults to 0.5, reducing the size ot 50% in the distance.\n     */\n    distanceScale?: number;\n    /**\n     * If `true`, icon is allowed to overlap other labels or icons of lower priority.\n     * @default `false`\n     */\n    mayOverlap?: boolean;\n    /**\n     * If `true`, element will reserve screen space, other markers of lower priority will not be\n     * able to overlap.\n     * @default `true`\n     */\n    reserveSpace?: boolean;\n    /**\n     * Fading time for labels in seconds.\n     */\n    textFadeTime?: number;\n    /**\n     * Horizontal offset (to the right) in screen pixels.\n     */\n    xOffset?: number;\n    /**\n     * Vertical offset (up) in screen pixels.\n     */\n    yOffset?: number;\n    /**\n     * Name of the text style.\n     */\n    style?: string;\n    /**\n     * Name of the preferred [[Font]] to be used when rendering.\n     */\n    fontName?: string;\n    /**\n     * Size of the text (pixels).\n     */\n    size?: DynamicProperty<number>;\n    /**\n     * Size of the text background (pixels).\n     */\n    backgroundSize?: DynamicProperty<number>;\n    /**\n     * Glyph style to apply for the currently active [[Font]].\n     */\n    fontStyle?: \"Regular\" | \"Bold\" | \"Italic\" | \"BoldItalic\";\n    /**\n     * Glyph variant to apply for the currently active [[Font]].\n     */\n    fontVariant?: \"Regular\" | \"AllCaps\" | \"SmallCaps\";\n    /**\n     * Glyph local rotation (radians).\n     */\n    rotation?: number;\n    /**\n     * Text color in hexadecimal or CSS-style notation, for example: `\"#e4e9ec\"`, `\"#fff\"`,\n     * `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    color?: DynamicProperty<StyleColor>;\n    /**\n     * Text background color in hexadecimal or CSS-style notation, for example: `\"#e4e9ec\"`,\n     * `\"#fff\"`, `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    backgroundColor?: DynamicProperty<StyleColor>;\n    /**\n     * For transparent text, set a value between 0.0 for totally transparent, to 1.0 for totally\n     * opaque.\n     */\n    opacity?: DynamicProperty<number>;\n    /**\n     * Background text opacity value.\n     */\n    backgroundOpacity?: DynamicProperty<number>;\n    /**\n     * Inter-glyph spacing (pixels). Scaled by `size`.\n     */\n    tracking?: DynamicProperty<number>;\n    /**\n     * Inter-line spacing (pixels). Scaled by `size`.\n     */\n    leading?: DynamicProperty<number>;\n    /**\n     * Maximum number of lines for this label.\n     */\n    maxLines?: DynamicProperty<number>;\n    /**\n     * Maximum line width (pixels).\n     */\n    lineWidth?: DynamicProperty<number>;\n    /**\n     * [[TextCanvas]] rotation (radians).\n     */\n    canvasRotation?: DynamicProperty<number>;\n    /**\n     * Line typesetting rotation (radians).\n     */\n    lineRotation?: DynamicProperty<number>;\n    /**\n     * Wrapping (line-breaking) mode.\n     */\n    wrappingMode?: DynamicProperty<\"None\" | \"Character\" | \"Word\">;\n    /**\n     * Text position regarding the baseline.\n     */\n    hAlignment?: DynamicProperty<\"Left\" | \"Center\" | \"Right\">;\n    /**\n     * Text position inside a line.\n     */\n    vAlignment?: DynamicProperty<\"Above\" | \"Center\" | \"Below\">;\n}\n\n/**\n * Buffer holding a texture.\n */\nexport interface TextureBuffer {\n    /**\n     * Buffer containing the (compressed) image or the raw texture data.\n     */\n    buffer: ArrayBuffer;\n\n    /**\n     * Mime type of the image or 'image/raw' in case of raw texture data.\n     */\n    type: string;\n\n    /**\n     * Properties for creating a three.js DataTexture\n     * (https://threejs.org/docs/#api/en/textures/DataTexture).\n     */\n    dataTextureProperties?: DataTextureProperties;\n}\n\n/**\n * Type guard to check if an object is an instance of `TextureBuffer`.\n */\nexport function isTextureBuffer(object: any): object is TextureBuffer {\n    return object && object.buffer && typeof object.type === \"string\";\n}\n\n/**\n * Properties of a DataTexture (https://threejs.org/docs/#api/en/textures/DataTexture).\n */\nexport interface DataTextureProperties {\n    width: number;\n    height: number;\n\n    format?: PixelFormat;\n    type?: TextureDataType;\n}\n\n/**\n * Properties of a Texture (https://threejs.org/docs/#api/en/textures/Texture).\n */\nexport interface TextureProperties {\n    /**\n     * Texture horizontal wrapping mode.\n     * See: https://threejs.org/docs/#api/en/textures/Texture.wrapS.\n     */\n    wrapS?: WrappingMode;\n\n    /**\n     * Texture vertical wrapping mode.\n     * See: https://threejs.org/docs/#api/en/textures/Texture.wrapT.\n     */\n    wrapT?: WrappingMode;\n\n    /**\n     * Texture magnification filter.\n     */\n    magFilter?: MagFilter;\n\n    /**\n     * Texture minification filter.\n     */\n    minFilter?: MinFilter;\n\n    /**\n     * Flip texture vertically.\n     * See: https://threejs.org/docs/#api/en/textures/Texture.flipY.\n     */\n    flipY?: boolean;\n\n    /**\n     * Texture horizontal repetition rate.\n     * See: https://threejs.org/docs/#api/en/textures/Texture.repeat.\n     */\n    repeatU?: number;\n\n    /**\n     * Texture vertical repetition rate.\n     * See: https://threejs.org/docs/#api/en/textures/Texture.repeat.\n     */\n    repeatV?: number;\n}\n\n/**\n * Interface containing the definition of different colors to be used at different heights with the\n * [[TerrainTechnique]].\n */\nexport interface HeightBasedColors {\n    heightArray: number[];\n    colorArray: string[];\n}\n\nexport type PixelFormat =\n    | \"Alpha\"\n    | \"RGB\"\n    | \"RGBA\"\n    | \"Luminance\"\n    | \"LuminanceAlpha\"\n    | \"RGBE\"\n    | \"Depth\"\n    | \"DepthStencil\"\n    | \"Red\";\n\nexport type TextureDataType =\n    | \"UnsignedByte\"\n    | \"Byte\"\n    | \"Short\"\n    | \"UnsignedShort\"\n    | \"Int\"\n    | \"UnsignedInt\"\n    | \"Float\"\n    | \"HalfFloat\";\n\n/**\n * Available texture wrapping modes.\n */\nexport type WrappingMode = \"clamp\" | \"repeat\" | \"mirror\";\n\n/**\n * Available texture magnification filters.\n */\nexport type MagFilter = \"nearest\" | \"linear\";\n\n/**\n * Available texture minification filters.\n */\nexport type MinFilter =\n    | \"nearest\"\n    | \"nearestMipMapNearest\"\n    | \"nearestMipMapLinear\"\n    | \"linear\"\n    | \"linearMipMapNearest\"\n    | \"linearMipMapLinear\";\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Technique } from \"./Techniques\";\n\nexport enum AttrScope {\n    /**\n     * Attributes that affect generation of feature geometry and thus must be resolved at decoding\n     * time.\n     *\n     * They may have huge variancy as they are implemented as vertex attributes or embedded in\n     * generated meshes.\n     *\n     * These attributes are available only in decoding scope.\n     */\n    FeatureGeometry,\n\n    /**\n     * Attributes that are common to whole group of features drawn with this technique.\n     * These attributes affect generated geometry and  thus must be resolved at decoding time.\n     *\n     * They shouldn't have big variancy and evaluate to at least dozens of values as each\n     * combination of these attributes consitute new technique and material.\n     *\n     * These attributes are available in decoding and rendering scope.\n     */\n    TechniqueGeometry,\n\n    /**\n     * Attributes that are common to whole group of features drawn with this technique.\n     * Attributes that can be changed in resulting object/material from frame to frame. They are\n     * usually implemented as uniforms.\n     *\n     * These attributes may be available only at rendering scope.\n     */\n    TechniqueRendering\n}\n\n/**\n * Extract  property names from [[Technique]]-like interface (excluding `name`) as union of string\n * literals.\n *\n * TechniquePropName<Base\n *\n */\nexport type TechniquePropNames<T> = T extends { name: any } ? keyof Omit<T, \"name\"> : keyof T;\n\nexport type TechniquePropScopes<T> = {\n    [P in TechniquePropNames<T>]?: AttrScope;\n};\n\nexport interface TechniqueDescriptor<T> {\n    attrTransparencyColor?: string;\n    attrScopes: TechniquePropScopes<T>;\n}\n\ntype OneThatMatches<T, P> = T extends P ? T : never;\ntype TechniqueByName<K extends Technique[\"name\"]> = OneThatMatches<Technique, { name: K }>;\n\nexport type TechniqueDescriptorRegistry = {\n    [P in Technique[\"name\"]]?: TechniqueDescriptor<TechniqueByName<P>>;\n};\n\nexport function mergeTechniqueDescriptor<T>(\n    ...descriptors: Array<Partial<TechniqueDescriptor<T>>>\n): TechniqueDescriptor<T> {\n    const result: TechniqueDescriptor<T> = {\n        attrScopes: {}\n    };\n    for (const descriptor of descriptors) {\n        if (descriptor.attrTransparencyColor !== undefined) {\n            result.attrTransparencyColor = descriptor.attrTransparencyColor;\n        }\n        if (descriptor.attrScopes !== undefined) {\n            result.attrScopes = { ...result.attrScopes, ...descriptor.attrScopes };\n        }\n    }\n    return result;\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { LoggerManager } from \"@here/harp-utils\";\nimport { Env } from \"./Env\";\nimport { Expr, ExprScope, Value } from \"./Expr\";\nimport { Pixels } from \"./Pixels\";\nimport { RGBA } from \"./RGBA\";\nimport { parseStringEncodedNumeral } from \"./StringEncodedNumeral\";\n\nconst logger = LoggerManager.instance.create(\"PropertyValue\");\n\n/**\n * Get the value of the specified property in given `env`.\n *\n * @param property - Property of a technique.\n * @param env - The {@link Env} used to evaluate the property\n * @param cache - An optional expression cache.\n */\nexport function getPropertyValue(\n    property: Value | undefined,\n    env: Env,\n    cache?: Map<Expr, Value>\n): any {\n    if (Expr.isExpr(property)) {\n        try {\n            let r = property.evaluate(env, ExprScope.Dynamic, cache);\n\n            if (typeof r === \"string\") {\n                r = RGBA.parse(r) ?? Pixels.parse(r) ?? r;\n            }\n\n            if (r instanceof RGBA) {\n                return r.getHex();\n            } else if (r instanceof Pixels) {\n                return r.value * (Number(env.lookup(\"$pixelToMeters\")) ?? 1);\n            }\n            return r;\n        } catch (error) {\n            logger.error(\n                \"failed to evaluate expression\",\n                JSON.stringify(property),\n                \"error\",\n                String(error)\n            );\n            return null;\n        }\n    }\n\n    if (property === null || typeof property === \"undefined\") {\n        return null;\n    } else if (typeof property !== \"string\") {\n        // Property in numeric or array, etc. format\n        return property;\n    } else {\n        // Non-interpolated string encoded numeral parsing\n        const pixelToMeters = (env.lookup(\"$pixelToMeters\") as number) || 1;\n        const value = parseStringEncodedNumeral(property, pixelToMeters);\n        return value !== undefined ? value : property;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    equirectangularProjection,\n    mercatorProjection,\n    normalizedEquirectangularProjection,\n    OrientedBox3,\n    Projection,\n    sphereProjection,\n    Vector3Like,\n    webMercatorProjection\n} from \"@here/harp-geoutils\";\nimport { Env } from \"./Expr\";\nimport { AttrEvaluationContext, evaluateTechniqueAttr } from \"./TechniqueAttr\";\nimport {\n    IndexedTechnique,\n    isLineMarkerTechnique,\n    isPoiTechnique,\n    isTextTechnique,\n    Technique\n} from \"./Techniques\";\nimport { TileInfo } from \"./TileInfo\";\n\n/**\n * This object has geometry data in the form of geometries buffers ready to be used by WebGL.\n * These geometries are not `three.js` objects. They are pure data stored as `ArrayBuffer`s and\n * metadata describing these buffers.\n */\nexport interface DecodedTile {\n    techniques: IndexedTechnique[];\n    geometries: Geometry[];\n    pathGeometries?: PathGeometry[];\n    textPathGeometries?: TextPathGeometry[];\n    textGeometries?: TextGeometry[]; // ### deprecate\n    poiGeometries?: PoiGeometry[];\n    tileInfo?: TileInfo;\n    decodeTime?: number; // time used to decode (in ms)\n\n    /**\n     * The default bounding box in [[Tile]] is based on the geo box of the tile.\n     * For data-sources that have 3d data this is not sufficient so the data-source can provide a\n     * more accurate bounding box once the data is decoded.\n     */\n    boundingBox?: OrientedBox3;\n\n    /**\n     * Data sources not defining a bounding box may define alternatively a maximum geometry height\n     * in meters. The bounding box of the resulting tile will be extended to encompass this height.\n     */\n    maxGeometryHeight?: number;\n\n    /**\n     * Tile data Copyright holder identifiers.\n     *\n     * `id`s should be unique. It is recommended to build them from unique identifiers like\n     * registered domain names.\n     *\n     * @see [[CopyrightInfo]]\n     */\n    copyrightHolderIds?: string[];\n}\n\n/**\n * This object keeps the path of the geometry. Space of the path depends on the\n * use case, so could be either world or local tile space.\n */\nexport interface PathGeometry {\n    path: Vector3Like[];\n}\n\n/**\n * Attributes corresponding to some decoded geometry. It may be either a map\n * of multiple attributes or just a number with the geometry's feature id.\n */\nexport type AttributeMap = {} | number;\n\n/**\n * This object keeps textual data together with metadata to place it on the map.\n */\nexport interface TextPathGeometry {\n    path: number[];\n    pathLengthSqr: number;\n    text: string;\n    technique: number;\n    objInfos?: AttributeMap;\n}\n\n/**\n * Returns an array with the data type specified as parameter.\n *\n * @param attr - specifies which type of data is being stored in the array\n */\nexport function getArrayConstructor(attr: BufferElementType) {\n    switch (attr) {\n        case \"float\":\n            return Float32Array;\n        case \"uint8\":\n            return Uint8Array;\n        case \"uint16\":\n            return Uint16Array;\n        case \"uint32\":\n            return Uint32Array;\n        case \"int8\":\n            return Int8Array;\n        case \"int16\":\n            return Int16Array;\n        case \"int32\":\n            return Int32Array;\n    }\n}\n\n/**\n * Structured clone compliant WebGL interleaved buffer with its metadata attached.\n */\nexport interface InterleavedBufferAttribute {\n    buffer: ArrayBufferLike;\n    stride: number;\n    type: BufferElementType;\n    attributes: Array<{\n        name: string;\n        itemSize: number;\n        offset: number;\n    }>;\n}\n\n/**\n * Geometry types supported by [[Geometry]] objects.\n */\nexport enum GeometryType {\n    Unspecified = 0,\n    Point,\n    Line,\n    SolidLine,\n    Text,\n    TextPath,\n    ExtrudedLine,\n    Polygon,\n    ExtrudedPolygon,\n    Object3D,\n    Other = 1000\n}\n\n/**\n * Structured clone compliant version of a `three.js` geometry object, consisting of buffers with\n * metadata for map features and objects for example roads, trees or parks.\n */\nexport interface Geometry {\n    type: GeometryType;\n    vertexAttributes?: BufferAttribute[];\n    interleavedVertexAttributes?: InterleavedBufferAttribute[];\n    index?: BufferAttribute;\n    edgeIndex?: BufferAttribute;\n    groups: Group[];\n    uuid?: string;\n\n    /**\n     * Optional sorted list of feature start indices. The indices point into the index attribute.\n     * Feature i starts at featureStarts[i] and ends at featureStarts[i+1]-1, except for the last\n     * feature, which ends at index[index.length-1].\n     */\n    featureStarts?: number[];\n\n    /**\n     * Optional array of objects. It can be used to pass user data from the geometry to the mesh.\n     */\n    objInfos?: AttributeMap[];\n\n    /**\n     * Optional [[Array]] of [[Attachment]]s.\n     */\n    attachments?: Attachment[];\n}\n\n/**\n * Attachments together with [[Geometry]] define the meshes and the objects\n * of a [[Scene]].\n */\nexport interface Attachment {\n    /**\n     * The unique uuid of this [[Attachment]].\n     */\n    uuid?: string;\n\n    /**\n     * The name of this [[Attachment]].\n     */\n    name?: string;\n\n    /**\n     * The index [[BufferAttribute]]. If not provided the index\n     * buffer of the [[Geometry]] will be used.\n     */\n    index?: BufferAttribute;\n\n    /**\n     * Optional additional buffer index used to create an edge object.\n     */\n    edgeIndex?: BufferAttribute;\n\n    /**\n     * The draw [[Group]]]s of this [[Attachment]].\n     */\n    groups: Group[];\n}\n\n/**\n * The data stored in Buffers' elements can be of the following elementary types: float, signed or\n * unsigned integers (8-bit, 16-bit or 32-bit long).\n */\nexport type BufferElementType =\n    | \"float\"\n    | \"uint8\"\n    | \"uint16\"\n    | \"uint32\"\n    | \"int8\"\n    | \"int16\"\n    | \"int32\";\n\n/**\n * Structured clone compliant WebGL buffer and its metadata.\n */\nexport interface BufferAttribute {\n    name: string;\n    buffer: ArrayBufferLike;\n    type: BufferElementType;\n    itemCount: number;\n    normalized?: boolean;\n}\n\n/**\n * Structured clone compliant version of a `three.js` geometry object with text to be rendered.\n * It is composed of buffers with metadata for text objects.\n */\nexport interface TextGeometry {\n    positions: BufferAttribute;\n    texts: number[];\n    technique?: number;\n    stringCatalog?: Array<string | undefined>;\n    objInfos?: AttributeMap[];\n}\n\n/**\n * Structured clone compliant version of a `three.js` geometry object with points of interest (POIs)\n * to be rendered. It is composed of buffers with metadata for POI objects.\n */\nexport interface PoiGeometry {\n    positions: BufferAttribute;\n    texts: number[];\n    /**\n     * Names of the image texture or the name of the POI as indices into the array `stringCatalog`.\n     */\n    imageTextures?: number[];\n    technique?: number;\n    stringCatalog?: Array<string | undefined>;\n    objInfos?: AttributeMap[];\n    // Angle in degrees from north clockwise specifying the directions the icons can be shifted.\n    offsetDirections?: number[];\n}\n\n/**\n * Structured clone compliant WebGL group object and its metadata.\n * Its purpose is to make working with groups of objects easier.\n */\nexport interface Group {\n    start: number;\n    count: number;\n    technique: number;\n\n    /**\n     * Contains tile offsets if its [[Geometry]] has been created.\n     */\n    createdOffsets?: number[];\n}\n\n/**\n * Returns the projection object specified in the parameter.\n *\n * @param projectionName - string describing projection to be used\n */\nexport function getProjection(projectionName: string): Projection | never {\n    switch (projectionName) {\n        case \"mercator\":\n            return mercatorProjection;\n        case \"webMercator\":\n            return webMercatorProjection;\n        case \"sphere\":\n            return sphereProjection;\n        case \"normalizedEquirectangular\":\n            return normalizedEquirectangularProjection;\n        case \"equirectangular\":\n            return equirectangularProjection;\n        default:\n            throw new Error(`Unknown projection ${projectionName}`);\n    } // switch\n}\n\n/**\n * String with the projection's name.\n *\n * @param projection - `Projection` object containing the name of the projection to retrieve\n */\nexport function getProjectionName(projection: Projection): string | never {\n    if (projection === mercatorProjection) {\n        return \"mercator\";\n    } else if (projection === webMercatorProjection) {\n        return \"webMercator\";\n    } else if (projection === sphereProjection) {\n        return \"sphere\";\n    } else if (projection === normalizedEquirectangularProjection) {\n        return \"normalizedEquirectangular\";\n    } else if (projection === equirectangularProjection) {\n        return \"equirectangular\";\n    }\n    throw new Error(\"Unknown projection\");\n}\n\n/**\n * @returns Feature id from the provided attribute map.\n */\nexport function getFeatureId(attributeMap: AttributeMap | undefined): number {\n    if (attributeMap === undefined) {\n        return 0;\n    }\n\n    if (typeof attributeMap === \"number\") {\n        return attributeMap;\n    }\n\n    if (attributeMap.hasOwnProperty(\"$id\")) {\n        return (attributeMap as any).$id as number;\n    }\n\n    return 0;\n}\n\n/**\n * Determine the name of (OMV) feature. It implements the special handling required\n * to determine the text content of a feature from its tags, which are passed in as the `env`.\n *\n * @param env - Environment containing the tags from the (OMV) feature.\n * @param useAbbreviation - `true` to use the abbreviation if available.\n * @param useIsoCode - `true` to use the tag \"iso_code\".\n * @param languages - List of languages to use, for example: Specify \"en\" to use the tag \"name_en\"\n *                  as the text of the string. Order reflects priority.\n */\nexport function getFeatureName(\n    env: Env,\n    basePropName: string | undefined,\n    useAbbreviation?: boolean,\n    useIsoCode?: boolean,\n    languages?: string[]\n): string | undefined {\n    let name;\n    if (basePropName === undefined) {\n        basePropName = \"name\";\n    }\n    if (useAbbreviation) {\n        const abbreviation = env.lookup(`${basePropName}:short`);\n        if (typeof abbreviation === \"string\" && abbreviation.length > 0) {\n            return abbreviation;\n        }\n    }\n    if (useIsoCode) {\n        const isoCode = env.lookup(`iso_code`);\n        if (typeof isoCode === \"string\" && isoCode.length > 0) {\n            return isoCode;\n        }\n    }\n    if (languages !== undefined) {\n        for (const lang of languages) {\n            name = env.lookup(`${basePropName}:${lang}`) || env.lookup(`${basePropName}_${lang}`);\n            if (typeof name === \"string\" && name.length > 0) {\n                return name;\n            }\n        }\n    }\n    name = env.lookup(basePropName);\n    if (typeof name === \"string\") {\n        return name;\n    }\n    return undefined;\n}\n\n/**\n * Determine the text string of the map feature. It implements the special handling required\n * to determine the text content of a feature from its tags, which are passed in as the `env`.\n *\n * @param feature - Feature, including properties from the (OMV) feature.\n * @param technique - technique defining how text should be created from feature\n * @param languages - List of languages to use, for example: Specify \"en\" to use the tag \"name_en\"\n *                  as the text of the string. Order reflects priority.\n */\nexport function getFeatureText(\n    context: Env | AttrEvaluationContext,\n    technique: Technique,\n    languages?: string[]\n): string | undefined {\n    let useAbbreviation: boolean | undefined;\n    let useIsoCode: boolean | undefined;\n    const env = context instanceof Env ? context : context.env;\n    let propName: string = \"name\";\n    if (\n        isTextTechnique(technique) ||\n        isPoiTechnique(technique) ||\n        isLineMarkerTechnique(technique)\n    ) {\n        if (technique.text !== undefined) {\n            return evaluateTechniqueAttr(context, technique.text);\n        }\n        // tslint:disable-next-line: deprecation\n        if (technique.label !== undefined) {\n            // tslint:disable-next-line: deprecation\n            propName = evaluateTechniqueAttr(context, technique.label)!;\n            if (typeof propName !== \"string\") {\n                return undefined;\n            }\n        }\n        // tslint:disable-next-line: deprecation\n        useAbbreviation = technique.useAbbreviation;\n        // tslint:disable-next-line: deprecation\n        useIsoCode = technique.useIsoCode;\n    }\n\n    return getFeatureName(env, propName, useAbbreviation, useIsoCode, languages);\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport * as THREE from \"three\";\n\n/**\n * The base shader to use for {@link @here/harp-mapview#MapView}'s\n * composing passes, like {@link MSAAMaterial}.\n */\nexport const CopyShader: THREE.Shader = {\n    uniforms: {\n        tDiffuse: { value: null },\n        opacity: { value: 1.0 }\n    },\n    vertexShader: `\n    varying vec2 vUv;\n    void main() {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }`,\n    fragmentShader: `\n    uniform float opacity;\n    uniform sampler2D tDiffuse;\n    varying vec2 vUv;\n    void main() {\n        vec4 texel = texture2D( tDiffuse, vUv );\n        gl_FragColor = opacity * texel;\n    }`\n};\n\n/**\n * The material is used for composing.\n */\nexport class CopyMaterial extends THREE.ShaderMaterial {\n    /**\n     * The constructor of `CopyMaterial`.\n     *\n     * @param uniforms - The [[CopyShader]]'s uniforms.\n     */\n    constructor(uniforms: { [uniformName: string]: THREE.IUniform }) {\n        super({\n            name: \"CopyMaterial\",\n            uniforms,\n            vertexShader: CopyShader.vertexShader,\n            fragmentShader: CopyShader.fragmentShader,\n            premultipliedAlpha: true,\n            transparent: false,\n            blending: THREE.NoBlending,\n            depthTest: false,\n            depthWrite: false\n        });\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport default {\n    atmosphere_common_utils: `\n\n    float conditionalBranchFree(bool condition, float primary, float secondary) {\n        // Interpolate between primary and secondary:\n        // result = secondary * (1 - factor) + primary * factor\n        // where:\n        // factor = float(condition)\n        return mix(secondary, primary, float(condition));\n    }\n\n    vec3 conditionalBranchFree(bool condition, vec3 primary, vec3 secondary) {\n        return mix(secondary, primary, float(condition));\n    }\n    `,\n    atmosphere_vertex_utils: `\n\n    const float RayleighScaleDepth = 0.25;\n\n    struct AtmosphereColor\n    {\n        vec3 mie;\n        vec3 rayleigh;\n    };\n\n    float scale(float cosAngle)\n    {\n        float x = 1.0 - cosAngle;\n        return RayleighScaleDepth  * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n    }\n\n    float getNearSphereIntersect(vec3 v3Pos, vec3 v3Ray, float fCameraHeight2, float fOuterRadius2) {\n        // Solve simple square equation for the x0 (first point of intersection).\n#if defined(IMPROVE_INTERSECT_PRECISION)\n        // To improve precision instead of simple projection: b = 2.0 * dot(vPos, v3Ray),\n        // we change the equation that gives better results especially around the poles.\n        float fB = 2.0 * length(v3Pos) * dot(normalize(v3Pos), v3Ray);\n#else\n        float fB = 2.0 * dot(v3Pos, v3Ray);\n#endif\n        float fC = fCameraHeight2 - fOuterRadius2;\n        // det = b^2 - 4*a*c, where a = 1\n        float fDet = max(0.0, fB * fB - 4.0 * fC);\n        // Intersection points distances are defined as follows:\n        // x0 = (-b - sqrt(det)) / 2*a ^ x1 = (-b + sqrt(det)) / 2*a\n        // we search for x0:\n        return 0.5 * (-fB - sqrt(fDet));\n    }\n\n    float getFarSphereIntersect(vec3 v3Pos, vec3 v3Ray, float fCameraHeight2, float fOuterRadius2) {\n        // Solve simple square equation for the x1 (second point of intersection).\n#if defined(IMPROVE_INTERSECT_PRECISION)\n        float fB = 2.0 * length(v3Pos) * dot(normalize(v3Pos), v3Ray);\n#else\n        float fB = 2.0 * dot(v3Pos, v3Ray);\n#endif\n        float fC = fCameraHeight2 - fOuterRadius2;\n        // det = b^2 - 4*a*c, where a = 1\n        float fDet = max(0.0, fB * fB - 4.0 * fC);\n        // Compute second intersection distance:\n        // x1 = (-b + sqrt(det)) / 2*a\n        return 0.5 * (-fB + sqrt(fDet));\n    }\n    `,\n    atmosphere_fragment_utils: `\n\n    // Branch free RGB to HSV conversion.\n    // Based on article:\n    // http://lolengine.net/blog/2013/01/13/fast-rgb-to-hsv\n    // and optimized OpenGL SL algorithm\n    // http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n    vec3 rgb2Hsv(vec3 c)\n    {\n        const vec4 RGB_HSV_CONV = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n        // Ternary operator may be used explicitly if compiler can use fast conditional move.\n        // vec4 p = c.g < c.b ? vec4(c.bg, RGB_HSV_CONV.wz) : vec4(c.gb, RGB_HSV_CONV.xy);\n        vec4 p = mix(vec4(c.bg, RGB_HSV_CONV.wz), vec4(c.gb, RGB_HSV_CONV.xy), step(c.b, c.g));\n        // vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n        vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n        float d = q.x - min(q.w, q.y);\n        float e = 1.0e-10;\n        return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n    }\n\n    // Branch free HSV to RGB conversion\n    vec3 hsv2Rgb(vec3 c)\n    {\n        const vec4 HSV_RGB_CONV = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n        vec3 p = abs(fract(c.xxx + HSV_RGB_CONV.xyz) * 6.0 - HSV_RGB_CONV.www);\n        return c.z * mix(HSV_RGB_CONV.xxx, clamp(p - HSV_RGB_CONV.xxx, 0.0, 1.0), c.y);\n    }\n\n    vec3 correctExposure(vec3 rgb, float exposure)\n    {\n        const vec3 fullColor = vec3(1.0);\n        return fullColor - exp(-exposure * rgb);\n    }\n\n    vec3 correctColor(vec3 rgb, vec3 hsvShift)\n    {\n        const float e = 0.0000001;\n        // Convert rgb color to hsv\n        vec3 hsv = rgb2Hsv(rgb);\n        // Shift hue value with angle wrapping\n        hsv.x = mod(hsv.x + hsvShift.x, 1.0);\n        // Shift and clamp saturation\n        hsv.y = clamp(hsv.y + hsvShift.y, 0.0, 1.0);\n        // Change value if it is significant (greater then epsilon)\n        hsv.z = hsv.z > e ? clamp(hsv.z + hsvShift.z, 0.0, 1.0) : 0.0;\n        // Convert shifted hsv back to rgb\n        return hsv2Rgb(hsv);\n    }\n    `\n};\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Vector3 } from \"three\";\n\nimport { MapView } from \"./MapView\";\nimport { MapViewUtils } from \"./Utils\";\n\n/**\n * The default value for camera movement throttling, in milliseconds.\n */\nconst DEFAULT_THROTTLING_TIMEOUT = 300;\n\n/**\n * The `CameraMovementDetector` class checks for changes in camera position and orientation, to\n * detect continuous movements without the animation mode activated in {@link MapView}. If the\n * interaction is not continuous enough, you can use a throttling timer to reduce the number of\n * callbacks.\n */\nexport class CameraMovementDetector {\n    private m_lastAttitude?: MapViewUtils.Attitude;\n    private m_lastCameraPos = new Vector3();\n    private m_newCameraPos = new Vector3();\n    private m_cameraMovedLastFrame: boolean | undefined;\n    private m_throttlingTimerId?: number = undefined;\n    private m_movementDetectorDeadline: number = 0;\n\n    /**\n     * Initializes the detector with timeout value and callbacks. {@link MapView} also provides\n     * events for client code to be notified when these cues occur.\n     *\n     * @param m_throttlingTimeout - The delay, in milliseconds, between the last user interaction\n     * detected and the call to `m_movementFinishedFunc`; the default is `300`.\n     * @param m_movementStartedFunc - Callback function, called when the user starts interacting.\n     * @param m_movementFinishedFunc - Callback function, called when the user stops interacting.\n     */\n    constructor(\n        private m_throttlingTimeout: number | undefined,\n        private m_movementStartedFunc: (() => void) | undefined,\n        private m_movementFinishedFunc: (() => void) | undefined\n    ) {\n        if (this.m_throttlingTimeout === undefined) {\n            this.m_throttlingTimeout = DEFAULT_THROTTLING_TIMEOUT;\n        }\n    }\n\n    /**\n     * Checks if the camera has moved since the last time it was checked. The\n     * `m_movementStartedFunc` is called when a movement starts. If no movement\n     * is detected, a timer for `m_movementFinishedFunc` starts.\n     *\n     * @param mapView - [[Mapview]]'s position and camera are checked for modifications.\n     */\n    checkCameraMoved(mapView: MapView, now: number): boolean {\n        const newAttitude = MapViewUtils.extractAttitude(mapView, mapView.camera);\n        const newCameraPos = mapView.camera.getWorldPosition(this.m_newCameraPos);\n\n        if (this.m_lastAttitude === undefined) {\n            this.m_lastCameraPos.copy(newCameraPos);\n            this.m_lastAttitude = newAttitude;\n            return false;\n        }\n        const cameraMoved =\n            !this.m_lastCameraPos.equals(newCameraPos) ||\n            newAttitude.yaw !== this.m_lastAttitude.yaw ||\n            newAttitude.pitch !== this.m_lastAttitude.pitch ||\n            newAttitude.roll !== this.m_lastAttitude.roll;\n\n        if (cameraMoved) {\n            this.m_lastCameraPos.copy(newCameraPos);\n            this.m_lastAttitude = newAttitude;\n        }\n\n        if (cameraMoved !== this.m_cameraMovedLastFrame) {\n            if (cameraMoved) {\n                this.movementStarted();\n            }\n            this.m_cameraMovedLastFrame = cameraMoved;\n        }\n        if (cameraMoved) {\n            // Start timer\n            this.m_movementDetectorDeadline = now + this.m_throttlingTimeout!;\n            this.startMovementFinishedTimer(now);\n        }\n\n        return this.m_cameraMovedLastFrame;\n    }\n\n    /**\n     * Reset the saved camera position. Next time checkCameraMoved is called, it will return\n     * `false`.\n     */\n    clear(mapView: MapView) {\n        const newCameraPos = mapView.camera.getWorldPosition(this.m_newCameraPos);\n        this.m_lastCameraPos.set(newCameraPos.x, newCameraPos.y, newCameraPos.z);\n\n        const newAttitude = MapViewUtils.extractAttitude(mapView, mapView.camera);\n        this.m_lastAttitude = newAttitude;\n    }\n\n    /**\n     * Force change of camera position. Next time checkCameraMoved is called, it will return `true`.\n     */\n    forceMoved() {\n        this.m_lastCameraPos.set(Number.NaN, Number.NaN, Number.NaN);\n    }\n\n    /**\n     * Returns `true` if the camera of this {@link MapView} is currently moving. In this case the\n     * `m_movementFinishedFunc` is waiting to be called after the throttling timer runs out.\n     */\n    get cameraIsMoving() {\n        return this.m_throttlingTimerId !== undefined;\n    }\n\n    /**\n     * Disposes resources and kills the throttling timer.\n     */\n    dispose() {\n        this.removeMovementFinishedTimer();\n        this.m_movementStartedFunc = undefined;\n        this.m_movementFinishedFunc = undefined;\n    }\n\n    /**\n     * Returns `true` if the camera has moved in the last frame.\n     */\n    get cameraMovedLastFrame(): boolean {\n        return this.m_cameraMovedLastFrame === true;\n    }\n\n    private movementStarted() {\n        if (this.m_movementStartedFunc !== undefined) {\n            this.m_movementStartedFunc();\n        }\n    }\n\n    private movementFinished() {\n        this.removeMovementFinishedTimer();\n        if (this.m_movementFinishedFunc !== undefined) {\n            this.m_movementFinishedFunc();\n        }\n    }\n\n    private startMovementFinishedTimer(now: number) {\n        if (this.m_throttlingTimerId === undefined) {\n            const remainingTime = Math.max(0, this.m_movementDetectorDeadline - now);\n            this.m_throttlingTimerId = setTimeout(this.onDeadlineTimer, remainingTime) as any;\n        }\n    }\n\n    private onDeadlineTimer = () => {\n        this.m_throttlingTimerId = undefined;\n        const now = performance.now();\n        if (now >= this.m_movementDetectorDeadline) {\n            this.movementFinished();\n        } else {\n            this.startMovementFinishedTimer(now);\n        }\n    };\n\n    private removeMovementFinishedTimer() {\n        if (this.m_throttlingTimerId !== undefined) {\n            clearTimeout(this.m_throttlingTimerId);\n            this.m_throttlingTimerId = undefined;\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\n/**\n * A mesh that can store multiple versions of a geometry with differents level of detail.\n * The rendered level of detail can be adapted during runtime.\n * @internal\n * @hidden\n */\nexport class LodMesh extends THREE.Mesh {\n    private m_geometries: Array<THREE.Geometry | THREE.BufferGeometry> | undefined;\n\n    /**\n     * Creates a [[LodMesh]] with given geometries and materials\n     * @param geometries - A list of geometries with different levels of detail\n     * @param material - Material for the mesh\n     */\n    constructor(\n        geometries?: Array<THREE.Geometry | THREE.BufferGeometry>,\n        material?: THREE.Material | THREE.Material[] | undefined\n    ) {\n        super(undefined, material);\n\n        this.geometries = geometries;\n    }\n\n    /**\n     * Update geometries of mesh\n     */\n    set geometries(geometries: Array<THREE.Geometry | THREE.BufferGeometry> | undefined) {\n        // dispose previous geometries\n        if (this.m_geometries !== geometries) {\n            this.disposeGeometries();\n        }\n\n        this.m_geometries = geometries;\n        if (this.geometries && this.m_geometries!.length > 0) {\n            this.geometry = this.m_geometries![0];\n        }\n    }\n\n    /**\n     * Get geometries of mesh\n     */\n    get geometries() {\n        return this.m_geometries;\n    }\n\n    /**\n     * Change the rendered level of detail of the mesh\n     * @param level - The level of detail (index of the geometry in the list).\n     */\n    setLevelOfDetail(level: number): void {\n        if (!this.m_geometries || this.m_geometries.length === 0) {\n            return;\n        }\n        level = THREE.MathUtils.clamp(level, 0, this.m_geometries.length - 1);\n\n        this.geometry = this.m_geometries[level];\n    }\n\n    /**\n     * Dispose all geometries of mesh\n     */\n    private disposeGeometries(): void {\n        if (this.m_geometries) {\n            for (const geometry of this.m_geometries!) {\n                geometry.dispose();\n            }\n        }\n        this.geometry.dispose();\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * LRU cache.\n *\n * @remarks\n *\n * @packageDocumentation\n */\n\nexport * from \"./lib/LRUCache\";\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nconst SdfShaderChunks = {\n    sdf_attributes: `\n        attribute vec4 position;\n        attribute vec4 uv;\n        attribute vec4 color;\n        attribute vec4 bgColor;\n        `,\n    sdf_varying: `\n        varying vec4 vColor;\n        varying float vWeight;\n        varying vec2 vUv;\n        varying float vRotation;\n        `,\n    sdf_varying_computation: `\n        #if BG_TEXT\n        vColor = bgColor;\n        vWeight = uv.w;\n        #else\n        vColor = color;\n        vWeight = uv.z;\n        #endif\n        vUv = vec2(uv.xy);\n        vRotation = position.w;\n        `,\n    sdf_frag_uniforms: `\n        uniform sampler2D sdfTexture;\n        uniform vec4 sdfParams;\n        `,\n    sdf_sampling_functions: `\n        float median(float r, float g, float b) {\n            return max(min(r, g), min(max(r, g), b));\n        }\n\n        float getDistance(vec2 uvOffset) {\n            vec3 sample = texture2D(sdfTexture, vUv.xy + uvOffset).rgb;\n            #if MSDF\n            return median(sample.r, sample.g, sample.b);\n            #else\n            return sample.r;\n            #endif\n        }\n\n        float getOpacity(vec2 uvOffset, float weight) {\n            vec2 uv = vUv + uvOffset;\n            vec2 rotatedUVs = abs(vec2(\n                cos(vRotation) * uv.x - sin(vRotation) * uv.y,\n                sin(vRotation) * uv.x + cos(vRotation) * uv.y));\n\n            float dx = dFdx(rotatedUVs.x) * sdfParams.x;\n            float dy = dFdy(rotatedUVs.y) * sdfParams.y;\n            float toPixels = sdfParams.w * inversesqrt( dx * dx + dy * dy );\n\n            float dist = getDistance(uvOffset) + min(weight, 0.5 - 1.0 / sdfParams.w) - 0.5;\n            return clamp(dist * toPixels + 0.5, 0.0, 1.0);\n        }\n        `\n};\nObject.assign(THREE.ShaderChunk, SdfShaderChunks);\n\nconst clearVertexSource: string = `\n    attribute vec2 position;\n\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n\n    void main() {\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xy, 0.0, 1.0);\n    }`;\n\nconst clearFragmentSource: string = `\n    precision highp float;\n    precision highp int;\n\n    void main() {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }`;\n\nconst copyVertexSource: string = `\n    attribute vec3 position;\n    attribute vec2 uv;\n\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n\n    varying vec3 vUv;\n\n    void main() {\n        vUv = vec3(uv.xy, position.z);\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xy, 0.0, 1.0);\n    }`;\n\nconst copyFragmentSource: string = `\n    precision highp float;\n    precision highp int;\n\n    uniform float pageOffset;\n    uniform sampler2D page0;\n    uniform sampler2D page1;\n    uniform sampler2D page2;\n    uniform sampler2D page3;\n    uniform sampler2D page4;\n    uniform sampler2D page5;\n    uniform sampler2D page6;\n    uniform sampler2D page7;\n\n    varying vec3 vUv;\n\n    void main() {\n        vec4 sample = vec4(0.0);\n        if (vUv.z < pageOffset || vUv.z > (pageOffset + 7.0)) discard;\n        else if (vUv.z < pageOffset + 1.0) sample = texture2D(page0, vUv.xy);\n        else if (vUv.z < pageOffset + 2.0) sample = texture2D(page1, vUv.xy);\n        else if (vUv.z < pageOffset + 3.0) sample = texture2D(page2, vUv.xy);\n        else if (vUv.z < pageOffset + 4.0) sample = texture2D(page3, vUv.xy);\n        else if (vUv.z < pageOffset + 5.0) sample = texture2D(page4, vUv.xy);\n        else if (vUv.z < pageOffset + 6.0) sample = texture2D(page5, vUv.xy);\n        else if (vUv.z < pageOffset + 7.0) sample = texture2D(page6, vUv.xy);\n        else sample = texture2D(page7, vUv.xy);\n\n        gl_FragColor = sample;\n    }`;\n\nconst sdfTextVertexSource: string = `\n    #include <sdf_attributes>\n    #include <sdf_varying>\n\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n\n    void main() {\n        #include <sdf_varying_computation>\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xyz, 1.0);\n    }`;\n\nconst sdfTextFragmentSource: string = `\n    precision highp float;\n    precision highp int;\n\n    #include <sdf_varying>\n    #include <sdf_frag_uniforms>\n    #include <sdf_sampling_functions>\n\n    void main() {\n        vec4 color = vColor;\n        color.a *= getOpacity(vec2(0.0), vWeight);\n        if (color.a < 0.05) {\n            discard;\n        }\n        gl_FragColor = color;\n    }`;\n\n/**\n * @hidden\n * Material used for clearing glyphs from a [[GlyphTextureCache]].\n */\nexport class GlyphClearMaterial extends THREE.RawShaderMaterial {\n    /**\n     * Creates a new `GlyphClearMaterial`.\n     *\n     * @returns New `GlyphClearMaterial`.\n     */\n    constructor() {\n        const shaderParams: THREE.ShaderMaterialParameters = {\n            name: \"GlyphClearMaterial\",\n            vertexShader: clearVertexSource,\n            fragmentShader: clearFragmentSource,\n            uniforms: {},\n            depthTest: false,\n            depthWrite: false\n        };\n        super(shaderParams);\n    }\n}\n\n/**\n * @hidden\n * Material used for copying glyphs into a [[GlyphTextureCache]].\n */\nexport class GlyphCopyMaterial extends THREE.RawShaderMaterial {\n    /**\n     * Creates a new `GlyphCopyMaterial`.\n     *\n     * @returns New `GlyphCopyMaterial`.\n     */\n    constructor() {\n        const shaderParams: THREE.ShaderMaterialParameters = {\n            name: \"GlyphCopyMaterial\",\n            vertexShader: copyVertexSource,\n            fragmentShader: copyFragmentSource,\n            uniforms: {\n                pageOffset: new THREE.Uniform(0.0),\n                page0: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),\n                page1: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),\n                page2: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),\n                page3: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),\n                page4: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),\n                page5: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),\n                page6: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),\n                page7: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE)\n            },\n            depthTest: false,\n            depthWrite: false\n        };\n        super(shaderParams);\n    }\n}\n\n/**\n * @hidden\n * Material parameters passed on [[SdfTextMaterial]] creation.\n */\nexport interface SdfTextMaterialParameters {\n    texture: THREE.Texture;\n    textureSize: THREE.Vector2;\n    size: number;\n    distanceRange: number;\n    isMsdf: boolean;\n    isBackground: boolean;\n    vertexSource?: string;\n    fragmentSource?: string;\n}\n\n/**\n * Material designed to render transformable, high quality SDF text.\n */\nexport class SdfTextMaterial extends THREE.RawShaderMaterial {\n    /**\n     * Creates a new `SdfTextMaterial`.\n     *\n     * @param params - Material parameters.\n     *\n     * @returns New `SdfTextMaterial`.\n     */\n    constructor(params: SdfTextMaterialParameters) {\n        const shaderParams: THREE.ShaderMaterialParameters = {\n            name: \"SdfTextMaterial\",\n            vertexShader:\n                params.vertexSource !== undefined ? params.vertexSource : sdfTextVertexSource,\n            fragmentShader:\n                params.fragmentSource !== undefined ? params.fragmentSource : sdfTextFragmentSource,\n            uniforms: {\n                sdfTexture: new THREE.Uniform(params.texture),\n                sdfParams: new THREE.Uniform(\n                    new THREE.Vector4(\n                        params.textureSize.x,\n                        params.textureSize.y,\n                        params.size,\n                        params.distanceRange\n                    )\n                )\n            },\n            defines: {\n                MSDF: params.isMsdf ? 1.0 : 0.0,\n                BG_TEXT: params.isBackground ? 1.0 : 0.0\n            },\n            depthTest: true,\n            depthWrite: false,\n            side: THREE.DoubleSide,\n            transparent: true\n        };\n        super(shaderParams);\n        this.extensions.derivatives = true;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\nimport { GlyphData } from \"./GlyphData\";\nimport { TextLayoutStyle, TextRenderStyle } from \"./TextStyle\";\n\n/**\n * Object containing vertex buffer data generated by [[TextCanvas]].\n */\nexport class TextBufferObject {\n    /**\n     * Constructs a new `TextBufferObject`.\n     *\n     * @param glyphs - Input glyphs.\n     * @param buffer - Buffer containing the data generated by [[TextCanvas]].\n     * @param bounds - Optional text bounds.\n     * @param characterBounds - Optional character bounds.\n     * @param textRenderStyle - [[TextRenderStyle]] applied by [[TextCanvas]].\n     * @param textLayoutStyle - [[TextLayoutStyle]] applied by [[TextCanvas]].\n     *\n     * @returns New `TextBufferObject`.\n     */\n    constructor(\n        readonly glyphs: GlyphData[],\n        readonly buffer: Float32Array,\n        readonly bounds?: THREE.Box2,\n        readonly characterBounds?: THREE.Box2[],\n        readonly textRenderStyle?: TextRenderStyle,\n        readonly textLayoutStyle?: TextLayoutStyle\n    ) {}\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { FontCatalog } from \"../rendering/FontCatalog\";\nimport { SdfTextMaterial } from \"../rendering/TextMaterials\";\n\n/**\n * Material parameters passed on [[SdfTextMaterial]] creation when using the `\n * `createSdfTextMaterial` helper function.\n */\nexport interface SdfTextMaterialParameters {\n    fontCatalog: FontCatalog;\n    isBackground?: boolean;\n    vertexSource?: string;\n    fragmentSource?: string;\n}\n\n/**\n * Helper function designed to create [[SdfTextMaterials]] that can be rendered using\n * [[TextCanvas]].\n *\n * @param params - Material parameters.\n *\n * @returns New `SdfTextMaterial`.\n */\nexport function createSdfTextMaterial(params: SdfTextMaterialParameters): SdfTextMaterial {\n    return new SdfTextMaterial({\n        texture: params.fontCatalog.texture,\n        textureSize: params.fontCatalog.textureSize,\n        size: params.fontCatalog.size,\n        distanceRange: params.fontCatalog.distanceRange,\n        isMsdf: params.fontCatalog.type === \"msdf\",\n        isBackground: params.isBackground === true,\n        vertexSource: params.vertexSource,\n        fragmentSource: params.fragmentSource\n    });\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport { IPassManager } from \"./IPassManager\";\nexport {\n    IMapAntialiasSettings,\n    IMapRenderingManager,\n    MapRenderingManager\n} from \"./MapRenderingManager\";\nexport { IPass, Pass } from \"./Pass\";\nexport { MSAARenderPass, MSAASampling } from \"./MSAARenderPass\";\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { CopyShader, MSAAMaterial } from \"@here/harp-materials\";\nimport * as THREE from \"three\";\n\nimport { Pass } from \"./Pass\";\n\n/**\n * This enum represents the sampling level to apply to\n * a {@link MSAARenderPass} instance. At level 0,\n * only one sample is performed, which is like\n * disabling the MSAA pass.\n */\nexport enum MSAASampling {\n    \"Level_0\",\n    \"Level_1\",\n    \"Level_2\",\n    \"Level_3\",\n    \"Level_4\",\n    \"Level_5\"\n}\n\n/**\n * {@link MapView}'s MSAA implementation.\n *\n * @remarks\n * MSAA stands for Multi Sampling Anti-Aliasing, and its concept\n * is to provide a rendering engine with additional color values for each pixel, so they can include\n * the missing bits between them on a screen. WebGL already comes with a native MSAA implementation\n * with four samples. Because of its native nature, it is more efficient and one may not want to use\n * MapView's MSAA implementation when these four samples are satisfying. However in some situations\n * they are not: on low devices, MSAA can impact the framerate and we may desire to reduce the\n * number of samples at runtime. On the other hand, when the interaction stops, the engine also\n * stops rendering the map, and because a map relies on many line-like patterns, aliasing can then\n * turn very noticeable. In such static renders, the number of samples could be dramatically\n * increased on a last frame to render.\n */\nexport class MSAARenderPass extends Pass {\n    /**\n     * The sampling level determines the number of samples that will be performed per frame.\n     * Renders will happen `2 ^ samplingLevel` time(s). `samplingLevel` stands between `0` and `5`.\n     * Therefore there can be between 1 and 32 samples.\n     *\n     * @default `SamplingLevel.Level_1`\n     */\n    samplingLevel: MSAASampling = MSAASampling.Level_1;\n\n    private m_renderTarget: THREE.WebGLRenderTarget | null = null;\n    private readonly m_localCamera: THREE.OrthographicCamera = new THREE.OrthographicCamera(\n        -1,\n        1,\n        1,\n        -1,\n        0,\n        1\n    );\n    private readonly m_quadScene: THREE.Scene = new THREE.Scene();\n    private readonly m_quadUniforms: { [uniformName: string]: THREE.IUniform } =\n        CopyShader.uniforms;\n    private readonly m_quadMaterial: THREE.ShaderMaterial = new MSAAMaterial(this.m_quadUniforms);\n    private readonly m_quad: THREE.Mesh = new THREE.Mesh(\n        new THREE.PlaneBufferGeometry(2, 2),\n        this.m_quadMaterial\n    );\n\n    /**\n     * The constructor for `MSAARenderPass`. It builds an internal scene with a camera looking at a\n     * quad.\n     *\n     * @param m_scene - The scene to render.\n     * @param m_camera - The camera to render the scene through.\n     */\n    constructor() {\n        super();\n        this.m_quad.frustumCulled = false;\n        this.m_quadScene.add(this.m_quad);\n    }\n\n    /**\n     * Releases all used resources.\n     */\n    dispose() {\n        if (this.m_renderTarget !== null) {\n            this.m_renderTarget.dispose();\n            this.m_renderTarget = null;\n        }\n    }\n\n    /**\n     * The render function of `MSAARenderPass`.\n     *\n     * @remarks\n     * At each call of this method, and for each sample the {@link MapView}\n     * camera provided in the `render method is offset within the dimension of a\n     * pixel on screen. It then renders the whole scene with this offset to a local\n     * `WebGLRenderTarget` instance, via a `WebGLRenderer` instance. Finally the local camera\n     * created in the constructor shoots the quad and renders to the write buffer or to the frame\n     * buffer. The quad material's opacity is modified so the renders can accumulate in the\n     * targetted buffer.\n     *\n     * The number of samples can be modified at runtime through the enum [[SamplingLevel]].\n     *\n     * If there is no further pass, the {@link Pass.renderToScreen} flag can be set to `true` to\n     * output directly to the framebuffer.\n     *\n     * @param renderer - The ThreeJS WebGLRenderer instance to render the scene with.\n     * @param scene - The ThreeJS Scene instance to render the scene with.\n     * @param camera - The ThreeJS Camera instance to render the scene with.\n     * @param writeBuffer - A ThreeJS WebGLRenderTarget instance to render the scene to.\n     * @param readBuffer - A ThreeJS WebGLRenderTarget instance to render the scene.\n     * @override\n     */\n    render(\n        renderer: THREE.WebGLRenderer,\n        scene: THREE.Scene,\n        camera: THREE.PerspectiveCamera | THREE.OrthographicCamera,\n        writeBuffer: THREE.WebGLRenderTarget | null,\n        readBuffer: THREE.WebGLRenderTarget\n    ) {\n        if (!this.enabled) {\n            return;\n        }\n\n        // Initiates the local render target with the read buffer's dimensions, if not available.\n        if (this.m_renderTarget === null) {\n            this.m_renderTarget = new THREE.WebGLRenderTarget(readBuffer.width, readBuffer.height, {\n                minFilter: THREE.LinearFilter,\n                magFilter: THREE.LinearFilter,\n                format: THREE.RGBAFormat\n            });\n            this.m_renderTarget.texture.name = \"MSAARenderPass.sample\";\n        }\n        this.m_quadUniforms.tDiffuse.value = this.m_renderTarget.texture;\n\n        const offsets = MSAARenderPass.OffsetVectors[this.samplingLevel];\n\n        const rendererClearColor = renderer.getClearColor();\n        const oldClearColor = rendererClearColor !== undefined ? rendererClearColor.getHex() : 0;\n\n        // The method `camera.setViewOffset` will be called in the next loop. In order to maintain\n        // its usability externally (like for the triple view in mosaic demo) we must cache the\n        // previous values stored in `camera.view` and re-assign them at the end of the pass.\n\n        // 1. Create a default cache object, with default dimensions the size of our read buffer.\n        const oldView = {\n            enabled: camera.view !== null && camera.view.enabled,\n            fullWidth: readBuffer.width,\n            fullHeight: readBuffer.height,\n            x: 0,\n            y: 0,\n            width: readBuffer.width,\n            height: readBuffer.height\n        };\n\n        // 2. If `camera.view` has been enabled previously, then `setViewOffset` has been called\n        // externally: copy the existing `camera.view` values in the cache. Override the cache\n        // object with the values provided externally.\n        if (oldView.enabled && camera.view !== null) {\n            oldView.fullWidth = camera.view.fullWidth;\n            oldView.fullHeight = camera.view.fullHeight;\n            oldView.x = camera.view.offsetX;\n            oldView.y = camera.view.offsetY;\n            oldView.width = camera.view.width;\n            oldView.height = camera.view.height;\n        }\n\n        const oldRenderTarget = renderer.getRenderTarget();\n        for (let i = 0; i < offsets.length; i++) {\n            // 4. Then for each sample, call `setViewOffset` with our object. This also updates the\n            // `camera.view` object in Three.js.\n            const offset = offsets[i];\n            camera.setViewOffset(\n                oldView.fullWidth,\n                oldView.fullHeight,\n                oldView.x + offset[0] / 16,\n                oldView.y + offset[1] / 16,\n                oldView.width,\n                oldView.height\n            );\n\n            // 5. Divide the opacity of the quad by the number of samples to accumulate on the\n            // target buffer, and reduce the impact of the offset on color to reduce banding. Then\n            // render.\n            const uniformCenteredDistribution = -0.5 + (i + 0.5) / offsets.length;\n            const sampleWeight = 1.0 / offsets.length + uniformCenteredDistribution / 32;\n\n            this.m_quadUniforms.opacity.value = sampleWeight;\n\n            renderer.setRenderTarget(this.m_renderTarget);\n            renderer.clear();\n            renderer.render(scene, camera);\n\n            // 6. Render the quad on top of the previous renders.\n\n            // NOTE: three.js doesn't like undefined as renderTarget, but works with `null`\n            renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);\n            if (i === 0) {\n                renderer.setClearColor(0x000000);\n                renderer.clear();\n            }\n            renderer.render(this.m_quadScene, this.m_localCamera);\n            if (i === 0 && rendererClearColor !== undefined) {\n                renderer.setClearColor(oldClearColor);\n            }\n        }\n        renderer.setRenderTarget(oldRenderTarget);\n\n        // 7. Restore `camera.view` as set externally (or not).\n        if (camera.view !== null) {\n            camera.view.enabled = oldView.enabled;\n            camera.view.offsetX = oldView.x;\n            camera.view.offsetY = oldView.y;\n        }\n    }\n\n    /**\n     * Resize the internal render target to match the new size specified.\n     *\n     * @param width - New width to apply to the render target.\n     * @param height - New height to apply to the render target.\n     * @override\n     */\n    setSize(width: number, height: number) {\n        if (this.m_renderTarget) {\n            this.m_renderTarget.setSize(width, height);\n        }\n    }\n\n    // tslint:disable:max-line-length\n    /**\n     * The list of offsets to apply to the camera, per sampling level, adapted from :\n     *\n     * @see https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396\n     */\n    // tslint:enable:max-line-length\n    // tslint:disable-next-line:member-ordering\n    static readonly OffsetVectors: number[][][] = [\n        [[0, 0]],\n        [\n            [4, 4],\n            [-4, -4]\n        ],\n        [\n            [-2, -6],\n            [6, -2],\n            [-6, 2],\n            [2, 6]\n        ],\n        [\n            [1, -3],\n            [-1, 3],\n            [5, 1],\n            [-3, -5],\n            [-5, 5],\n            [-7, -1],\n            [3, 7],\n            [7, -7]\n        ],\n        [\n            [1, 1],\n            [-1, -3],\n            [-3, 2],\n            [4, -1],\n            [-5, -2],\n            [2, 5],\n            [5, 3],\n            [3, -5],\n            [-2, 6],\n            [0, -7],\n            [-4, -6],\n            [-6, 4],\n            [-8, 0],\n            [7, -4],\n            [6, 7],\n            [-7, -8]\n        ],\n        [\n            [-4, -7],\n            [-7, -5],\n            [-3, -5],\n            [-5, -4],\n            [-1, -4],\n            [-2, -2],\n            [-6, -1],\n            [-4, 0],\n            [-7, 1],\n            [-1, 2],\n            [-6, 3],\n            [-3, 3],\n            [-7, 6],\n            [-3, 6],\n            [-5, 7],\n            [-1, 7],\n            [5, -7],\n            [1, -6],\n            [6, -5],\n            [4, -4],\n            [2, -3],\n            [7, -2],\n            [1, -1],\n            [4, -1],\n            [2, 1],\n            [6, 2],\n            [0, 4],\n            [4, 4],\n            [2, 5],\n            [7, 5],\n            [5, 6],\n            [3, 7]\n        ]\n    ];\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { RequestController, WorkerServiceProtocol } from \"@here/harp-datasource-protocol\";\nimport {\n    getOptionValue,\n    IWorkerChannelMessage,\n    LoggerManager,\n    LogLevel,\n    WORKERCHANNEL_MSG_TYPE\n} from \"@here/harp-utils\";\n\nimport { WorkerLoader } from \"./workers/WorkerLoader\";\n\nimport * as THREE from \"three\";\n\nconst logger = LoggerManager.instance.create(\"ConcurrentWorkerSet\");\n\nexport function isLoggingMessage(message: IWorkerChannelMessage): message is IWorkerChannelMessage {\n    return message && typeof message.level === \"number\" && message.type === WORKERCHANNEL_MSG_TYPE;\n}\n\ninterface ReadyPromise {\n    count: number;\n    promise?: Promise<void>;\n    resolve: () => void;\n    reject: (reason: any) => void;\n    error?: any;\n}\n\ninterface RequestEntry {\n    promise: Promise<any>;\n    resolver: (error?: Error, response?: object) => void;\n}\n\nexport interface ConcurrentWorkerSetOptions {\n    /**\n     * The URL of the script for each worker to start.\n     */\n    scriptUrl: string;\n\n    /**\n     * The number of Web Workers for processing data.\n     *\n     * Defaults to CLAMP(`navigator.hardwareConcurrency` - 1, 1, 4) or [[DEFAULT_WORKER_COUNT]].\n     */\n    workerCount?: number;\n\n    /**\n     * Timeout in milliseconds, in which each worker should set initial message.\n     *\n     * @default 10 seconds, see [[DEFAULT_WORKER_INITIALIZATION_TIMEOUT]]\n     */\n    workerConnectionTimeout?: number;\n}\n\n/**\n * Interface for an item in the started worker list queue.\n */\ninterface WorkerEntry {\n    worker: Worker;\n    listener: EventListener;\n}\n\n/**\n * Interface for an item in the request queue. Stores the data to be decoded along with an\n * [[AbortController]].\n */\ninterface WorkerRequestEntry {\n    message: WorkerServiceProtocol.RequestMessage;\n    buffers?: ArrayBuffer[] | undefined;\n    requestController?: RequestController;\n}\n\n/**\n * The default number of Web Workers to use if `navigator.hardwareConcurrency` is unavailable.\n */\nconst DEFAULT_WORKER_COUNT = 2;\n\n/**\n * The default timeout for first message from worker.\n *\n * @see {@link WorkerLoader.startWorker}\n */\nexport const DEFAULT_WORKER_INITIALIZATION_TIMEOUT = 10000;\n\n/**\n * A set of concurrent Web Workers. Acts as a Communication Peer for [[WorkerService]] instances\n * running in Web Workers.\n *\n * Starts and manages a certain number of web workers and provides a means to communicate\n * with them using various communication schemes, such as:\n *  - [[addEventListener]] : receive a unidirectional messages\n *  - [[broadcastMessage]] : send unidirectional broadcast message\n *  - [[invokeRequest]] : send a request that waits for a response, with load balancing\n *  - [[postMessage]] : send a unidirectional message, with load balancing\n *\n * The request queue holds all requests before they are stuffed into the event queue, allows for\n * easy (and early) cancelling of requests. The workers now only get a single new RequestMessage\n * when they return their previous result, or if they are idle. When they are idle, they are stored\n * in m_availableWorkers.\n */\nexport class ConcurrentWorkerSet {\n    private m_workerChannelLogger = LoggerManager.instance.create(\"WorkerChannel\");\n    private readonly m_eventListeners = new Map<string, (message: any) => void>();\n    private m_workers = new Array<Worker>();\n\n    // List of idle workers that can be given the next job. It is using a LIFO scheme to reduce\n    // memory consumption in idle workers.\n    private m_availableWorkers = new Array<Worker>();\n    private m_workerPromises = new Array<Promise<WorkerEntry | undefined>>();\n    private m_workerCount: number | undefined;\n\n    private readonly m_readyPromises = new Map<string, ReadyPromise>();\n    private readonly m_requests: Map<number, RequestEntry> = new Map();\n    private m_workerRequestQueue: WorkerRequestEntry[] = [];\n\n    private m_nextMessageId: number = 0;\n    private m_stopped: boolean = true;\n\n    private m_referenceCount: number = 0;\n\n    /**\n     * Creates a new `ConcurrentWorkerSet`.\n     *\n     * Creates as many Web Workers as specified in `options.workerCount`, from the script provided\n     * in `options.scriptUrl`. If `options.workerCount` is not specified, the value specified in\n     * `navigator.hardwareConcurrency` is used instead.\n     *\n     * The worker set is implicitly started when constructed.\n     */\n    constructor(private m_options: ConcurrentWorkerSetOptions) {\n        this.start();\n    }\n\n    /**\n     * Adds an external reference and increments the internal reference counter by one.\n     *\n     * To implement a reference-count based automatic resource cleanup, use this function with\n     * [[removeReference]].\n     */\n    addReference() {\n        this.m_referenceCount += 1;\n        if (this.m_referenceCount === 1 && this.m_stopped) {\n            this.start();\n        }\n    }\n\n    /**\n     * Decrements the internal reference counter by 1.\n     *\n     * When the internal reference counter reaches 0, this function calls [[dispose]] to clear the\n     * resources.\n     *\n     * Use with [[addReference]] to implement reference-count based automatic resource cleanup.\n     */\n    removeReference() {\n        this.m_referenceCount -= 1;\n        if (this.m_referenceCount === 0) {\n            this.destroy();\n        }\n    }\n\n    /**\n     * Starts workers.\n     *\n     * Use to start workers already stopped by [[stop]] or [[destroy]] calls.\n     *\n     * Note: The worker set is implicitly started on construction - no need to call [[start]] on\n     * fresh instance.\n     *\n     * @param options - optional, new worker set options\n     */\n    start(options?: ConcurrentWorkerSetOptions) {\n        if (options !== undefined) {\n            this.m_options = options;\n        }\n        if (!this.m_stopped) {\n            throw new Error(\"ConcurrentWorker set already started\");\n        }\n\n        this.m_workerCount = getOptionValue(\n            this.m_options.workerCount,\n            typeof navigator !== \"undefined\" && navigator.hardwareConcurrency !== undefined\n                ? // We need to have at least one worker\n                  THREE.MathUtils.clamp(navigator.hardwareConcurrency - 1, 1, 2)\n                : undefined,\n            DEFAULT_WORKER_COUNT\n        );\n\n        // Initialize the workers. The workers now have an ID to identify specific workers and\n        // handle their busy state.\n        const timeout = getOptionValue(\n            this.m_options.workerConnectionTimeout,\n            DEFAULT_WORKER_INITIALIZATION_TIMEOUT\n        );\n        for (let workerId = 0; workerId < this.m_workerCount; ++workerId) {\n            const workerPromise = WorkerLoader.startWorker(this.m_options.scriptUrl, timeout).then(\n                worker => {\n                    const listener = (evt: Event): void => {\n                        this.onWorkerMessage(workerId, evt as MessageEvent);\n                    };\n\n                    worker.addEventListener(\"message\", listener);\n                    this.m_workers.push(worker);\n                    this.m_availableWorkers.push(worker);\n                    return {\n                        worker,\n                        listener\n                    };\n                }\n            );\n            this.m_workerPromises.push(workerPromise);\n        }\n        this.m_stopped = false;\n    }\n\n    /**\n     * The number of workers started for this worker set. The value is `undefined` until the workers\n     * have been created.\n     */\n    get workerCount(): number | undefined {\n        return this.m_workerCount;\n    }\n\n    /**\n     * Stops workers.\n     *\n     * Waits for all pending requests to be finished and stops all workers.\n     *\n     * Use [[start]] to start this worker again.\n     *\n     * @returns `Promise` that resolves when all workers are destroyed.\n     */\n    async stop() {\n        this.m_stopped = true;\n\n        await this.waitForAllResponses().then(() => {\n            this.terminateWorkers();\n        });\n    }\n\n    /**\n     * Destroys all workers immediately.\n     *\n     * Resolves all pending request promises with a `worker destroyed` error.\n     *\n     * Use [[start]] to start this worker again.\n     */\n    destroy() {\n        this.m_stopped = true;\n\n        // respond with all pending request\n        this.m_requests.forEach(entry => {\n            entry.resolver(new Error(\"worker destroyed\"));\n        });\n        this.m_requests.clear();\n        this.m_workerRequestQueue = [];\n\n        this.terminateWorkers();\n\n        // clean other stuff\n        this.m_eventListeners.clear();\n    }\n\n    /**\n     * Waits for `service` to be initialized in all workers.\n     *\n     * Each service that starts in a worker sends an [[isInitializedMessage]] to confirm that\n     * it has started successfully. This method resolves when all workers in a set have\n     * `service` initialized.\n     *\n     * Promise is rejected if any of worker fails to start.\n     *\n     * @param serviceId - The service identifier.\n     */\n    async connect(serviceId: string): Promise<void> {\n        this.ensureStarted();\n        await Promise.all(this.m_workerPromises);\n        return this.getReadyPromise(serviceId).promise as Promise<void>;\n    }\n\n    /**\n     * Registers an event listener for events that originated in a web worker, for a given\n     * `serviceId`. You can only set one event listener per `serviceId`.\n     *\n     * @param serviceId - The service to listen to.\n     * @param callback - The callback to invoke for matching events.\n     */\n    addEventListener(serviceId: string, callback: (message: any) => void) {\n        this.m_eventListeners.set(serviceId, callback);\n    }\n\n    /**\n     * Removes a previously set event listener for the given `serviceId`.\n     *\n     * @param serviceId - The service from which to remove the event listeners.\n     */\n    removeEventListener(serviceId: string) {\n        this.m_eventListeners.delete(serviceId);\n    }\n\n    /**\n     * Invokes a request that expects a response from a random worker.\n     *\n     * Sends [[RequestMessage]] and resolves when a matching [[ResponseMessage]] is received from\n     * workers. Use this function when interfacing with \"RPC-like\" calls to services.\n     *\n     * @param serviceId - The name of service, as registered with the [[WorkerClient]] instance.\n     * @param request - The request to process.\n     * @param transferList - An optional array of `ArrayBuffer`s to transfer to the worker context.\n     * @param requestController - An optional [[RequestController]] to store state of cancelling.\n     *\n     * @returns A `Promise` that resolves with a response from the service.\n     */\n    invokeRequest<Res>(\n        serviceId: string,\n        request: WorkerServiceProtocol.ServiceRequest,\n        transferList?: ArrayBuffer[],\n        requestController?: RequestController\n    ): Promise<Res> {\n        this.ensureStarted();\n\n        const messageId = this.m_nextMessageId++;\n        let resolver: ((error?: any, response?: any) => void) | undefined;\n\n        const promise = new Promise<Res>((resolve, reject) => {\n            resolver = (error?: Error, response?: Res) => {\n                this.m_requests.delete(messageId);\n\n                if (error !== undefined) {\n                    reject(error);\n                } else {\n                    resolve(response as Res);\n                }\n            };\n        });\n        this.m_requests.set(messageId, {\n            promise,\n            resolver: resolver!\n        });\n\n        const message: WorkerServiceProtocol.RequestMessage = {\n            service: serviceId,\n            type: WorkerServiceProtocol.ServiceMessageName.Request,\n            messageId,\n            request\n        };\n        this.postRequestMessage(message, transferList, requestController);\n        return promise;\n    }\n\n    /**\n     * Invokes a request that expects responses from all workers.\n     *\n     * Send [[RequestMessage]]  to all workers and resolves when all workers have sent a matching\n     * [[ResponseMessage]]. Use this function to wait on request that need to happen on all workers\n     * before proceeding (like synchronous worker service creation).\n     *\n     * @param serviceId - The name of service, as registered with the [[WorkerClient]] instance.\n     * @param request - The request to process.\n     * @param transferList - An optional array of `ArrayBuffer`s to transfer to the worker context.\n     *\n     * @returns Array of `Promise`s that resolves with a response from each worker (unspecified\n     * order).\n     */\n    broadcastRequest<Res>(\n        serviceId: string,\n        request:\n            | WorkerServiceProtocol.WorkerServiceManagerRequest\n            | WorkerServiceProtocol.ServiceRequest,\n        transferList?: ArrayBuffer[]\n    ): Promise<Res[]> {\n        this.ensureStarted();\n\n        const promises = [];\n        for (const worker of this.m_workers) {\n            const messageId = this.m_nextMessageId++;\n\n            let resolver: ((error?: any, response?: any) => void) | undefined;\n            const promise = new Promise<Res>((resolve, reject) => {\n                resolver = (error: Error, response: Res) => {\n                    this.m_requests.delete(messageId);\n\n                    if (error !== undefined) {\n                        reject(error);\n                    } else {\n                        resolve(response as Res);\n                    }\n                };\n            });\n            promises.push(promise);\n\n            this.m_requests.set(messageId, {\n                promise,\n                resolver: resolver!\n            });\n\n            const message: WorkerServiceProtocol.RequestMessage = {\n                service: serviceId,\n                type: WorkerServiceProtocol.ServiceMessageName.Request,\n                messageId,\n                request\n            };\n            if (transferList !== undefined) {\n                worker.postMessage(message, transferList);\n            } else {\n                worker.postMessage(message);\n            }\n        }\n\n        return Promise.all(promises);\n    }\n\n    /**\n     * Posts a message to all workers.\n     *\n     * @param message - The message to send.\n     * @param buffers - Optional buffers to transfer to the workers.\n     */\n    broadcastMessage(message: any, buffers?: ArrayBuffer[] | undefined) {\n        this.ensureStarted();\n\n        if (buffers !== undefined) {\n            this.m_workers.forEach(worker => worker.postMessage(message, buffers));\n        } else {\n            this.m_workers.forEach(worker => worker.postMessage(message));\n        }\n    }\n\n    /**\n     * The size of the request queue for debugging and profiling.\n     */\n    get requestQueueSize() {\n        return this.m_workerRequestQueue.length;\n    }\n\n    /**\n     * The number of workers for debugging and profiling.\n     */\n    get numWorkers() {\n        return this.m_workers.length;\n    }\n\n    /**\n     * The number of workers for debugging and profiling.\n     */\n    get numIdleWorkers() {\n        return this.m_availableWorkers.length;\n    }\n\n    /**\n     * Subclasses must call this function when a worker emits an event.\n     *\n     * @param event - The event to dispatch.\n     */\n    protected eventHandler(event: any) {\n        if (typeof event.data.type !== \"string\") {\n            return; // not an event generated by us, ignore.\n        }\n\n        this.dispatchEvent(event.data.type, event);\n    }\n\n    /**\n     * Handles messages received from workers. This method is protected so that the message\n     * reception can be simulated through an extended class, to avoid relying on real workers.\n     *\n     * @param workerId - The workerId of the web worker.\n     * @param event - The event to dispatch.\n     */\n    private onWorkerMessage = (workerId: number, event: MessageEvent) => {\n        if (WorkerServiceProtocol.isResponseMessage(event.data)) {\n            const response = event.data;\n            if (response.messageId === null) {\n                logger.error(`[${this.m_options.scriptUrl}]: Bad ResponseMessage: no messageId`);\n                return;\n            }\n            const entry = this.m_requests.get(response.messageId);\n            if (entry === undefined) {\n                logger.error(\n                    `[${this.m_options.scriptUrl}]: Bad ResponseMessage: invalid messageId`\n                );\n                return;\n            }\n\n            if (workerId >= 0 && workerId < this.m_workers.length) {\n                const worker = this.m_workers[workerId];\n                this.m_availableWorkers.push(worker);\n                // Check if any new work has been put into the queue.\n                this.checkWorkerRequestQueue();\n            } else {\n                logger.error(`[${this.m_options.scriptUrl}]: onWorkerMessage: invalid workerId`);\n            }\n            if (response.errorMessage !== undefined) {\n                const error = new Error(response.errorMessage);\n                if (response.errorStack !== undefined) {\n                    error.stack = response.errorStack;\n                }\n                entry.resolver(error);\n            } else {\n                entry.resolver(undefined, response.response);\n            }\n        } else if (WorkerServiceProtocol.isInitializedMessage(event.data)) {\n            const readyPromise = this.getReadyPromise(event.data.service);\n            if (++readyPromise.count === this.m_workerPromises.length) {\n                readyPromise.resolve();\n            }\n        } else if (isLoggingMessage(event.data)) {\n            switch (event.data.level) {\n                case LogLevel.Trace:\n                    this.m_workerChannelLogger.trace(...event.data.message);\n                    break;\n                case LogLevel.Debug:\n                    this.m_workerChannelLogger.debug(...event.data.message);\n                    break;\n                case LogLevel.Log:\n                    this.m_workerChannelLogger.log(...event.data.message);\n                    break;\n                case LogLevel.Info:\n                    this.m_workerChannelLogger.info(...event.data.message);\n                    break;\n                case LogLevel.Warn:\n                    this.m_workerChannelLogger.warn(...event.data.message);\n                    break;\n                case LogLevel.Error:\n                    this.m_workerChannelLogger.error(...event.data.message);\n                    break;\n            }\n        } else {\n            this.eventHandler(event);\n        }\n    };\n\n    /**\n     * Posts a [[WorkerServiceProtocol.RequestMessage]] to an available worker. If no worker is\n     * available, the request is put into a queue.\n     *\n     * @param message - The message to send.\n     * @param buffers - Optional buffers to transfer to the worker.\n     * @param requestController - An optional [[RequestController]] to store state of cancelling.\n     */\n    private postRequestMessage(\n        message: WorkerServiceProtocol.RequestMessage,\n        buffers?: ArrayBuffer[] | undefined,\n        requestController?: RequestController\n    ) {\n        this.ensureStarted();\n        if (this.m_workers.length === 0) {\n            throw new Error(\"ConcurrentWorkerSet#postMessage: no workers started\");\n        }\n\n        // Check if the requestController has received the abort signal, in which case the request\n        // is ignored.\n        if (requestController !== undefined && requestController.signal.aborted) {\n            const entry = this.m_requests.get(message.messageId);\n            if (entry === undefined) {\n                logger.error(\n                    `[${this.m_options.scriptUrl}]: Bad RequestMessage: invalid messageId`\n                );\n                return;\n            }\n\n            const err = new Error(\"Aborted\");\n            err.name = \"AbortError\";\n\n            entry.resolver(err, undefined);\n            return;\n        }\n\n        if (this.m_availableWorkers.length > 0) {\n            const worker = this.m_availableWorkers.pop()!;\n\n            if (buffers !== undefined) {\n                worker.postMessage(message, buffers);\n            } else {\n                worker.postMessage(message);\n            }\n        } else {\n            // We need a priority to keep sorting stable, so we have to add a RequestController.\n            if (requestController === undefined) {\n                requestController = new RequestController(0);\n            }\n            if (requestController.priority === 0) {\n                // If the requests do not get a priority, they should keep their sorting order.\n                requestController.priority = -this.m_nextMessageId;\n            }\n            this.m_workerRequestQueue.unshift({\n                message,\n                buffers,\n                requestController\n            });\n        }\n    }\n\n    private ensureStarted() {\n        if (this.m_stopped) {\n            throw new Error(\"ConcurrentWorkerSet stopped\");\n        }\n    }\n\n    private async waitForAllResponses(): Promise<any> {\n        const promises = new Array<Promise<void>>();\n        this.m_requests.forEach(entry => {\n            promises.push(entry.promise);\n        });\n        await Promise.all(promises);\n    }\n\n    private dispatchEvent(id: string, message: any) {\n        const callback = this.m_eventListeners.get(id);\n        if (callback === undefined) {\n            return;\n        } // unknown event, ignore.\n        callback(message);\n    }\n\n    private terminateWorkers() {\n        // terminate all workers\n        this.m_workerPromises.forEach(workerPromise => {\n            workerPromise.then(workerEntry => {\n                if (workerEntry === undefined) {\n                    return;\n                }\n                workerEntry.worker.removeEventListener(\"message\", workerEntry.listener);\n                workerEntry.worker.terminate();\n            });\n        });\n        this.m_workers = [];\n        this.m_workerPromises = [];\n        this.m_availableWorkers = [];\n        this.m_readyPromises.clear();\n    }\n\n    private getReadyPromise(id: string): ReadyPromise {\n        const readyPromise = this.m_readyPromises.get(id);\n        if (readyPromise !== undefined) {\n            return readyPromise;\n        }\n\n        const newPromise: ReadyPromise = {\n            count: 0,\n            promise: undefined,\n            resolve: () => {\n                /* placeholder */\n            },\n            reject: (error: any) => {\n                newPromise.error = error;\n            },\n            error: undefined\n        };\n\n        newPromise.promise = new Promise<void>((resolve, reject) => {\n            const that = newPromise;\n\n            if (that.error !== undefined) {\n                reject(that.error);\n            } else if (that.count === this.m_workerPromises.length) {\n                resolve();\n            }\n\n            that.resolve = resolve;\n            that.reject = reject;\n        });\n\n        this.m_readyPromises.set(id, newPromise);\n        return newPromise;\n    }\n\n    /**\n     * Check the worker request queue, if there are any queued up decoding jobs and idle workers,\n     * they will be executed with postRequestMessage. The requests in the queue are sorted before\n     * the request with the highest priority is selected for processing.\n     */\n    private checkWorkerRequestQueue() {\n        if (this.m_workerRequestQueue.length === 0 || this.m_availableWorkers.length === 0) {\n            return;\n        }\n        this.m_workerRequestQueue.sort((a: WorkerRequestEntry, b: WorkerRequestEntry) => {\n            return a.requestController!.priority - b.requestController!.priority;\n        });\n\n        // Get the request with the highest priority and send it (again).\n        while (this.m_availableWorkers.length > 0 && this.m_workerRequestQueue.length > 0) {\n            const request = this.m_workerRequestQueue.pop()!;\n            this.postRequestMessage(request.message, request.buffers, request.requestController);\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport \"@here/harp-fetch\";\n\nimport { getUrlOrigin, LoggerManager } from \"@here/harp-utils\";\nimport { isWorkerBootstrapRequest, WorkerBootstrapResponse } from \"./WorkerBootstrapDefs\";\n\nconst logger = LoggerManager.instance.create(\"WorkerLoader\");\n\n/**\n * Set of `Worker` loading and initialization helpers:\n *  - starting Worker from URL with fallback to XHR+blob {@link WorkerLoader.startWorker}\n *  - waiting for proper worker initialization, see {@link WorkerLoader.waitWorkerInitialized}\n */\nexport class WorkerLoader {\n    static directlyFallbackToBlobBasedLoading: boolean = false;\n    static sourceLoaderCache = new Map<string, Promise<string>>();\n    static dependencyUrlMapping: { [name: string]: string } = {};\n\n    /**\n     * Starts worker by first attempting load from `scriptUrl` using native `Worker` constructor.\n     * Then waits (using [[waitWorkerInitialized]]) for first message that indicates successful\n     * initialization.\n     * If `scriptUrl`'s origin is different than `baseUrl`, then in case of error falls back to\n     * [[startWorkerBlob]].\n     *\n     * We must resolve/reject promise at some time, so it is expected that any sane application will\n     * be able to load worker code in some amount of time.\n     * By default, this method timeouts after 10 seconds (configurable using `timeout` argument).\n     *\n     * This method is needed as browsers in general forbid to load worker if it's not on 'same\n     * origin' regardless of Content-Security-Policy.\n     *\n     * For blob-based fallback work, one need to ensure that Content Security Policy (CSP) allows\n     * loading web worker code from `Blob`s. By default browsers, allow 'blob:' for workers, but\n     * this may change.\n     *\n     * Following snippet setups CSP, so workers can be started from blob urls:\n     *\n     *     <head>\n     *         <meta http-equiv=\"Content-Security-Policy\" content=\"child-src blob:\">\n     *     </head>\n     *\n     * Tested on:\n     *   * Chrome 67 / Linux, Window, OSX, Android\n     *   * Firefox 60 / Linux, Windows, OSX\n     *   * Edge 41 / Windows\n     *   * Safari 11 / OSX\n     *   * Samsung Internet 7.2\n     *\n     * See\n     *  * https://benohead.com/cross-domain-cross-browser-web-workers/\n     *  * MapBox\n     *    * https://stackoverflow.com/questions/21913673/execute-web-worker-from-different-origin\n     *    * https://github.com/mapbox/mapbox-gl-js/issues/2658\n     *    * https://github.com/mapbox/mapbox-gl-js/issues/559\n     *    * https://github.com/mapbox/mapbox-gl-js/issues/6058\n     *\n     * Findings:\n     *\n     * * Chrome reports CSP by exception when constructing [[Worker]] instance.\n     * * Firefox reports CSP errors when loading in first event:\n     *   https://bugzilla.mozilla.org/show_bug.cgi?id=1241888\n     * * Firefox 62, Chrome 67 obeys `<meta http-equiv=\"Content-Security-Policy\">` with\n     *   `worker-src blob:` but doesn't obey `worker-src URL` when used\n     * * Chrome 67 doesn't obey CSP `worker-src URL` despite it's documented as supported\n     *   (https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Security-Policy/worker-src)\n     *\n     * @param scriptUrl - web worker script URL\n     * @param timeout - timeout in milliseconds, in which worker should set initial message\n     *    (default 10 seconds)\n     */\n    static startWorker(scriptUrl: string, timeout: number = 10000): Promise<Worker> {\n        if (scriptUrl.startsWith(\"blob:\")) {\n            return this.startWorkerImmediately(scriptUrl, timeout);\n        }\n\n        if (this.directlyFallbackToBlobBasedLoading) {\n            return this.startWorkerBlob(scriptUrl, timeout);\n        }\n        return this.startWorkerImmediately(scriptUrl, timeout).catch(error => {\n            if (typeof window !== \"undefined\") {\n                const pageUrl = window.location.href;\n                const fullScriptUrl = new URL(scriptUrl, pageUrl).href;\n                if (getUrlOrigin(fullScriptUrl) === getUrlOrigin(pageUrl)) {\n                    throw error;\n                }\n                logger.log(\n                    \"#startWorker: cross-origin worker construction failed, trying load with blob\"\n                );\n                this.directlyFallbackToBlobBasedLoading = true;\n                return WorkerLoader.startWorkerBlob(scriptUrl, timeout);\n            } else {\n                throw error;\n            }\n        });\n    }\n\n    /**\n     * Start worker, loading it immediately from `scriptUrl`. Waits (using\n     * [[waitWorkerInitialized]]) for successful worker start.\n     *\n     * @param scriptUrl - web worker script URL\n     */\n    static startWorkerImmediately(scriptUrl: string, timeout: number): Promise<Worker> {\n        try {\n            const worker = new Worker(scriptUrl);\n            return this.waitWorkerInitialized(worker, timeout);\n        } catch (error) {\n            return Promise.reject(error);\n        }\n    }\n\n    /**\n     * Start worker \"via blob\" by first loading worker script code with [[fetch]], creating `Blob`\n     * and attempting to start worker from blob url. Waits (using [[waitWorkerInitialized]]) for\n     * successful worker start.\n     *\n     * @param scriptUrl - web worker script URL\n     */\n    static startWorkerBlob(scriptUrl: string, timeout: number): Promise<Worker> {\n        return this.fetchScriptSourceToBlobUrl(scriptUrl).then(blobUrl => {\n            return this.startWorkerImmediately(blobUrl, timeout);\n        });\n    }\n\n    /**\n     * Fetch script source as `Blob` url.\n     *\n     * Reuses results, if there are many simultaneous requests.\n     *\n     * @param scriptUrl - web worker script URL\n     * @return promise that resolves to url of a `Blob` with script source code\n     */\n    static fetchScriptSourceToBlobUrl(scriptUrl: string): Promise<string> {\n        let loadingPromise = this.sourceLoaderCache.get(scriptUrl);\n        if (loadingPromise !== undefined) {\n            return loadingPromise;\n        }\n        loadingPromise = fetch(scriptUrl)\n            .then(response => response.text())\n            .catch(error => {\n                throw new Error(\n                    `WorkerLoader#fetchScriptSourceToBlob: failed to load worker script: ${error}`\n                );\n            })\n            .then(scriptSource => {\n                this.sourceLoaderCache.delete(scriptUrl);\n                const blob = new Blob([scriptSource], { type: \"application/javascript\" });\n                return URL.createObjectURL(blob);\n            });\n        this.sourceLoaderCache.set(scriptUrl, loadingPromise);\n        return loadingPromise;\n    }\n\n    /**\n     * Waits for successful Web Worker start.\n     *\n     * Expects that worker script sends initial message.\n     *\n     * If first event is `message` then assumes that worker has been loaded sussesfully and promise\n     * resolves to `worker` object passed as argument.\n     *\n     * If first event is 'error', then it is assumed that worker failed to load and promise is\n     * rejected.\n     *\n     * (NOTE: The initial 'message' - if received - is immediately replayed using worker's\n     * `dispatchEvent`, so application code can also consume it as confirmation of successful\n     * worker initialization.\n     *\n     * We must resolve/reject promise at some time, so it is expected that any sane application will\n     * be able to load worker code in some amount of time.\n     *\n     * @param worker - [[Worker]] instance to be checked\n     * @param timeout - timeout in milliseconds, in which worker should set initial message\n     * @returns `Promise` that resolves to `worker` on success\n     */\n    static waitWorkerInitialized(worker: Worker, timeout: number): Promise<Worker> {\n        return new Promise<Worker>((resolve, reject) => {\n            const firstMessageCallback = (event: MessageEvent) => {\n                const message = event.data;\n                if (isWorkerBootstrapRequest(message)) {\n                    const dependencies = message.dependencies;\n                    const resolvedDependencies: string[] = [];\n                    for (const dependency of dependencies) {\n                        const resolved = this.dependencyUrlMapping[dependency];\n                        if (!resolved) {\n                            cleanup();\n                            reject(\n                                new Error(\n                                    `#waitWorkerInitialized: Unable to resolve '${dependency}'` +\n                                        ` as needed by worker script.`\n                                )\n                            );\n                            return;\n                        }\n                        resolvedDependencies.push(resolved);\n                    }\n                    const response: WorkerBootstrapResponse = {\n                        type: \"worker-bootstrap-response\",\n                        resolvedDependencies\n                    };\n                    worker.postMessage(response);\n                    return;\n                }\n\n                cleanup();\n                resolve(worker);\n\n                // We've just consumed first message from worker before client has any chance to\n                // even call `addEventListener` on it, so here after resolve, we wait next tick and\n                // replay message so user has chance to intercept it in its own handler.\n                setTimeout(() => {\n                    worker.dispatchEvent(event);\n                }, 0);\n            };\n            const errorCallback = (error: ErrorEvent) => {\n                cleanup();\n                // Error events do not carry any useful information on tested browsers, so we assume\n                // that any error before 'firstMessageCallback' as failed Worker initialization.\n                let message = \"Error during worker initialization\";\n                if (error.message) {\n                    message = message + `: ${error.message}`;\n                }\n                if (typeof error.filename === \"string\" && typeof error.lineno === \"number\") {\n                    message = message + ` in ${error.filename}:${error.lineno}`;\n                }\n                reject(new Error(message));\n            };\n            const cleanup = () => {\n                clearTimeout(timerId);\n                worker.removeEventListener(\"message\", firstMessageCallback);\n                worker.removeEventListener(\"error\", errorCallback);\n            };\n\n            worker.addEventListener(\"error\", errorCallback);\n            worker.addEventListener(\"message\", firstMessageCallback);\n            const timerId = setTimeout(() => {\n                cleanup();\n                reject(new Error(\"Timeout exceeded when waiting for first message from worker.\"));\n            }, timeout);\n        });\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {\n    DecodedTile,\n    Definitions,\n    getProjectionName,\n    ITileDecoder,\n    OptionsMap,\n    RequestController,\n    StyleSet,\n    TileInfo,\n    WorkerDecoderProtocol,\n    WorkerServiceProtocol\n} from \"@here/harp-datasource-protocol\";\nimport { Projection, TileKey } from \"@here/harp-geoutils\";\n\nimport { ConcurrentWorkerSet } from \"./ConcurrentWorkerSet\";\n\n/**\n * Identifier of next decoder worker-service. Used to ensure uniqueness of service ids of decoders\n * dedicated to different datasources.\n */\nlet nextUniqueServiceId = 0;\n\n/**\n * Decoder based on [[ConcurrentWorkerSet]].\n *\n * Decodes tiles using workers running in separate contexts (also known as `WebWorkers`):\n * - connection establishment,\n * - sends decode requests,\n * - configuration.\n */\nexport class WorkerBasedDecoder implements ITileDecoder {\n    private serviceId: string;\n    private m_serviceCreated: boolean = false;\n\n    /**\n     * Creates a new `WorkerBasedDecoder`.\n     *\n     * @param workerSet - [[ConcurrentWorkerSet]] this tiler will live in.\n     * @param decoderServiceType - Service type identifier.\n     */\n    constructor(\n        private readonly workerSet: ConcurrentWorkerSet,\n        private readonly decoderServiceType: string\n    ) {\n        this.workerSet.addReference();\n        this.serviceId = `${this.decoderServiceType}-${nextUniqueServiceId++}`;\n    }\n\n    /**\n     * Dispose of dedicated tile decoder services in workers and remove reference to underlying\n     * [[ConcurrentWorkerSet]].\n     */\n    dispose() {\n        if (this.m_serviceCreated) {\n            this.workerSet\n                .broadcastRequest(WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {\n                    type: WorkerServiceProtocol.Requests.DestroyService,\n                    targetServiceId: this.serviceId\n                })\n                .catch(() => {\n                    /* Ignoring these errors as underlying workers possibly do not exist anymore. */\n                });\n        }\n\n        this.workerSet.removeReference();\n    }\n\n    /**\n     * Connects to [[WorkerServiceManager]]s in underlying [[ConcurrentWorkerSet]] and creates\n     * dedicated [[TileDecoderService]]s in all workers to serve decode requests.\n     */\n    async connect(): Promise<void> {\n        await this.workerSet.connect(WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID);\n        if (!this.m_serviceCreated) {\n            await this.workerSet.broadcastRequest(\n                WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID,\n                {\n                    type: WorkerServiceProtocol.Requests.CreateService,\n                    targetServiceType: this.decoderServiceType,\n                    targetServiceId: this.serviceId\n                }\n            );\n            this.m_serviceCreated = true;\n        }\n    }\n\n    /**\n     * Get {@link Tile} from tile decoder service in worker.\n     *\n     * @remarks\n     * Invokes {@link @here/harp-datasource-protocol#DecodeTileRequest} on\n     * [[TileDecoderService]] running in worker pool.\n     */\n    decodeTile(\n        data: ArrayBufferLike,\n        tileKey: TileKey,\n        projection: Projection,\n        requestController?: RequestController\n    ): Promise<DecodedTile> {\n        const tileKeyCode = tileKey.mortonCode();\n\n        const message: WorkerDecoderProtocol.DecodeTileRequest = {\n            type: WorkerDecoderProtocol.Requests.DecodeTileRequest,\n            tileKey: tileKeyCode,\n            data,\n            projection: getProjectionName(projection)\n        };\n\n        const transferList = data instanceof ArrayBuffer ? [data] : undefined;\n\n        return this.workerSet.invokeRequest(\n            this.serviceId,\n            message,\n            transferList,\n            requestController\n        );\n    }\n\n    /**\n     * Get {@link @here/harp-datasource-protocol#TileInfo} from tile decoder service in worker.\n     *\n     * @remarks\n     * Invokes {@link @here/harp-datasource-protocol#TileInfoRequest}\n     * on [[TileDecoderService]] running in worker pool.\n     */\n    getTileInfo(\n        data: ArrayBufferLike,\n        tileKey: TileKey,\n        projection: Projection,\n        requestController?: RequestController\n    ): Promise<TileInfo | undefined> {\n        const tileKeyCode = tileKey.mortonCode();\n\n        const message: WorkerDecoderProtocol.TileInfoRequest = {\n            type: WorkerDecoderProtocol.Requests.TileInfoRequest,\n            tileKey: tileKeyCode,\n            data,\n            projection: getProjectionName(projection)\n        };\n\n        const transferList = data instanceof ArrayBuffer ? [data] : undefined;\n        return this.workerSet.invokeRequest(\n            this.serviceId,\n            message,\n            transferList,\n            requestController\n        );\n    }\n\n    /**\n     * Configure tile decoder service in workers.\n     *\n     * @remarks\n     * Broadcasts {@link @here/harp-datasource-protocol#ConfigurationMessage}\n     * to all [[TileDecoderService]]s running in worker pool.\n     *\n     * @param styleSet -  new [[StyleSet]], undefined means no change\n     * @param languages - new list of languages\n     * @param options -   new options, undefined options are not changed\n     */\n    configure(\n        styleSet?: StyleSet,\n        definitions?: Definitions,\n        languages?: string[],\n        options?: OptionsMap\n    ): void {\n        const message: WorkerDecoderProtocol.ConfigurationMessage = {\n            service: this.serviceId,\n            type: WorkerDecoderProtocol.DecoderMessageName.Configuration,\n            styleSet,\n            definitions,\n            options,\n            languages\n        };\n\n        this.workerSet.broadcastMessage(message);\n    }\n\n    /**\n     * The number of workers started for this decoder. The value is `undefined` until the workers\n     * have been created.\n     */\n    get workerCount(): number | undefined {\n        return this.workerSet.workerCount;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ITiler } from \"@here/harp-datasource-protocol\";\nimport { ConcurrentWorkerSet } from \"./ConcurrentWorkerSet\";\nimport { WorkerBasedTiler } from \"./WorkerBasedTiler\";\n\n/**\n * Default concurrent tiler helper.\n *\n * A convenient singleton that maintains a separate [[ConcurrentWorkerSet]] for each bundle\n * requested. Provides easy access to {@link WorkerBasedTiler}s for data sources.\n */\nexport class ConcurrentTilerFacade {\n    /**\n     * The URL containing a script to fall back (default) to when looking for worker sets\n     * and tilers.\n     */\n    static defaultScriptUrl: string = \"./decoder.bundle.js\";\n\n    /**\n     * The default number of workers.\n     */\n    static defaultWorkerCount: number = 1;\n\n    /**\n     * Returns a {@link WorkerBasedTiler} instance.\n     *\n     * @param tilerServiceType - The name of the tiler service type.\n     * @param scriptUrl - The optional URL with the workers' script.\n     * @param workerCount - The number of web workers to use.\n     */\n    static getTiler(tilerServiceType: string, scriptUrl?: string, workerCount?: number): ITiler {\n        const workerSet = this.getWorkerSet(scriptUrl, workerCount);\n\n        return new WorkerBasedTiler(workerSet, tilerServiceType);\n    }\n\n    /**\n     * Returns a [[ConcurrentWorkerSet]] instance based on the script URL specified.\n     *\n     * @param scriptUrl - The optional URL with the workers' script. If not specified,\n     * the function uses [[defaultScriptUrl]] instead.\n     * @param workerCount - The number of web workers to use.\n     */\n    static getWorkerSet(scriptUrl?: string, workerCount?: number): ConcurrentWorkerSet {\n        if (scriptUrl === undefined) {\n            scriptUrl = this.defaultScriptUrl;\n        }\n\n        let workerSet = this.workerSets[scriptUrl];\n        if (workerSet === undefined) {\n            workerSet = new ConcurrentWorkerSet({\n                scriptUrl,\n                workerCount: workerCount === undefined ? this.defaultWorkerCount : workerCount\n            });\n            this.workerSets[scriptUrl] = workerSet;\n        }\n        return workerSet;\n    }\n\n    /**\n     * Destroys a [[ConcurrentWorkerSet]] instance.\n     *\n     * @param scriptUrl - The worker script URL that was used to create the [[ConcurrentWorkerSet]].\n     */\n    static destroyWorkerSet(scriptUrl: string) {\n        const workerSet = this.workerSets[scriptUrl];\n        if (workerSet !== undefined) {\n            workerSet.destroy();\n            delete this.workerSets[scriptUrl];\n        }\n    }\n\n    /**\n     * Destroys all managed [[ConcurrentWorkerSet]]s.\n     */\n    static destroy() {\n        Object.keys(this.workerSets).forEach(name => {\n            this.workerSets[name].destroy();\n        });\n        this.workerSets = {};\n    }\n\n    /**\n     * The [[ConcurrentWorkerSet]] instances which are stored by the script URL.\n     */\n    private static workerSets: {\n        [bundleUrl: string]: ConcurrentWorkerSet;\n    } = {};\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    GeoJson,\n    ITiler,\n    WorkerServiceProtocol,\n    WorkerTilerProtocol\n} from \"@here/harp-datasource-protocol\";\nimport { TileKey } from \"@here/harp-geoutils\";\nimport { ConcurrentWorkerSet } from \"./ConcurrentWorkerSet\";\n\n/**\n * Identifier of next tiler worker-service. Used to ensure uniqueness of service ids of tilers\n * dedicated to different datasources.\n */\nlet nextUniqueServiceId = 0;\n\n/**\n * Tiler based on [[ConcurrentWorkerSet]].\n *\n * Tiles payloads using workers running in separate contexts (also known as `WebWorkers`):\n * - connection establishment,\n * - sends tile requests,\n * - configuration.\n */\nexport class WorkerBasedTiler implements ITiler {\n    private serviceId: string;\n    private m_serviceCreated: boolean = false;\n\n    /**\n     * Creates a new `WorkerBasedTiler`.\n     *\n     * @param workerSet - [[ConcurrentWorkerSet]] this tiler will live in.\n     * @param tilerServiceType - Service type identifier.\n     */\n    constructor(\n        private readonly workerSet: ConcurrentWorkerSet,\n        private readonly tilerServiceType: string\n    ) {\n        this.workerSet.addReference();\n        this.serviceId = `${this.tilerServiceType}-${nextUniqueServiceId++}`;\n    }\n\n    /**\n     * Dispose of dedicated tiler services in workers and remove reference to underlying\n     * [[ConcurrentWorkerSet]].\n     */\n    dispose() {\n        if (this.m_serviceCreated) {\n            this.workerSet\n                .broadcastRequest(WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {\n                    type: WorkerServiceProtocol.Requests.DestroyService,\n                    targetServiceId: this.serviceId\n                })\n                .catch(() => {\n                    /* Ignoring these errors as underlying workers possibly do not exist anymore. */\n                });\n        }\n\n        this.workerSet.removeReference();\n    }\n\n    /**\n     * Connects to [[WorkerServiceManager]]s in underlying [[ConcurrentWorkerSet]] and creates\n     * dedicated [[TilerService]]s in all workers to serve tiling requests.\n     */\n    async connect(): Promise<void> {\n        await this.workerSet.connect(WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID);\n        if (!this.m_serviceCreated) {\n            await this.workerSet.broadcastRequest(\n                WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID,\n                {\n                    type: WorkerServiceProtocol.Requests.CreateService,\n                    targetServiceType: this.tilerServiceType,\n                    targetServiceId: this.serviceId\n                }\n            );\n\n            this.m_serviceCreated = true;\n        }\n    }\n\n    /**\n     * Register index in the tiler. Indexes registered in the tiler can be later used to retrieved\n     * tiled payloads using `getTile`.\n     *\n     * @param indexId - Index identifier.\n     * @param input - Url to the index payload, or direct GeoJSON.\n     */\n    registerIndex(indexId: string, input: URL | GeoJson): Promise<void> {\n        const message: WorkerTilerProtocol.RegisterIndexRequest = {\n            type: WorkerTilerProtocol.Requests.RegisterIndex,\n            id: indexId,\n            input: input instanceof URL ? input.href : (input as GeoJson)\n        };\n        return this.workerSet.invokeRequest(this.serviceId, message);\n    }\n\n    /**\n     * Update index in the tiler. Indexes registered in the tiler can be later used to retrieved\n     * tiled payloads using `getTile`.\n     *\n     * @param indexId - Index identifier.\n     * @param input - Url to the index payload, or direct GeoJSON.\n     */\n    updateIndex(indexId: string, input: URL | GeoJson): Promise<void> {\n        const message: WorkerTilerProtocol.UpdateIndexRequest = {\n            type: WorkerTilerProtocol.Requests.UpdateIndex,\n            id: indexId,\n            input: input instanceof URL ? input.href : (input as GeoJson)\n        };\n        return this.workerSet.invokeRequest(this.serviceId, message);\n    }\n\n    /**\n     * Retrieves a tile for a previously registered index.\n     *\n     * @param indexId - Index identifier.\n     * @param tileKey - The {@link @here/harp-geoutils#TileKey} that identifies the tile.\n     */\n    getTile(indexId: string, tileKey: TileKey): Promise<{}> {\n        const tileKeyCode = tileKey.mortonCode();\n        const message: WorkerTilerProtocol.TileRequest = {\n            type: WorkerTilerProtocol.Requests.TileRequest,\n            index: indexId,\n            tileKey: tileKeyCode\n        };\n        return this.workerSet.invokeRequest(this.serviceId, message);\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Theme } from \"@here/harp-datasource-protocol\";\nimport { TileKey, TilingScheme, webMercatorTilingScheme } from \"@here/harp-geoutils\";\nimport { DataSource } from \"./DataSource\";\nimport { TileGeometryCreator } from \"./geometry/TileGeometryCreator\";\nimport { Tile } from \"./Tile\";\n\n/**\n * Provides background geometry for all tiles.\n */\nexport class BackgroundDataSource extends DataSource {\n    private static readonly DEFAULT_TILING_SCHEME = webMercatorTilingScheme;\n    private m_tilingScheme: TilingScheme = BackgroundDataSource.DEFAULT_TILING_SCHEME;\n\n    constructor() {\n        super({ name: \"background\" });\n        this.cacheable = true;\n        this.addGroundPlane = true;\n    }\n\n    updateStorageLevelOffset() {\n        let storageLevelOffset: number | undefined;\n\n        this.mapView.dataSources.forEach(ds => {\n            if (ds === this) {\n                return;\n            }\n            const tilingScheme = ds.getTilingScheme();\n            if (tilingScheme === this.m_tilingScheme) {\n                storageLevelOffset =\n                    storageLevelOffset === undefined\n                        ? ds.storageLevelOffset\n                        : Math.max(storageLevelOffset, ds.storageLevelOffset);\n            }\n        });\n\n        if (storageLevelOffset === undefined) {\n            storageLevelOffset = 0;\n        }\n\n        if (storageLevelOffset !== this.storageLevelOffset) {\n            this.storageLevelOffset = storageLevelOffset;\n            this.mapView.clearTileCache(this.name);\n        }\n    }\n\n    /** @override */\n    setTheme(theme: Theme, languages?: string[]) {\n        this.mapView.clearTileCache(this.name);\n    }\n\n    setTilingScheme(tilingScheme?: TilingScheme) {\n        const newScheme = tilingScheme || BackgroundDataSource.DEFAULT_TILING_SCHEME;\n        if (newScheme === this.m_tilingScheme) {\n            return;\n        }\n\n        this.m_tilingScheme = newScheme;\n        this.updateStorageLevelOffset();\n        this.mapView.clearTileCache(this.name);\n    }\n\n    /** @override */\n    getTilingScheme(): TilingScheme {\n        return this.m_tilingScheme;\n    }\n\n    /** @override */\n    getTile(tileKey: TileKey): Tile | undefined {\n        const tile = new Tile(this, tileKey);\n        tile.forceHasGeometry(true);\n        tile.removeDecodedTile(); // Skip geometry loading.\n        TileGeometryCreator.instance.addGroundPlane(tile, Number.MIN_SAFE_INTEGER);\n\n        return tile;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    BooleanLiteralExpr,\n    CallExpr,\n    CaseExpr,\n    Expr,\n    ExprVisitor,\n    HasAttributeExpr,\n    InterpolateExpr,\n    MatchExpr,\n    NullLiteralExpr,\n    NumberLiteralExpr,\n    ObjectLiteralExpr,\n    StepExpr,\n    StringLiteralExpr,\n    VarExpr\n} from \"./Expr\";\n\nimport { Value } from \"./Env\";\n\n/**\n * [[ExprPool]] maintains a set of unique interned {@link Expr} objects.\n *\n * @hidden\n */\nexport class ExprPool implements ExprVisitor<Expr, void> {\n    private readonly m_booleanLiterals = new Map<boolean, BooleanLiteralExpr>();\n    private readonly m_numberLiterals = new Map<number, NumberLiteralExpr>();\n    private readonly m_stringLiterals = new Map<string, StringLiteralExpr>();\n    private readonly m_objectLiterals = new Map<object, ObjectLiteralExpr>();\n    private readonly m_arrayLiterals: ObjectLiteralExpr[] = [];\n    private readonly m_varExprs = new Map<string, VarExpr>();\n    private readonly m_hasAttributeExprs = new Map<string, HasAttributeExpr>();\n    private readonly m_matchExprs: MatchExpr[] = [];\n    private readonly m_caseExprs: CaseExpr[] = [];\n    private readonly m_interpolateExprs: InterpolateExpr[] = [];\n    private readonly m_stepExprs: StepExpr[] = [];\n    private readonly m_callExprs = new Map<string, CallExpr[]>();\n\n    /**\n     * Add `expr` to this [[ExprPool]] and return a unique {@link Expr}\n     * object that is structurally equivalent to `expr`.\n     *\n     * @param expr - The {@link Expr} to add to this [[ExprPool]].\n     * @returns A unique {@link Expr} that is structurally equivalent to `expr`.\n     */\n    add(expr: Expr): Expr {\n        return expr.accept(this, undefined);\n    }\n\n    visitNullLiteralExpr(expr: NullLiteralExpr, context: void): Expr {\n        return NullLiteralExpr.instance;\n    }\n\n    visitBooleanLiteralExpr(expr: BooleanLiteralExpr, context: void): Expr {\n        const e = this.m_booleanLiterals.get(expr.value);\n        if (e) {\n            return e;\n        }\n        this.m_booleanLiterals.set(expr.value, expr);\n        return expr;\n    }\n\n    visitNumberLiteralExpr(expr: NumberLiteralExpr, context: void): Expr {\n        const e = this.m_numberLiterals.get(expr.value);\n        if (e) {\n            return e;\n        }\n        this.m_numberLiterals.set(expr.value, expr);\n        return expr;\n    }\n\n    visitStringLiteralExpr(expr: StringLiteralExpr, context: void): Expr {\n        const e = this.m_stringLiterals.get(expr.value);\n        if (e) {\n            return e;\n        }\n        this.m_stringLiterals.set(expr.value, expr);\n        return expr;\n    }\n\n    visitObjectLiteralExpr(expr: ObjectLiteralExpr, context: void): Expr {\n        const e = this.m_objectLiterals.get(expr.value);\n        if (e) {\n            return e;\n        }\n\n        if (Array.isArray(expr.value)) {\n            const array = expr.value as Value[];\n\n            const r = this.m_arrayLiterals.find(literal => {\n                const elements = literal.value as Value[];\n                if (elements.length !== array.length) {\n                    return false;\n                }\n                return array.every((x, i) => x === elements[i]);\n            });\n\n            if (r !== undefined) {\n                return r;\n            }\n\n            this.m_arrayLiterals.push(expr);\n        }\n\n        this.m_objectLiterals.set(expr.value, expr);\n\n        return expr;\n    }\n\n    visitVarExpr(expr: VarExpr, context: void): Expr {\n        const e = this.m_varExprs.get(expr.name);\n        if (e) {\n            return e;\n        }\n        this.m_varExprs.set(expr.name, expr);\n        return expr;\n    }\n\n    visitHasAttributeExpr(expr: HasAttributeExpr, context: void): Expr {\n        const e = this.m_hasAttributeExprs.get(expr.name);\n        if (e) {\n            return e;\n        }\n        this.m_hasAttributeExprs.set(expr.name, expr);\n        return expr;\n    }\n\n    visitMatchExpr(expr: MatchExpr, context: void): Expr {\n        const value = expr.value.accept(this, context);\n        const branches: typeof expr.branches = expr.branches.map(([label, body]) => [\n            label,\n            body.accept(this, context)\n        ]);\n        const fallback = expr.fallback.accept(this, context);\n        for (const candidate of this.m_matchExprs) {\n            if (candidate.value !== value) {\n                continue;\n            }\n            if (candidate.fallback !== fallback) {\n                continue;\n            }\n            if (candidate.branches.length !== branches.length) {\n                continue;\n            }\n            let branchesMatching = true;\n            for (let i = 0; i < branches.length; i++) {\n                if (\n                    branches[i][0] !== candidate.branches[i][0] ||\n                    branches[i][1] !== candidate.branches[i][1]\n                ) {\n                    branchesMatching = false;\n                    break;\n                }\n            }\n            if (branchesMatching) {\n                return candidate;\n            }\n        }\n        const r = new MatchExpr(value, branches, fallback);\n        this.m_matchExprs.push(r);\n        return r;\n    }\n\n    visitCaseExpr(expr: CaseExpr, context: void): Expr {\n        const branches: typeof expr.branches = expr.branches.map(([condition, body]) => [\n            condition.accept(this, context),\n            body.accept(this, context)\n        ]);\n        const fallback = expr.fallback.accept(this, context);\n\n        for (const candidate of this.m_caseExprs) {\n            if (candidate.fallback !== fallback) {\n                continue;\n            }\n            if (candidate.branches.length !== branches.length) {\n                continue;\n            }\n            let branchesMatching = true;\n            for (let i = 0; i < branches.length; i++) {\n                if (\n                    branches[i][0] !== candidate.branches[i][0] ||\n                    branches[i][1] !== candidate.branches[i][1]\n                ) {\n                    branchesMatching = false;\n                    break;\n                }\n            }\n            if (branchesMatching) {\n                return candidate;\n            }\n        }\n\n        const r = new CaseExpr(branches, fallback);\n        this.m_caseExprs.push(r);\n        return r;\n    }\n\n    visitCallExpr(expr: CallExpr, context: void): Expr {\n        // rewrite the actual arguments\n        const expressions = expr.args.map(childExpr => childExpr.accept(this, context));\n        // ensure we have a valid set of interned expressions for the calls\n        if (!this.m_callExprs.has(expr.op)) {\n            this.m_callExprs.set(expr.op, []);\n        }\n        // get the calls for the given operator.\n        const calls = this.m_callExprs.get(expr.op)!;\n        for (const call of calls) {\n            // check the number of arguments\n            if (call.args.length !== expressions.length) {\n                continue;\n            }\n            // find the index of the first mismatch.\n            let index = 0;\n            for (; index < call.args.length; ++index) {\n                if (call.args[index] !== expressions[index]) {\n                    break;\n                }\n            }\n            if (index === call.args.length) {\n                // no mismatch found, return the 'interned' call.\n                return call;\n            }\n        }\n        const e = new CallExpr(expr.op, expressions);\n        e.descriptor = expr.descriptor;\n        calls.push(e);\n        return e;\n    }\n\n    visitStepExpr(expr: StepExpr, context: void): Expr {\n        if (this.m_stepExprs.includes(expr)) {\n            return expr;\n        }\n        const input = expr.input.accept(this, context);\n        const defaultValue = expr.defaultValue.accept(this, context);\n        const stops: Array<[number, Expr]> = expr.stops.map(stop => {\n            const key = stop[0];\n            const value = stop[1].accept(this, context);\n            return value === stop[1] ? stop : [key, value];\n        });\n        for (const step of this.m_stepExprs) {\n            if (\n                step.input === input &&\n                step.defaultValue === defaultValue &&\n                stops.length === step.stops.length &&\n                stops.every(\n                    ([key, value], i) => key === step.stops[i][0] && value === step.stops[i][1]\n                )\n            ) {\n                return step;\n            }\n        }\n        const e = new StepExpr(input, defaultValue, stops);\n        this.m_stepExprs.push(e);\n        return e;\n    }\n\n    visitInterpolateExpr(expr: InterpolateExpr, context: void): Expr {\n        if (this.m_interpolateExprs.includes(expr)) {\n            return expr;\n        }\n        const input = expr.input.accept(this, context);\n        const stops: Array<[number, Expr]> = expr.stops.map(stop => {\n            const key = stop[0];\n            const value = stop[1].accept(this, context);\n            return value === stop[1] ? stop : [key, value];\n        });\n        for (const interp of this.m_interpolateExprs) {\n            if (\n                interp.input === input &&\n                interp.mode[0] === expr.mode[0] &&\n                interp.mode[1] === expr.mode[1] &&\n                stops.length === interp.stops.length &&\n                stops.every(\n                    ([key, value], i) => key === interp.stops[i][0] && value === interp.stops[i][1]\n                )\n            ) {\n                return interp;\n            }\n        }\n        const e = new InterpolateExpr(expr.mode, input, stops);\n        this.m_interpolateExprs.push(e);\n        return e;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { BufferAttribute, BufferGeometry, Vector3 } from \"three\";\n\nconst tmpVectorA = new Vector3();\nconst tmpVectorB = new Vector3();\nconst tmpVectorC = new Vector3();\n\n/**\n * The [[SubdivisionModifier]] subdivides triangle mesh geometries.\n */\nexport abstract class SubdivisionModifier {\n    /**\n     * Constructs a new [[SubdivisionModifier]].\n     */\n    constructor() {\n        // nothing to do\n    }\n\n    /**\n     * Subdivides the faces of the given [[THREE.BufferGeometry]].\n     *\n     * This method modifies (in-place) the vertices and the faces of the geometry.\n     * Please note that only the vertex position and their UV coordinates are subdivided.\n     * Normals, vertex colors and other attributes are left unmodified.\n     *\n     * @param geometry - The [[THREE.BufferGeometry]] to subdivide.\n     */\n    modify(geometry: BufferGeometry): BufferGeometry {\n        const positionAttr = geometry.getAttribute(\"position\") as BufferAttribute;\n        const position = Array.from(positionAttr.array);\n\n        const uvAttr = geometry.getAttribute(\"uv\") as BufferAttribute;\n        const uv = uvAttr !== undefined ? Array.from(uvAttr.array) : undefined;\n\n        const edgeAttr = geometry.getAttribute(\"edge\") as BufferAttribute;\n        const edge = edgeAttr !== undefined ? Array.from(edgeAttr.array) : undefined;\n\n        const wallAttr = geometry.getAttribute(\"wall\") as BufferAttribute;\n        const wall = wallAttr !== undefined ? Array.from(wallAttr.array) : undefined;\n\n        const indexAttr = geometry.getIndex() as BufferAttribute;\n        const indices = Array.from(indexAttr.array);\n\n        // A cache containing the indices of the vertices added\n        // when subdiving the faces of the geometry.\n        const cache = new Map<string, number>();\n\n        /**\n         * Returns the index of the vertex positioned in the middle of the given vertices.\n         */\n        function middleVertex(i: number, j: number): number {\n            // Build a unique `key` for the pair of indices `(i, j)`.\n            const key = `${Math.min(i, j)}_${Math.max(i, j)}`;\n\n            const h = cache.get(key);\n\n            if (h !== undefined) {\n                // Nothing to do, a vertex in the middle of (i, j) was already created.\n                return h;\n            }\n\n            // The position of the new vertex.\n            tmpVectorA.set(position[i * 3], position[i * 3 + 1], position[i * 3 + 2]);\n            tmpVectorB.set(position[j * 3], position[j * 3 + 1], position[j * 3 + 2]);\n            tmpVectorC.lerpVectors(tmpVectorA, tmpVectorB, 0.5);\n\n            // The index of the new vertex.\n            const index = position.length / 3;\n            position.push(...tmpVectorC.toArray());\n            // Cache the position of the new vertex.\n            cache.set(key, index);\n\n            // The uvs of the new vertex.\n            if (uv !== undefined) {\n                tmpVectorA.set(uv[i * 2], uv[i * 2 + 1], 0);\n                tmpVectorB.set(uv[j * 2], uv[j * 2 + 1], 0);\n                tmpVectorC.lerpVectors(tmpVectorA, tmpVectorB, 0.5);\n                uv.push(tmpVectorC.x, tmpVectorC.y);\n            }\n\n            // The edge and wall attributes of the new vertex.\n            // If a new vertex has been introduced between i and j, connect the elements\n            // accordingly.\n            if (edge !== undefined) {\n                if (edge[i] === j) {\n                    edge.push(j);\n                    edge[i] = index;\n                } else if (edge[j] === i) {\n                    edge.push(i);\n                    edge[j] = index;\n                } else {\n                    edge.push(-1);\n                }\n            }\n            if (wall !== undefined) {\n                if (wall[i] === j) {\n                    wall.push(j);\n                    wall[i] = index;\n                } else if (wall[j] === i) {\n                    wall.push(i);\n                    wall[j] = index;\n                } else {\n                    wall.push(-1);\n                }\n            }\n\n            return index;\n        }\n\n        const newIndices = [];\n        while (indices.length >= 3) {\n            const v0 = indices.shift()!;\n            const v1 = indices.shift()!;\n            const v2 = indices.shift()!;\n\n            tmpVectorA.set(position[v0 * 3], position[v0 * 3 + 1], position[v0 * 3 + 2]);\n            tmpVectorB.set(position[v1 * 3], position[v1 * 3 + 1], position[v1 * 3 + 2]);\n            tmpVectorC.set(position[v2 * 3], position[v2 * 3 + 1], position[v2 * 3 + 2]);\n\n            const edgeToSplit = this.shouldSplitTriangle(tmpVectorA, tmpVectorB, tmpVectorC);\n\n            switch (edgeToSplit) {\n                case 0: {\n                    const v3 = middleVertex(v0, v1);\n                    indices.push(v0, v3, v2, v3, v1, v2);\n                    break;\n                }\n\n                case 1: {\n                    const v3 = middleVertex(v1, v2);\n                    indices.push(v0, v1, v3, v0, v3, v2);\n                    break;\n                }\n\n                case 2: {\n                    const v3 = middleVertex(v2, v0);\n                    indices.push(v0, v1, v3, v3, v1, v2);\n                    break;\n                }\n\n                case undefined: {\n                    newIndices.push(v0, v1, v2);\n                    break;\n                }\n\n                default:\n                    throw new Error(\"failed to subdivide the given geometry\");\n            }\n        }\n\n        positionAttr.array = new Float32Array(position);\n        positionAttr.count = position.length / positionAttr.itemSize;\n        positionAttr.needsUpdate = true;\n\n        geometry.setIndex(newIndices);\n\n        if (uv !== undefined) {\n            uvAttr.array = new Float32Array(uv);\n            uvAttr.count = uv.length / uvAttr.itemSize;\n            uvAttr.needsUpdate = true;\n        }\n\n        if (edge !== undefined) {\n            edgeAttr.array = new Float32Array(edge);\n            edgeAttr.count = edge.length / edgeAttr.itemSize;\n            edgeAttr.needsUpdate = true;\n        }\n\n        return geometry;\n    }\n\n    /**\n     * Returns if the given triangle should be subdivide.\n     *\n     * Implementations of this function should return the index of\n     * the edge of the triangle to split (0, 1, or 2) or undefined if\n     * the triangle doesn't need to be subdivided.\n     *\n     * @param a - The position of the first vertex of the triangle.\n     * @param b - The position of the second vertex of the triangle.\n     * @param c - The position of the third vertex of the triangle.\n     */\n    protected abstract shouldSplitTriangle(a: Vector3, b: Vector3, c: Vector3): number | undefined;\n}\n","/*\n * Copyright (C) 2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Vector3Like } from \"@here/harp-geoutils\";\nimport { sampleBilinear } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\nimport { VertexCache } from \"./VertexCache\";\n\n/**\n * @internal\n * BufferAttribute decorator that displaces on the fly the coordinates in a given attribute using a\n * specified displacement map.\n */\nexport class DisplacedBufferAttribute extends THREE.BufferAttribute {\n    private static MAX_CACHE_SIZE = 6;\n    private m_texture?: Float32Array;\n    private m_textureWidth: number = 0;\n    private m_textureHeight: number = 0;\n    private m_cache = new VertexCache(DisplacedBufferAttribute.MAX_CACHE_SIZE);\n    private m_lastBufferIndex?: number;\n    private m_lastPos = new THREE.Vector3();\n    private m_tmpNormal = new THREE.Vector3();\n\n    /**\n     * Creates an instance of displaced buffer attribute.\n     * @param originalAttribute - The buffer attribute to be displaced\n     *                            (e.g. the position attribute).\n     * @param m_normals - The normals along which the coordinates will be displaced.\n     * @param m_uvs - The uv coordinates to be used to sample the displacement map.\n     * @param displacementMap - A texture with the displacement values in 32bit floats.\n     */\n    constructor(\n        public originalAttribute: THREE.BufferAttribute | THREE.InterleavedBufferAttribute,\n        private m_normals: THREE.BufferAttribute | THREE.InterleavedBufferAttribute,\n        private m_uvs: THREE.BufferAttribute | THREE.InterleavedBufferAttribute,\n        displacementMap: THREE.DataTexture\n    ) {\n        super(originalAttribute.array, originalAttribute.itemSize, originalAttribute.normalized);\n        this.resetTexture(displacementMap);\n    }\n\n    /**\n     * Resets the displaced buffer attribute to use new buffer attributes or displacement map.\n     * @param originalAttribute - The buffer attribute to be displaced\n     *                            (e.g. the position attribute).\n     * @param normals - The normals along which the coordinates will be displaced.\n     * @param uvs -  The uv coordinates to be used to sample the displacement map.\n     * @param displacementMap - A texture with the displacement values in 32bit floats.\n     */\n    reset(\n        originalAttribute: THREE.BufferAttribute | THREE.InterleavedBufferAttribute,\n        normals: THREE.BufferAttribute | THREE.InterleavedBufferAttribute,\n        uvs: THREE.BufferAttribute | THREE.InterleavedBufferAttribute,\n        displacementMap: THREE.DataTexture\n    ) {\n        this.array = originalAttribute.array;\n        this.itemSize = originalAttribute.itemSize;\n        this.count = this.array.length / this.itemSize;\n        this.normalized = originalAttribute.normalized;\n        this.originalAttribute = originalAttribute;\n        this.m_normals = normals;\n        this.m_uvs = uvs;\n        this.m_cache.clear();\n        this.m_lastBufferIndex = undefined;\n        this.resetTexture(displacementMap);\n    }\n\n    // HARP-9585: These getters are overrides of the base class ones, however tslint doesn't\n    // recognize them as such.\n    getX(index: number): number {\n        return this.getDisplacedCoordinate(index).x;\n    }\n    getY(index: number): number {\n        return this.getDisplacedCoordinate(index).y;\n    }\n    getZ(index: number): number {\n        return this.getDisplacedCoordinate(index).z;\n    }\n\n    private resetTexture(displacementMap: THREE.DataTexture) {\n        this.m_texture = new Float32Array(displacementMap.image.data.buffer);\n        this.m_textureWidth = displacementMap.image.width;\n        this.m_textureHeight = displacementMap.image.height;\n    }\n    private getDisplacedCoordinate(bufferIndex: number): Vector3Like {\n        if (bufferIndex === this.m_lastBufferIndex) {\n            return this.m_lastPos;\n        }\n        this.m_lastBufferIndex = bufferIndex;\n        if (this.m_cache.get(bufferIndex, this.m_lastPos)) {\n            return this.m_lastPos;\n        }\n        this.displacePosition(bufferIndex);\n        this.m_cache.set(bufferIndex, this.m_lastPos);\n        return this.m_lastPos;\n    }\n    private displacePosition(bufferIndex: number) {\n        this.m_lastPos.fromBufferAttribute(\n            this.originalAttribute as THREE.BufferAttribute,\n            bufferIndex\n        );\n        const normals = this.m_normals as THREE.BufferAttribute;\n        this.m_tmpNormal.fromBufferAttribute(normals, bufferIndex);\n        const uvs = this.m_uvs;\n        const u = THREE.MathUtils.clamp(uvs.getX(bufferIndex), 0, 1);\n        const v = THREE.MathUtils.clamp(uvs.getY(bufferIndex), 0, 1);\n        const displacement = sampleBilinear(\n            this.m_texture!,\n            this.m_textureWidth,\n            this.m_textureHeight,\n            u,\n            v\n        );\n        this.m_lastPos.add(this.m_tmpNormal.multiplyScalar(displacement));\n    }\n}\n","/*\n * Copyright (C) 2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\nimport { DisplacedBufferAttribute } from \"./DisplacedBufferAttribute\";\n\nconst tmpV1 = new THREE.Vector3();\nconst tmpV2 = new THREE.Vector3();\nconst tmpBox = new THREE.Box3();\n\n/**\n * @internal\n * Range of displacement values found in a given displacement map.\n */\nexport interface DisplacementRange {\n    min: number;\n    max: number;\n}\n\n/**\n * @internal\n * Displace a box in a given direction by a specified range. The original box min and max vertices\n * are translated as a result by displacementRange.min and displacementRange.max respectively.\n * @param box - The original box to displace.\n * @param displacementRange - The minimum and maximum displacement values.\n * @param displacementDir - Direction in which the displacement will be applied.\n * @return The displaced box.\n */\nexport function displaceBox(\n    box: THREE.Box3,\n    displacementRange: DisplacementRange,\n    displacementDir: THREE.Vector3\n): THREE.Box3 {\n    tmpBox.copy(box);\n    const tmpNormalMin = tmpV1.copy(displacementDir);\n    const tmpNormalMax = tmpV2.copy(tmpNormalMin);\n    box.translate(tmpNormalMin.multiplyScalar(displacementRange.min)).union(\n        tmpBox.translate(tmpNormalMax.multiplyScalar(displacementRange.max))\n    );\n    return box;\n}\n\n/**\n * @internal\n * BufferGeometry decorator that displaces on the fly the position attribute using a specified\n * displacement map.\n */\nexport class DisplacedBufferGeometry extends THREE.BufferGeometry {\n    private m_displacedPositions: DisplacedBufferAttribute;\n    private m_originalBoundingBox = new THREE.Box3();\n\n    /**\n     * Creates an instance of displaced buffer geometry.\n     * @param originalGeometry - The goeometry to be displaced.\n     * @param displacementMap - A texture with the displacement values.\n     * @param displacementRange - The displacement value range found in the displacement map.\n     * @param displacedPositions - Buffer attribute that will be used for displaced positions if\n     * provided, otherwise a new buffer attribute will be created.\n     */\n    constructor(\n        public originalGeometry: THREE.BufferGeometry,\n        displacementMap: THREE.DataTexture,\n        public displacementRange: DisplacementRange,\n        displacedPositions?: DisplacedBufferAttribute\n    ) {\n        super();\n        if (!displacedPositions) {\n            this.m_displacedPositions = new DisplacedBufferAttribute(\n                originalGeometry.attributes.position,\n                originalGeometry.attributes.normal,\n                originalGeometry.attributes.uv,\n                displacementMap\n            );\n        } else {\n            this.m_displacedPositions = displacedPositions;\n        }\n        this.resetAttributes();\n    }\n\n    /**\n     * Resets the displaced buffer geometry to use new geometry or displacement map.\n     * @param geometry - The goeometry to be displaced.\n     * @param displacementMap - A texture with the displacement values.\n     * @param displacementRange - The displacement value range found in the displacement map.\n     */\n    reset(\n        geometry: THREE.BufferGeometry,\n        displacementMap: THREE.DataTexture,\n        displacementRange: DisplacementRange\n    ) {\n        this.originalGeometry = geometry;\n        const positions = geometry.attributes.position;\n        const normals = geometry.attributes.normal;\n        const uvs = geometry.attributes.uv;\n        this.m_displacedPositions.reset(positions, normals, uvs, displacementMap);\n        const displacementRangeChanged =\n            this.displacementRange.min !== displacementRange.min ||\n            this.displacementRange.max !== displacementRange.max;\n        this.displacementRange = displacementRange;\n        this.resetAttributes();\n        this.resetBoundingVolumes(displacementRangeChanged);\n    }\n\n    // HARP-9585: Override of base class method, however tslint doesn't recognize it as such.\n    // tslint:disable-next-line: explicit-override\n    computeBoundingBox(): void {\n        // Calculate a coarse approximation of the displaced geometry bbox by displacing the\n        // original bbox and enlarging it to cover the whole displacement range.\n        // This approximation is used to avoid having to displace the whole geometry, which will\n        // be done only if the bbox test passes.\n        if (this.originalGeometry.boundingBox === null) {\n            this.originalGeometry.computeBoundingBox();\n        }\n        const origBBox = this.m_originalBoundingBox.copy(this.originalGeometry.boundingBox!);\n        if (this.boundingBox === null) {\n            this.boundingBox = origBBox.clone();\n        } else {\n            this.boundingBox.copy(origBBox);\n        }\n        displaceBox(\n            this.boundingBox,\n            this.displacementRange,\n            tmpV1.fromBufferAttribute(this.attributes.normal as THREE.BufferAttribute, 0)\n        );\n    }\n\n    // HARP-9585: Override of base class method, however tslint doesn't recognize it as such.\n    // tslint:disable-next-line: explicit-override\n    computeBoundingSphere(): void {\n        // Use as coarse approximation the sphere bounding the bbox.\n        if (this.boundingBox === null) {\n            this.computeBoundingBox();\n        }\n        if (this.boundingSphere === null) {\n            this.boundingSphere = new THREE.Sphere();\n        }\n        this.boundingBox!.getBoundingSphere(this.boundingSphere!);\n    }\n\n    private needsBoundingBoxUpdate(displacementRangeChanged: boolean): boolean {\n        return (\n            displacementRangeChanged ||\n            (this.boundingBox !== null &&\n                (!this.originalGeometry.boundingBox ||\n                    !this.m_originalBoundingBox.equals(this.originalGeometry.boundingBox)))\n        );\n    }\n\n    private resetBoundingVolumes(displacementRangeChanged: boolean) {\n        if (this.needsBoundingBoxUpdate(displacementRangeChanged)) {\n            this.computeBoundingBox();\n            if (this.boundingSphere) {\n                this.computeBoundingSphere();\n            }\n        }\n    }\n\n    private resetAttributes() {\n        this.index = this.originalGeometry.index;\n        this.groups = this.originalGeometry.groups;\n        this.drawRange = this.originalGeometry.drawRange;\n        this.attributes = { ...this.originalGeometry.attributes };\n        this.attributes.position = this.m_displacedPositions;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport {\n    Light,\n    MagFilter,\n    MinFilter,\n    PixelFormat,\n    TextureDataType,\n    WrappingMode\n} from \"@here/harp-datasource-protocol\";\n\n/**\n * Returns `three.js` pixel format object basing on a [[PixelFormat]] specified.\n */\nexport function toPixelFormat(format: PixelFormat): THREE.PixelFormat {\n    switch (format) {\n        case \"Alpha\":\n            return THREE.AlphaFormat;\n        case \"RGB\":\n            return THREE.RGBFormat;\n        case \"RGBA\":\n            return THREE.RGBAFormat;\n        case \"Luminance\":\n            return THREE.LuminanceFormat;\n        case \"LuminanceAlpha\":\n            return THREE.LuminanceAlphaFormat;\n        case \"RGBE\":\n            return THREE.RGBEFormat;\n        case \"Depth\":\n            return THREE.DepthFormat;\n        case \"DepthStencil\":\n            return THREE.DepthStencilFormat;\n        case \"Red\":\n            return THREE.RedFormat;\n        default:\n            throw new Error(`invalid pixel format: ${format}`);\n    }\n}\n\n/**\n * Returns `three.js` texture data types based on a [[TextureDataType]] specified.\n */\nexport function toTextureDataType(dataType: TextureDataType): THREE.TextureDataType {\n    switch (dataType) {\n        case \"UnsignedByte\":\n            return THREE.UnsignedByteType;\n        case \"Byte\":\n            return THREE.ByteType;\n        case \"Short\":\n            return THREE.ShortType;\n        case \"UnsignedShort\":\n            return THREE.UnsignedShortType;\n        case \"Int\":\n            return THREE.IntType;\n        case \"UnsignedInt\":\n            return THREE.UnsignedIntType;\n        case \"Float\":\n            return THREE.FloatType;\n        case \"HalfFloat\":\n            return THREE.HalfFloatType;\n        default:\n            throw new Error(`invalid texture data type: ${dataType}`);\n    }\n}\n\n/**\n * Returns `three.js` wrapping mode object based on a [[WrappingMode]] specified.\n */\nexport function toWrappingMode(mode: WrappingMode): THREE.Wrapping {\n    switch (mode) {\n        case \"clamp\":\n            return THREE.ClampToEdgeWrapping;\n        case \"repeat\":\n            return THREE.RepeatWrapping;\n        case \"mirror\":\n            return THREE.MirroredRepeatWrapping;\n        default:\n            throw new Error(`invalid wrapping mode: ${mode}`);\n    }\n}\n\n/**\n * Returns `three.js` texture filter object based on a [[MagFilter]] or [[MinFilter]] specified.\n */\nexport function toTextureFilter(filter: MagFilter | MinFilter): THREE.TextureFilter {\n    switch (filter) {\n        case \"nearest\":\n            return THREE.NearestFilter;\n        case \"nearestMipMapNearest\":\n            return THREE.NearestMipMapNearestFilter;\n        case \"nearestMipMapLinear\":\n            return THREE.NearestMipMapLinearFilter;\n        case \"linear\":\n            return THREE.LinearFilter;\n        case \"linearMipMapNearest\":\n            return THREE.LinearMipMapNearestFilter;\n        case \"linearMipMapLinear\":\n            return THREE.LinearMipMapLinearFilter;\n        default:\n            throw new Error(`invalid texture filter: ${filter}`);\n    }\n}\n\n/**\n * Create a specific light for lighting the map.\n */\nexport function createLight(lightDescription: Light): THREE.Light {\n    switch (lightDescription.type) {\n        case \"ambient\": {\n            const light = new THREE.AmbientLight(\n                lightDescription.color,\n                lightDescription.intensity\n            );\n            light.name = lightDescription.name;\n            return light;\n        }\n        case \"directional\": {\n            const light = new THREE.DirectionalLight(\n                lightDescription.color,\n                lightDescription.intensity\n            );\n            light.name = lightDescription.name;\n            if (lightDescription.castShadow !== undefined) {\n                light.castShadow = lightDescription.castShadow;\n            }\n            if (light.castShadow) {\n                light.shadow.bias = 0.00001;\n                light.shadow.mapSize.width = 1024;\n                light.shadow.mapSize.height = 1024;\n            }\n            light.position.set(\n                lightDescription.direction.x,\n                lightDescription.direction.y,\n                lightDescription.direction.z\n            );\n            light.position.normalize();\n            return light;\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { Env, ExtrudedPolygonTechnique } from \"@here/harp-datasource-protocol\";\nimport { ColorUtils } from \"@here/harp-datasource-protocol/lib/ColorUtils\";\nimport { enforceBlending, MapMeshStandardMaterial } from \"@here/harp-materials\";\nimport { evaluateBaseColorProperty } from \"./DecodedTileHelpers\";\n\n/**\n * Bitmask used for the depth pre-pass to prevent multiple fragments in the same screen position\n * from rendering color.\n */\nexport const DEPTH_PRE_PASS_STENCIL_MASK = 0x01;\n\n/**\n * Render order offset for the depth pre-pass to ensure that it's rendered first.\n */\nconst DEPTH_PRE_PASS_RENDER_ORDER_OFFSET = 1e-6;\n\n/**\n * Check if technique requires (and not disables) use of depth prepass.\n *\n * Depth prepass is enabled if correct opacity is specified (in range `(0,1)`) _and_ not explicitly\n * disabled by `enableDepthPrePass` option.\n *\n * @param technique - [[BaseStandardTechnique]] instance to be checked\n * @param env - {@link @here/harp-datasource-protocol#Env} instance used\n *              to evaluate {@link @here/harp-datasource-protocol#Expr}\n *              based properties of [[Technique]]\n */\nexport function isRenderDepthPrePassEnabled(technique: ExtrudedPolygonTechnique, env: Env) {\n    // Depth pass explicitly disabled\n    if (technique.enableDepthPrePass === false) {\n        return false;\n    }\n    let transparent =\n        technique.opacity !== undefined && technique.opacity > 0.0 && technique.opacity < 1.0;\n    // If not opaque then check if transparency may be modified via alpha in base color.\n    // Otherwise we don't need to even test base color because opacity mixed with any base alpha,\n    // will always produce some transparency effect.\n    if (!transparent) {\n        // We do not support switching depth pass during alpha interpolation, ignore zoom level\n        // when calculating base color value.\n        const color = evaluateBaseColorProperty(technique, env);\n        if (color !== undefined) {\n            const alpha = ColorUtils.getAlphaFromHex(color);\n            transparent = alpha > 0.0 && alpha < 1.0;\n        }\n    }\n    return transparent;\n}\n\n/**\n * Property identifying a material that is being used as a DepthPrePass material.\n */\nexport interface DepthPrePassProperties {\n    /**\n     * This material is a special depth prepass material.\n     */\n    isDepthPrepassMaterial?: true;\n}\n\n/**\n * Creates material for depth prepass.\n *\n * Creates material that writes only to the z-buffer. Updates the original material instance, to\n * support depth prepass.\n *\n * @param baseMaterial - The base material of mesh that is updated to work with depth prepass\n *     and then used. This parameter is a template for depth prepass material that is returned.\n * @returns depth prepass material, which is a clone of `baseMaterial` with the adapted settings.\n */\nexport function createDepthPrePassMaterial(baseMaterial: THREE.Material): THREE.Material {\n    baseMaterial.depthWrite = false;\n    baseMaterial.depthFunc = THREE.EqualDepth;\n    baseMaterial.colorWrite = true;\n    enforceBlending(baseMaterial);\n\n    const depthPassMaterial: THREE.Material & DepthPrePassProperties = baseMaterial.clone();\n    depthPassMaterial.isDepthPrepassMaterial = true;\n    depthPassMaterial.depthWrite = true;\n    depthPassMaterial.depthTest = true;\n    depthPassMaterial.depthFunc = THREE.LessDepth;\n    depthPassMaterial.colorWrite = false;\n    depthPassMaterial.opacity = 1.0;\n    depthPassMaterial.blending = THREE.NoBlending;\n    return depthPassMaterial;\n}\n\n// tslint:disable:max-line-length\n/**\n * Clones a given mesh to render it in the depth prepass with another material. Both the original\n * and depth prepass meshes, when rendered in the correct order, create the proper depth prepass\n * effect. The original mesh material is slightly modified by [[createDepthPrePassMaterial]] to\n * support the depth prepass. This method is usable only if the material of this mesh has an\n * opacity value in the range `(0,1)`.\n *\n * The DepthPrePass object is created wis a slightly smaller `renderOrder` as the original mesh\n * to ensure that it's rendered first.\n *\n * @param mesh - original mesh\n * @returns `Mesh` depth pre pass\n */\n// tslint:enable:max-line-length\nexport function createDepthPrePassMesh(mesh: THREE.Mesh): THREE.Mesh {\n    const originalGeometry = mesh.geometry;\n\n    if (!(originalGeometry instanceof THREE.BufferGeometry)) {\n        throw new Error(\"#createDepthPassMesh only BufferGeometry is supported\");\n    }\n    const positionAttribute = originalGeometry.getAttribute(\"position\");\n    if (!positionAttribute) {\n        throw new Error(\"#createDepthPassMesh position attribute not found\");\n    }\n\n    const depthPassGeometry = new THREE.BufferGeometry();\n    depthPassGeometry.setAttribute(\"position\", positionAttribute);\n    const uvAttribute = originalGeometry.getAttribute(\"uv\");\n    if (uvAttribute) {\n        depthPassGeometry.setAttribute(\"uv\", uvAttribute);\n    }\n    const normalAttribute = originalGeometry.getAttribute(\"normal\");\n    if (normalAttribute) {\n        depthPassGeometry.setAttribute(\"normal\", normalAttribute);\n    }\n    const extrusionAxisAttribute = originalGeometry.getAttribute(\"extrusionAxis\");\n    if (extrusionAxisAttribute) {\n        depthPassGeometry.setAttribute(\"extrusionAxis\", extrusionAxisAttribute);\n    }\n\n    if (originalGeometry.index) {\n        depthPassGeometry.setIndex(originalGeometry.index);\n    }\n\n    for (const group of originalGeometry.groups) {\n        const { start, count, materialIndex } = group;\n        depthPassGeometry.addGroup(start, count, materialIndex);\n    }\n\n    const depthPassMaterial =\n        mesh.material instanceof Array\n            ? mesh.material.map(createDepthPrePassMaterial)\n            : createDepthPrePassMaterial(mesh.material);\n\n    const depthPassMesh = new THREE.Mesh(depthPassGeometry, depthPassMaterial);\n    depthPassMesh.renderOrder = mesh.renderOrder - DEPTH_PRE_PASS_RENDER_ORDER_OFFSET;\n\n    return depthPassMesh;\n}\n\n/**\n * Sets up all the needed stencil logic needed for the depth pre-pass.\n *\n * This logic is in place to avoid z-fighting artifacts that can appear in geometries that have\n * coplanar triangles inside the same mesh.\n *\n * @param depthMesh - Mesh created by `createDepthPrePassMesh`.\n * @param colorMesh - Original mesh.\n */\nexport function setDepthPrePassStencil(depthMesh: THREE.Mesh, colorMesh: THREE.Mesh) {\n    // Set up depth mesh stencil logic.\n    // Set the depth pre-pass stencil bit for all processed fragments. We use\n    // `THREE.AlwaysStencilFunc` and not `THREE.NotEqualStencilFunc` to force all fragments to pass\n    // the stencil test and write the correct depth value.\n    const depthMaterial = depthMesh.material as MapMeshStandardMaterial;\n    depthMaterial.stencilWrite = true;\n    depthMaterial.stencilFail = THREE.KeepStencilOp;\n    depthMaterial.stencilZFail = THREE.KeepStencilOp;\n    depthMaterial.stencilZPass = THREE.ReplaceStencilOp;\n    depthMaterial.stencilFunc = THREE.AlwaysStencilFunc;\n    depthMaterial.stencilRef = 0xff;\n    (depthMaterial as any).stencilFuncMask = DEPTH_PRE_PASS_STENCIL_MASK;\n\n    // Set up color mesh stencil logic.\n    // Only write color for pixels with the depth pre-pass stencil bit set. Also, once a pixel is\n    // rendered, set the stencil bit to 0 to prevent subsequent pixels in the same clip position\n    // from rendering color again.\n    const colorMaterial = colorMesh.material as MapMeshStandardMaterial;\n    colorMaterial.stencilWrite = true;\n    colorMaterial.stencilFail = THREE.KeepStencilOp;\n    colorMaterial.stencilZFail = THREE.KeepStencilOp;\n    colorMaterial.stencilZPass = THREE.ZeroStencilOp;\n    colorMaterial.stencilFunc = THREE.EqualStencilFunc;\n    colorMaterial.stencilRef = 0xff;\n    (colorMaterial as any).stencilFuncMask = DEPTH_PRE_PASS_STENCIL_MASK;\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeometryKind } from \"@here/harp-datasource-protocol\";\nimport { Projection } from \"@here/harp-geoutils\";\nimport { hasDisplacementFeature } from \"@here/harp-materials\";\nimport { assert } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\nimport { TileDisplacementMap } from \"../DisplacementMap\";\nimport { ElevationProvider } from \"../ElevationProvider\";\nimport { TextElement } from \"../text/TextElement\";\nimport { Tile, TileObject } from \"../Tile\";\n\n/**\n * Overlays the specified object's geometry on the elevation represented by the given displacement\n * map .\n *\n * @param object - The object to be overlaid.\n * @param displacementMap - Texture representing the elevation data used to overlay the object.\n */\nfunction overlayObject(object: TileObject, displacementMap: THREE.DataTexture): void {\n    if (!(\"material\" in object)) {\n        return;\n    }\n\n    const material = (object as any).material as THREE.Mesh[\"material\"];\n\n    if (Array.isArray(material)) {\n        material.forEach(mat => {\n            if (hasDisplacementFeature(mat)) {\n                mat.displacementMap = displacementMap;\n            }\n        });\n    } else if (material && hasDisplacementFeature(material)) {\n        material.displacementMap = displacementMap;\n    }\n}\n\n/**\n * Overlays the specified coordinates on top of elevation data if available.\n *\n * @param worldCoords - World coordinates to overlay.\n * @param elevationProvider - Used to sample elevation data.\n * @param displacementMap - Elevation data to be sampled.\n * @param projection - Projection from geo to world space.\n * @returns `true` if the position was successfully overlaid, `false` otherwise (e.g. elevation\n * data not available).\n */\nfunction overlayPosition(\n    worldCoords: THREE.Vector3,\n    elevationProvider: ElevationProvider,\n    displacementMap: TileDisplacementMap,\n    projection: Projection\n): boolean {\n    // TODO: Move calculation of text element geoCoordinates to decoder.\n    const geoCoords = projection.unprojectPoint(worldCoords);\n\n    if (displacementMap.geoBox.contains(geoCoords)) {\n        geoCoords.altitude = elevationProvider.sampleHeight(geoCoords, displacementMap);\n    } else {\n        geoCoords.altitude = elevationProvider.getHeight(geoCoords, displacementMap.tileKey.level);\n        if (geoCoords.altitude === undefined) {\n            return false;\n        }\n    }\n    projection.projectPoint(geoCoords, worldCoords);\n    return true;\n}\n\n/**\n * Overlays the specified coordinates on top of elevation data if available.\n *\n * @param path - World coordinates to overlay.\n * @param elevationProvider - Used to sample elevation data.\n * @param displacementMap - Elevation data to be sampled.\n * @param projection - Projection from geo to world space.\n * @returns `true` if the position was successfully overlaid, `false` otherwise (e.g. elevation\n * data not available).\n */\nfunction overlayPath(\n    path: THREE.Vector3[],\n    elevationProvider: ElevationProvider,\n    displacementMap: TileDisplacementMap,\n    projection: Projection\n): boolean {\n    for (const position of path) {\n        if (!overlayPosition(position, elevationProvider, displacementMap, projection)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * Overlays a text element on top of elevation data if available.\n *\n * @param textElement - The text element whose geometry will be overlaid.\n * @param elevationProvider -  Used to sample elevation data.\n * @param displacementMap - Elevation data to be sampled.\n * @param projection - Projection from geo to world space.\n */\nexport function overlayTextElement(\n    textElement: TextElement,\n    elevationProvider: ElevationProvider,\n    displacementMap: TileDisplacementMap,\n    projection: Projection\n) {\n    assert(!textElement.elevated);\n    if (!displacementMap) {\n        return;\n    }\n\n    textElement.elevated = textElement.path\n        ? overlayPath(textElement.path, elevationProvider, displacementMap, projection)\n        : overlayPosition(textElement.position, elevationProvider, displacementMap, projection);\n}\n\n/**\n * Overlays the geometry in the given tile on top of elevation data if available. The tile's\n * elevation may be updated with a more precise range.\n *\n * @param tile - The tile whose geometry will be overlaid.\n */\nexport function overlayOnElevation(tile: Tile): void {\n    const elevationProvider = tile.mapView.elevationProvider;\n\n    if (elevationProvider === undefined || tile.objects.length === 0) {\n        return;\n    }\n    const firstObject = tile.objects[0];\n    if (\n        !firstObject.userData ||\n        !firstObject.userData.kind ||\n        !firstObject.userData.kind.find((kind: GeometryKind) => {\n            return kind !== GeometryKind.All && kind !== GeometryKind.Terrain;\n        })\n    ) {\n        return;\n    }\n\n    const displacementMap = elevationProvider.getDisplacementMap(tile.tileKey);\n    if (displacementMap === undefined) {\n        return;\n    }\n\n    // TODO: HARP-8808 Apply displacement maps once per material.\n    for (const object of tile.objects) {\n        overlayObject(object, displacementMap.texture);\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Env, getPropertyValue, PoiTechnique } from \"@here/harp-datasource-protocol\";\nimport { OrientedBox3, Projection, ProjectionType } from \"@here/harp-geoutils\";\nimport {\n    hAlignFromPlacement,\n    HorizontalPlacement,\n    hPlacementFromAlignment,\n    MeasurementParameters,\n    TextCanvas,\n    TextPlacement,\n    vAlignFromPlacement,\n    VerticalPlacement,\n    vPlacementFromAlignment\n} from \"@here/harp-text-canvas\";\nimport { assert, Math2D, MathUtils } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\nimport { PoiManager } from \"../poi/PoiManager\";\nimport { PoiRenderer } from \"../poi/PoiRenderer\";\nimport { CollisionBox, DetailedCollisionBox, IBox, ScreenCollisions } from \"../ScreenCollisions\";\nimport { ScreenProjector } from \"../ScreenProjector\";\nimport { RenderState } from \"./RenderState\";\nimport { PoiInfo, poiIsRenderable, TextElement } from \"./TextElement\";\nimport { TextElementState } from \"./TextElementState\";\nimport { TextElementType } from \"./TextElementType\";\nimport { ViewState } from \"./ViewState\";\n\n/**\n * Minimum number of pixels per character. Used during estimation if there is enough screen space\n * available to render a text.\n */\nconst MIN_AVERAGE_CHAR_WIDTH = 5;\n\n/**\n * Functions related to text element placement.\n */\n\nconst tmpPosition = new THREE.Vector3(0, 0, 0);\nconst tmpCameraDir = new THREE.Vector3(0, 0, 0);\nconst tmpPointDir = new THREE.Vector3(0, 0, 0);\nconst COS_TEXT_ELEMENT_FALLOFF_ANGLE = 0.5877852522924731; // Math.cos(0.3 * Math.PI)\n\n/**\n * Checks whether the distance of the text element to the camera plane meets threshold criterias.\n *\n * @param textElement - The textElement of which the view distance will be checked, with coordinates\n * in world space.\n * @param eyePos - The eye (or camera) position that will be used as reference to calculate\n * the distance.\n * @param eyeLookAt - The eye looking direction - normalized.\n * @param maxViewDistance - The maximum distance value.\n * @returns The text element view distance if it's lower than the maximum value, otherwise\n * `undefined`.\n */\nfunction checkViewDistance(\n    textElement: TextElement,\n    eyePos: THREE.Vector3,\n    eyeLookAt: THREE.Vector3,\n    projectionType: ProjectionType,\n    maxViewDistance: number\n): number | undefined {\n    const textDistance = computeViewDistance(textElement, eyePos, eyeLookAt);\n\n    if (projectionType !== ProjectionType.Spherical) {\n        return textDistance <= maxViewDistance ? textDistance : undefined;\n    }\n\n    // For sphere projection: Filter labels that are close to the horizon\n    tmpPosition.copy(textElement.position).normalize();\n    tmpCameraDir.copy(eyePos).normalize();\n    const cosAlpha = tmpPosition.dot(tmpCameraDir);\n    const viewDistance =\n        cosAlpha > COS_TEXT_ELEMENT_FALLOFF_ANGLE && textDistance <= maxViewDistance\n            ? textDistance\n            : undefined;\n\n    return viewDistance;\n}\n\n/**\n * Computes distance of the specified text element to camera plane given with position and normal.\n *\n * The distance is measured as projection of the vector between `eyePosition` and text\n * eonto the `eyeLookAt` vector, so it actually computes the distance to plane that\n * contains `eyePosition` and is described with `eyeLookAt` as normal.\n *\n * @note Used for measuring the distances to camera, results in the metric that describes\n * distance to camera near plane (assuming near = 0). Such metric is better as input for labels\n * scaling or fading factors then simple euclidean distance because it does not fluctuate during\n * simple camera panning.\n *\n * @param textElement - The textElement of which the view distance will be checked. It must have\n *                      coordinates in world space.\n * @param eyePosition - The world eye coordinates used a reference position to calculate\n *                      the distance.\n * @param eyeLookAt - The eye looking direction or simply said projection plane normal.\n * @returns The text element view distance.\n */\nexport function computeViewDistance(\n    textElement: TextElement,\n    eyePosition: THREE.Vector3,\n    eyeLookAt: THREE.Vector3\n): number {\n    let viewDistance: number;\n\n    // Compute the distances as the distance along plane normal.\n    const path = textElement.path;\n    if (path && path.length > 1) {\n        const viewDistance0 = pointToPlaneDistance(path[0], eyePosition, eyeLookAt);\n        const viewDistance1 = pointToPlaneDistance(path[path.length - 1], eyePosition, eyeLookAt);\n\n        viewDistance = Math.min(viewDistance0, viewDistance1);\n    } else {\n        viewDistance = pointToPlaneDistance(textElement.position, eyePosition, eyeLookAt);\n    }\n\n    return viewDistance;\n}\n\n/**\n * Computes distance between the given point and a plane.\n *\n * May be used to measure distance of point labels to the camera projection (near) plane.\n *\n * @param pointPos - The position to measure distance to.\n * @param planePos - The position of any point on the plane.\n * @param planeNorm - The plane normal vector (have to be normalized already).\n */\nexport function pointToPlaneDistance(\n    pointPos: THREE.Vector3,\n    planePos: THREE.Vector3,\n    planeNorm: THREE.Vector3\n) {\n    const labelCamVec = tmpPointDir.copy(pointPos).sub(planePos);\n    return labelCamVec.dot(planeNorm);\n}\n\n/**\n * Computes the maximum view distance for text elements as a ratio of the given view's maximum far\n * plane distance.\n * @param viewState - The view for which the maximum view distance will be calculated.\n * @param farDistanceLimitRatio - The ratio to apply to the maximum far plane distance.\n * @returns Maximum view distance.\n */\nexport function getMaxViewDistance(viewState: ViewState, farDistanceLimitRatio: number): number {\n    return viewState.maxVisibilityDist * farDistanceLimitRatio;\n}\n\n/**\n * State of fading.\n */\nexport enum PrePlacementResult {\n    Ok = 0,\n    NotReady,\n    Invisible,\n    TooFar,\n    Duplicate,\n    Count\n}\n\nconst tmpPlacementPosition = new THREE.Vector3();\nconst tmpPlacementBounds = new THREE.Box2();\n\n/**\n * Applies early rejection tests for a given text element meant to avoid trying to place labels\n * that are not visible, not ready, duplicates etc...\n * @param textElement - The Text element to check.\n * @param viewState - The view for which the text element will be placed.\n * @param viewCamera - The view's camera.\n * @param m_poiManager - To prepare pois for rendering.\n * @param maxViewDistance - If specified, text elements farther than this max distance will be\n *                          rejected.\n * @returns An object with the result code and the text element view distance\n * ( or `undefined` of the checks failed) as second.\n */\nexport function checkReadyForPlacement(\n    textElement: TextElement,\n    viewState: ViewState,\n    viewCamera: THREE.Camera,\n    poiManager: PoiManager,\n    maxViewDistance?: number\n): { result: PrePlacementResult; viewDistance: number | undefined } {\n    let viewDistance: number | undefined;\n\n    if (!textElement.visible) {\n        return { result: PrePlacementResult.Invisible, viewDistance };\n    }\n\n    // If a PoiTable is specified in the technique, the table is required to be\n    // loaded before the POI can be rendered.\n    if (!poiManager.updatePoiFromPoiTable(textElement)) {\n        // PoiTable has not been loaded, but is required to determine\n        // visibility.\n        return { result: PrePlacementResult.NotReady, viewDistance };\n    }\n\n    // Text element visibility and zoom level ranges must be checked after calling\n    // updatePoiFromPoiTable, since that function may change those values.\n    if (\n        !textElement.visible ||\n        !MathUtils.isClamped(\n            viewState.zoomLevel,\n            textElement.minZoomLevel,\n            textElement.maxZoomLevel\n        )\n    ) {\n        return { result: PrePlacementResult.Invisible, viewDistance };\n    }\n\n    viewDistance =\n        maxViewDistance === undefined\n            ? computeViewDistance(textElement, viewState.worldCenter, viewState.lookAtVector)\n            : checkViewDistance(\n                  textElement,\n                  viewState.worldCenter,\n                  viewState.lookAtVector,\n                  viewState.projection.type,\n                  maxViewDistance\n              );\n\n    if (viewDistance === undefined) {\n        return { result: PrePlacementResult.TooFar, viewDistance };\n    }\n\n    return { result: PrePlacementResult.Ok, viewDistance };\n}\n\n/**\n * Computes the offset for a point text accordingly to text alignment (and icon, if any).\n * @param textElement - The text element of which the offset will computed. It must be a point\n * label with [[layoutStyle]] and [[bounds]] already computed.\n * @param placement - The relative anchor placement (may be different then original alignment).\n * @param scale - The scaling factor (due to distance, etc.).\n * @param env - The {@link @here/harp-datasource-protocol#Env} used\n *                  to evaluate technique attributes.\n * @param offset - The offset result.\n */\nfunction computePointTextOffset(\n    textElement: TextElement,\n    placement: TextPlacement,\n    scale: number,\n    env: Env,\n    offset: THREE.Vector2 = new THREE.Vector2()\n): THREE.Vector2 {\n    assert(textElement.type === TextElementType.PoiLabel);\n    assert(textElement.layoutStyle !== undefined);\n    assert(textElement.bounds !== undefined);\n\n    offset.x = textElement.xOffset;\n    offset.y = textElement.yOffset;\n\n    switch (placement.h) {\n        case HorizontalPlacement.Left:\n            // Already accounts for any margin that is already applied to the text element bounds.\n            offset.x -= textElement.bounds!.max.x;\n            break;\n        case HorizontalPlacement.Right:\n            // Account for any margin applied as above.\n            offset.x -= textElement.bounds!.min.x;\n            break;\n    }\n    switch (placement.v) {\n        case VerticalPlacement.Top:\n            offset.y -= textElement.bounds!.min.y;\n            break;\n        case VerticalPlacement.Center:\n            offset.y -= 0.5 * (textElement.bounds!.max.y + textElement.bounds!.min.y);\n            break;\n        case VerticalPlacement.Bottom:\n            // Accounts for vertical margin that may be applied to the text bounds.\n            offset.y -= textElement.bounds!.max.y;\n            break;\n    }\n\n    if (textElement.poiInfo !== undefined && poiIsRenderable(textElement.poiInfo)) {\n        assert(textElement.poiInfo.computedWidth !== undefined);\n        assert(textElement.poiInfo.computedHeight !== undefined);\n\n        // Apply offset moving text out of the icon\n        offset.x += textElement.poiInfo.computedWidth! * (0.5 + placement.h);\n        offset.y += textElement.poiInfo.computedHeight! * (0.5 + placement.v);\n\n        // Reverse, mirror or project offsets on different axis depending on the placement\n        // required only for alternative placements.\n        const hAlign = hPlacementFromAlignment(textElement.layoutStyle!.horizontalAlignment);\n        const vAlign = vPlacementFromAlignment(textElement.layoutStyle!.verticalAlignment);\n        if (hAlign !== placement.h || vAlign !== placement.v) {\n            // Read icon offset used.\n            const technique = textElement.poiInfo.technique;\n            let iconXOffset = getPropertyValue(technique.iconXOffset, env);\n            let iconYOffset = getPropertyValue(technique.iconYOffset, env);\n            iconXOffset = typeof iconXOffset === \"number\" ? iconXOffset : 0;\n            iconYOffset = typeof iconYOffset === \"number\" ? iconYOffset : 0;\n\n            // Now mirror the text offset relative to icon so manhattan distance is preserved, when\n            // alternative position is taken, this ensures that text-icon relative position is\n            // the same as in base alignment.\n            const hAlignDiff = hAlign - placement.h;\n            const vAlignDiff = vAlign - placement.v;\n            const relOffsetX = iconXOffset - textElement.xOffset;\n            const relOffsetY = iconYOffset - textElement.yOffset;\n            const centerBased =\n                hAlign === HorizontalPlacement.Center || vAlign === VerticalPlacement.Center;\n            if (centerBased) {\n                // Center based alternative placements.\n                offset.x += 2 * Math.abs(hAlignDiff) * relOffsetX;\n                offset.y -= 2 * vAlignDiff * Math.abs(relOffsetX);\n\n                offset.y += 2 * Math.abs(vAlignDiff) * relOffsetY;\n                offset.x -= 2 * hAlignDiff * Math.abs(relOffsetY);\n            } else {\n                // Corner alternative placements\n                offset.x += 2 * Math.min(Math.abs(hAlignDiff), 0.5) * relOffsetX;\n                offset.y -=\n                    2 *\n                    Math.sign(vAlignDiff) *\n                    Math.min(Math.abs(vAlignDiff), 0.5) *\n                    Math.abs(relOffsetX);\n\n                offset.y += 2 * Math.min(Math.abs(vAlignDiff), 0.5) * relOffsetY;\n                offset.x -=\n                    2 *\n                    Math.sign(hAlignDiff) *\n                    Math.min(Math.abs(hAlignDiff), 0.5) *\n                    Math.abs(relOffsetY);\n            }\n        }\n    }\n\n    offset.multiplyScalar(scale);\n    return offset;\n}\n\nconst tmpBox = new THREE.Box2();\nconst tmpBoxes: THREE.Box2[] = [];\nconst tmpMeasurementParams: MeasurementParameters = {};\nconst tmpCollisionBoxes: CollisionBox[] = [];\nconst tmpCollisionBox = new CollisionBox();\nconst tmpScreenPosition = new THREE.Vector2();\nconst tmpTextOffset = new THREE.Vector2();\nconst tmp2DBox = new Math2D.Box();\nconst tmpCenter = new THREE.Vector2();\nconst tmpSize = new THREE.Vector2();\n\n/**\n * The margin applied to the text bounds of every point label.\n */\nexport const persistentPointLabelTextMargin = new THREE.Vector2(2, 2);\n/**\n * Additional bounds scaling (described as percentage of full size) applied to the new labels.\n *\n * This additional scaling (margin) allows to account for slight camera position and\n * orientation changes, so new labels are placed only if there is enough space around them.\n * Such margin limits collisions with neighboring labels while doing small camera movements and\n * thus reduces labels flickering.\n */\nexport const newPointLabelTextMarginPercent = 0.1;\n\nexport enum PlacementResult {\n    Ok,\n    Rejected,\n    Invisible\n}\n\n/**\n * Places an icon on screen.\n * @param iconRenderState - The icon state.\n * @param poiInfo - Icon information necessary to compute its dimensions.\n * @param screenPosition - Screen position of the icon.\n * @param scaleFactor - Scaling factor to apply to the icon dimensions.\n * @param screenCollisions - Used to check the icon visibility and collisions.\n * @param env - Current map env.\n * @returns `PlacementResult.Ok` if icon can be placed, `PlacementResult.Rejected` if there's\n * a collision, `PlacementResult.Invisible` if it's not visible.\n */\nexport function placeIcon(\n    iconRenderState: RenderState,\n    poiInfo: PoiInfo,\n    screenPosition: THREE.Vector2,\n    scaleFactor: number,\n    env: Env,\n    screenCollisions: ScreenCollisions\n): PlacementResult {\n    PoiRenderer.computeIconScreenBox(poiInfo, screenPosition, scaleFactor, env, tmp2DBox);\n    if (!screenCollisions.isVisible(tmp2DBox)) {\n        return PlacementResult.Invisible;\n    }\n\n    const iconSpaceAvailable =\n        poiInfo.mayOverlap === true || !screenCollisions.isAllocated(tmp2DBox);\n\n    if (!iconSpaceAvailable) {\n        return iconRenderState.isVisible() ? PlacementResult.Rejected : PlacementResult.Invisible;\n    }\n    return PlacementResult.Ok;\n}\n\n/**\n * Place a point label text using single or multiple alternative placement anchors.\n *\n * @param labelState - State of the point label to place.\n * @param screenPosition - Position of the label in screen coordinates.\n * @param scale - Scale factor to be applied to label dimensions.\n * @param textCanvas - The text canvas where the label will be placed.\n * @param env - The {@link @here/harp-datasource-protocol#Env} used\n *              to evaluate technique attributes.\n * @param screenCollisions - Used to check collisions with other labels.\n * @param isRejected - Whether the label is already rejected (e.g. because its icon was rejected).\n * If `true`, text won't be checked for collision, result will be either `PlacementResult.Invisible`\n * for newly placed (upcoming) label or `PlacementResult.Rejected` if the label was persistent.\n * @param outScreenPosition - The final label screen position after applying any offsets.\n * @param multiAnchor - The parameter decides if multi-anchor placement algorithm should be\n * used, be default [[false]] meaning try to place label using current alignment settings only.\n * @returns `PlacementResult.Ok` if point __label can be placed__ at the base or any optional\n * anchor point. `PlacementResult.Rejected` if there's a collision for all placements or it's\n * __persistent label with icon rejected and text visible__. Finally `PlacementResult.Invisible`\n * if it's text is not visible at any placement position or it's __new label with text or icon__\n * __rejected__.\n */\nexport function placePointLabel(\n    labelState: TextElementState,\n    screenPosition: THREE.Vector2,\n    scale: number,\n    textCanvas: TextCanvas,\n    env: Env,\n    screenCollisions: ScreenCollisions,\n    isRejected: boolean,\n    outScreenPosition: THREE.Vector3,\n    multiAnchor: boolean = false\n): PlacementResult {\n    assert(labelState.element.layoutStyle !== undefined);\n\n    const layoutStyle = labelState.element.layoutStyle!;\n\n    // For the new labels with rejected icons we don't need to go further.\n    // Make them invisible.\n    const newLabel = !labelState.visible;\n    if (isRejected && newLabel) {\n        return PlacementResult.Invisible;\n    }\n    // Check if alternative placements have been provided.\n    multiAnchor =\n        multiAnchor && layoutStyle.placements !== undefined && layoutStyle.placements.length > 1;\n    // For single placement labels or labels with icon rejected, do only current anchor testing.\n    if (!multiAnchor || isRejected) {\n        return placePointLabelAtCurrentAnchor(\n            labelState,\n            screenPosition,\n            scale,\n            textCanvas,\n            env,\n            screenCollisions,\n            isRejected,\n            outScreenPosition\n        );\n    }\n    // Otherwise test also alternative text placements.\n    else {\n        return placePointLabelChoosingAnchor(\n            labelState,\n            screenPosition,\n            scale,\n            textCanvas,\n            env,\n            screenCollisions,\n            outScreenPosition\n        );\n    }\n}\n\n/**\n * Try to place a point label text using multiple optional placements.\n *\n * @note Function should be called only for labels with icons not rejected and for text alignments\n * different then [[HorizontalAlignment.Center]] and [[VerticalAlignment.Center]].\n *\n * @param labelState - State of the point label to place.\n * @param screenPosition - Position of the label in screen coordinates.\n * @param scale - Scale factor to be applied to label dimensions.\n * @param textCanvas - The text canvas where the label will be placed.\n * @param env - The {@link @here/harp-datasource-protocol#Env}\n *              used to evaluate technique attributes.\n * @param screenCollisions - Used to check collisions with other labels.\n * @param outScreenPosition - The final label screen position after applying any offsets.\n * @returns `PlacementResult.Ok` if label can be placed at the base or optional anchor point,\n * `PlacementResult.Rejected` if there's a collision for all placements, `PlacementResult.Invisible`\n * if it's not visible at any placement position.\n *\n * @internal\n * @hidden\n */\nfunction placePointLabelChoosingAnchor(\n    labelState: TextElementState,\n    screenPosition: THREE.Vector2,\n    scale: number,\n    textCanvas: TextCanvas,\n    env: Env,\n    screenCollisions: ScreenCollisions,\n    outScreenPosition: THREE.Vector3\n): PlacementResult {\n    assert(labelState.element.layoutStyle !== undefined);\n\n    const label = labelState.element;\n\n    // Store label state - persistent or new label.\n    const persistent = labelState.visible;\n\n    // Start with last alignment settings if layout state was stored or\n    // simply begin from layout defined in theme.\n    const lastPlacement = labelState.textPlacement;\n    const placements = label.layoutStyle!.placements;\n    const placementsNum = placements.length;\n    // Find current anchor placement on the optional placements list.\n    // Index of exact match.\n    const matchIdx = placements.findIndex(p => p.h === lastPlacement.h && p.v === lastPlacement.v);\n    assert(matchIdx >= 0);\n    // Will be true if all text placements are invisible.\n    let allInvisible: boolean = true;\n    // Iterate all placements starting from current one.\n    for (let i = matchIdx; i < placementsNum + matchIdx; ++i) {\n        const anchorPlacement = placements[i % placementsNum];\n\n        // Bounds may be already calculated for persistent label, force re-calculation only\n        // for alternative (new) placements.\n        const isLastPlacement = i === matchIdx && persistent;\n        // Compute label bounds, visibility or collision according to new layout settings.\n        const placementResult = placePointLabelAtAnchor(\n            labelState,\n            screenPosition,\n            anchorPlacement,\n            scale,\n            textCanvas,\n            env,\n            screenCollisions,\n            false,\n            !isLastPlacement,\n            outScreenPosition\n        );\n\n        // Store last successful (previous) placement coordinates in temp variables.\n        if (isLastPlacement) {\n            assert(label.bounds !== undefined);\n            tmpPlacementPosition.copy(outScreenPosition);\n            tmpPlacementBounds.copy(label.bounds!);\n        }\n\n        // Check the text allocation\n        if (placementResult === PlacementResult.Invisible) {\n            // Persistent label out of screen or the new label that is colliding - next iteration.\n            continue;\n        } else {\n            // This placement is visible, but surely colliding.\n            allInvisible = false;\n        }\n\n        // If text rejected (label collides), proceed to test further placements.\n        if (placementResult === PlacementResult.Rejected) {\n            continue;\n        }\n\n        // Proper placement found.\n        return PlacementResult.Ok;\n    }\n    // Revert recent screen position and bounds.\n    outScreenPosition.copy(tmpPlacementPosition);\n    label.bounds!.copy(tmpPlacementBounds);\n    // Revert back text canvas layout of the last placement.\n    // In case of label rejected this allows to fade out text in the last position.\n    applyTextPlacement(textCanvas, lastPlacement);\n\n    return allInvisible\n        ? // All text's placements out of the screen.\n          PlacementResult.Invisible\n        : persistent\n        ? // All placements are either colliding or out of screen for persistent label.\n          PlacementResult.Rejected\n        : // No placement found for the new label.\n          PlacementResult.Invisible;\n}\n\n/**\n * Places a point label on a specified text canvas using the alignment (anchor) currently set.\n *\n * @param labelState - State of the point label to place.\n * @param screenPosition - Position of the label in screen coordinates.\n * @param scale - Scale factor to be applied to label dimensions.\n * @param textCanvas - The text canvas where the label will be placed.\n * @param env - The {@link @here/harp-datasource-protocol#Env}\n *              used to evaluate technique attributes.\n * @param screenCollisions - Used to check collisions with other labels.\n * @param isRejected - Whether the label is already rejected (e.g. because its icon was rejected).\n * If `true`, text won't be checked for collision, result will be either `PlacementResult.Invisible`\n * or `PlacementResult.Rejected`.\n * @param outScreenPosition - The final label screen position after applying any offsets.\n * @returns `PlacementResult.Ok` if point label can be placed, `PlacementResult.Rejected` if there's\n * a collision, `PlacementResult.Invisible` if it's not visible.\n *\n * @internal\n * @hidden\n */\nfunction placePointLabelAtCurrentAnchor(\n    labelState: TextElementState,\n    screenPosition: THREE.Vector2,\n    scale: number,\n    textCanvas: TextCanvas,\n    env: Env,\n    screenCollisions: ScreenCollisions,\n    isRejected: boolean,\n    outScreenPosition: THREE.Vector3\n): PlacementResult {\n    assert(labelState.element.layoutStyle !== undefined);\n\n    // Use recently rendered (state stored) layout if available, otherwise theme based style.\n    const lastPlacement = labelState.textPlacement;\n    const result = placePointLabelAtAnchor(\n        labelState,\n        screenPosition,\n        lastPlacement,\n        scale,\n        textCanvas,\n        env,\n        screenCollisions,\n        isRejected,\n        !labelState.visible,\n        outScreenPosition\n    );\n\n    return result;\n}\n\n/**\n * Auxiliary function that tries to place a point label on a text canvas using specified alignment.\n *\n * @param labelState - State of the point label to place.\n * @param screenPosition - Position of the label in screen coordinates\n * @param placement - Text placement relative to the label position.\n * @param scale - Scale factor to be applied to label dimensions.\n * @param textCanvas - The text canvas where the label will be placed.\n * @param env - The {@link @here/harp-datasource-protocol#Env}\n *              used to evaluate technique attributes.\n * @param screenCollisions - Used to check collisions with other labels.\n * @param isRejected - Whether the label is already rejected (e.g. because its icon was rejected).\n * If `true`, text won't be checked for collision, result will be either `PlacementResult.Invisible`\n * or `PlacementResult.Rejected`.\n * @param forceInvalidation - Set to true if text layout or other params has changed such as text\n * re-measurement is required and text buffer need to be invalidated.\n * @param outScreenPosition - The final label screen position after applying any offsets.\n * @returns `PlacementResult.Ok` if point label can be placed, `PlacementResult.Rejected` if there's\n * a collision, `PlacementResult.Invisible` if it's not visible.\n *\n * @internal\n * @hidden\n */\nfunction placePointLabelAtAnchor(\n    labelState: TextElementState,\n    screenPosition: THREE.Vector2,\n    placement: TextPlacement,\n    scale: number,\n    textCanvas: TextCanvas,\n    env: Env,\n    screenCollisions: ScreenCollisions,\n    isRejected: boolean,\n    forceInvalidation: boolean,\n    outScreenPosition: THREE.Vector3\n): PlacementResult {\n    const label = labelState.element;\n    assert(label.glyphs !== undefined);\n    assert(label.layoutStyle !== undefined);\n\n    const measureText = label.bounds === undefined || forceInvalidation;\n    if (label.bounds === undefined) {\n        label.bounds = new THREE.Box2();\n    }\n\n    // Override label text layout (on TextCanvas) for measurements and text buffer creation.\n    applyTextPlacement(textCanvas, placement);\n\n    if (measureText) {\n        // Setup measurements parameters for textCanvas.measureText().\n        tmpMeasurementParams.outputCharacterBounds = undefined;\n        tmpMeasurementParams.path = undefined;\n        tmpMeasurementParams.pathOverflow = false;\n        tmpMeasurementParams.letterCaseArray = label.glyphCaseArray!;\n        // Compute label bounds according to layout settings.\n        textCanvas.measureText(label.glyphs!, label.bounds, tmpMeasurementParams);\n        // Apply additional persistent margin, keep in mind that text bounds just calculated\n        // are not (0, 0, w, h) based, so their coords usually are also non-zero.\n        // TODO: Make the margin configurable\n        label.bounds.expandByVector(persistentPointLabelTextMargin);\n    }\n\n    // Compute text offset from the anchor point\n    const textOffset = computePointTextOffset(label, placement, scale, env, tmpTextOffset);\n    textOffset.add(screenPosition);\n    tmpBox.copy(label.bounds!);\n    tmpBox.translate(textOffset);\n\n    tmpBox.getCenter(tmpCenter);\n    tmpBox.getSize(tmpSize);\n\n    tmpSize.multiplyScalar(scale);\n    tmp2DBox.set(tmpCenter.x - tmpSize.x / 2, tmpCenter.y - tmpSize.y / 2, tmpSize.x, tmpSize.y);\n\n    // Update output screen position.\n    outScreenPosition.set(textOffset.x, textOffset.y, labelState.renderDistance);\n\n    // Check the text visibility if invisible finish immediately\n    // regardless of the persistence state - no fading required.\n    if (!screenCollisions.isVisible(tmp2DBox)) {\n        return PlacementResult.Invisible;\n    }\n\n    const persistent = labelState.visible;\n    // Check if icon's label was already rejected.\n    if (isRejected) {\n        // Allows to fade out persistent label and simply ignore new one.\n        // NOTE:\n        // It might be changed if we would like to render text without icon (at border, etc.).\n        return persistent ? PlacementResult.Rejected : PlacementResult.Invisible;\n    }\n\n    if (measureText) {\n        // Up-scaled label bounds are used only for new labels and after visibility check, this is\n        // intentional to avoid processing labels out of the screen due to increased bounds, such\n        // labels would be again invisible in the next frame.\n        tmpBox.getSize(tmpSize);\n        tmpSize.multiplyScalar(scale * (1 + newPointLabelTextMarginPercent));\n        tmp2DBox.set(\n            tmpCenter.x - tmpSize.x / 2,\n            tmpCenter.y - tmpSize.y / 2,\n            tmpSize.x,\n            tmpSize.y\n        );\n    }\n\n    // Check label's text collision.\n    if (!label.textMayOverlap && screenCollisions.isAllocated(tmp2DBox)) {\n        // Allows to fade persistent and ignore new label.\n        return persistent ? PlacementResult.Rejected : PlacementResult.Invisible;\n    }\n\n    // Don't allocate space for rejected text. When zooming, this allows placement of a\n    // lower priority text element that was displaced by a higher priority one (not\n    // present in the new zoom level) before an even lower priority one takes the space.\n    // Otherwise the lowest priority text will fade in and back out.\n    // TODO: Add a unit test for this scenario.\n    if (label.textReservesSpace) {\n        screenCollisions.allocate(tmp2DBox);\n    }\n\n    // Glyphs arrangement have been changed remove text buffer object which needs to be\n    // re-created.\n    if (measureText) {\n        label.textBufferObject = undefined;\n    }\n\n    // Save current placement in label state.\n    // TextElementState creates layout snapshot solely for alternative placements which saves\n    // memory that could be wasted on unnecessary objects construction.\n    labelState.textPlacement = placement;\n\n    return PlacementResult.Ok;\n}\n\n/**\n * Applied modified text layout style to TextCanvas for further use.\n * @param textCanvas - TextCanvas reference.\n * @param placement - The text placement to be used.\n */\nfunction applyTextPlacement(textCanvas: TextCanvas, placement: TextPlacement) {\n    // Setup TextCanvas layout settings of the new placement as it is required for further\n    // TextBufferObject creation and measurements in addText().\n    textCanvas.textLayoutStyle.horizontalAlignment = hAlignFromPlacement(placement.h);\n    textCanvas.textLayoutStyle.verticalAlignment = vAlignFromPlacement(placement.v);\n}\n\n/**\n * Places a path label along a given path on a specified text canvas.\n * @param labelState - The state of the path label to place.\n * @param textPath - The text path along which the label will be placed.\n * @param screenPosition - Position of the label in screen coordinates.\n * @param textCanvas - The text canvas where the label will be placed.\n * @param screenCollisions - Used to check collisions with other labels.\n * @returns `PlacementResult.Ok` if path label can be placed, `PlacementResult.Rejected` if there's\n * a collision or text doesn't fit into path, `PlacementResult.Invisible` if it's not visible.\n */\nexport function placePathLabel(\n    labelState: TextElementState,\n    textPath: THREE.Path,\n    screenPosition: THREE.Vector2,\n    textCanvas: TextCanvas,\n    screenCollisions: ScreenCollisions\n): PlacementResult {\n    // Recalculate the text bounds for this path label. If measurement fails, the whole\n    // label doesn't fit the path and should be discarded.\n    tmpMeasurementParams.path = textPath;\n    tmpMeasurementParams.outputCharacterBounds = tmpBoxes;\n    tmpMeasurementParams.letterCaseArray = labelState.element.glyphCaseArray!;\n\n    // TODO: HARP-7648. TextCanvas.measureText does the placement as in TextCanvas.addText but\n    // without storing the result. If the measurement succeeds, the placement work is done\n    // twice.\n    // This could be done in one step (e.g measureAndAddText). Collision test could be injected\n    // in the middle as a function.\n    if (!textCanvas.measureText(labelState.element.glyphs!, tmpBox, tmpMeasurementParams)) {\n        return PlacementResult.Rejected;\n    }\n\n    // Coarse collision check.\n    tmpCollisionBox.copy(tmpBox.translate(screenPosition));\n    if (!screenCollisions.isVisible(tmpCollisionBox)) {\n        return PlacementResult.Invisible;\n    }\n\n    let checkGlyphCollision = false;\n    let candidateBoxes: IBox[] | undefined;\n    if (!labelState.element.textMayOverlap) {\n        candidateBoxes = screenCollisions.search(tmpCollisionBox);\n        checkGlyphCollision = candidateBoxes.length > 0;\n    }\n\n    const checkGlyphVisible = !screenCollisions.isFullyVisible(tmpCollisionBox);\n\n    // Perform per-character collision checks.\n    tmpCollisionBoxes.length = tmpBoxes.length;\n    for (let i = 0; i < tmpBoxes.length; ++i) {\n        const glyphBox = tmpBoxes[i].translate(screenPosition);\n        let collisionBox = tmpCollisionBoxes[i];\n        if (collisionBox === undefined) {\n            collisionBox = new CollisionBox(glyphBox);\n            tmpCollisionBoxes[i] = collisionBox;\n        } else {\n            collisionBox.copy(glyphBox);\n        }\n        if (checkGlyphVisible && !screenCollisions.isVisible(collisionBox)) {\n            return PlacementResult.Invisible;\n        }\n\n        if (\n            checkGlyphCollision &&\n            screenCollisions.intersectsDetails(collisionBox, candidateBoxes!)\n        ) {\n            return PlacementResult.Rejected;\n        }\n    }\n    // Allocate collision info if needed.\n    if (labelState.element.textReservesSpace) {\n        const collisionBox = new DetailedCollisionBox(tmpCollisionBox, tmpCollisionBoxes.slice());\n        tmpCollisionBoxes.length = 0;\n        screenCollisions.allocate(collisionBox);\n    }\n    return PlacementResult.Ok;\n}\n\n/**\n * Check if a given path label is too small to be rendered.\n * @param textElement - The text element to check.\n * @param screenProjector - Used to project coordinates from world to screen space.\n * @param outScreenPoints - Label path projected to screen space.\n * @returns `true` if label is too small, `false` otherwise.\n */\nexport function isPathLabelTooSmall(\n    textElement: TextElement,\n    screenProjector: ScreenProjector,\n    outScreenPoints: THREE.Vector2[]\n): boolean {\n    assert(textElement.type === TextElementType.PathLabel);\n\n    // Get the screen points that define the label's segments and create a path with\n    // them.\n    outScreenPoints.length = 0;\n    let anyPointVisible = false;\n\n    for (const pt of textElement.points as THREE.Vector3[]) {\n        // Skip invisible points at the beginning of the path.\n        const screenPoint = anyPointVisible\n            ? screenProjector.project(pt, tmpScreenPosition)\n            : screenProjector.projectOnScreen(pt, tmpScreenPosition);\n        if (screenPoint === undefined) {\n            continue;\n        }\n        anyPointVisible = true;\n\n        outScreenPoints.push(tmpScreenPosition.clone());\n    }\n\n    // TODO: (HARP-3515)\n    //      The rendering of a path label that contains just a single point that is not\n    //      visible is impossible, which is problematic with long paths.\n    //      Fix: Skip/clip the invisible points at beginning and end of the path to get\n    //      the visible part of the path.\n\n    // If not a single point is visible, skip the path\n    if (!anyPointVisible) {\n        return true;\n    }\n\n    // Check/guess if the screen box can hold a string of that length. It is important\n    // to guess that value without measuring the font first to save time.\n    const minScreenSpace = textElement.text.length * MIN_AVERAGE_CHAR_WIDTH;\n\n    tmpBox.setFromPoints(outScreenPoints);\n    const boxDiagonalSq = tmpBox.max.sub(tmpBox.min).lengthSq();\n\n    if (boxDiagonalSq < minScreenSpace * minScreenSpace) {\n        textElement.dbgPathTooSmall = true;\n        return true;\n    }\n\n    return false;\n}\n\nconst tmpOrientedBox = new OrientedBox3();\n\n/**\n * Calculates the world position of the supplied label. The label will be shifted if there is a\n * specified offsetDirection and value to shift it in.\n * @param poiLabel - The label to shift\n * @param projection - The projection, required to compute the correct direction offset for\n *                     spherical projections.\n * @param env - The environment to extract the worldOffset needed to shift the icon in world space,\n *              if configured in the style.\n * @param outWorldPosition - Preallocated vector to store the result in\n * @returns the [[outWorldPosition]] vector.\n */\nexport function getWorldPosition(\n    poiLabel: TextElement,\n    projection: Projection,\n    env: Env,\n    outWorldPosition: THREE.Vector3\n): THREE.Vector3 {\n    const worldOffsetShiftValue = getPropertyValue(\n        (poiLabel.poiInfo?.technique as PoiTechnique)?.worldOffset,\n        env\n    );\n    outWorldPosition?.copy(poiLabel.position);\n    if (\n        worldOffsetShiftValue !== null &&\n        worldOffsetShiftValue !== undefined &&\n        poiLabel.offsetDirection !== undefined\n    ) {\n        projection.localTangentSpace(poiLabel.position, tmpOrientedBox);\n        const offsetDirectionVector = tmpOrientedBox.yAxis;\n        const offsetDirectionRad = THREE.MathUtils.degToRad(poiLabel.offsetDirection);\n        // Negate to get the normal, i.e. the vector pointing to the sky.\n        offsetDirectionVector.applyAxisAngle(tmpOrientedBox.zAxis.negate(), offsetDirectionRad);\n\n        outWorldPosition.addScaledVector(tmpOrientedBox.yAxis, worldOffsetShiftValue);\n    }\n    return outWorldPosition;\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Env, getPropertyValue, ImageTexture } from \"@here/harp-datasource-protocol\";\nimport { IconMaterial } from \"@here/harp-materials\";\nimport { MemoryUsage, TextCanvas } from \"@here/harp-text-canvas\";\nimport { assert, LoggerManager, Math2D } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { ImageItem } from \"../image/Image\";\nimport { MipMapGenerator } from \"../image/MipMapGenerator\";\nimport { MapView } from \"../MapView\";\nimport { ScreenCollisions } from \"../ScreenCollisions\";\nimport { PoiInfo, TextElement } from \"../text/TextElement\";\nimport { BoxBuffer } from \"./BoxBuffer\";\n\nconst logger = LoggerManager.instance.create(\"PoiRenderer\");\n\nconst INVALID_RENDER_BATCH = -1;\nconst tempPos = new THREE.Vector3(0);\n\n/**\n * Neutral color used as `vColor` attribute of [[IconMaterial]] if no `iconColor` color was\n * specified.\n */\nconst neutralColor = new THREE.Color(1, 1, 1);\n\n/**\n * Temporary color instance used by `addPoi` to pass color derived from `iconBrightness` property.\n */\nconst tmpIconColor = new THREE.Color();\n\n/**\n * The `PoiRenderBufferBatch` contains the geometry and the material for all POIs that share the\n * same icon image ({@link @here/harp-datasource-protocol#ImageTexture}).\n *\n * @remarks\n * If the image is the same, all the objects in this batch can\n * share the same material, which makes them renderable in the same draw call, whatever the number\n * of actual objects (WebGL limits apply!).\n *\n * There is a `PoiRenderBufferBatch` for every icon in a texture atlas, since the size of the icon\n * in the atlas as well as the texture coordinates are specified in the `PoiRenderBufferBatch`.\n */\nclass PoiRenderBufferBatch {\n    // Enable trilinear filtering to reduce flickering due to distance scaling\n    static trilinear: boolean = true;\n\n    boxBuffer: BoxBuffer | undefined;\n\n    private m_material?: THREE.Material | THREE.Material[];\n\n    /**\n     * Create the `PoiRenderBufferBatch`.\n     *\n     * @param mapView - The {@link MapView} instance.\n     * @param scene - The three.js scene to add the POIs to.\n     * @param imageItem - The icon that will have his material shared.\n     * @param renderOrder - RenderOrder of the batch geometry's [[Mesh]].\n     */\n    constructor(\n        readonly mapView: MapView,\n        readonly scene: THREE.Scene,\n        readonly imageItem: ImageItem,\n        readonly renderOrder: number\n    ) {}\n\n    /**\n     * Initialize with the {@link @here/harp-datasource-protocol#ImageTexture}.\n     *\n     * @remarks\n     * Loads the image and sets up the icon size, the texture\n     * coordinates and material of the batch. Since image loading is done asynchronously, this\n     * batch cannot be rendered right away. MapView#update is being triggered if it loaded\n     * successfully.\n     */\n    init() {\n        if (this.boxBuffer === undefined) {\n            this.setup();\n        }\n    }\n\n    /**\n     * Clean the `PoiRenderBufferBatch`, remove all icon boxes. Called before starting a new frame.\n     */\n    reset(): void {\n        if (this.boxBuffer === undefined) {\n            this.init();\n        }\n        this.boxBuffer!.reset();\n    }\n\n    /**\n     * Update the geometry with all the added boxes during the frame.\n     */\n    update(): void {\n        if (this.boxBuffer === undefined) {\n            this.init();\n        }\n        this.boxBuffer!.updateBufferGeometry();\n    }\n\n    /**\n     * Update the info with the memory footprint caused by objects owned by the\n     * `PoiRenderBufferBatch`.\n     *\n     * @param info - The info object to increment with the values from this `PoiRenderBufferBatch`.\n     */\n    updateMemoryUsage(info: MemoryUsage) {\n        if (this.boxBuffer !== undefined) {\n            this.boxBuffer.updateMemoryUsage(info);\n        }\n    }\n\n    /**\n     * Setup texture and material for the batch.\n     */\n    private setup() {\n        // Texture images should be generated with premultiplied alpha\n        const premultipliedAlpha = true;\n\n        const texture = new THREE.Texture(\n            this.imageItem.imageData as any,\n            THREE.UVMapping,\n            undefined,\n            undefined,\n            PoiRenderBufferBatch.trilinear ? THREE.LinearFilter : THREE.LinearFilter,\n            PoiRenderBufferBatch.trilinear ? THREE.LinearMipMapLinearFilter : THREE.LinearFilter,\n            THREE.RGBAFormat\n        );\n        if (PoiRenderBufferBatch.trilinear && this.imageItem.mipMaps) {\n            // Generate mipmaps for distance scaling of icon\n            texture.mipmaps = this.imageItem.mipMaps;\n            texture.image = texture.mipmaps[0];\n        }\n        texture.flipY = false;\n        texture.premultiplyAlpha = premultipliedAlpha;\n        texture.needsUpdate = true;\n\n        this.m_material = new IconMaterial({\n            map: texture\n        });\n\n        this.boxBuffer = new BoxBuffer(this.m_material, this.renderOrder);\n\n        const mesh = this.boxBuffer.mesh;\n\n        mesh.frustumCulled = false;\n\n        this.scene.add(mesh);\n\n        this.mapView.update();\n    }\n}\n\n/**\n * Contains all [[PoiRenderBufferBatch]]es. Selects (and initializes) the correct batch for a POI.\n */\nclass PoiRenderBuffer {\n    readonly batches: PoiRenderBufferBatch[] = [];\n    private readonly m_batchMap: Map<string, Map<number, number>> = new Map();\n\n    /**\n     * Create the `PoiRenderBuffer`.\n     *\n     * @param mapView - The {@link MapView} to be rendered to.\n     * @param textCanvas - The [[TextCanvas]] to which scenes this `PoiRenderBuffer`\n     *                     adds geometry to.\n     * The actual scene a {@link TextElement} is added to is specified by the renderOrder of the\n     * {@link TextElement}.\n     */\n    constructor(readonly mapView: MapView, readonly textCanvas: TextCanvas) {}\n\n    /**\n     * Register the POI and prepare the [[PoiRenderBufferBatch]] for the POI at first usage.\n     *\n     * @param poiInfo - Describes the POI icon.\n     */\n    registerPoi(poiInfo: PoiInfo): number {\n        const { imageItem, imageTexture, imageTextureName } = poiInfo;\n\n        if (\n            imageItem === undefined ||\n            imageTextureName === undefined ||\n            imageTexture === undefined\n        ) {\n            // No image -> invisible -> ignore\n            return INVALID_RENDER_BATCH;\n        }\n\n        const renderOrder = poiInfo.renderOrder!;\n\n        // There is a batch for every ImageDefinition, which could be a texture atlas with many\n        // ImageTextures in it.\n        const batchKey = imageTexture.image;\n        let batchSet = this.m_batchMap.get(batchKey);\n        let mappedIndex: number | undefined;\n        let bufferBatch: PoiRenderBufferBatch;\n\n        if (batchSet === undefined) {\n            batchSet = new Map<number, number>();\n            this.m_batchMap.set(batchKey, batchSet);\n        }\n\n        mappedIndex = batchSet.get(renderOrder);\n        if (mappedIndex !== undefined) {\n            return mappedIndex;\n        }\n        mappedIndex = this.batches.length;\n\n        let layer = this.textCanvas.getLayer(renderOrder);\n        if (layer === undefined) {\n            this.textCanvas.addText(\"\", tempPos, { layer: renderOrder });\n            layer = this.textCanvas.getLayer(renderOrder);\n        }\n\n        bufferBatch = new PoiRenderBufferBatch(\n            this.mapView,\n            layer!.storage.scene,\n            imageItem,\n            renderOrder\n        );\n        bufferBatch.init();\n        batchSet.set(renderOrder, mappedIndex);\n        this.batches.push(bufferBatch);\n        return mappedIndex;\n    }\n\n    /**\n     * Render a POI image at the specified location.\n     *\n     * @param poiInfo - PoiInfo containing information for rendering the POI icon.\n     * @param screenBox - Box to render icon into in 2D coordinates.\n     * @param viewDistance - Box's distance to camera.\n     * @param opacity - Opacity of icon to allow fade in/out.\n     */\n    addPoi(poiInfo: PoiInfo, screenBox: Math2D.Box, viewDistance: number, opacity: number): number {\n        const poiRegistered =\n            poiInfo.poiRenderBatch !== undefined && poiInfo.poiRenderBatch !== INVALID_RENDER_BATCH;\n        const batchIndex = poiRegistered ? poiInfo.poiRenderBatch! : this.registerPoi(poiInfo);\n        if (batchIndex === INVALID_RENDER_BATCH) {\n            return INVALID_RENDER_BATCH;\n        }\n        assert(batchIndex >= 0);\n        assert(batchIndex < this.batches.length);\n        assert(poiInfo.uvBox !== undefined);\n\n        if (this.batches[batchIndex].boxBuffer === undefined) {\n            this.batches[batchIndex].init();\n        }\n\n        let color: THREE.Color;\n        if (poiInfo.iconBrightness !== undefined) {\n            color = tmpIconColor.setScalar(poiInfo.iconBrightness);\n            if (poiInfo.iconColor !== undefined) {\n                color = tmpIconColor.multiply(poiInfo.iconColor);\n            }\n        } else if (poiInfo.iconColor !== undefined) {\n            color = poiInfo.iconColor;\n        } else {\n            color = neutralColor;\n        }\n        this.batches[batchIndex].boxBuffer!.addBox(\n            screenBox,\n            poiInfo.uvBox!,\n            color,\n            opacity,\n            viewDistance,\n            poiInfo.textElement\n        );\n\n        return batchIndex;\n    }\n\n    /**\n     * Retrieve the [[PoiRenderBufferBatch]] from the array at the specified index. May be invalid\n     * if the imageTexture could not be found\n     *\n     * @param index - Index into batch array.\n     */\n    getBatch(index: number): PoiRenderBufferBatch | undefined {\n        if (index >= 0) {\n            assert(index < this.batches.length);\n            return this.batches[index];\n        }\n        // may be invalid if the imageTexture could not be found\n        return undefined;\n    }\n\n    /**\n     * Reset all batches, removing all content from the [[PoiRenderBufferBatch]]es. Called at the\n     * beginning of a frame before the POIs are placed.\n     */\n    reset(): void {\n        for (const batch of this.batches) {\n            batch.reset();\n        }\n    }\n\n    /**\n     * Update the geometry of all [[PoiRenderBufferBatch]]es. Called before rendering.\n     */\n    update(): void {\n        for (const batch of this.batches) {\n            batch.update();\n        }\n    }\n\n    /**\n     * Fill the picking results for the pixel with the given screen coordinate. If multiple\n     * {@link PoiInfo}s are found, the order of the results is unspecified.\n     *\n     * @param screenPosition - Screen coordinate of picking position.\n     * @param pickCallback - Callback to be called for every picked element.\n     */\n    pickTextElements(\n        screenPosition: THREE.Vector2,\n        pickCallback: (pickData: any | undefined) => void\n    ) {\n        for (const batch of this.batches) {\n            if (batch.boxBuffer === undefined) {\n                batch.init();\n            }\n            batch.boxBuffer!.pickBoxes(screenPosition, pickCallback, batch.imageItem.imageData);\n        }\n    }\n\n    /**\n     * Update the info with the memory footprint caused by objects owned by the `PoiRenderBuffer`.\n     *\n     * @param info - The info object to increment with the values from this `PoiRenderBuffer`.\n     */\n    updateMemoryUsage(info: MemoryUsage) {\n        for (const batch of this.batches) {\n            if (batch.imageItem.imageData !== undefined) {\n                const imageBytes =\n                    batch.imageItem.imageData.width * batch.imageItem.imageData.height * 4;\n                info.heapSize += imageBytes;\n                info.gpuSize += imageBytes;\n            }\n            if (batch.boxBuffer !== undefined) {\n                batch.boxBuffer.updateMemoryUsage(info);\n            }\n        }\n    }\n}\n\n/**\n * Manage POI rendering. Uses a [[PoiRenderBuffer]] to actually create the geometry that is being\n * rendered.\n */\nexport class PoiRenderer {\n    /**\n     * Compute screen box for icon. It is required that `prepareRender` has been successfully called\n     * before `computeScreenBox` may be called.\n     *\n     * @param poiInfo - PoiInfo containing information for rendering the POI icon.\n     * @param screenPosition - Position on screen (2D).\n     * @param scale - Scale to apply to icon.\n     * @param env - Current zoom level.\n     * @param screenBox - Box that will be used to store the result.\n     * @returns The computed screen box for the icon.\n     */\n    static computeIconScreenBox(\n        poiInfo: PoiInfo,\n        screenPosition: THREE.Vector2,\n        scale: number,\n        env: Env,\n        /* out */ screenBox: Math2D.Box = new Math2D.Box()\n    ): Math2D.Box {\n        assert(poiInfo.poiRenderBatch !== undefined);\n        assert(poiInfo.poiRenderBatch !== INVALID_RENDER_BATCH);\n\n        const width = poiInfo.computedWidth! * scale;\n        const height = poiInfo.computedHeight! * scale;\n        const technique = poiInfo.technique;\n        const iconXOffset = getPropertyValue(technique.iconXOffset, env);\n        const iconYOffset = getPropertyValue(technique.iconYOffset, env);\n\n        const centerX =\n            screenPosition.x + (typeof iconXOffset === \"number\" ? iconXOffset : 0) * scale;\n        const centerY =\n            screenPosition.y + (typeof iconYOffset === \"number\" ? iconYOffset : 0) * scale;\n\n        screenBox.x = centerX - width / 2;\n        screenBox.y = centerY - height / 2;\n        screenBox.w = width;\n        screenBox.h = height;\n\n        return screenBox;\n    }\n    // keep track of the missing textures, but only warn once\n    private static m_missingTextureName: Map<string, boolean> = new Map();\n\n    // the render buffer containing all batches, one batch per texture/material.\n    private m_renderBuffer: PoiRenderBuffer;\n\n    // temporary variable to save allocations\n    private m_tempScreenBox = new Math2D.Box();\n\n    /**\n     * Create the `PoiRenderer` for the specified {@link MapView}.\n     *\n     * @param mapView - The MapView to be rendered to.\n     * @param textCanvas - The [[TextCanvas]] this `PoiRenderer` is associated to. POIs are added to\n     * the different layers of this [[TextCanvas]] based on renderOrder.\n     */\n    constructor(readonly mapView: MapView, readonly textCanvas: TextCanvas) {\n        this.m_renderBuffer = new PoiRenderBuffer(mapView, textCanvas);\n    }\n\n    /**\n     * Prepare the POI for rendering, and determine which `poiRenderBatch` should be used. If a\n     * `poiRenderBatch` is assigned, the POI is ready to be rendered.\n     *\n     * @param pointLabel - TextElement with PoiInfo for rendering the POI icon.\n     * @param env - TODO! The current zoomLevel level of {@link MapView}\n     *\n     * @returns `True` if the space is not already allocated by another object (text label or POI)\n     */\n    prepareRender(pointLabel: TextElement, env: Env): boolean {\n        const poiInfo = pointLabel.poiInfo;\n        if (poiInfo === undefined) {\n            return false;\n        }\n        if (poiInfo.poiRenderBatch === undefined) {\n            this.preparePoi(pointLabel, env);\n        }\n        return poiInfo.poiRenderBatch !== undefined;\n    }\n\n    /**\n     * Reset all batches, removing all content from the [[PoiRenderBuffer]]es. Called at the\n     * beginning of a frame before the POIs are placed.\n     */\n    reset(): void {\n        this.m_renderBuffer.reset();\n    }\n\n    /**\n     * Render the icon.\n     *\n     * @param poiInfo - PoiInfo containing information for rendering the POI icon.\n     * @param screenPosition - Position on screen (2D):\n     * @param screenCollisions - Object handling the collision checks for screen-aligned 2D boxes.\n     * @param viewDistance - Box's distance to camera.\n     * @param scale - Scaling factor to apply to text and icon.\n     * @param allocateScreenSpace - If `true` screen space will be allocated for the icon.\n     * @param opacity - Opacity of icon to allow fade in/out.\n     */\n    renderPoi(\n        poiInfo: PoiInfo,\n        screenPosition: THREE.Vector2,\n        screenCollisions: ScreenCollisions,\n        viewDistance: number,\n        scale: number,\n        allocateScreenSpace: boolean,\n        opacity: number,\n        env: Env\n    ): void {\n        assert(poiInfo.poiRenderBatch !== undefined);\n\n        PoiRenderer.computeIconScreenBox(poiInfo, screenPosition, scale, env, this.m_tempScreenBox);\n\n        if (allocateScreenSpace) {\n            screenCollisions.allocate(this.m_tempScreenBox);\n        }\n\n        this.m_renderBuffer.addPoi(poiInfo, this.m_tempScreenBox, viewDistance, opacity);\n    }\n\n    /**\n     * Update the geometry of all [[PoiRenderBuffer]]es. Called before rendering.\n     */\n    update(): void {\n        this.m_renderBuffer.update();\n    }\n\n    /**\n     * Fill the picking results for the pixel with the given screen coordinate. If multiple\n     * {@link PoiInfo}s are found, the order of the results is unspecified.\n     *\n     * @param screenPosition - Screen coordinate of picking position.\n     * @param pickCallback - Callback to be called for every picked element.\n     */\n    pickTextElements(\n        screenPosition: THREE.Vector2,\n        pickCallback: (pickData: any | undefined) => void\n    ) {\n        this.m_renderBuffer.pickTextElements(screenPosition, pickCallback);\n    }\n\n    /**\n     * Update the info with the memory footprint caused by objects owned by the `PoiRenderer`.\n     *\n     * @param info - The info object to increment with the values from this `PoiRenderer`.\n     */\n    getMemoryUsage(info: MemoryUsage) {\n        this.m_renderBuffer.updateMemoryUsage(info);\n    }\n\n    /**\n     * Register the POI at the [[PoiRenderBuffer]] which may require some setup, for example loading\n     * of the actual image.\n     */\n    private preparePoi(pointLabel: TextElement, env: Env): void {\n        const poiInfo = pointLabel.poiInfo;\n        if (poiInfo === undefined || !pointLabel.visible) {\n            return;\n        }\n\n        if (poiInfo.poiRenderBatch !== undefined || poiInfo.isValid === false) {\n            // Already set up, nothing to be done here.\n            return;\n        }\n\n        if (poiInfo.poiTableName !== undefined) {\n            if (this.mapView.poiManager.updatePoiFromPoiTable(pointLabel)) {\n                if (!pointLabel.visible) {\n                    // PoiTable set this POI to not visible.\n                    return;\n                }\n            } else {\n                // PoiTable has not been loaded, but is required to determine visibility.\n                return;\n            }\n        }\n\n        const imageTextureName = poiInfo.imageTextureName;\n\n        const imageTexture = this.mapView.poiManager.getImageTexture(imageTextureName);\n        if (imageTexture === undefined) {\n            // Warn about a missing texture, but only once.\n            if (PoiRenderer.m_missingTextureName.get(imageTextureName) === undefined) {\n                PoiRenderer.m_missingTextureName.set(imageTextureName, true);\n                logger.error(`preparePoi: No imageTexture with name '${imageTextureName}' found`);\n            }\n            poiInfo.isValid = false;\n            return;\n        }\n\n        const imageDefinition = imageTexture.image;\n\n        let imageItem = this.mapView.imageCache.findImageByName(imageDefinition);\n        if (imageItem === undefined) {\n            logger.error(`init: No imageItem found with name '${imageDefinition}'`);\n            poiInfo.isValid = false;\n            return;\n        }\n\n        if (!imageItem.loaded) {\n            if (imageItem.loadingPromise !== undefined) {\n                // already being loaded, will be rendered once available\n                return;\n            }\n            const imageUrl = imageItem.url;\n            const loading = this.mapView.imageCache.loadImage(imageItem);\n            if (loading instanceof Promise) {\n                loading\n                    .then(loadedImageItem => {\n                        if (loadedImageItem === undefined) {\n                            logger.error(`preparePoi: Failed to load imageItem: '${imageUrl}`);\n                            return;\n                        }\n                        this.setupPoiInfo(poiInfo, imageTexture, loadedImageItem, env);\n                    })\n                    .catch(error => {\n                        logger.error(`preparePoi: Failed to load imageItem: '${imageUrl}`, error);\n                        poiInfo.isValid = false;\n                    });\n                return;\n            } else {\n                imageItem = loading;\n            }\n        }\n\n        this.setupPoiInfo(poiInfo, imageTexture, imageItem, env);\n    }\n\n    /**\n     * Setup texture and material for the batch.\n     *\n     * @param poiInfo - {@link PoiInfo} to initialize.\n     * @param imageTexture - Shared {@link @here/harp-datasource-protocol#ImageTexture},\n     *                       defines used area in atlas.\n     * @param imageItem - Shared {@link ImageItem}, contains cached image for texture.\n     * @param env - The current zoom level of {@link MapView}\n     */\n    private setupPoiInfo(\n        poiInfo: PoiInfo,\n        imageTexture: ImageTexture,\n        imageItem: ImageItem,\n        env: Env\n    ) {\n        assert(poiInfo.uvBox === undefined);\n\n        if (imageItem === undefined || imageItem.imageData === undefined) {\n            logger.error(\"setupPoiInfo: No imageItem/imageData found\");\n            // invalid render batch number\n            poiInfo.poiRenderBatch = INVALID_RENDER_BATCH;\n            poiInfo.isValid = false;\n            return;\n        }\n\n        const technique = poiInfo.technique;\n\n        const imageWidth = imageItem.imageData.width;\n        const imageHeight = imageItem.imageData.height;\n        const paddedSize = MipMapGenerator.getPaddedSize(imageWidth, imageHeight);\n        const trilinearFiltering = PoiRenderBufferBatch.trilinear && imageItem.mipMaps;\n        const paddedImageWidth = trilinearFiltering ? paddedSize.width : imageWidth;\n        const paddedImageHeight = trilinearFiltering ? paddedSize.height : imageHeight;\n\n        const iconWidth = imageTexture.width !== undefined ? imageTexture.width : imageWidth;\n        const iconHeight = imageTexture.height !== undefined ? imageTexture.height : imageHeight;\n\n        let minS = 0;\n        let maxS = 1;\n        let minT = 0;\n        let maxT = 1;\n\n        let iconScaleH = technique.iconScale !== undefined ? technique.iconScale : 1;\n        let iconScaleV = technique.iconScale !== undefined ? technique.iconScale : 1;\n\n        const width = imageTexture.width !== undefined ? imageTexture.width : imageWidth;\n        const height = imageTexture.height !== undefined ? imageTexture.height : imageHeight;\n        const xOffset = imageTexture.xOffset !== undefined ? imageTexture.xOffset : 0;\n        const yOffset = imageTexture.yOffset !== undefined ? imageTexture.yOffset : 0;\n\n        minS = xOffset / paddedImageWidth;\n        maxS = (xOffset + width) / paddedImageWidth;\n\n        const flipY = false;\n        if (flipY) {\n            minT = (imageHeight - yOffset) / paddedImageHeight;\n            maxT = (imageHeight - yOffset - height) / paddedImageHeight;\n        } else {\n            minT = yOffset / paddedImageHeight;\n            maxT = (yOffset + height) / paddedImageHeight;\n        }\n\n        // minS += 0.5 / imageWidth;\n        // maxS += 0.5 / imageWidth;\n        // minT += 0.5 / imageHeight;\n        // maxT += 0.5 / imageHeight;\n\n        // By default, iconScaleV should be equal to iconScaleH, whatever is set in the style.\n        const screenWidth = getPropertyValue(technique.screenWidth, env);\n        if (screenWidth !== undefined) {\n            iconScaleV = iconScaleH = screenWidth / iconWidth;\n        }\n\n        const screenHeight = getPropertyValue(technique.screenHeight, env);\n        if (screenHeight !== undefined) {\n            iconScaleV = screenHeight / iconHeight;\n            if (screenWidth !== undefined) {\n                iconScaleH = iconScaleV;\n            }\n        }\n\n        // compute stored values in imageTexture\n        poiInfo.computedWidth = iconWidth * iconScaleH;\n        poiInfo.computedHeight = iconHeight * iconScaleV;\n        poiInfo.uvBox = {\n            s0: minS,\n            t0: maxT,\n            s1: maxS,\n            t1: minT\n        };\n        poiInfo.imageItem = imageItem;\n        poiInfo.imageTexture = imageTexture;\n        poiInfo.poiRenderBatch = this.m_renderBuffer.registerPoi(poiInfo);\n        poiInfo.isValid = true;\n\n        assert(poiInfo.poiRenderBatch !== undefined);\n    }\n}\n","/*\n * Copyright (C) 2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { ImageItem } from \"./Image\";\n\nconst isNode = typeof window === \"undefined\";\n\n/**\n * Mip map generator resizes textures to next bigger power-of-two size by adding padding\n * and creates mip map levels.\n * @internal\n */\nexport class MipMapGenerator {\n    /**\n     * Gets size of an image padded to the next bigger power-of-two size\n     * @param width - Width of image\n     * @param height - Height of image\n     */\n    static getPaddedSize(width: number, height: number): { width: number; height: number } {\n        return {\n            width: THREE.MathUtils.ceilPowerOfTwo(width),\n            height: THREE.MathUtils.ceilPowerOfTwo(height)\n        };\n    }\n\n    private m_paddingCanvas?: HTMLCanvasElement;\n    private m_paddingContext?: CanvasRenderingContext2D;\n    private m_resizeCanvas?: HTMLCanvasElement;\n    private m_resizeContext?: CanvasRenderingContext2D;\n\n    constructor() {\n        if (!isNode) {\n            this.m_paddingCanvas = document.createElement(\"canvas\");\n            this.m_paddingContext = this.m_paddingCanvas.getContext(\"2d\")!;\n            this.m_resizeCanvas = document.createElement(\"canvas\");\n            this.m_resizeContext = this.m_resizeCanvas.getContext(\"2d\")!;\n        }\n    }\n\n    /**\n     * Generate downsampled mip map levels from an image.\n     * If the input image is not power-of-two the image is padded to the\n     * next bigger power-of-two size.\n     * @param image - Input image\n     * @returns A list of images with mip maps of the input image\n     */\n    generateTextureAtlasMipMap(image: ImageItem): ImageData[] {\n        if (isNode) {\n            throw new Error(\"MipMapGenerator only works in browser.\");\n        }\n\n        if (image.imageData === undefined) {\n            throw new Error(\"Can not generate mip maps. Image data not loaded!\");\n        }\n        const imageData = image.imageData;\n        const mipMaps: ImageData[] = [];\n\n        // Add initial texture with padding as level 0\n        const { width: paddedWidth, height: paddedHeight } = MipMapGenerator.getPaddedSize(\n            imageData.width,\n            imageData.height\n        );\n        this.copyImageWithPadding(imageData, paddedWidth, paddedHeight);\n        mipMaps.push(this.m_paddingContext!.getImageData(0, 0, paddedWidth, paddedHeight));\n\n        let width = paddedWidth * 0.5;\n        let height = paddedHeight * 0.5;\n        while (width >= 1 && height >= 1) {\n            const mipMapLevel = mipMaps.length;\n            const previousImage = mipMaps[mipMapLevel - 1];\n            // Resize previous mip map level\n            mipMaps.push(this.resizeImage(previousImage, width, height));\n            width *= 0.5;\n            height *= 0.5;\n        }\n\n        return mipMaps;\n    }\n\n    /**\n     * Copy image to a canvas and add padding if necessary.\n     * @param image - Input image.\n     * @param width - Width of output image\n     * @param height - Width of output image\n     * @returns Canvas with image and padding.\n     */\n    private copyImageWithPadding(\n        image: ImageData | ImageBitmap,\n        width: number,\n        height: number\n    ): HTMLCanvasElement {\n        this.m_paddingCanvas!.width = width;\n        this.m_paddingCanvas!.height = height;\n\n        this.m_paddingContext!.clearRect(0, 0, width, height);\n        if (image instanceof ImageBitmap) {\n            this.m_paddingContext!.drawImage(image, 0, 0);\n        } else {\n            this.m_paddingContext!.putImageData(image, 0, 0);\n        }\n\n        // Add horizontal padding\n        if (image.width !== width) {\n            this.m_paddingContext!.drawImage(\n                this.m_paddingCanvas!,\n                image.width - 1,\n                0,\n                1,\n                image.height,\n                image.width,\n                0,\n                width - image.width,\n                image.height\n            );\n        }\n\n        // Add vertical padding\n        if (image.height !== height) {\n            this.m_paddingContext!.drawImage(\n                this.m_paddingCanvas!,\n                0,\n                image.height - 1,\n                width,\n                1,\n                0,\n                image.height,\n                width,\n                height - image.height\n            );\n        }\n\n        return this.m_paddingCanvas!;\n    }\n\n    /**\n     * Resize an image.\n     *\n     * Quality of resized image is best when\n     * image.width and image.height are even numbers and the image\n     * is resized by factor 0.5 or 2.\n     * @param image - Input image\n     * @param width - Width of output image\n     * @param height - Height of output image\n     * @return Resized image\n     */\n    private resizeImage(image: ImageData, width: number, height: number): ImageData {\n        //  Copy image data to canvas because ImageData can't be resized directly\n        const paddedImage = this.copyImageWithPadding(image, image.width, image.height);\n\n        // Resize image to resize canvas\n        this.m_resizeCanvas!.width = width;\n        this.m_resizeCanvas!.height = height;\n        this.m_resizeContext!.clearRect(0, 0, width, height);\n        this.m_resizeContext!.drawImage(paddedImage, 0, 0, width, height);\n\n        return this.m_resizeContext!.getImageData(0, 0, width, height);\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { LoggerManager, Math2D } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\nimport { debugContext } from \"./DebugContext\";\n\ndeclare const require: any;\n\n// tslint:disable-next-line:no-var-requires\nconst RBush = require(\"rbush\");\n\nconst logger = LoggerManager.instance.create(\"ScreenCollissions\");\n\nexport interface IBox {\n    minX: number;\n    minY: number;\n    maxX: number;\n    maxY: number;\n}\n\nexport class CollisionBox extends Math2D.Box implements IBox {\n    constructor(box?: Math2D.Box | THREE.Box2 | IBox) {\n        super();\n        if (box !== undefined) {\n            this.copy(box);\n        }\n    }\n\n    copy(box: Math2D.Box | THREE.Box2 | IBox): CollisionBox {\n        if (box instanceof Math2D.Box) {\n            this.set(box.x, box.y, box.w, box.h);\n        } else if (box instanceof THREE.Box2) {\n            this.set(box.min.x, box.min.y, box.max.x - box.min.x, box.max.y - box.min.y);\n        } else {\n            this.set(box.minX, box.minY, box.maxX - box.minX, box.maxY - box.minY);\n        }\n        return this;\n    }\n    get minX(): number {\n        return this.x;\n    }\n    set minX(minX: number) {\n        this.x = minX;\n    }\n    get maxX(): number {\n        return this.x + this.w;\n    }\n    set maxX(maxX: number) {\n        this.w = maxX - this.x;\n    }\n    get minY(): number {\n        return this.y;\n    }\n    set minY(minY: number) {\n        this.y = minY;\n    }\n    get maxY(): number {\n        return this.y + this.h;\n    }\n    set maxY(maxY: number) {\n        this.h = maxY - this.y;\n    }\n}\n\n/**\n * Collision box with additional boxes defining tighter bounds for the enclosed feature\n * (e.g.glyph bounds for text).\n */\nexport class DetailedCollisionBox extends CollisionBox {\n    constructor(box: Math2D.Box | THREE.Box2 | IBox, readonly detailBoxes: CollisionBox[]) {\n        super(box);\n    }\n}\n\nexport interface LineWithBound extends IBox {\n    line: THREE.Line3;\n}\n\nexport function isLineWithBound(box: IBox): box is LineWithBound {\n    return (box as LineWithBound).line !== undefined;\n}\n\nconst tmpCollisionBox = new CollisionBox();\n\nexport class ScreenCollisions {\n    /** The screen bounding box. */\n    readonly screenBounds = new Math2D.Box();\n\n    /** Tree of allocated bounds. */\n\n    private rtree = new RBush();\n\n    /**\n     * Constructs a new ScreenCollisions object.\n     */\n    constructor() {\n        //\n    }\n\n    /**\n     * Resets the list of allocated screen bounds.\n     */\n    reset() {\n        this.rtree.clear();\n    }\n\n    /**\n     * Updates the screen bounds that are used to check if bounding boxes are visible.\n     *\n     * @param width - The width of the container.\n     * @param height - The height of the container.\n     */\n    update(width: number, height: number) {\n        this.screenBounds.set(width / -2, height / -2, width, height);\n        this.reset();\n    }\n\n    /**\n     * Marks the region of the screen intersecting with the given bounding box as allocated.\n     *\n     * @param bounds - The bounding box in NDC scaled coordinates (i.e. top left is -width/2,\n     * -height/2)\n     */\n    allocate(bounds: Math2D.Box | CollisionBox | DetailedCollisionBox): void {\n        const bbox = !(bounds instanceof CollisionBox) ? new CollisionBox(bounds) : bounds;\n        this.rtree.insert(bbox);\n    }\n\n    /**\n     * Inserts the given bounds into the rtree.\n     *\n     * @param bounds - The bounding boxes (the bounding boxes must be in the space returned from the\n     * ScreenProjector.project method).\n     */\n    allocateIBoxes(bounds: IBox[]) {\n        this.rtree.load(bounds);\n    }\n\n    /**\n     * Search for all bounds in the tree intersecting with the given box.\n     * @param box - The box used for the search.\n     * @returns An array of all IBoxes intersecting with the given box.\n     */\n    search(box: CollisionBox): IBox[] {\n        return this.rtree.search(box);\n    }\n\n    /**\n     * Checks if the given bounding box is already allocated.\n     *\n     * @param bounds - The bounding box in world coordinates.\n     */\n    isAllocated(bounds: Math2D.Box | CollisionBox): boolean {\n        const collisionBox = bounds instanceof CollisionBox ? bounds : tmpCollisionBox.copy(bounds);\n        const results = this.search(collisionBox);\n        return this.intersectsDetails(collisionBox, results);\n    }\n\n    /**\n     * Checks if the given screen bounds intersects with the frustum of the active camera.\n     *\n     * @param bounds - The bounding box in world coordinates.\n     */\n    isVisible(bounds: Math2D.Box): boolean {\n        return this.screenBounds.intersects(bounds);\n    }\n\n    /**\n     * Checks if the given screen bounds is contained within the frustum of the active camera.\n     *\n     * @param bounds - The bounding box in world coordinates.\n     */\n    isFullyVisible(bounds: Math2D.Box): boolean {\n        return this.screenBounds.containsBox(bounds);\n    }\n\n    /**\n     * Test whether a given [[CollisionBox]] intersects with any of the details in the specified\n     * [[IBox]]es.\n     *\n     * @param testBox - The box to test for intersection.\n     * @param boxes - The candidate boxes the test box may intersect with. It's assumed that the\n     * global bounds of these boxes intersect with the given test box.\n     * @returns `true` if any intersection found.\n     */\n    intersectsDetails(testBox: CollisionBox, boxes: IBox[]): boolean {\n        for (const box of boxes) {\n            if (box instanceof DetailedCollisionBox) {\n                for (const detailBox of box.detailBoxes) {\n                    if (detailBox.intersects(testBox)) {\n                        return true;\n                    }\n                }\n            } else if (isLineWithBound(box)) {\n                const boundedLine = box as LineWithBound;\n                if (this.intersectsLine(testBox, boundedLine)) {\n                    return true;\n                }\n            } else {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Computes the intersection between the supplied CollisionBox and the LineWithBound.\n     * @note The [[CollisionBox]] is in Screen Bounds space, whereas the line must be\n     * in Screen Coordinate space\n     */\n    private intersectsLine(bbox: CollisionBox, boundedLine: LineWithBound): boolean {\n        const line = boundedLine.line;\n\n        // Note, these aren't normalized, but it doesn't matter, we are just interested\n        // in the sign.\n        const lineXDiffTransformed = line.end.x - line.start.x;\n\n        // Sign of bottom left, bottom right, top left and top right corners.\n        let signBL: number;\n        let signBR: number;\n        let signTL: number;\n        let signTR: number;\n        if (lineXDiffTransformed !== 0) {\n            const lineYDiffTransformed = line.end.y - line.start.y;\n            const normalX = lineYDiffTransformed;\n            const normalY = -lineXDiffTransformed;\n            const D = line.start.y - (lineYDiffTransformed / lineXDiffTransformed) * line.start.x;\n\n            signBL = Math.sign(bbox.minX * normalX + (bbox.minY - D) * normalY);\n            signBR = Math.sign(bbox.maxX * normalX + (bbox.minY - D) * normalY);\n            signTL = Math.sign(bbox.minX * normalX + (bbox.maxY - D) * normalY);\n            signTR = Math.sign(bbox.maxX * normalX + (bbox.maxY - D) * normalY);\n        } else {\n            signBL = Math.sign(bbox.minX - line.start.x);\n            signBR = Math.sign(bbox.maxX - line.start.x);\n            signTL = Math.sign(bbox.minX - line.start.x);\n            signTR = Math.sign(bbox.maxX - line.start.x);\n        }\n        return signBL !== signBR || signBL !== signTL || signBL !== signTR;\n    }\n}\n\n/**\n * @hidden\n *\n * Shows requests for screen space during labelling in an HTML canvas, which should be sized like\n * the actual map canvas. It can be placed on top of the map canvas to show exactly which requests\n * for screen space were done.\n *\n * Also logs statistics.\n */\nexport class ScreenCollisionsDebug extends ScreenCollisions {\n    /** 2D rendering context. */\n    private m_renderContext: CanvasRenderingContext2D | null = null;\n    private m_renderingEnabled = false;\n    private m_numAllocations = 0;\n    private m_numSuccessfulTests = 0;\n    private m_numFailedTests = 0;\n    private m_numSuccessfulVisibilityTests = 0;\n    private m_numFailedVisibilityTests = 0;\n\n    /**\n     * Constructs a new ScreenCollisions object which renders its state to a 2D canvas.\n     */\n    constructor(debugCanvas: HTMLCanvasElement) {\n        super();\n\n        if (debugCanvas !== undefined && debugCanvas !== null) {\n            this.m_renderContext = debugCanvas.getContext(\"2d\");\n        }\n    }\n\n    /**\n     * Resets the list of allocated bounds and clears the debug canvas.\n     * @override\n     */\n    reset() {\n        super.reset();\n\n        this.m_numAllocations = 0;\n        this.m_numSuccessfulTests = 0;\n        this.m_numFailedTests = 0;\n        this.m_numSuccessfulVisibilityTests = 0;\n        this.m_numFailedVisibilityTests = 0;\n    }\n\n    /**\n     * Updates the screen bounds used to check if bounding boxes are visible.\n     *\n     * @param width - The width of the container.\n     * @param height - The height of the container.\n     * @override\n     */\n    update(width: number, height: number) {\n        if (this.m_renderingEnabled) {\n            logger.log(\n                // tslint:disable-next-line: max-line-length\n                `Allocations: ${this.m_numAllocations} Successful Tests: ${this.m_numSuccessfulTests} Failed Tests: ${this.m_numFailedTests}  Successful Visibility Tests: ${this.m_numSuccessfulVisibilityTests}  Failed Visibility Tests: ${this.m_numFailedVisibilityTests} `\n            );\n        }\n\n        super.update(width, height);\n\n        if (this.m_renderContext !== null) {\n            this.m_renderContext.canvas.width = width;\n            this.m_renderContext.canvas.height = height;\n        }\n\n        // activate in the browser with:\n        // window.__debugContext.setValue(\"DEBUG_SCREEN_COLLISIONS\", true)\n        this.m_renderingEnabled = debugContext.getValue(\"DEBUG_SCREEN_COLLISIONS\");\n    }\n\n    /**\n     * Marks the region of the screen intersecting with the given bounding box as allocated.\n     *\n     * @param bounds - the bounding box in world coordinates.\n     * @override\n     */\n    allocate(bounds: Math2D.Box | CollisionBox): void {\n        super.allocate(bounds);\n\n        this.m_numAllocations++;\n\n        if (this.m_renderingEnabled && this.m_renderContext !== null) {\n            this.m_renderContext.strokeStyle = \"#6666ff\";\n            this.m_renderContext.strokeRect(\n                bounds.x - this.screenBounds.x,\n                this.screenBounds.y + this.screenBounds.h - bounds.y,\n                bounds.w,\n                -bounds.h\n            );\n        }\n    }\n\n    /** @override */\n    allocateIBoxes(boundsArray: IBox[]) {\n        for (const bounds of boundsArray) {\n            this.m_numAllocations++;\n\n            if (this.m_renderingEnabled && this.m_renderContext !== null) {\n                this.m_renderContext.strokeStyle = \"#aa2222\";\n                this.m_renderContext.strokeRect(\n                    bounds.minX - this.screenBounds.x,\n                    this.screenBounds.y + this.screenBounds.h - bounds.minY,\n                    bounds.maxX - bounds.minX,\n                    -(bounds.maxY - bounds.minY)\n                );\n            }\n        }\n        super.allocateIBoxes(boundsArray);\n    }\n\n    /** @override */\n    intersectsDetails(testBox: CollisionBox, boxes: IBox[]): boolean {\n        const collisionFound = super.intersectsDetails(testBox, boxes);\n        if (this.m_renderingEnabled && this.m_renderContext !== null) {\n            const padding = collisionFound ? 2 : 1;\n            this.m_renderContext.strokeStyle = collisionFound ? \"#FF0000\" : \"#00ff00\";\n            this.m_renderContext.strokeRect(\n                testBox.x - this.screenBounds.x - padding,\n                this.screenBounds.y + this.screenBounds.h - testBox.y + padding,\n                testBox.w + 2 * padding,\n                -testBox.h - 2 * padding\n            );\n        }\n\n        if (collisionFound) {\n            this.m_numFailedTests++;\n        } else {\n            this.m_numSuccessfulTests++;\n        }\n\n        return collisionFound;\n    }\n\n    /**\n     * Checks if the given screen bounds intersects with the frustum of the active camera.\n     *\n     * @param bounds - The bounding box in world coordinates.\n     * @override\n     */\n    isVisible(bounds: Math2D.Box): boolean {\n        const visible = super.isVisible(bounds);\n\n        if (visible) {\n            this.m_numSuccessfulVisibilityTests++;\n        } else {\n            this.m_numFailedVisibilityTests++;\n        }\n        return visible;\n    }\n}\n","!function(t,i){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=i():\"function\"==typeof define&&define.amd?define(i):(t=t||self).RBush=i()}(this,function(){\"use strict\";function t(t,r,e,a,h){!function t(n,r,e,a,h){for(;a>e;){if(a-e>600){var o=a-e+1,s=r-e+1,l=Math.log(o),f=.5*Math.exp(2*l/3),u=.5*Math.sqrt(l*f*(o-f)/o)*(s-o/2<0?-1:1),m=Math.max(e,Math.floor(r-s*f/o+u)),c=Math.min(a,Math.floor(r+(o-s)*f/o+u));t(n,r,m,c,h)}var p=n[r],d=e,x=a;for(i(n,e,r),h(n[a],p)>0&&i(n,e,a);d<x;){for(i(n,d,x),d++,x--;h(n[d],p)<0;)d++;for(;h(n[x],p)>0;)x--}0===h(n[e],p)?i(n,e,x):i(n,++x,a),x<=r&&(e=x+1),r<=x&&(a=x-1)}}(t,r,e||0,a||t.length-1,h||n)}function i(t,i,n){var r=t[i];t[i]=t[n],t[n]=r}function n(t,i){return t<i?-1:t>i?1:0}var r=function(t){void 0===t&&(t=9),this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()};function e(t,i,n){if(!n)return i.indexOf(t);for(var r=0;r<i.length;r++)if(n(t,i[r]))return r;return-1}function a(t,i){h(t,0,t.children.length,i,t)}function h(t,i,n,r,e){e||(e=p(null)),e.minX=1/0,e.minY=1/0,e.maxX=-1/0,e.maxY=-1/0;for(var a=i;a<n;a++){var h=t.children[a];o(e,t.leaf?r(h):h)}return e}function o(t,i){return t.minX=Math.min(t.minX,i.minX),t.minY=Math.min(t.minY,i.minY),t.maxX=Math.max(t.maxX,i.maxX),t.maxY=Math.max(t.maxY,i.maxY),t}function s(t,i){return t.minX-i.minX}function l(t,i){return t.minY-i.minY}function f(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function u(t){return t.maxX-t.minX+(t.maxY-t.minY)}function m(t,i){return t.minX<=i.minX&&t.minY<=i.minY&&i.maxX<=t.maxX&&i.maxY<=t.maxY}function c(t,i){return i.minX<=t.maxX&&i.minY<=t.maxY&&i.maxX>=t.minX&&i.maxY>=t.minY}function p(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function d(i,n,r,e,a){for(var h=[n,r];h.length;)if(!((r=h.pop())-(n=h.pop())<=e)){var o=n+Math.ceil((r-n)/e/2)*e;t(i,o,n,r,a),h.push(n,o,o,r)}}return r.prototype.all=function(){return this._all(this.data,[])},r.prototype.search=function(t){var i=this.data,n=[];if(!c(t,i))return n;for(var r=this.toBBox,e=[];i;){for(var a=0;a<i.children.length;a++){var h=i.children[a],o=i.leaf?r(h):h;c(t,o)&&(i.leaf?n.push(h):m(t,o)?this._all(h,n):e.push(h))}i=e.pop()}return n},r.prototype.collides=function(t){var i=this.data;if(!c(t,i))return!1;for(var n=[];i;){for(var r=0;r<i.children.length;r++){var e=i.children[r],a=i.leaf?this.toBBox(e):e;if(c(t,a)){if(i.leaf||m(t,a))return!0;n.push(e)}}i=n.pop()}return!1},r.prototype.load=function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var i=0;i<t.length;i++)this.insert(t[i]);return this}var n=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===n.height)this._splitRoot(this.data,n);else{if(this.data.height<n.height){var r=this.data;this.data=n,n=r}this._insert(n,this.data.height-n.height-1,!0)}else this.data=n;return this},r.prototype.insert=function(t){return t&&this._insert(t,this.data.height-1),this},r.prototype.clear=function(){return this.data=p([]),this},r.prototype.remove=function(t,i){if(!t)return this;for(var n,r,a,h=this.data,o=this.toBBox(t),s=[],l=[];h||s.length;){if(h||(h=s.pop(),r=s[s.length-1],n=l.pop(),a=!0),h.leaf){var f=e(t,h.children,i);if(-1!==f)return h.children.splice(f,1),s.push(h),this._condense(s),this}a||h.leaf||!m(h,o)?r?(n++,h=r.children[n],a=!1):h=null:(s.push(h),l.push(n),n=0,r=h,h=h.children[0])}return this},r.prototype.toBBox=function(t){return t},r.prototype.compareMinX=function(t,i){return t.minX-i.minX},r.prototype.compareMinY=function(t,i){return t.minY-i.minY},r.prototype.toJSON=function(){return this.data},r.prototype.fromJSON=function(t){return this.data=t,this},r.prototype._all=function(t,i){for(var n=[];t;)t.leaf?i.push.apply(i,t.children):n.push.apply(n,t.children),t=n.pop();return i},r.prototype._build=function(t,i,n,r){var e,h=n-i+1,o=this._maxEntries;if(h<=o)return a(e=p(t.slice(i,n+1)),this.toBBox),e;r||(r=Math.ceil(Math.log(h)/Math.log(o)),o=Math.ceil(h/Math.pow(o,r-1))),(e=p([])).leaf=!1,e.height=r;var s=Math.ceil(h/o),l=s*Math.ceil(Math.sqrt(o));d(t,i,n,l,this.compareMinX);for(var f=i;f<=n;f+=l){var u=Math.min(f+l-1,n);d(t,f,u,s,this.compareMinY);for(var m=f;m<=u;m+=s){var c=Math.min(m+s-1,u);e.children.push(this._build(t,m,c,r-1))}}return a(e,this.toBBox),e},r.prototype._chooseSubtree=function(t,i,n,r){for(;r.push(i),!i.leaf&&r.length-1!==n;){for(var e=1/0,a=1/0,h=void 0,o=0;o<i.children.length;o++){var s=i.children[o],l=f(s),u=(m=t,c=s,(Math.max(c.maxX,m.maxX)-Math.min(c.minX,m.minX))*(Math.max(c.maxY,m.maxY)-Math.min(c.minY,m.minY))-l);u<a?(a=u,e=l<e?l:e,h=s):u===a&&l<e&&(e=l,h=s)}i=h||i.children[0]}var m,c;return i},r.prototype._insert=function(t,i,n){var r=n?t:this.toBBox(t),e=[],a=this._chooseSubtree(r,this.data,i,e);for(a.children.push(t),o(a,r);i>=0&&e[i].children.length>this._maxEntries;)this._split(e,i),i--;this._adjustParentBBoxes(r,e,i)},r.prototype._split=function(t,i){var n=t[i],r=n.children.length,e=this._minEntries;this._chooseSplitAxis(n,e,r);var h=this._chooseSplitIndex(n,e,r),o=p(n.children.splice(h,n.children.length-h));o.height=n.height,o.leaf=n.leaf,a(n,this.toBBox),a(o,this.toBBox),i?t[i-1].children.push(o):this._splitRoot(n,o)},r.prototype._splitRoot=function(t,i){this.data=p([t,i]),this.data.height=t.height+1,this.data.leaf=!1,a(this.data,this.toBBox)},r.prototype._chooseSplitIndex=function(t,i,n){for(var r,e,a,o,s,l,u,m=1/0,c=1/0,p=i;p<=n-i;p++){var d=h(t,0,p,this.toBBox),x=h(t,p,n,this.toBBox),v=(e=d,a=x,o=void 0,s=void 0,l=void 0,u=void 0,o=Math.max(e.minX,a.minX),s=Math.max(e.minY,a.minY),l=Math.min(e.maxX,a.maxX),u=Math.min(e.maxY,a.maxY),Math.max(0,l-o)*Math.max(0,u-s)),M=f(d)+f(x);v<m?(m=v,r=p,c=M<c?M:c):v===m&&M<c&&(c=M,r=p)}return r||n-i},r.prototype._chooseSplitAxis=function(t,i,n){var r=t.leaf?this.compareMinX:s,e=t.leaf?this.compareMinY:l;this._allDistMargin(t,i,n,r)<this._allDistMargin(t,i,n,e)&&t.children.sort(r)},r.prototype._allDistMargin=function(t,i,n,r){t.children.sort(r);for(var e=this.toBBox,a=h(t,0,i,e),s=h(t,n-i,n,e),l=u(a)+u(s),f=i;f<n-i;f++){var m=t.children[f];o(a,t.leaf?e(m):m),l+=u(a)}for(var c=n-i-1;c>=i;c--){var p=t.children[c];o(s,t.leaf?e(p):p),l+=u(s)}return l},r.prototype._adjustParentBBoxes=function(t,i,n){for(var r=n;r>=0;r--)o(i[r],t)},r.prototype._condense=function(t){for(var i=t.length-1,n=void 0;i>=0;i--)0===t[i].children.length?i>0?(n=t[i-1].children).splice(n.indexOf(t[i]),1):this.clear():a(t[i],this.toBBox)},r});\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    ColorUtils,\n    getPropertyValue,\n    isPoiTechnique,\n    LineMarkerTechnique,\n    MapEnv,\n    PlacementToken,\n    PoiTechnique,\n    TextStyleDefinition,\n    TextTechnique,\n    Theme\n} from \"@here/harp-datasource-protocol\";\nimport {\n    DefaultTextStyle,\n    FontStyle,\n    FontUnit,\n    FontVariant,\n    HorizontalAlignment,\n    HorizontalPlacement,\n    resolvePlacementAndAlignment,\n    TextCanvas,\n    TextLayoutParameters,\n    TextLayoutStyle,\n    TextPlacement,\n    TextPlacements,\n    TextRenderParameters,\n    TextRenderStyle,\n    VerticalAlignment,\n    VerticalPlacement,\n    WrappingMode\n} from \"@here/harp-text-canvas\";\nimport { getOptionValue, LoggerManager } from \"@here/harp-utils\";\nimport { ColorCache } from \"../ColorCache\";\nimport { evaluateColorProperty } from \"../DecodedTileHelpers\";\nimport { PoiRenderer } from \"../poi/PoiRenderer\";\nimport { Tile } from \"../Tile\";\nimport { TextCanvasRenderer } from \"./TextCanvasRenderer\";\n\nconst logger = LoggerManager.instance.create(\"TextStyleCache\");\n\nconst defaultTextRenderStyle = new TextRenderStyle({\n    fontSize: {\n        unit: FontUnit.Pixel,\n        size: 32,\n        backgroundSize: 8\n    },\n    color: ColorCache.instance.getColor(\"#6d7477\"),\n    opacity: 1.0,\n    backgroundColor: ColorCache.instance.getColor(\"#f7fbfd\"),\n    backgroundOpacity: 0.5\n});\n\n// By default text layout provides no options for placement, but single alignment.\nconst defaultTextLayoutStyle = new TextLayoutStyle({\n    verticalAlignment: VerticalAlignment.Center,\n    horizontalAlignment: HorizontalAlignment.Center,\n    placements: []\n});\n\nconst DEFAULT_STYLE_NAME = \"default\";\n\n/**\n * {@link TextElementsRenderer} representation of a\n * {@link @here/harp-datasource-protocol#Theme}'s TextStyle.\n */\nexport interface TextElementStyle {\n    name: string;\n    fontCatalog: string;\n    renderParams: TextRenderParameters;\n    layoutParams: TextLayoutParameters;\n    textCanvas?: TextCanvas;\n    poiRenderer?: PoiRenderer;\n}\n\nexport class TextStyleCache {\n    private m_textStyles: Map<string, TextElementStyle> = new Map();\n    private m_defaultStyle: TextElementStyle = {\n        name: DEFAULT_STYLE_NAME,\n        fontCatalog: \"\",\n        renderParams: defaultTextRenderStyle.params,\n        layoutParams: defaultTextLayoutStyle.params\n    };\n\n    constructor(private m_theme: Theme) {}\n\n    initializeDefaultTextElementStyle(defaultFontCatalogName: string) {\n        if (this.m_theme.textStyles === undefined) {\n            this.m_theme.textStyles = [];\n        }\n        const styles = this.m_theme.textStyles;\n\n        const themedDefaultStyle = styles.find(style => style.name === DEFAULT_STYLE_NAME);\n        if (themedDefaultStyle !== undefined) {\n            this.m_defaultStyle = this.createTextElementStyle(\n                themedDefaultStyle,\n                DEFAULT_STYLE_NAME\n            );\n        } else if (this.m_theme.defaultTextStyle !== undefined) {\n            this.m_defaultStyle = this.createTextElementStyle(\n                this.m_theme.defaultTextStyle,\n                DEFAULT_STYLE_NAME\n            );\n        } else if (styles.length > 0) {\n            this.m_defaultStyle = this.createTextElementStyle(styles[0], DEFAULT_STYLE_NAME);\n        }\n        this.m_defaultStyle.fontCatalog = defaultFontCatalogName;\n    }\n\n    initializeTextElementStyles(\n        defaultPoiRenderer: PoiRenderer,\n        defaultTextCanvas: TextCanvas,\n        textRenderers: TextCanvasRenderer[]\n    ) {\n        // Initialize default text style.\n        if (this.m_defaultStyle.fontCatalog !== undefined) {\n            const styledTextRenderer = textRenderers.find(\n                textRenderer => textRenderer.fontCatalog === this.m_defaultStyle.fontCatalog\n            );\n            this.m_defaultStyle.textCanvas =\n                styledTextRenderer !== undefined ? styledTextRenderer.textCanvas : undefined;\n            this.m_defaultStyle.poiRenderer =\n                styledTextRenderer !== undefined ? styledTextRenderer.poiRenderer : undefined;\n        }\n        if (this.m_defaultStyle.textCanvas === undefined) {\n            if (this.m_defaultStyle.fontCatalog !== undefined) {\n                logger.warn(\n                    `FontCatalog '${this.m_defaultStyle.fontCatalog}' set in TextStyle '${\n                        this.m_defaultStyle.name\n                    }' not found, using default fontCatalog(${\n                        defaultTextCanvas!.fontCatalog.name\n                    }).`\n                );\n            }\n            this.m_defaultStyle.textCanvas = defaultTextCanvas;\n            this.m_defaultStyle.poiRenderer = defaultPoiRenderer;\n        }\n\n        // Initialize theme text styles.\n        this.m_theme.textStyles!.forEach(element => {\n            this.m_textStyles.set(\n                element.name!,\n                this.createTextElementStyle(element, element.name!)\n            );\n        });\n        // tslint:disable-next-line:no-unused-variable\n        for (const [, style] of this.m_textStyles) {\n            if (style.textCanvas === undefined) {\n                if (style.fontCatalog !== undefined) {\n                    const styledTextRenderer = textRenderers.find(\n                        textRenderer => textRenderer.fontCatalog === style.fontCatalog\n                    );\n                    style.textCanvas =\n                        styledTextRenderer !== undefined\n                            ? styledTextRenderer.textCanvas\n                            : undefined;\n                    style.poiRenderer =\n                        styledTextRenderer !== undefined\n                            ? styledTextRenderer.poiRenderer\n                            : undefined;\n                }\n                if (style.textCanvas === undefined) {\n                    if (style.fontCatalog !== undefined) {\n                        logger.warn(\n                            `FontCatalog '${style.fontCatalog}' set in TextStyle '${\n                                style.name\n                            }' not found, using default fontCatalog(${\n                                defaultTextCanvas!.fontCatalog.name\n                            }).`\n                        );\n                    }\n                    style.textCanvas = defaultTextCanvas;\n                    style.poiRenderer = defaultPoiRenderer;\n                }\n            }\n        }\n    }\n\n    /**\n     * Retrieves a {@link TextElementStyle} for {@link @here/harp-datasource-protocol#Theme}'s\n     * [[TextStyle]] id.\n     */\n    getTextElementStyle(styleId?: string): TextElementStyle {\n        let result;\n        if (styleId === undefined) {\n            result = this.m_defaultStyle;\n        } else {\n            result = this.m_textStyles.get(styleId);\n            if (result === undefined) {\n                result = this.m_defaultStyle;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Gets the appropriate {@link @here/harp-text-canvas#TextRenderStyle}\n     * to use for a label. Depends heavily on the label's\n     * [[Technique]] and the current zoomLevel.\n     */\n    createRenderStyle(\n        tile: Tile,\n        technique: TextTechnique | PoiTechnique | LineMarkerTechnique\n    ): TextRenderStyle {\n        const mapView = tile.mapView;\n        const zoomLevel = mapView.zoomLevel;\n        const discreteZoomLevel = Math.floor(zoomLevel);\n\n        // Environment with $zoom forced to integer to achieve stable interpolated values.\n        const discreteZoomEnv = new MapEnv({ $zoom: discreteZoomLevel }, mapView.env);\n\n        const defaultRenderParams = this.m_defaultStyle.renderParams;\n\n        // Sets opacity to 1.0 if default and technique attribute are undefined.\n        const defaultOpacity = getOptionValue(defaultRenderParams.opacity, 1.0);\n        // Interpolate opacity but only on discreet zoom levels (step interpolation).\n        let opacity = getPropertyValue(\n            getOptionValue(technique.opacity, defaultOpacity),\n            discreteZoomEnv\n        );\n\n        let color: THREE.Color | undefined;\n        // Store color (RGB) in cache and multiply opacity value with the color alpha channel.\n        if (technique.color !== undefined) {\n            let hexColor = evaluateColorProperty(technique.color, discreteZoomEnv);\n            if (hexColor !== undefined) {\n                if (ColorUtils.hasAlphaInHex(hexColor)) {\n                    const alpha = ColorUtils.getAlphaFromHex(hexColor);\n                    opacity = opacity * alpha;\n                    hexColor = ColorUtils.removeAlphaFromHex(hexColor);\n                }\n                color = ColorCache.instance.getColor(hexColor);\n            }\n        }\n\n        // Sets background size to 0.0 if default and technique attribute is undefined.\n        const defaultBackgroundSize = getOptionValue(\n            defaultRenderParams.fontSize!.backgroundSize,\n            0\n        );\n        const backgroundSize = getPropertyValue(\n            getOptionValue(technique.backgroundSize, defaultBackgroundSize),\n            discreteZoomEnv\n        );\n\n        const hasBackgroundDefined =\n            technique.backgroundColor !== undefined &&\n            technique.backgroundSize !== undefined &&\n            backgroundSize > 0;\n\n        // Sets background opacity to 1.0 if default and technique value is undefined while\n        // background size and color is specified, otherwise set value in default render\n        // params or 0.0 if neither set. Makes label opaque when backgroundColor and\n        // backgroundSize are set.\n        const defaultBackgroundOpacity = getOptionValue(defaultRenderParams.backgroundOpacity, 0.0);\n        let backgroundOpacity = getPropertyValue(\n            getOptionValue(\n                technique.backgroundOpacity,\n                hasBackgroundDefined ? 1.0 : defaultBackgroundOpacity\n            ),\n            discreteZoomEnv\n        );\n\n        let backgroundColor: THREE.Color | undefined;\n        // Store background color (RGB) in cache and multiply backgroundOpacity by its alpha.\n        if (technique.backgroundColor !== undefined) {\n            let hexBgColor = evaluateColorProperty(technique.backgroundColor, discreteZoomEnv);\n            if (hexBgColor !== undefined) {\n                if (ColorUtils.hasAlphaInHex(hexBgColor)) {\n                    const alpha = ColorUtils.getAlphaFromHex(hexBgColor);\n                    backgroundOpacity = backgroundOpacity * alpha;\n                    hexBgColor = ColorUtils.removeAlphaFromHex(hexBgColor);\n                }\n                backgroundColor = ColorCache.instance.getColor(hexBgColor);\n            }\n        }\n\n        const renderParams = {\n            fontName: getOptionValue(technique.fontName, defaultRenderParams.fontName),\n            fontSize: {\n                unit: FontUnit.Pixel,\n                size: getPropertyValue(\n                    getOptionValue(technique.size, defaultRenderParams.fontSize!.size),\n                    discreteZoomEnv\n                ),\n                backgroundSize\n            },\n            fontStyle:\n                technique.fontStyle === \"Regular\" ||\n                technique.fontStyle === \"Bold\" ||\n                technique.fontStyle === \"Italic\" ||\n                technique.fontStyle === \"BoldItalic\"\n                    ? FontStyle[technique.fontStyle]\n                    : defaultRenderParams.fontStyle,\n            fontVariant:\n                technique.fontVariant === \"Regular\" ||\n                technique.fontVariant === \"AllCaps\" ||\n                technique.fontVariant === \"SmallCaps\"\n                    ? FontVariant[technique.fontVariant]\n                    : defaultRenderParams.fontVariant,\n            rotation: getOptionValue(technique.rotation, defaultRenderParams.rotation),\n            color: getOptionValue(\n                color,\n                getOptionValue(defaultRenderParams.color, DefaultTextStyle.DEFAULT_COLOR)\n            ),\n            backgroundColor: getOptionValue(\n                backgroundColor,\n                getOptionValue(\n                    defaultRenderParams.backgroundColor,\n                    DefaultTextStyle.DEFAULT_BACKGROUND_COLOR\n                )\n            ),\n            opacity,\n            backgroundOpacity\n        };\n\n        const themeRenderParams = this.getTextElementStyle(technique.style).renderParams;\n        const renderStyle = new TextRenderStyle({\n            ...themeRenderParams,\n            ...renderParams\n        });\n\n        return renderStyle;\n    }\n\n    /**\n     * Create the appropriate {@link @here/harp-text-canvas#TextLayoutStyle}\n     * to use for a label. Depends heavily on the label's\n     * [[Technique]] and the current zoomLevel.\n     *\n     * @param tile - The {@link Tile} to process.\n     * @param technique - Label's technique.\n     */\n    createLayoutStyle(\n        tile: Tile,\n        technique: TextTechnique | PoiTechnique | LineMarkerTechnique\n    ): TextLayoutStyle {\n        const mapView = tile.mapView;\n        const floorZoomLevel = Math.floor(tile.mapView.zoomLevel);\n\n        const discreteZoomEnv = new MapEnv({ $zoom: floorZoomLevel }, mapView.env);\n\n        const defaultLayoutParams = this.m_defaultStyle.layoutParams;\n\n        const hAlignment = getPropertyValue(technique.hAlignment, discreteZoomEnv) as string | null;\n        const vAlignment = getPropertyValue(technique.vAlignment, discreteZoomEnv) as string | null;\n\n        // Text alternative placements are currently supported only for PoiTechnique.\n        const textPlacements = isPoiTechnique(technique)\n            ? (getPropertyValue((technique as PoiTechnique).placements, discreteZoomEnv) as\n                  | string\n                  | null)\n            : null;\n\n        const { horizontalAlignment, verticalAlignment, placements } = parseAlignmentAndPlacements(\n            hAlignment,\n            vAlignment,\n            textPlacements\n        );\n\n        const wrapping = getPropertyValue(technique.wrappingMode, discreteZoomEnv) as string | null;\n\n        const wrappingMode =\n            wrapping === \"None\" || wrapping === \"Character\" || wrapping === \"Word\"\n                ? WrappingMode[wrapping]\n                : defaultLayoutParams.wrappingMode;\n\n        const layoutParams = {\n            tracking:\n                getPropertyValue(technique.tracking, discreteZoomEnv) ??\n                defaultLayoutParams.tracking,\n            leading:\n                getPropertyValue(technique.leading, discreteZoomEnv) ?? defaultLayoutParams.leading,\n            maxLines:\n                getPropertyValue(technique.maxLines, discreteZoomEnv) ??\n                defaultLayoutParams.maxLines,\n            lineWidth:\n                getPropertyValue(technique.lineWidth, discreteZoomEnv) ??\n                defaultLayoutParams.lineWidth,\n            canvasRotation:\n                getPropertyValue(technique.canvasRotation, discreteZoomEnv) ??\n                defaultLayoutParams.canvasRotation,\n            lineRotation:\n                getPropertyValue(technique.lineRotation, discreteZoomEnv) ??\n                defaultLayoutParams.lineRotation,\n            wrappingMode,\n            horizontalAlignment,\n            verticalAlignment,\n            placements\n        };\n\n        const themeLayoutParams = this.getTextElementStyle(technique.style);\n        const layoutStyle = new TextLayoutStyle({\n            ...themeLayoutParams,\n            ...layoutParams\n        });\n\n        return layoutStyle;\n    }\n\n    private createTextElementStyle(\n        style: TextStyleDefinition,\n        styleName: string\n    ): TextElementStyle {\n        const { horizontalAlignment, verticalAlignment, placements } = parseAlignmentAndPlacements(\n            style.hAlignment,\n            style.vAlignment,\n            style.placements\n        );\n        return {\n            name: styleName,\n            fontCatalog: getOptionValue(style.fontCatalogName, this.m_defaultStyle.fontCatalog),\n            renderParams: {\n                fontName: style.fontName,\n                fontSize: {\n                    unit: FontUnit.Pixel,\n                    size: 32,\n                    backgroundSize: style.backgroundSize || 8\n                },\n                fontStyle:\n                    style.fontStyle === \"Regular\" ||\n                    style.fontStyle === \"Bold\" ||\n                    style.fontStyle === \"Italic\" ||\n                    style.fontStyle === \"BoldItalic\"\n                        ? FontStyle[style.fontStyle]\n                        : undefined,\n                fontVariant:\n                    style.fontVariant === \"Regular\" ||\n                    style.fontVariant === \"AllCaps\" ||\n                    style.fontVariant === \"SmallCaps\"\n                        ? FontVariant[style.fontVariant]\n                        : undefined,\n                rotation: style.rotation,\n                color:\n                    style.color !== undefined\n                        ? ColorCache.instance.getColor(style.color)\n                        : undefined,\n                backgroundColor:\n                    style.backgroundColor !== undefined\n                        ? ColorCache.instance.getColor(style.backgroundColor)\n                        : undefined,\n                opacity: style.opacity,\n                backgroundOpacity: style.backgroundOpacity\n            },\n            layoutParams: {\n                tracking: style.tracking,\n                leading: style.leading,\n                maxLines: style.maxLines,\n                lineWidth: style.lineWidth,\n                canvasRotation: style.canvasRotation,\n                lineRotation: style.lineRotation,\n                wrappingMode:\n                    style.wrappingMode === \"None\" ||\n                    style.wrappingMode === \"Character\" ||\n                    style.wrappingMode === \"Word\"\n                        ? WrappingMode[style.wrappingMode]\n                        : WrappingMode.Word,\n                verticalAlignment,\n                horizontalAlignment,\n                placements\n            }\n        };\n    }\n}\n\nfunction parseAlignmentAndPlacements(\n    hAlignment: string | null | undefined,\n    vAlignment: string | null | undefined,\n    placementsTokens: string | null | undefined\n): {\n    horizontalAlignment: HorizontalAlignment;\n    verticalAlignment: VerticalAlignment;\n    placements: TextPlacements;\n} {\n    // Currently supported only for PoiTechnique.\n    const placements: TextPlacements | undefined = placementsTokens\n        ? parseTechniquePlacements(placementsTokens)\n        : undefined;\n\n    return resolvePlacementAndAlignment(\n        parseTechniqueHAlignValue(hAlignment),\n        parseTechniqueVAlignValue(vAlignment),\n        placements\n    );\n}\n\nfunction parseTechniqueHAlignValue(hAlignment: string | undefined | null): HorizontalAlignment {\n    return hAlignment === \"Left\" || hAlignment === \"Center\" || hAlignment === \"Right\"\n        ? HorizontalAlignment[hAlignment]\n        : defaultTextLayoutStyle.horizontalAlignment;\n}\n\nfunction parseTechniqueVAlignValue(vAlignment: string | undefined | null): VerticalAlignment {\n    return vAlignment === \"Above\" || vAlignment === \"Center\" || vAlignment === \"Below\"\n        ? VerticalAlignment[vAlignment]\n        : defaultTextLayoutStyle.verticalAlignment;\n}\n\nfunction parseTechniquePlacements(placementsString: string | undefined | null): TextPlacements {\n    // Parse placement properties if available.\n    const placements: TextPlacements = [];\n    const placementsTokens = placementsString\n        ? placementsString!\n              .toUpperCase()\n              .replace(\" \", \"\")\n              .split(\",\")\n        : [];\n    placementsTokens.forEach(p => {\n        const val = parseTechniquePlacementValue(p);\n        if (val !== undefined) {\n            placements.push(val);\n        }\n    });\n    return placements;\n}\n\nfunction parseTechniquePlacementValue(p: string): TextPlacement | undefined {\n    // May be only literal of single or two characters.\n    if (p.length < 1 || p.length > 2) {\n        return undefined;\n    }\n    // If no value is specified for vertical/horizontal placement it is by default center.\n    const textPlacement: TextPlacement = {\n        h: HorizontalPlacement.Center,\n        v: VerticalPlacement.Center\n    };\n    // Firstly try to find vertical placement.\n    let modifier = p.charAt(0);\n    let found: boolean = true;\n    switch (modifier) {\n        // Top / north\n        case PlacementToken.Top:\n        case PlacementToken.North:\n            textPlacement.v = VerticalPlacement.Top;\n            break;\n        // Bottom / south\n        case PlacementToken.Bottom:\n        case PlacementToken.South:\n            textPlacement.v = VerticalPlacement.Bottom;\n            break;\n        default:\n            found = false;\n            if (p.length === 2) {\n                // For 2 characters tag both vertical/horizontal should be defined.\n                return undefined;\n            }\n    }\n    if (found && p.length === 1) {\n        return textPlacement;\n    }\n    modifier = p.length === 1 ? p.charAt(0) : p.charAt(1);\n    switch (modifier) {\n        // Right / east\n        case PlacementToken.Right:\n        case PlacementToken.East:\n            textPlacement.h = HorizontalPlacement.Right;\n            break;\n        // Left / west\n        case PlacementToken.Left:\n        case PlacementToken.West:\n            textPlacement.h = HorizontalPlacement.Left;\n            break;\n        default:\n            // Either for single character or multi-char tag, we must surrender.\n            return undefined;\n    }\n    return textPlacement;\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { TilingScheme } from \"@here/harp-geoutils\";\nimport { TileKey } from \"@here/harp-geoutils/lib/tiling/TileKey\";\n\n/**\n * Status of the elevation range calculation.\n */\nexport enum CalculationStatus {\n    // Calculated approximately. A more precise result may be available later.\n    PendingApproximate,\n    // Calculation completed. The result is final, won't improve upon retrying.\n    FinalPrecise\n}\n\n/**\n * Elevation range with an optional calculation status.\n */\nexport interface ElevationRange {\n    minElevation: number;\n    maxElevation: number;\n    calculationStatus?: CalculationStatus;\n}\n\n/**\n * Source for elevation ranges per tile. The returned elevation ranges will be used in the visible\n * tile computation to calculate proper bounding boxes.\n */\nexport interface ElevationRangeSource {\n    /**\n     * Compute the elevation range for a given {@link @here/harp-geoutils#TileKey}.\n     * @param tileKey - The tile for which the elevation range should be computed.\n     */\n    getElevationRange(tileKey: TileKey): ElevationRange;\n\n    /**\n     * The tiling scheme of this {@link ElevationRangeSource}.\n     *\n     * @remarks\n     * {@link MapView} will only apply the elevation\n     * ranges returned by [[getElevationRange]] that have\n     * the same {@link @here/harp-geoutils#TilingScheme}.\n     */\n    getTilingScheme(): TilingScheme;\n\n    /**\n     * Connects to the underlying data.\n     */\n    connect(): Promise<void>;\n\n    /**\n     * Returns `true` if this `ElevationRangeSource` is ready and the {@link MapView} can invoke\n     * `getElevationRange()` to start requesting data.\n     */\n    ready(): boolean;\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { MapView } from \"../MapView\";\nimport { ImageItem } from \"./Image\";\nimport { ImageCache } from \"./ImageCache\";\n\n/**\n * Cache images wrapped into {@link ImageItem}s for a {@link MapView}.\n *\n * @remarks\n * An image may have multiple names in\n * a theme, the `MapViewImageCache` will take care of that.\n * Registering multiple images with the\n * same name is invalid.\n *\n * The `MapViewImageCache` uses a global {@link ImageCache} to actually store (and generate) the\n * image data.\n */\nexport class MapViewImageCache {\n    private m_name2Url: Map<string, string> = new Map();\n    private m_url2Name: Map<string, string[]> = new Map();\n\n    /**\n     * The constructor for `MapViewImageCache`.\n     *\n     * @param mapView - a {@link MapView} instance.\n     */\n    constructor(public mapView: MapView) {}\n\n    /**\n     * Register an existing image by name.\n     *\n     * @param name - Name of the image from {@link @here/harp-datasource-protocol#Theme}.\n     * @param url - URL of image.\n     * @param image - Optional [[ImageData]] of image.\n     */\n    registerImage(\n        name: string | undefined,\n        url: string,\n        image: ImageData | ImageBitmap | undefined\n    ): ImageItem {\n        if (name !== undefined) {\n            if (this.hasName(name)) {\n                throw new Error(\"duplicate name in cache\");\n            }\n\n            const oldNames = this.m_url2Name.get(url);\n            if (oldNames !== undefined) {\n                if (oldNames.indexOf(name) < 0) {\n                    oldNames.push(name);\n                }\n            } else {\n                this.m_url2Name.set(url, [name]);\n            }\n            this.m_name2Url.set(name, url);\n        }\n\n        const imageItem = ImageCache.instance.findImage(url);\n        if (imageItem === undefined) {\n            return ImageCache.instance.registerImage(this.mapView, url, image);\n        }\n        return imageItem;\n    }\n\n    /**\n     * Add an image and optionally start loading it. Once done, the [[ImageData]] or [[ImageBitmap]]\n     * will be stored in the {@link ImageItem}.\n     *\n     * @param name - Name of image from {@link @here/harp-datasource-protocol#Theme}.\n     * @param url - URL of image.\n     * @param startLoading - Optional. Pass `true` to start loading the image in the background.\n     */\n    addImage(\n        name: string,\n        url: string,\n        startLoading = true\n    ): ImageItem | Promise<ImageItem | undefined> {\n        const imageItem = this.registerImage(name, url, undefined);\n        if (startLoading === true) {\n            return ImageCache.instance.loadImage(imageItem);\n        }\n\n        return imageItem;\n    }\n\n    /**\n     * Find {@link ImageItem} by its name.\n     *\n     * @param name - Name of image.\n     */\n    findImageByName(name: string): ImageItem | undefined {\n        const url = this.m_name2Url.get(name);\n        if (url === undefined) {\n            return undefined;\n        }\n        return ImageCache.instance.findImage(url);\n    }\n\n    /**\n     * Find {@link ImageItem} by URL.\n     *\n     * @param url - Url of image.\n     */\n    findImageByUrl(url: string): ImageItem | undefined {\n        return ImageCache.instance.findImage(url);\n    }\n\n    /**\n     * Load an {@link ImageItem}. Returns a promise or a loaded {@link ImageItem}.\n     *\n     * @param imageItem - ImageItem to load.\n     */\n    loadImage(imageItem: ImageItem): ImageItem | Promise<ImageItem | undefined> {\n        return ImageCache.instance.loadImage(imageItem);\n    }\n\n    /**\n     * Remove all {@link ImageItem}s from the cache.\n     *\n     * @remarks\n     * Also removes all {@link ImageItem}s that belong to this\n     * {@link MapView} from the global {@link ImageCache}.\n     */\n    clear() {\n        ImageCache.instance.clear(this.mapView);\n        this.m_name2Url = new Map();\n        this.m_url2Name = new Map();\n    }\n\n    /**\n     * Returns number of image names stored in the cache.\n     */\n    get numberOfNames(): number {\n        return this.m_name2Url.size;\n    }\n\n    /**\n     * Returns number of image URLs in the cache.\n     */\n    get numberOfUrls(): number {\n        return this.m_url2Name.size;\n    }\n\n    /**\n     * Return `true` if an image with the given name is known.\n     *\n     * @param name - Name of the image.\n     */\n    hasName(name: string): boolean {\n        return this.m_name2Url.get(name) !== undefined;\n    }\n\n    /**\n     * Return `true` if an image with the given URL is known.\n     * @param url - URL of image.\n     */\n    hasUrl(url: string): boolean {\n        return this.m_url2Name.get(url) !== undefined;\n    }\n\n    /**\n     * Return the names under which an image with the given URL is saved.\n     */\n    findNames(url: string): string[] | undefined {\n        return this.m_url2Name.get(url);\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { LoggerManager } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { MapView } from \"../MapView\";\nimport { ImageItem } from \"./Image\";\nimport { MipMapGenerator } from \"./MipMapGenerator\";\n\nconst logger = LoggerManager.instance.create(\"ImageCache\");\nconst mipMapGenerator = new MipMapGenerator();\n\n// override declaration of createImageBitmap, add optional options parameter that\n// was removed in typings for TypeScript 3.1\ndeclare function createImageBitmap(\n    image: ImageBitmapSource,\n    sx: number,\n    sy: number,\n    sw: number,\n    sh: number,\n    options?: any\n): Promise<ImageBitmap>;\n\n/**\n * Combines an {@link ImageItem} with a list of [[MapViews]] that reference it.\n */\nclass ImageCacheItem {\n    /**\n     * The list of {@link MapView}s referencing the {@link ImageItem}.\n     */\n    mapViews: MapView[] = [];\n\n    /**\n     * Instantiates `ImageCacheItem`.\n     *\n     * @param imageItem - The {@link ImageItem} referenced by\n     *                    the associated {@link MapView}s instances.\n     * @param mapView - An optional first {@link MapView} referencing the {@link ImageItem}.\n     */\n    constructor(public imageItem: ImageItem, mapView?: MapView) {\n        if (mapView !== undefined) {\n            this.mapViews.push(mapView);\n        }\n    }\n}\n\n/**\n * `ImageCache` is a singleton, so it can be used with multiple MapViews on a single page. This\n * allows to have an image loaded only once for multiple views. THREE is doing something similar,\n * but does not allow to share images that have been loaded from a canvas (which we may need to do\n * if we use SVG images for textures).\n *\n * One application that makes our own cache necessary is the generation of our own textures from\n * data that is not an URL.\n *\n * The `ImageCache` can be improved by adding satistics for memory footprint as well.\n */\nexport class ImageCache {\n    /**\n     * Returns the singleton `instance` of the `ImageCache`.\n     */\n    static get instance(): ImageCache {\n        if (ImageCache.m_instance === undefined) {\n            ImageCache.m_instance = new ImageCache();\n        }\n        return ImageCache.m_instance;\n    }\n\n    /**\n     * Dispose the singleton object. Not normally implemented for singletons, but good for\n     * debugging.\n     */\n    static dispose(): void {\n        ImageCache.m_instance = undefined;\n    }\n\n    private static m_instance: ImageCache | undefined;\n\n    private m_images: Map<string, ImageCacheItem> = new Map();\n\n    /**\n     * Add an image definition to the global cache. Useful when the image data is already loaded.\n     *\n     * @param mapView - Specifiy which {@link MapView} requests the image.\n     * @param url - URL of image.\n     * @param imageData - Optional [ImageData]] containing the image content.\n     */\n    registerImage(\n        mapView: MapView,\n        url: string,\n        imageData: ImageData | ImageBitmap | undefined\n    ): ImageItem {\n        let imageCacheItem = this.findImageCacheItem(url);\n        if (imageCacheItem !== undefined) {\n            if (mapView !== undefined && imageCacheItem.mapViews.indexOf(mapView) < 0) {\n                imageCacheItem.mapViews.push(mapView);\n            }\n            return imageCacheItem.imageItem;\n        }\n\n        const mapViews: MapView[] = [];\n        if (mapView !== undefined) {\n            mapViews.push(mapView);\n        }\n\n        imageCacheItem = {\n            imageItem: {\n                url,\n                imageData,\n                loaded: false\n            },\n            mapViews\n        };\n\n        this.m_images.set(url, imageCacheItem);\n\n        return imageCacheItem.imageItem;\n    }\n\n    /**\n     * Add an image definition, and optionally start loading the content.\n     *\n     * @param mapView - {@link MapView} requesting the image.\n     * @param url - URL of image.\n     * @param startLoading - Optional flag. If `true` the image will be loaded in the background.\n     */\n    addImage(\n        mapView: MapView,\n        url: string,\n        startLoading = true\n    ): ImageItem | Promise<ImageItem | undefined> | undefined {\n        const imageItem = this.registerImage(mapView, url, undefined);\n        if (imageItem !== undefined && startLoading === true) {\n            return this.loadImage(imageItem);\n        }\n\n        return imageItem;\n    }\n\n    /**\n     * Find {@link ImageItem} for the specified URL.\n     *\n     * @param url - URL of image.\n     * @returns `ImageItem` for the URL if the URL is registered, `undefined` otherwise.\n     */\n    findImage(url: string): ImageItem | undefined {\n        const imageItem = this.m_images.get(url);\n        if (imageItem !== undefined) {\n            return imageItem.imageItem;\n        }\n        return undefined;\n    }\n\n    /**\n     * Clear all {@link ImageItem}s belonging to a {@link MapView}. May remove cached items if no\n     * {@link MapView} are registered anymore.\n     *\n     * @param mapView - MapView to remove all {@link ImageItem}s from.\n     */\n    clear(mapView: MapView) {\n        const itemsToRemove: string[] = [];\n\n        this.m_images.forEach(imageItem => {\n            const mapViewIndex = imageItem.mapViews.indexOf(mapView);\n            if (mapViewIndex >= 0) {\n                imageItem.mapViews.splice(mapViewIndex, 1);\n            }\n            if (imageItem.mapViews.length === 0) {\n                itemsToRemove.push(imageItem.imageItem.url);\n            }\n        });\n\n        for (const keyToDelete of itemsToRemove) {\n            this.m_images.delete(keyToDelete);\n        }\n    }\n\n    /**\n     * Clear all {@link ImageItem}s from all {@link MapView}s.\n     */\n    clearAll() {\n        this.m_images = new Map();\n    }\n\n    /**\n     * Returns the number of all cached {@link ImageItem}s.\n     */\n    get size(): number {\n        return this.m_images.size;\n    }\n\n    /**\n     * Load an {@link ImageItem}. If the loading process is already running, it returns the current\n     * promise.\n     *\n     * @param imageItem - `ImageItem` containing the URL to load image from.\n     * @returns An {@link ImageItem} if the image has already been loaded, a promise otherwise.\n     */\n    loadImage(imageItem: ImageItem): ImageItem | Promise<ImageItem | undefined> {\n        if (imageItem.imageData !== undefined) {\n            return imageItem;\n        }\n\n        if (imageItem.loadingPromise !== undefined) {\n            return imageItem.loadingPromise;\n        }\n\n        const imageLoader = new THREE.ImageLoader();\n\n        imageItem.loadingPromise = new Promise(resolve => {\n            logger.debug(`Loading image: ${imageItem.url}`);\n            imageLoader.load(\n                imageItem.url,\n                image => {\n                    logger.debug(`... finished loading image: ${imageItem.url}`);\n                    this.renderImage(imageItem, image)\n                        .then(() => {\n                            imageItem.mipMaps = mipMapGenerator.generateTextureAtlasMipMap(\n                                imageItem\n                            );\n                            imageItem.loadingPromise = undefined;\n                            resolve(imageItem);\n                        })\n                        .catch(ex => {\n                            logger.error(`... loading image failed: ${imageItem.url} : ${ex}`);\n                            resolve(undefined);\n                        });\n                },\n                // Loading events no longer supported\n                undefined,\n                errorEvent => {\n                    logger.error(`... loading image failed: ${imageItem.url} : ${errorEvent}`);\n\n                    imageItem.loadingPromise = undefined;\n                    resolve(undefined);\n                }\n            );\n        });\n        return imageItem.loadingPromise;\n    }\n\n    /**\n     * Find the cached {@link ImageItem} by URL.\n     *\n     * @param url - URL of image.\n     */\n    private findImageCacheItem(url: string): ImageCacheItem | undefined {\n        return this.m_images.get(url);\n    }\n\n    /**\n     * Render the `ImageItem` by using `createImageBitmap()` or by rendering the image into a\n     * [[HTMLCanvasElement]].\n     *\n     * @param imageItem - {@link ImageItem} to assign image data to.\n     * @param image - [[HTMLImageElement]] to\n     */\n    private renderImage(\n        imageItem: ImageItem,\n        image: HTMLImageElement\n    ): Promise<ImageData | ImageBitmap | undefined> {\n        return new Promise((resolve, reject) => {\n            // use createImageBitmap if it is available. It should be available in webworkers as\n            // well\n            if (typeof createImageBitmap === \"function\") {\n                const options: ImageBitmapOptions = {\n                    premultiplyAlpha: \"default\"\n                };\n\n                logger.debug(`Creating bitmap image: ${imageItem.url}`);\n                createImageBitmap(image, 0, 0, image.width, image.height, options)\n                    .then(imageBitmap => {\n                        logger.debug(`... finished creating bitmap image: ${imageItem.url}`);\n\n                        imageItem.loadingPromise = undefined;\n                        imageItem.imageData = imageBitmap;\n                        imageItem.loaded = true;\n                        resolve(imageBitmap);\n                    })\n                    .catch(ex => {\n                        logger.error(`... loading image failed: ${imageItem.url} : ${ex}`);\n                        resolve(undefined);\n                    });\n            } else {\n                try {\n                    if (typeof document === \"undefined\") {\n                        logger.error(\"Error: document is not available, cannot generate image\");\n                        reject(\n                            new Error(\n                                \"ImageCache#renderImage: document is not available, cannot \" +\n                                    \"render image to create texture\"\n                            )\n                        );\n                    }\n\n                    // TODO: Extract the rendering to the canvas part and make it configurable for\n                    // the client, so it does not rely on the `document`.\n\n                    // use the image, e.g. draw part of it on a canvas\n                    const canvas = document.createElement(\"canvas\");\n                    canvas.width = image.width;\n                    canvas.height = image.height;\n\n                    const context = canvas.getContext(\"2d\");\n                    if (context !== null) {\n                        logger.debug(\n                            // tslint:disable-next-line: max-line-length\n                            `... finished creating bitmap image in canvas: ${imageItem.url} ${image}`\n                        );\n                        context.drawImage(\n                            image,\n                            0,\n                            0,\n                            image.width,\n                            image.height,\n                            0,\n                            0,\n                            canvas.width,\n                            canvas.height\n                        );\n                        const imageData = context.getImageData(0, 0, image.width, image.height);\n                        imageItem.imageData = imageData;\n                        imageItem.loaded = true;\n                        resolve(imageData);\n                    } else {\n                        logger.error(`renderImage: no context found`);\n                        reject(new Error(`ImageCache#renderImage: no context found`));\n                    }\n                } catch (ex) {\n                    logger.error(`renderImage failed: ${ex}`);\n                    imageItem.imageData = undefined;\n                    imageItem.loaded = true;\n                    reject(new Error(`ImageCache#renderImage failed: ${ex}`));\n                }\n            }\n        });\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { StylePriority } from \"@here/harp-datasource-protocol\";\nimport {\n    GeoCoordinates,\n    GeoCoordLike,\n    isGeoCoordinatesLike,\n    isVector3Like,\n    Projection,\n    Vector3Like\n} from \"@here/harp-geoutils\";\n\nimport * as THREE from \"three\";\n\n/**\n * An interface describing [[THREE.Object3D]]s anchored on\n * given {@link @here/harp-geoutils#GeoCoordinates}.\n *\n * @remarkks\n * @example\n * Example:\n * ```typescript\n * const mesh: MapAnchor<THREE.Mesh> = new THREE.Mesh(geometry, material);\n * mesh.anchor = new GeoCoordinates(latitude, longitude, altitude);\n * mapView.mapAnchors.add(mesh);\n * ```\n */\nexport type MapAnchor<T extends THREE.Object3D = THREE.Object3D> = T & {\n    /**\n     * The position of this [[MapAnchor]] in {@link @here/harp-geoutils#GeoCoordinates}.\n     * @deprecated Use [[anchor]] instead.\n     */\n    geoPosition?: GeoCoordinates;\n\n    /**\n     * The anchor of this Object3D in {@link @here/harp-geoutils#GeoCoordinates}\n     * or world coordinates.\n     */\n    anchor?: GeoCoordLike | Vector3Like;\n\n    /**\n     * Flag defining if the object may be picked.\n     *\n     * @note By default all objects are pickable even if this flag is undefined.\n     */\n    pickable?: boolean;\n\n    /**\n     * The styleSet that owns this map object.\n     *\n     * @remarks\n     * This property is used together with [[Theme.priorities]] to compute the render\n     * order of this map object.\n     */\n    styleSet?: string;\n\n    /**\n     * The category of this style.\n     *\n     * @remarks\n     * This property is used together with [[Theme.priorities]] to compute the render\n     * order of this mao object.\n     */\n    category?: string;\n\n    /**\n     * Whether to draw the anchor on top of labels.\n     * @defaultValue false\n     */\n    overlay?: boolean;\n};\n\n/**\n * Container holding [[MapAnchor]] objects.\n */\nexport class MapAnchors {\n    private m_anchors: MapAnchor[] = [];\n\n    /**\n     * All currently added [[MapAnchor]]s.\n     */\n    get children() {\n        return this.m_anchors;\n    }\n\n    /**\n     * Add a [[MapAnchor]].\n     * @param mapAnchor [[MapAnchor]] instance to add.\n     */\n    add(mapAnchor: MapAnchor) {\n        this.m_anchors.push(mapAnchor);\n    }\n\n    /**\n     * Remove a [[MapAnchor]].\n     * @param mapAnchor - [[MapAnchor]] instance to remove.\n     *\n     * @note This method is potentially slow when removing a lot of anchors.\n     * [[clear]]ing and [[add]]ing anchors should be considered in that case.\n     */\n    remove(mapAnchor: MapAnchor) {\n        const index = this.m_anchors.findIndex(element => element === mapAnchor);\n        if (index > -1) {\n            this.m_anchors.splice(index, 1);\n        }\n    }\n\n    /**\n     * Remove all [[MapAnchor]]s.\n     */\n    clear() {\n        this.m_anchors.length = 0;\n    }\n\n    /**\n     * Update the map anchors.\n     * @param projection - Current projection\n     * @param cameraPosition - Current camera position\n     * @param rootNode - Node where normal anchors will be inserted.\n     * @param overlayRootNode - Node where overlay anchors will be insterted.\n     * @param priorities - Optional theme priority list\n     *\n     * @internal\n     * @hidden\n     */\n    update(\n        projection: Projection,\n        cameraPosition: THREE.Vector3,\n        rootNode: THREE.Object3D,\n        overlayRootNode: THREE.Object3D,\n        priorities?: StylePriority[]\n    ) {\n        const worldPosition = new THREE.Vector3();\n\n        this.m_anchors.forEach((mapAnchor: MapAnchor) => {\n            if (mapAnchor.styleSet !== undefined) {\n                const priority = priorities?.findIndex(\n                    entry =>\n                        entry.group === mapAnchor.styleSet && entry.category === mapAnchor.category\n                );\n\n                if (priority !== undefined && priority !== -1) {\n                    mapAnchor.renderOrder = (priority + 1) * 10;\n                }\n            }\n\n            const anchor =\n                // tslint:disable-next-line: deprecation\n                mapAnchor.geoPosition !== undefined ? mapAnchor.geoPosition : mapAnchor.anchor;\n            if (anchor !== undefined) {\n                if (isVector3Like(anchor)) {\n                    worldPosition.set(anchor.x, anchor.y, anchor.z);\n                } else if (isGeoCoordinatesLike(anchor)) {\n                    projection.projectPoint(anchor, worldPosition);\n                }\n                mapAnchor.position.copy(worldPosition).sub(cameraPosition);\n            }\n\n            if (mapAnchor.overlay === true) {\n                overlayRootNode.add(mapAnchor);\n            } else {\n                rootNode.add(mapAnchor);\n            }\n        });\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Theme } from \"@here/harp-datasource-protocol\";\nimport { HighPrecisionLineMaterial } from \"@here/harp-materials\";\nimport { assert, MathUtils } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\nimport { MapView } from \"./MapView\";\n\n/**\n * Manages the fog display in {@link MapView}.\n */\nexport class MapViewFog {\n    private m_enabled: boolean = true;\n    private m_fog: THREE.Fog = new THREE.Fog(0x000000); // Default color asked by DefinitelyTyped.\n    private m_fogIsDefined: boolean = false;\n    private m_cachedTheme: Theme = { styles: {} };\n\n    /**\n     * Constructs a `MapViewFog` instance.\n     *\n     * @param m_scene - The scene used in {@link MapView} that contains the map objects.\n     */\n    constructor(private m_scene: THREE.Scene) {}\n\n    /**\n     * Allows for disabling the fog, even if it is defined in the theme. Use this property for\n     * custom views like the demo app's debug camera. However, if the theme does not define a\n     * fog, enabling this property here has no effect.\n     *\n     * @param value - A boolean that specifies whether the fog should be enabled or disabled.\n     */\n    set enabled(enableFog: boolean) {\n        this.m_enabled = enableFog;\n        if (enableFog && this.m_fogIsDefined && this.m_scene.fog === null) {\n            this.add();\n        } else if (!enableFog && this.m_scene.fog !== null) {\n            this.remove();\n        }\n    }\n\n    /**\n     * Returns the current fog status, enabled or disabled.\n     */\n    get enabled(): boolean {\n        return this.m_enabled;\n    }\n\n    /**\n     * Sets the fog depending on the {@link @here/harp-datasource-protocol#Theme}\n     * instance provided. This function is called when a\n     * theme is loaded. Fog is added only if the theme contains a fog definition with a:\n     * - `color` property, used to set the fog color.\n     * - `startRatio` property, used to set the start distance of the fog as a ratio of the far\n     * clipping plane distance.\n     *\n     * @param theme - A {@link @here/harp-datasource-protocol#Theme} instance.\n     */\n    reset(theme: Theme) {\n        this.m_cachedTheme = theme;\n        if (\n            theme !== undefined &&\n            theme.fog !== undefined &&\n            theme.fog.color !== undefined &&\n            theme.fog.startRatio !== undefined\n        ) {\n            this.m_fogIsDefined = true;\n            this.m_fog.color.set(theme.fog.color);\n            if (this.m_enabled && this.m_scene.fog === null) {\n                this.add();\n            }\n        } else {\n            this.m_fogIsDefined = false;\n            if (this.m_scene.fog !== null) {\n                this.remove();\n            }\n        }\n    }\n\n    /**\n     * Updates the fog at runtime, depending on the camera.\n     *\n     * @param camera - An instance of a `THREE.Camera` with a `far` property.\n     */\n    update(mapView: MapView, viewDistance?: number) {\n        if (\n            this.m_scene.fog !== null &&\n            this.m_cachedTheme !== undefined &&\n            this.m_cachedTheme.fog &&\n            this.m_cachedTheme.fog.startRatio !== undefined &&\n            (mapView.camera.far !== undefined || viewDistance !== undefined)\n        ) {\n            // If maximum visibility range is available use it instead of camera.far distance,\n            // this makes fog independent from dynamic camera planes and keeps consistent\n            // distance based \"melting\" (fog) effect during a tilt.\n            const viewRange = viewDistance !== undefined ? viewDistance : mapView.camera.far;\n            // TODO: We may move below constants to theme Fog definition\n            // Density of the fog when viewing straight along the horizon line.\n            const horizontalDensity = 1.0;\n            // Theoretical density of the fog when viewing straight from top to down.\n            const verticalDensity = 0.0;\n            // The fraction of the maximum viewing distance along the eye vector\n            // to start applying the fog.\n            const startRatio = this.m_cachedTheme.fog.startRatio;\n            // The fraction of maximum viewing range at which fog fully covers geometry.\n            const endRatio = 1.0;\n            assert(startRatio <= endRatio);\n            const t = Math.abs(Math.cos(mapView.tilt));\n            const density = MathUtils.smoothStep(horizontalDensity, verticalDensity, t);\n            this.m_fog.near = MathUtils.lerp(viewRange * startRatio, viewRange, 1.0 - density);\n            this.m_fog.far = MathUtils.lerp(viewRange * endRatio, viewRange, density);\n            this.m_fog.near = Math.min(this.m_fog.near, mapView.camera.far);\n            this.m_fog.far = Math.min(this.m_fog.far, mapView.camera.far);\n        }\n    }\n\n    /**\n     * Handles fog addition.\n     */\n    private add() {\n        // When the fog is changed, ThreeJS takes care of recompiling its built-in materials...\n        this.m_scene.fog = this.m_fog;\n        // ...except the `RawShaderMaterial`, on purpose, so it needs to be updated from the app.\n        this.setFogInRawShaderMaterials(true);\n    }\n\n    /**\n     * Handles fog removal.\n     */\n    private remove() {\n        // When the fog is changed, ThreeJS takes care of recompiling its built-in materials...\n        this.m_scene.fog = null;\n        // ...except the `RawShaderMaterial`, on purpose, so it needs to be updated from the app.\n        this.setFogInRawShaderMaterials(false);\n    }\n\n    /**\n     * ThreeJS lets users manage the `RawShaderMaterial` themselves, so they need to be modified\n     * explicitly.\n     *\n     * @see https://github.com/mrdoob/three.js/blob/dev/src/renderers/webgl/WebGLProgram.js#L298\n     */\n    private setFogInRawShaderMaterials(enableFog: boolean) {\n        this.m_scene.traverse(object => {\n            if (!(object instanceof THREE.Mesh)) {\n                return;\n            }\n            if (!(object.material instanceof THREE.Material)) {\n                return;\n            }\n            // HighPrecisionLineMaterial does not support fog\n            if (object.material instanceof HighPrecisionLineMaterial) {\n                return;\n            }\n            // We may skip redundant updates.\n            if (object.material.fog === enableFog) {\n                return;\n            }\n            object.material.fog = enableFog;\n            // Fog properties can't be easily changed at runtime (once the material\n            // is rendered at least once) and thus requires building of new shader\n            // program - force material update.\n            object.material.needsUpdate = true;\n        });\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    AttributeMap,\n    composeTechniqueTextureName,\n    DecodedTile,\n    getFeatureId,\n    getPropertyValue,\n    ImageTexture,\n    IndexedTechnique,\n    IndexedTechniqueParams,\n    isLineMarkerTechnique,\n    isPoiTechnique,\n    LineMarkerTechnique,\n    PoiGeometry,\n    PoiTechnique\n} from \"@here/harp-datasource-protocol\";\nimport { ContextualArabicConverter } from \"@here/harp-text-canvas\";\nimport { assert, assertExists, LoggerManager } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\nimport { ColorCache } from \"../ColorCache\";\nimport { MapView } from \"../MapView\";\nimport { TextElement } from \"../text/TextElement\";\nimport { DEFAULT_TEXT_DISTANCE_SCALE } from \"../text/TextElementsRenderer\";\nimport { Tile } from \"../Tile\";\nimport { PoiTable } from \"./PoiTableManager\";\n\nconst logger = LoggerManager.instance.create(\"PoiManager\");\n\n/**\n * Interface for the {@link @here/harp-datasource-protocol#ImageTexture}s\n * that are defined in the atlas.\n */\ninterface ImageTextureDef {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    pixelRatio?: number;\n}\n\n/**\n * POI manager class, responsible for loading the\n * {@link @here/harp-datasource-protocol#PoiGeometry} objects\n * from the {@link @here/harp-datasource-protocol#DecodedTile},\n * and preparing them for rendering.\n *\n * @remarks\n * Also loads and manages the texture atlases for the icons.\n */\nexport class PoiManager {\n    // Keep track of the missing POI table names, but only warn once.\n    private static m_missingPoiTableName: Map<string, boolean> = new Map();\n    private static m_missingPoiName: Map<string, boolean> = new Map();\n\n    /**\n     * Warn about a missing POI table name, but only once.\n     * @param poiTableName - POI mapping table name.\n     * @param poiTable - POI table instance.\n     */\n    private static notifyMissingPoiTable(\n        poiTableName: string,\n        poiTable: PoiTable | undefined\n    ): void {\n        if (poiTableName === undefined) {\n            poiTableName = \"undefined\";\n        }\n        if (PoiManager.m_missingPoiTableName.get(poiTableName) === undefined) {\n            PoiManager.m_missingPoiTableName.set(poiTableName, true);\n            if (poiTable !== undefined && !poiTable.loadedOk) {\n                logger.error(`updatePoiFromPoiTable: Could not load POI table '${poiTableName}'!`);\n            } else {\n                logger.error(\n                    `updatePoiFromPoiTable: No POI table with name '${poiTableName}' found!`\n                );\n            }\n        }\n    }\n\n    /**\n     * Warn about a missing POI name, but only once.\n     * @param poiName - name of POI.\n     * @param poiTableName - POI mapping table name.\n     */\n    private static notifyMissingPoi(poiName: string, poiTableName: string): void {\n        if (poiName === undefined) {\n            poiName = \"undefined\";\n        }\n        const key: string = `${poiTableName}[${poiName}]`;\n        if (PoiManager.m_missingPoiName.get(key) === undefined) {\n            PoiManager.m_missingPoiName.set(key, true);\n            logger.warn(\n                `updatePoiFromPoiTable: ` +\n                    `Cannot find POI info for '${poiName}' in table '${poiTableName}'.`\n            );\n        }\n    }\n\n    private m_imageTextures: Map<string, ImageTexture> = new Map();\n    private m_poiShieldGroups: Map<string, number> = new Map();\n\n    /**\n     * The constructor of the `PoiManager`.\n     *\n     * @param mapView - The {@link MapView} instance that should display the POIs.\n     */\n    constructor(readonly mapView: MapView) {}\n\n    /**\n     * Add all POIs from a decoded tile and store them as {@link TextElement}s in the {@link Tile}.\n     *\n     * Also handles LineMarkers, which is a recurring marker along a line (road).\n     *\n     * @param tile - Tile to add POIs to.\n     * @param decodedTile - DecodedTile containing the raw\n     *                      {@link @here/harp-datasource-protocol#PoiGeometry}\n     *                      objects describing the POIs.\n     */\n    addPois(tile: Tile, decodedTile: DecodedTile): void {\n        const poiGeometries = assertExists(decodedTile.poiGeometries);\n        const worldOffsetX = tile.computeWorldOffsetX();\n\n        for (const poiGeometry of poiGeometries) {\n            assert(poiGeometry.technique !== undefined);\n            const techniqueIndex = assertExists(poiGeometry.technique);\n            const technique = decodedTile.techniques[techniqueIndex] as IndexedTechnique;\n\n            if (\n                technique._kindState === false ||\n                (!isLineMarkerTechnique(technique) && !isPoiTechnique(technique))\n            ) {\n                continue;\n            }\n\n            // The POI may be in the data, and there may be a Technique, but the technique may\n            // specify to not show it.\n            if (technique.showOnMap === false) {\n                continue;\n            }\n\n            const positions = new THREE.BufferAttribute(\n                new Float32Array(poiGeometry.positions.buffer),\n                poiGeometry.positions.itemCount\n            );\n\n            if (isLineMarkerTechnique(technique) && positions.count > 0) {\n                this.addLineMarker(tile, poiGeometry, technique, positions, worldOffsetX);\n            } else if (isPoiTechnique(technique)) {\n                this.addPoi(tile, poiGeometry, technique, positions, worldOffsetX);\n            }\n        }\n    }\n\n    /**\n     * Load the texture atlas that defines the segments of the texture that should be used for\n     * specific icons.\n     *\n     * @remarks\n     * Creates an {@link @here/harp-datasource-protocol#ImageTexture}\n     * for every element in the atlas, such that it can\n     * be addressed in the theme file.\n     *\n     * @param imageName - Name of the image from the theme (NOT the url!).\n     * @param atlas - URL of the JSON file defining the texture atlas.\n     */\n    addTextureAtlas(imageName: string, atlas: string) {\n        fetch(atlas)\n            .then(response => {\n                if (!response.ok) {\n                    throw new Error(\n                        `addTextureAtlas: Cannot load textureAtlas: ${response.statusText}`\n                    );\n                }\n\n                return response.json();\n            })\n            .then((jsonAtlas: any | undefined) => {\n                if (jsonAtlas === undefined) {\n                    logger.info(`addTextureAtlas: TextureAtlas empty: ${atlas}`);\n                    return;\n                }\n\n                try {\n                    logger.debug(\n                        `addTextureAtlas: Loading textureAtlas '${atlas}' for image '${imageName}'`\n                    );\n                    for (const textureName of Object.getOwnPropertyNames(jsonAtlas)) {\n                        const imageTextureDef = jsonAtlas[textureName] as ImageTextureDef;\n\n                        const imageTexture: ImageTexture = {\n                            name: textureName,\n                            image: imageName,\n                            xOffset: imageTextureDef.x,\n                            yOffset: imageTextureDef.y,\n                            width: imageTextureDef.width,\n                            height: imageTextureDef.height\n                        };\n\n                        this.addImageTexture(imageTexture);\n                    }\n                } catch (ex) {\n                    logger.error(\n                        `addTextureAtlas: Failed to load textureAtlas ` + `'${atlas}' : ${ex}`\n                    );\n                }\n                this.mapView.update();\n            })\n\n            .catch((reason: any) => {\n                logger.error(`addTextureAtlas: Failed to load textureAtlas '${atlas}' : ${reason}`);\n            });\n    }\n\n    /**\n     * Add an {@link @here/harp-datasource-protocol#ImageTexture} such that it\n     * is available as a named entity for techniques in theme files.\n     *\n     * @param imageTexture - {@link @here/harp-datasource-protocol#ImageTexture}\n     *                       that should be available for POIs.\n     */\n    addImageTexture(imageTexture: ImageTexture) {\n        if (imageTexture.name === undefined) {\n            logger.error(\"addImageTexture: Name required\", imageTexture);\n            return;\n        }\n        if (this.m_imageTextures.get(imageTexture.name) !== undefined) {\n            logger.warn(\n                `addImageTexture: Name already used: ${imageTexture.name}` + ` (overriding it)`\n            );\n        }\n\n        this.m_imageTextures.set(imageTexture.name, imageTexture);\n    }\n\n    /**\n     * Return the {@link @here/harp-datasource-protocol#ImageTexture}\n     * registered under the specified name.\n     *\n     * @param name - Name of the {@link @here/harp-datasource-protocol#ImageTexture}.\n     */\n    getImageTexture(name: string): ImageTexture | undefined {\n        return this.m_imageTextures.get(name);\n    }\n\n    /**\n     * Update the {@link TextElement} with the information taken from the {@link PoiTable} which is\n     * referenced in the {@link PoiInfo} of the pointLabel.\n     *\n     * If the requested {@link PoiTable} is not available yet, the function returns `false`.\n     * If the {@link PoiTable} is not defined, or if the references POI has no entry in\n     * the {@link PoiTable}, no action is taken, and the function returns `false`.\n     *\n     * If the {@link PoiTable} has been processed, it returns `true`, indicating that this function\n     * doesn't have to be called again.\n     *\n     * @param pointLabel - The {@link TextElement} to update.\n     *\n     * @returns `true` if the {@link PoiTable} has been processed, and the\n     *          function does not have to be called again.\n     */\n    updatePoiFromPoiTable(pointLabel: TextElement): boolean {\n        const poiInfo = pointLabel.poiInfo;\n        // PoiTable requires poiName to be defined otherwise mapping via PoiTable is\n        // not possible, such as table key is not defined.\n        if (\n            poiInfo === undefined ||\n            poiInfo.poiTableName === undefined ||\n            poiInfo.poiName === undefined\n        ) {\n            return true;\n        }\n\n        // Try to acquire PoiTable\n        const poiTableName = poiInfo.poiTableName;\n        const poiTable = this.mapView.poiTableManager.getPoiTable(poiTableName);\n\n        // Check if PoiTable is found, but its still loading.\n        if (poiTable !== undefined && poiTable.isLoading) {\n            // The PoiTable is still loading, we have to try again.\n            return false;\n        }\n\n        // Remove poiTableName to mark this POI as processed.\n        poiInfo.poiTableName = undefined;\n\n        // PoiTable not found or can not be loaded.\n        if (poiTable === undefined || !poiTable.loadedOk) {\n            PoiManager.notifyMissingPoiTable(poiTableName, poiTable);\n            return true;\n        }\n\n        // Try to acquire PoiTableEntry.\n        const poiName = poiInfo.poiName;\n        const poiTableEntry = poiTable.getEntry(poiName);\n        if (poiTableEntry === undefined) {\n            PoiManager.notifyMissingPoi(poiName, poiTableName);\n            return true;\n        }\n\n        if (poiTableEntry.iconName !== undefined && poiTableEntry.iconName.length > 0) {\n            poiInfo.imageTextureName = composeTechniqueTextureName(\n                poiTableEntry.iconName,\n                poiInfo.technique\n            );\n        }\n\n        pointLabel.visible =\n            poiTableEntry.visible !== undefined ? poiTableEntry.visible : pointLabel.visible;\n        pointLabel.priority =\n            poiTableEntry.priority !== undefined ? poiTableEntry.priority : pointLabel.priority;\n        poiInfo.iconMinZoomLevel =\n            poiTableEntry.iconMinLevel !== undefined\n                ? poiTableEntry.iconMinLevel\n                : poiInfo.iconMinZoomLevel;\n        poiInfo.iconMaxZoomLevel =\n            poiTableEntry.iconMaxLevel !== undefined\n                ? poiTableEntry.iconMaxLevel\n                : poiInfo.iconMaxZoomLevel;\n        poiInfo.textMinZoomLevel =\n            poiTableEntry.textMinLevel !== undefined\n                ? poiTableEntry.textMinLevel\n                : poiInfo.textMinZoomLevel;\n        poiInfo.textMaxZoomLevel =\n            poiTableEntry.textMaxLevel !== undefined\n                ? poiTableEntry.textMaxLevel\n                : poiInfo.textMaxZoomLevel;\n\n        pointLabel.updateMinMaxZoomLevelsFromPoiInfo();\n\n        return true;\n    }\n\n    /**\n     * Clear internal state. Applicable when switching themes.\n     */\n    clear() {\n        this.m_imageTextures.clear();\n        this.m_poiShieldGroups.clear();\n    }\n\n    /**\n     * Add the LineMarker as a POI with a series of positions. Make sure that the LineMarkers\n     * having the same visual all get their `shieldGroupIndex` set appropriately, so it can be taken\n     * care of later that not too many of them are rendered (obey `minDistance` attribute).\n     */\n    private addLineMarker(\n        tile: Tile,\n        poiGeometry: PoiGeometry,\n        technique: LineMarkerTechnique & IndexedTechniqueParams,\n        positions: THREE.BufferAttribute,\n        worldOffsetX: number\n    ) {\n        const env = this.mapView.env;\n\n        let imageTextureName: string | undefined =\n            technique.imageTexture !== undefined\n                ? composeTechniqueTextureName(\n                      getPropertyValue(technique.imageTexture, env),\n                      technique\n                  )\n                : undefined;\n\n        let text: string = \"\";\n        let userData: AttributeMap | undefined;\n        let featureId: number | undefined;\n\n        if (poiGeometry.stringCatalog !== undefined) {\n            assert(poiGeometry.texts.length > 0);\n            text = poiGeometry.stringCatalog[poiGeometry.texts[0]] || \"\";\n            if (poiGeometry.objInfos !== undefined) {\n                userData = poiGeometry.objInfos[0];\n                featureId = getFeatureId(userData);\n            }\n\n            if (poiGeometry.imageTextures !== undefined) {\n                assert(poiGeometry.imageTextures.length > 0);\n                imageTextureName = poiGeometry.stringCatalog[poiGeometry.imageTextures[0]];\n            }\n        }\n\n        // let the combined image texture name (name of image in atlas, not the URL) and\n        // text of the shield be the group key, at worst scenario it may be:\n        // \"undefined-\"\n        const groupKey = String(imageTextureName) + \"-\" + text;\n        let shieldGroupIndex = this.m_poiShieldGroups.get(groupKey);\n        if (shieldGroupIndex === undefined) {\n            shieldGroupIndex = this.m_poiShieldGroups.size;\n            this.m_poiShieldGroups.set(groupKey, shieldGroupIndex);\n        }\n\n        // Debugging help to identify the group of a shield :\n        // text = groupKey + \": \" + text;\n\n        const positionArray: THREE.Vector3[] = [];\n        for (let i = 0; i < positions.count; i += 3) {\n            const x = positions.getX(i) + worldOffsetX;\n            const y = positions.getY(i);\n            const z = positions.getZ(i);\n            positionArray.push(new THREE.Vector3(x, y, z));\n        }\n        const textElement = this.checkCreateTextElement(\n            tile,\n            text,\n            technique,\n            imageTextureName,\n            undefined, // TBD for road shields\n            undefined,\n            shieldGroupIndex,\n            featureId,\n            positionArray,\n            undefined,\n            undefined,\n            undefined,\n            userData\n        );\n\n        // If the poi icon is rendered, the label that shows text should also be rendered.\n        // The distance rule of the icon should apply, not the one for text (only) labels.\n        textElement.ignoreDistance = false;\n        tile.addTextElement(textElement);\n    }\n\n    /**\n     * Create and add POI {@link TextElement}s to tile with a series of positions.\n     */\n    private addPoi(\n        tile: Tile,\n        poiGeometry: PoiGeometry,\n        technique: PoiTechnique & IndexedTechniqueParams,\n        positions: THREE.BufferAttribute,\n        worldOffsetX: number\n    ) {\n        if (poiGeometry.stringCatalog === undefined) {\n            return;\n        }\n\n        const env = tile.mapView.env;\n\n        const techniqueTextureName: string | undefined =\n            technique.imageTexture !== undefined\n                ? composeTechniqueTextureName(\n                      getPropertyValue(technique.imageTexture, env),\n                      technique\n                  )\n                : undefined;\n\n        const poiTechnique = technique as PoiTechnique;\n        const poiTableName = poiTechnique.poiTable;\n        let poiName = poiTechnique.poiName;\n\n        for (let i = 0; i < positions.count; ++i) {\n            const x = positions.getX(i) + worldOffsetX;\n            const y = positions.getY(i);\n            const z = positions.getZ(i);\n\n            assert(poiGeometry.texts.length > i);\n            let imageTextureName = techniqueTextureName;\n            const text: string = poiGeometry.stringCatalog[poiGeometry.texts[i]] || \"\";\n            const userData =\n                poiGeometry.objInfos !== undefined ? poiGeometry.objInfos[i] : undefined;\n            const featureId = getFeatureId(userData);\n            const offsetDirection =\n                poiGeometry.offsetDirections === undefined ? 0 : poiGeometry.offsetDirections[i];\n            if (poiGeometry.imageTextures !== undefined && poiGeometry.imageTextures[i] >= 0) {\n                assert(poiGeometry.imageTextures.length > i);\n                imageTextureName = poiGeometry.stringCatalog[poiGeometry.imageTextures[i]];\n            }\n            if (poiTableName !== undefined) {\n                // The POI name to be used is taken from the data, since it will\n                // specify the name of the texture to use.\n\n                // The POI name in the technique may override the POI name from the\n                // data.\n                poiName =\n                    poiTechnique.poiName === undefined ? imageTextureName : poiTechnique.poiName;\n\n                imageTextureName = undefined;\n            }\n\n            const textElement = this.checkCreateTextElement(\n                tile,\n                text,\n                technique,\n                imageTextureName,\n                poiTableName,\n                poiName,\n                0,\n                featureId,\n                x,\n                y,\n                z,\n                offsetDirection,\n                userData\n            );\n\n            tile.addTextElement(textElement);\n        }\n    }\n\n    /**\n     * Create the {@link TextElement} for a POI.\n     *\n     * @remarks\n     * Even if the POI has no text, it is required that there\n     * is a {@link TextElement}, since POIs are hooked onto {@link TextElement}s\n     * for sorting.(Sorted by priority attribute).\n     */\n    private checkCreateTextElement(\n        tile: Tile,\n        text: string,\n        technique: (PoiTechnique | LineMarkerTechnique) & IndexedTechniqueParams,\n        imageTextureName: string | undefined,\n        poiTableName: string | undefined,\n        poiName: string | undefined,\n        shieldGroupIndex: number,\n        featureId: number | undefined,\n        x: number | THREE.Vector3[],\n        y: number | undefined,\n        z: number | undefined,\n        offsetDirection?: number,\n        userData?: {}\n    ): TextElement {\n        const priority = technique.priority !== undefined ? technique.priority : 0;\n        const positions = Array.isArray(x) ? (x as THREE.Vector3[]) : new THREE.Vector3(x, y, z);\n\n        // The current zoomlevel of mapview. Since this method is called for all tiles in the\n        // VisibleTileSet we can be sure that the current zoomlevel matches the zoomlevel where\n        // the tile should be shown.\n        const env = this.mapView.env;\n        const fadeNear =\n            technique.fadeNear !== undefined\n                ? getPropertyValue(technique.fadeNear, env)\n                : technique.fadeNear;\n        const fadeFar =\n            technique.fadeFar !== undefined\n                ? getPropertyValue(technique.fadeFar, env)\n                : technique.fadeFar;\n        const xOffset = getPropertyValue(technique.xOffset, env);\n        const yOffset = getPropertyValue(technique.yOffset, env);\n\n        const textElement: TextElement = new TextElement(\n            ContextualArabicConverter.instance.convert(text),\n            positions,\n            tile.textStyleCache.getRenderStyle(technique),\n            tile.textStyleCache.getLayoutStyle(technique),\n            getPropertyValue(priority, env),\n            xOffset !== undefined ? xOffset : 0.0,\n            yOffset !== undefined ? yOffset : 0.0,\n            featureId,\n            technique.style,\n            fadeNear,\n            fadeFar,\n            tile.offset,\n            offsetDirection\n        );\n\n        textElement.mayOverlap = technique.textMayOverlap === true;\n        textElement.reserveSpace = technique.textReserveSpace !== false;\n        textElement.alwaysOnTop = technique.alwaysOnTop === true;\n        textElement.userData = userData;\n\n        // imageTextureName may be undefined if a poiTable is used.\n        if (imageTextureName === undefined && poiTableName !== undefined) {\n            imageTextureName = \"\";\n        } else if (imageTextureName !== undefined && poiTableName !== undefined) {\n            logger.warn(\n                \"Possible duplicate POI icon definition via imageTextureName and poiTable!\"\n            );\n        }\n\n        if (imageTextureName !== undefined) {\n            const textIsOptional = technique.textIsOptional === true;\n            const iconIsOptional = technique.iconIsOptional !== false;\n            const renderTextDuringMovements = !(technique.renderTextDuringMovements === false);\n            const iconMayOverlap =\n                technique.iconMayOverlap === undefined\n                    ? textElement.textMayOverlap\n                    : technique.iconMayOverlap === true;\n            const iconReserveSpace =\n                technique.iconReserveSpace === undefined\n                    ? textElement.textReservesSpace\n                    : technique.iconReserveSpace !== false;\n\n            const iconColorRaw = technique.iconColor\n                ? getPropertyValue(technique.iconColor, env)\n                : null;\n            const iconColor =\n                iconColorRaw !== null ? ColorCache.instance.getColor(iconColorRaw) : undefined;\n\n            textElement.poiInfo = {\n                technique,\n                imageTextureName,\n                poiTableName,\n                poiName,\n                shieldGroupIndex,\n                textElement,\n                textIsOptional,\n                iconIsOptional,\n                renderTextDuringMovements,\n                mayOverlap: iconMayOverlap,\n                reserveSpace: iconReserveSpace,\n                featureId,\n                iconBrightness: technique.iconBrightness,\n                iconColor,\n                iconMinZoomLevel: technique.iconMinZoomLevel,\n                iconMaxZoomLevel: technique.iconMaxZoomLevel,\n                textMinZoomLevel: technique.textMinZoomLevel,\n                textMaxZoomLevel: technique.textMaxZoomLevel\n            };\n            textElement.updateMinMaxZoomLevelsFromPoiInfo();\n        } else {\n            // Select the smaller/larger one of the two min/max values, because the TextElement\n            // is a container for both.\n            if (textElement.minZoomLevel === undefined) {\n                textElement.minZoomLevel = technique.textMinZoomLevel;\n            }\n\n            if (textElement.maxZoomLevel === undefined) {\n                textElement.maxZoomLevel = technique.textMaxZoomLevel;\n            }\n        }\n\n        textElement.distanceScale =\n            technique.distanceScale !== undefined\n                ? technique.distanceScale\n                : DEFAULT_TEXT_DISTANCE_SCALE;\n\n        // tslint:disable-next-line: deprecation\n        textElement.kind = technique.kind;\n        return textElement;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {\n    PoiStackMode,\n    PoiTableDef,\n    PoiTableEntryDef,\n    PoiTableRef,\n    Theme\n} from \"@here/harp-datasource-protocol\";\nimport { LoggerManager } from \"@here/harp-utils\";\n\nimport { MapView } from \"../MapView\";\n\nconst logger = LoggerManager.instance.create(\"PoiTable\");\n\n/**\n * Class to store and maintain individual POI information for the {@link PoiTable}.\n */\nclass PoiTableEntry implements PoiTableEntryDef {\n    /**\n     * Verify that the JSON description of the POI table entry is valid.\n     *\n     * @param jsonEntry - JSON description of the POI table entry.\n     *\n     * @returns `true` if the `jsonEntry` is valid.\n     */\n    static verifyJSON(jsonEntry: PoiTableEntryDef): boolean {\n        let isOK =\n            typeof jsonEntry.name === \"string\" &&\n            jsonEntry.name.length > 0 &&\n            (jsonEntry.altNames === undefined || Array.isArray(jsonEntry.altNames)) &&\n            (jsonEntry.stackMode === undefined ||\n                jsonEntry.stackMode === \"yes\" ||\n                jsonEntry.stackMode === \"no\" ||\n                jsonEntry.stackMode === \"parent\") &&\n            (jsonEntry.visible === undefined || typeof jsonEntry.visible === \"boolean\") &&\n            (jsonEntry.priority === undefined || typeof jsonEntry.priority === \"number\") &&\n            (jsonEntry.iconMinLevel === undefined || typeof jsonEntry.iconMinLevel === \"number\") &&\n            (jsonEntry.iconMaxLevel === undefined || typeof jsonEntry.iconMaxLevel === \"number\") &&\n            (jsonEntry.textMinLevel === undefined || typeof jsonEntry.textMinLevel === \"number\") &&\n            (jsonEntry.textMaxLevel === undefined || typeof jsonEntry.textMaxLevel === \"number\");\n\n        if (isOK && jsonEntry.altNames !== undefined) {\n            const altNames = jsonEntry.altNames as string[];\n            for (const str in altNames) {\n                if (typeof str !== \"string\") {\n                    isOK = false;\n                    break;\n                }\n            }\n        }\n\n        return isOK;\n    }\n\n    /** Default name of the POI as the key for looking it up. */\n    name?: string;\n    /** Alternative names of the POI. */\n    altNames?: string[];\n    /** Visibility of the POI. If `false`, the POI will not be rendered. */\n    visible?: boolean;\n    /** Name of the icon, defined in the the texture atlases. */\n    iconName?: string;\n    /** Stacking mode of the POI. For future use. */\n    stackMode?: PoiStackMode;\n    /**\n     * Priority of the POI to select the visible set in case there are more POIs than can be\n     * handled.\n     */\n    priority?: number;\n    /** Minimum zoom level to render the icon on. */\n    iconMinLevel?: number;\n    /** Maximum zoom level to render the icon on. */\n    iconMaxLevel?: number;\n    /** Minimum zoom level to render the text label on. */\n    textMinLevel?: number;\n    /** Maximum zoom level to render the text label on. */\n    textMaxLevel?: number;\n\n    /**\n     * Setup the [[PoiTableEntry]] from the JSON description. It is assumed that the jsonEntry has\n     * been verified with [[PoiTableEntry#verifyJSON]].\n     *\n     * @param jsonEntry - JSON description of the POI table entry. Expected to have been verified\n     *                    with [[PoiTableEntry#verifyJSON]].\n     */\n    setup(jsonEntry: PoiTableEntryDef) {\n        this.name = jsonEntry.name;\n        this.altNames = jsonEntry.altNames;\n        this.iconName = jsonEntry.iconName;\n        this.visible = jsonEntry.visible;\n        this.priority = jsonEntry.priority;\n        this.iconMinLevel = jsonEntry.iconMinLevel;\n        this.iconMaxLevel = jsonEntry.iconMaxLevel;\n        this.textMinLevel = jsonEntry.textMinLevel;\n        this.textMaxLevel = jsonEntry.textMaxLevel;\n\n        switch (jsonEntry.stackMode) {\n            case \"yes\":\n                this.stackMode = PoiStackMode.Show;\n                break;\n            case \"no\":\n                this.stackMode = PoiStackMode.Hide;\n                break;\n            case \"parent\":\n                this.stackMode = PoiStackMode.ShowParent;\n                break;\n            default:\n        }\n    }\n}\n\n/**\n * The `PoiTable` stores individual information for each POI type. If a {@link TextElement} has a\n * reference to a PoiTable (if TextElement.poiInfo.poiTableName is set), information for the\n * TextElement and its icon are read from the PoiTable.\n *\n * The key to look up the POI is taken from the data, in case of OSM data with TileZen data, the\n * `poiNameField` is set to `kind`, which makes the content of the field `kind` in the data the key\n * to look up the POIs in the {@link PoiTable}.\n *\n * On the side of the {@link PoiTable}, the key to look up the PoiTableEntry is either the property\n * \"name\" of the [[PoiTableEntry]] (which should be unique), or the alternative list of names\n * `altNames`, where each value should also be unique. If the property `useAltNamesForKey` is set to\n * `true`, the `altNames` will be used.\n */\nexport class PoiTable {\n    /**\n     * Stores the list of [[PoiTableEntry]]s.\n     */\n    private readonly poiList: PoiTableEntry[] = new Array();\n    /**\n     * Dictionary to look up for [[PoiTableEntry]] quickly. The dictionary is either created for\n     * the `name` property of the [[PoiTableEntry]], which will identify POI, or for all of\n     * alternative the names defined in `altNames` of [[PoiTableEntry]] JSON object.\n     * Value assigned to key it is the index to [[poiList]] array which contain actual\n     * [[PoiTabelEntry]] objects.\n     */\n    private readonly poiDict: Map<string, number> = new Map();\n    private m_isLoading = false;\n    private m_loadedOk: boolean | undefined = undefined;\n\n    /**\n     * Creates an instance of PoiTable.\n     *\n     * @param {string} name Name of the `PoiTable`. Must be unique.\n     * @param {boolean} useAltNamesForKey Pass `true` to use the contents of the property `altNames`\n     *          to find a [[PoiTableEntry]] in the table.\n     */\n    constructor(readonly name: string, readonly useAltNamesForKey: boolean) {}\n\n    /**\n     * Returns `true` if the table is currently being loaded, `false` otherwise.\n     *\n     * @readonly\n     */\n    get isLoading(): boolean {\n        return this.m_isLoading;\n    }\n\n    /**\n     * Returns `true` if the table has been loaded correctly, `false` otherwise.\n     *\n     * @readonly\n     */\n    get loadedOk(): boolean {\n        return this.m_loadedOk === true;\n    }\n\n    /**\n     * Gets [[PoiTableEntry]] for poi name specified.\n     *\n     * @param poiName - poi name or one of its alternative names if [[useAltNamesForKey]] is\n     * set to `true`.\n     * @returns [[PoiTableEntry]] object or undefined if name was not found in dictionary.\n     */\n    getEntry(poiName: string): PoiTableEntry | undefined {\n        const entryIdx: number | undefined = this.poiDict.get(poiName);\n        if (entryIdx !== undefined) {\n            if (entryIdx < this.poiList.length) {\n                return this.poiList[entryIdx];\n            } else {\n                throw new Error(\"Poi table entry index out of stored list!\");\n            }\n        }\n        return undefined;\n    }\n\n    /**\n     * Start to load the PoiTable from the specified URL. Can only be called once per table.\n     *\n     * @param {string} poiTableUrl URL that points to the JSON file.\n     *\n     * @returns {Promise<boolean>} Promise is being resolved once the JSON file has been fetched and\n     *          the `PoiTable` has been set up.\n     */\n    async load(poiTableUrl: string): Promise<boolean> {\n        if (this.m_loadedOk !== undefined) {\n            // Only load once.\n            return true;\n        }\n\n        this.m_loadedOk = false;\n\n        const response = await fetch(poiTableUrl);\n\n        if (!response.ok) {\n            throw new Error(\n                `load: Cannot load POI table at ${poiTableUrl}:` + ` ${response.statusText}`\n            );\n        }\n\n        const jsonPoiTable = (await response.json()) as PoiTableDef;\n        if (jsonPoiTable === undefined) {\n            logger.info(`load: TextureAtlas empty: ${poiTableUrl}`);\n            return true;\n        }\n\n        this.startLoading();\n\n        try {\n            logger.debug(`load: Loading POI table '${poiTableUrl}' for table '${this.name}'`);\n\n            if (jsonPoiTable.poiList !== undefined && Array.isArray(jsonPoiTable.poiList)) {\n                for (const tableEntry of jsonPoiTable.poiList) {\n                    if (PoiTableEntry.verifyJSON(tableEntry)) {\n                        const newPoiEntry = new PoiTableEntry();\n                        newPoiEntry.setup(tableEntry);\n                        const entryIdx = this.poiList.push(newPoiEntry) - 1;\n\n                        if (!this.useAltNamesForKey) {\n                            // Use actual name of entry as the key\n                            if (newPoiEntry.name === undefined) {\n                                logger.warn(\n                                    `load: Invalid entry in POI table '${poiTableUrl}' : ` +\n                                        `. No name set in entry: ${tableEntry}.`\n                                );\n                            } else {\n                                this.poiDict.set(newPoiEntry.name, entryIdx);\n                            }\n                        } else {\n                            if (\n                                newPoiEntry.altNames !== undefined &&\n                                newPoiEntry.altNames.length > 0\n                            ) {\n                                // Use the list of alternative names as keys.\n                                for (const altName of newPoiEntry.altNames) {\n                                    this.poiDict.set(altName, entryIdx);\n                                }\n                            } else {\n                                logger.debug(\n                                    `load: Invalid entry in POI table '${poiTableUrl}' : ` +\n                                        `No alternative names set in entry: ${JSON.stringify(\n                                            tableEntry\n                                        )}.`\n                                );\n                            }\n                        }\n                    } else {\n                        logger.warn(\n                            `load: Invalid entry in POI table '${poiTableUrl}' : ${JSON.stringify(\n                                tableEntry\n                            )}`\n                        );\n                    }\n                }\n            }\n            this.m_loadedOk = true;\n            this.finishedLoading();\n        } catch (ex) {\n            logger.error(`load: Failed to load POI table ` + `'${poiTableUrl}' : ${ex}`);\n            this.m_loadedOk = false;\n            this.finishedLoading();\n            return false;\n        }\n        return true;\n    }\n\n    private startLoading() {\n        this.m_isLoading = true;\n    }\n\n    private finishedLoading() {\n        this.m_isLoading = false;\n    }\n}\n\n/**\n * The `PoiTableManager` manages the list of [[PoiTables]] that\n * can be defined in the {@link @here/harp-datasource-protocol#Theme} sfile.\n */\nexport class PoiTableManager {\n    private m_isLoading = false;\n    private m_poiTables: Map<string, PoiTable> = new Map();\n\n    /**\n     * Creates an instance of PoiTableManager.\n     * @param {MapView} mapView Owning {@link MapView}.\n     */\n    constructor(readonly mapView: MapView) {}\n\n    /**\n     * Load the {@link PoiTable}s that are stored in the {@link MapView}s\n     * {@link @here/harp-datasource-protocol#Theme}.\n     *\n     * @remarks\n     * Note that duplicate names of {@link PoiTable}s in the\n     * {@link @here/harp-datasource-protocol#Theme} will lead to inaccessible {@link PoiTable}s.\n     *\n     * @param theme - {@link @here/harp-datasource-protocol#Theme}\n     *                containing all {@link PoiTable}s to load.\n     *\n     * @returns Resolved once all the {@link PoiTable}s in\n     *          the {@link @here/harp-datasource-protocol#Theme} have been loaded.\n     */\n    async loadPoiTables(theme: Theme): Promise<void> {\n        const finished = new Promise<void>(resolve => {\n            this.clear();\n\n            // Add the POI tables defined in the theme.\n            if (theme.poiTables !== undefined) {\n                this.startLoading();\n\n                // Gather promises to signal the success of having loaded them all\n                const loadPromises: Array<Promise<boolean>> = new Array();\n\n                theme.poiTables.forEach((poiTableRef: PoiTableRef) => {\n                    if (\n                        poiTableRef !== undefined &&\n                        poiTableRef.name !== undefined &&\n                        typeof poiTableRef.name === \"string\"\n                    ) {\n                        const poiTable = new PoiTable(\n                            poiTableRef.name,\n                            poiTableRef.useAltNamesForKey !== false\n                        );\n                        if (poiTableRef.url !== undefined && typeof poiTableRef.url === \"string\") {\n                            this.addTable(poiTable);\n                            loadPromises.push(poiTable.load(poiTableRef.url));\n                        } else {\n                            logger.error(`POI table definition has no valid url: ${poiTableRef}`);\n                        }\n                    } else {\n                        logger.error(`POI table definition has no valid name: ${poiTableRef}`);\n                    }\n                });\n\n                if (loadPromises.length > 0) {\n                    Promise.all(loadPromises).finally(() => {\n                        this.finishLoading();\n                        resolve();\n                    });\n                } else {\n                    this.finishLoading();\n                    resolve();\n                }\n            } else {\n                this.finishLoading();\n                resolve();\n            }\n        });\n\n        return finished;\n    }\n\n    /**\n     * Clear the list of {@link PoiTable}s.\n     */\n    clear() {\n        this.m_poiTables = new Map();\n    }\n\n    /**\n     * Return the map of {@link PoiTable}s.\n     */\n    get poiTables(): Map<string, PoiTable> {\n        return this.m_poiTables;\n    }\n\n    /**\n     * Manually add a {@link PoiTable}. Normally, the [[PoiTables]]s\n     * are specified in the {@link @here/harp-datasource-protocol#Theme}.\n     *\n     * @remarks\n     * Ensure that the name is unique.\n     */\n    addTable(poiTable: PoiTable) {\n        this.m_poiTables.set(poiTable.name, poiTable);\n    }\n\n    /**\n     * Retrieve a {@link PoiTable} by name.\n     *\n     * @param {(string | undefined)} poiTableName Name of the {@link PoiTable}.\n     *\n     * @returns {(PoiTable | undefined)} The found [[poiTable]] if it could be found, `undefined`\n     *          otherwise.\n     */\n    getPoiTable(poiTableName: string | undefined): PoiTable | undefined {\n        return poiTableName === undefined ? undefined : this.m_poiTables.get(poiTableName);\n    }\n\n    /**\n     * Return `true` if the {@link PoiTable}s have finished loading.\n     *\n     * @readonly\n     */\n    get finishedLoading(): boolean {\n        return !this.m_isLoading;\n    }\n\n    private startLoading() {\n        this.m_isLoading = true;\n    }\n\n    private finishLoading() {\n        this.m_isLoading = false;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport {\n    Definitions,\n    StandardGeometryKind,\n    StyleSet,\n    Technique,\n    Theme\n} from \"@here/harp-datasource-protocol\";\nimport { MapEnv, StyleSetEvaluator } from \"@here/harp-datasource-protocol/index-decoder\";\nimport {\n    GeoCoordinates,\n    MercatorConstants,\n    polarTilingScheme,\n    TileKey,\n    TilingScheme,\n    TransverseMercatorUtils\n} from \"@here/harp-geoutils\";\n\nimport { DataSource, DataSourceOptions } from \"./DataSource\";\nimport { createMaterial } from \"./DecodedTileHelpers\";\nimport { MapObjectAdapter } from \"./MapObjectAdapter\";\nimport { Tile } from \"./Tile\";\n\nexport interface PolarTileDataSourceOptions extends DataSourceOptions {\n    /**\n     * Optional level offset of regular tiles from reference datasource to align tiles to.\n     * Default is -1.\n     */\n    geometryLevelOffset?: number;\n\n    /**\n     * Enable debug display for generated tiles.\n     * Default is false.\n     */\n    debugTiles?: boolean;\n}\n\ninterface TechniqueEntry {\n    technique: Technique;\n    material: THREE.Material;\n}\n\n/**\n * {@link DataSource} providing geometry for poles\n */\nexport class PolarTileDataSource extends DataSource {\n    private m_tilingScheme: TilingScheme = polarTilingScheme;\n    private m_maxLatitude = THREE.MathUtils.radToDeg(MercatorConstants.MAXIMUM_LATITUDE);\n    private m_geometryLevelOffset: number;\n    private m_debugTiles: boolean;\n\n    private m_styleSetEvaluator?: StyleSetEvaluator;\n    private m_northPoleEntry?: TechniqueEntry;\n    private m_southPoleEntry?: TechniqueEntry;\n\n    constructor({\n        name = \"polar\",\n        styleSetName,\n        minDataLevel,\n        maxDataLevel,\n        minDisplayLevel,\n        maxDisplayLevel,\n        storageLevelOffset = -2,\n        geometryLevelOffset = 1,\n        debugTiles = false\n    }: PolarTileDataSourceOptions) {\n        super({\n            name,\n            styleSetName,\n            minDataLevel,\n            maxDataLevel,\n            minDisplayLevel,\n            maxDisplayLevel,\n            storageLevelOffset\n        });\n\n        this.m_geometryLevelOffset = geometryLevelOffset;\n        this.m_debugTiles = debugTiles;\n        this.cacheable = false;\n    }\n\n    /** @override */\n    dispose() {\n        if (this.m_northPoleEntry) {\n            this.m_northPoleEntry.material.dispose();\n            delete this.m_northPoleEntry;\n        }\n        if (this.m_southPoleEntry) {\n            this.m_southPoleEntry.material.dispose();\n            delete this.m_southPoleEntry;\n        }\n        if (this.m_styleSetEvaluator) {\n            delete this.m_styleSetEvaluator;\n        }\n    }\n\n    createTechiqueEntry(kind: string): TechniqueEntry | undefined {\n        if (!this.m_styleSetEvaluator) {\n            return undefined;\n        }\n        const env = new MapEnv({\n            $geometryType: \"polygon\",\n            $layer: \"earth\",\n            kind\n        });\n        const techniques = this.m_styleSetEvaluator.getMatchingTechniques(env);\n\n        if (techniques.length === 0) {\n            return undefined;\n        }\n        const technique = techniques[0];\n        const material = createMaterial({ technique, env: this.mapView.env });\n        if (!material) {\n            return undefined;\n        }\n        return { material, technique };\n    }\n\n    /** @override */\n    setStyleSet(styleSet?: StyleSet, definitions?: Definitions, languages?: string[]): void {\n        this.dispose();\n\n        if (styleSet !== undefined) {\n            this.m_styleSetEvaluator = new StyleSetEvaluator(styleSet, definitions);\n\n            this.m_northPoleEntry = this.createTechiqueEntry(\"north_pole\");\n            this.m_southPoleEntry = this.createTechiqueEntry(\"south_pole\");\n        }\n\n        this.mapView.markTilesDirty(this);\n    }\n\n    /** @override */\n    setTheme(theme: Theme, languages?: string[]): void {\n        const styleSet =\n            (this.styleSetName !== undefined && theme.styles && theme.styles[this.styleSetName]) ||\n            [];\n\n        this.setStyleSet(styleSet, theme.definitions, languages);\n    }\n\n    /** @override */\n    canGetTile(zoomLevel: number, tileKey: TileKey): boolean {\n        if (zoomLevel !== tileKey.level || tileKey.level < 1) {\n            return false;\n        }\n\n        const { north, south } = this.m_tilingScheme.getGeoBox(tileKey);\n\n        return north > this.m_maxLatitude || south < -this.m_maxLatitude;\n    }\n\n    /** @override */\n    shouldSubdivide(zoomLevel: number, tileKey: TileKey): boolean {\n        if (zoomLevel <= tileKey.level) {\n            return false;\n        }\n\n        const { north, south } = this.m_tilingScheme.getGeoBox(tileKey);\n\n        return north > this.m_maxLatitude || south < -this.m_maxLatitude;\n    }\n\n    /** @override */\n    getTilingScheme(): TilingScheme {\n        return this.m_tilingScheme;\n    }\n\n    /** @override */\n    getTile(tileKey: TileKey): Tile {\n        const tile = new Tile(this, tileKey);\n\n        this.createTileGeometry(tile);\n\n        return tile;\n    }\n\n    get geometryLevelOffset(): number {\n        return this.m_geometryLevelOffset;\n    }\n\n    set geometryLevelOffset(geometryLevelOffset: number) {\n        this.m_geometryLevelOffset = geometryLevelOffset;\n    }\n\n    private intersectEdge(latitude: number, a: GeoCoordinates, b: GeoCoordinates): GeoCoordinates {\n        const latA = a.latitude;\n        const latB = b.latitude;\n\n        let lonA = a.longitude;\n        let lonB = b.longitude;\n\n        if (Math.abs(latA) === 90) {\n            lonA = lonB;\n        }\n        if (Math.abs(latB) === 90) {\n            lonB = lonA;\n        }\n        const deltaLat = latB - latA;\n        const deltaLon = lonB - lonA;\n        const scale = (latitude - latA) / deltaLat;\n\n        return new GeoCoordinates(latitude, lonA + deltaLon * scale, 0);\n    }\n\n    private createTileGeometry(tile: Tile): void {\n        const { north, south } = tile.geoBox;\n\n        const isNorthPole = north > 0 && south >= 0;\n        const techniqueEntry = isNorthPole ? this.m_northPoleEntry : this.m_southPoleEntry;\n        if (techniqueEntry === undefined) {\n            tile.forceHasGeometry(true);\n            return;\n        }\n\n        const srcProjection = this.m_tilingScheme.projection;\n        const dstProjection = this.projection;\n\n        const maxLat = this.m_maxLatitude;\n        const poleLat = isNorthPole ? maxLat : -maxLat;\n\n        const box = this.m_tilingScheme.boundingBoxGenerator.getWorldBox(tile.tileKey);\n\n        const pBL = srcProjection.unprojectPoint(new THREE.Vector3(box.min.x, box.min.y, 0));\n        const pBR = srcProjection.unprojectPoint(new THREE.Vector3(box.max.x, box.min.y, 0));\n        const pTR = srcProjection.unprojectPoint(new THREE.Vector3(box.max.x, box.max.y, 0));\n        const pTL = srcProjection.unprojectPoint(new THREE.Vector3(box.min.x, box.max.y, 0));\n\n        let points: GeoCoordinates[];\n        let needsGeometryCut = false;\n\n        // special case where tile contains half of the hemisphere\n        if (tile.tileKey.level === 1) {\n            const isLeftHalf = box.min.x === 0;\n\n            const poleX = isLeftHalf ? box.max.x : box.min.x;\n            const poleY = (box.max.y + box.min.y) / 2;\n            const pPole = srcProjection.unprojectPoint(new THREE.Vector3(poleX, poleY, 0));\n\n            // coordinates are not used, needed for right position\n            const pXX = isLeftHalf ? pBL : pBR;\n\n            points = isNorthPole\n                ? isLeftHalf\n                    ? [pPole, pTR, pXX, pBR]\n                    : [pPole, pBL, pXX, pTL]\n                : isLeftHalf\n                ? [pPole, pBR, pXX, pTR]\n                : [pPole, pTL, pXX, pBL];\n\n            needsGeometryCut = true;\n        } else {\n            // ccw for north, cw for south\n            points = isNorthPole ? [pBL, pBR, pTR, pTL] : [pBL, pTL, pTR, pBR];\n\n            const lats = points.map(p => p.latitude);\n            const lmax = Math.max(...lats);\n            const lmin = Math.min(...lats);\n\n            const isAllPointsOut = isNorthPole ? lmax < poleLat : lmin > poleLat;\n            if (isAllPointsOut) {\n                return;\n            }\n\n            const isSomePointsOut = isNorthPole ? lmin < poleLat : lmax > poleLat;\n            needsGeometryCut = isSomePointsOut;\n\n            if (needsGeometryCut) {\n                const nearest = lats.indexOf(isNorthPole ? lmax : lmin);\n                if (nearest !== 0) {\n                    for (let i = 0; i < nearest; i++) {\n                        points.push(points.shift() as GeoCoordinates);\n                    }\n                }\n            }\n        }\n\n        if (needsGeometryCut) {\n            const centerX = (box.min.x + box.max.x) / 2;\n            const centerY = (box.min.y + box.max.y) / 2;\n            const center = srcProjection.unprojectPoint(new THREE.Vector3(centerX, centerY, 0));\n\n            TransverseMercatorUtils.alignLongitude(points, center);\n\n            // points aligned as follows:\n            // a - nearest to the pole, always in\n            // b - next to nearest\n            // c - farthes from the pole, always out\n            // d - prev from nearest\n            const a = points[0];\n            const b = points[1];\n            const c = points[2];\n            const d = points[3];\n\n            const inPointB = Math.abs(b.latitude) >= maxLat;\n            const inPointD = Math.abs(d.latitude) >= maxLat;\n\n            const cutStart = inPointB\n                ? this.intersectEdge(poleLat, b, c)\n                : this.intersectEdge(poleLat, a, b);\n\n            const cutEnd = inPointD\n                ? this.intersectEdge(poleLat, d, c)\n                : this.intersectEdge(poleLat, a, d);\n\n            points.splice(inPointB ? 2 : 1, 4, cutStart);\n\n            const level = tile.tileKey.level - this.storageLevelOffset + this.m_geometryLevelOffset;\n            // tslint:disable-next-line:no-bitwise\n            const subdivisions = 1 << Math.max(0, level);\n            const step = 360 / subdivisions;\n\n            const cutIndexStart = Math.floor((cutStart.longitude + 180) / step);\n            const cutIndexEnd = Math.ceil((cutEnd.longitude + 180) / step);\n\n            for (let i = cutIndexStart + 1; i < cutIndexEnd; i++) {\n                points.push(new GeoCoordinates(poleLat, i * step - 180, 0));\n            }\n\n            points.push(cutEnd);\n            if (inPointD) {\n                points.push(d);\n            }\n        }\n\n        const g = new THREE.Geometry();\n\n        for (const point of points) {\n            const projected = dstProjection.projectPoint(point, new THREE.Vector3());\n            g.vertices.push(projected.sub(tile.center));\n        }\n\n        for (let i = 1; i < points.length - 1; i++) {\n            g.faces.push(isNorthPole ? new THREE.Face3(0, i, i + 1) : new THREE.Face3(0, i + 1, i));\n        }\n\n        const geometry = new THREE.BufferGeometry();\n        geometry.fromGeometry(g);\n        g.dispose();\n\n        const mesh = new THREE.Mesh(geometry, techniqueEntry.material);\n        mesh.userData = {\n            dataSource: this.name,\n            tileKey: tile.tileKey\n        };\n\n        if (this.m_debugTiles) {\n            const color = Math.round(Math.abs(Math.sin(11 * tile.tileKey.mortonCode())) * 0xffffff);\n            mesh.material = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.5 });\n\n            tile.objects.push(\n                new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ color, wireframe: true }))\n            );\n        }\n\n        MapObjectAdapter.create(mesh, {\n            technique: techniqueEntry.technique,\n            kind: [isNorthPole ? StandardGeometryKind.Water : StandardGeometryKind.Background]\n        });\n\n        tile.objects.push(mesh);\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CubemapSky } from \"@here/harp-datasource-protocol\";\nimport { LoggerManager } from \"@here/harp-utils\";\nimport { CubeTexture, CubeTextureLoader, Texture } from \"three\";\n\nconst logger = LoggerManager.instance.create(\"SkyCubemapTexture\");\n\n/**\n * Number of faces that form a [[SkyCubemapTexture]].\n */\nexport const SKY_CUBEMAP_FACE_COUNT = 6;\n\n/**\n * Maps the faceId to the expected position in the threejs faces array.\n */\nexport enum SkyCubemapFaceId {\n    \"positiveX\",\n    \"negativeX\",\n    \"positiveY\",\n    \"negativeY\",\n    \"positiveZ\",\n    \"negativeZ\"\n}\n\n/**\n * Class that handles loading all 6 faces of a [[CubeTexture]], to be used with [[SkyBackground]].\n */\nexport class SkyCubemapTexture {\n    private m_skybox: CubeTexture;\n\n    /**\n     * Constructs a new `SkyCubemapTexture`.\n     *\n     * @param sky - Initial [[CubemapSky]] configuration.\n     */\n    constructor(sky: CubemapSky) {\n        const faces = this.createCubemapFaceArray(sky);\n        this.m_skybox =\n            faces !== undefined ? new CubeTextureLoader().load(faces) : new CubeTexture();\n    }\n\n    /**\n     * Disposes allocated resources.\n     */\n    dispose() {\n        this.m_skybox.dispose();\n    }\n\n    /**\n     * `SkyCubemapTexture`'s texture resource.\n     */\n    get texture(): Texture {\n        return this.m_skybox;\n    }\n\n    /**\n     * Updates the `SkyCubemapTexture` with new parameters.\n     *\n     * @param params - New [[CubemapSky]] configuration.\n     */\n    updateTexture(sky: CubemapSky) {\n        const faces = this.createCubemapFaceArray(sky);\n        if (faces === undefined) {\n            return;\n        }\n        this.m_skybox = new CubeTextureLoader().load(faces);\n    }\n\n    private createCubemapFaceArray(sky: CubemapSky): string[] | undefined {\n        const faces: Array<string | undefined> = [\n            undefined,\n            undefined,\n            undefined,\n            undefined,\n            undefined,\n            undefined\n        ];\n        for (let i = 0; i < SKY_CUBEMAP_FACE_COUNT; ++i) {\n            const face: string | undefined = (sky as any)[SkyCubemapFaceId[i]];\n            if (face === undefined) {\n                logger.error(`Face \"${SkyCubemapFaceId[i]}\" was not defined.`);\n                return;\n            }\n            faces[i] = face;\n        }\n\n        return faces as string[];\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { isJsonExpr } from \"@here/harp-datasource-protocol\";\nimport {\n    Definitions,\n    FlatTheme,\n    isActualSelectorDefinition,\n    isBoxedDefinition,\n    isJsonExprReference,\n    isLiteralDefinition,\n    ResolvedStyleDeclaration,\n    ResolvedStyleSet,\n    StyleDeclaration,\n    Styles,\n    StyleSet,\n    Theme\n} from \"@here/harp-datasource-protocol/lib/Theme\";\nimport {\n    cloneDeep,\n    composeUriResolvers,\n    ContextLogger,\n    getAppBaseUrl,\n    getOptionValue,\n    IContextLogger,\n    ISimpleChannel,\n    RelativeUriResolver,\n    resolveReferenceUri,\n    UriResolver\n} from \"@here/harp-utils\";\nimport { SkyCubemapFaceId, SKY_CUBEMAP_FACE_COUNT } from \"./SkyCubemapTexture\";\n\nimport \"@here/harp-fetch\";\n\nexport const DEFAULT_MAX_THEME_INTHERITANCE_DEPTH = 4;\n\n/**\n * Options to customize {@link @here/harp-datasource-protocol#Theme} loading process.\n *\n * @see {@link ThemeLoader.load}\n */\nexport interface ThemeLoadOptions {\n    /**\n     * Whether to resolve `ref` expressions in `definition` and `styles` elements.\n     *\n     * @default `false`, as datasources resolve definitions in [[StyleSetEvaluator]].\n     */\n    resolveDefinitions?: boolean;\n\n    /**\n     * Resolve the URIs to resources like fonts, icons, ...\n     * If true, [[uriResolver]] will be used to resolve the URI\n     * @default true\n     */\n    resolveResourceUris?: boolean;\n\n    /**\n     * Resolve the URIs of inherited themes (using `extends` feature).\n     * If true, [[uriResolver]] will be used to resolve the URI\n     * @default true\n     */\n    resolveIncludeUris?: boolean;\n\n    /**\n     * An `AbortSignal` object instance; allows you to communicate with a loading process\n     * (including fetch requests) request and abort it if desired via an `AbortController`.\n     *\n     * Modeled after Web APIs `fetch`s `init.signal`.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/AbortController\n     */\n    signal?: AbortSignal;\n\n    /**\n     * Maximum recursion depth when resolving base themes\n     * through [{@link @here/harp-datasource-protocol#Theme}s `extends` property.\n     *\n     * @default [[DEFAULT_MAX_THEME_INTHERITANCE_DEPTH]]\n     */\n    maxInheritanceDepth?: number;\n\n    /**\n     * Custom logging channel on which diagnostics and warnings will be reported.\n     *\n     * If not specified, {@link ThemeLoader.load} will log to `console`.\n     */\n    logger?: ISimpleChannel;\n\n    /**\n     * Resolve asset `URI`s referenced in `Theme` assets using this resolver.\n     */\n    uriResolver?: UriResolver;\n}\n\n/**\n * Loads and validates a theme from URL objects.\n */\nexport class ThemeLoader {\n    /**\n     * Loads a {@link @here/harp-datasource-protocol#Theme} from a\n     * remote resource, provided as a URL that points to a\n     * JSON-encoded theme.\n     *\n     * By default, resolves following features of theme:\n     *\n     *  -  `extends` - loads and merges all inherited themes (see [[resolveBaseTheme]])\n     *  -  `ref` - resolves all `ref` instances to their values defined in `definitions` section\n     *     of theme (see [[resolveThemeReferences]])\n     *\n     * Relative URIs of reference resources are resolved to full URL using the document's base URL\n     * (see [[resolveUrls]]).\n     *\n     * Custom URIs (of theme itself and of resources referenced by theme) may be resolved with by\n     * providing {@link @here/harp-utils#UriResolver} using {@link ThemeLoadOptions.uriResolver}\n     * option.\n     *\n     * @param theme - {@link @here/harp-datasource-protocol#Theme} instance or theme URL\n     *                to the theme.\n     * @param options - Optional, a {@link ThemeLoadOptions} objects\n     *                  containing any custom settings for\n     *                  this load request.\n     */\n    static async load(\n        theme: string | Theme | FlatTheme,\n        options?: ThemeLoadOptions\n    ): Promise<Theme> {\n        options = options || {};\n        if (typeof theme === \"string\") {\n            const uriResolver = options.uriResolver;\n            const themeUrl = uriResolver !== undefined ? uriResolver.resolveUri(theme) : theme;\n            const response = await fetch(themeUrl, { signal: options.signal });\n            if (!response.ok) {\n                throw new Error(`ThemeLoader#load: cannot load theme: ${response.statusText}`);\n            }\n            theme = (await response.json()) as Theme;\n            theme.url = resolveReferenceUri(getAppBaseUrl(), themeUrl);\n            theme = this.resolveUrls(theme, options);\n        } else if (theme.url === undefined) {\n            // assume that theme url is same as baseUrl\n            theme.url = getAppBaseUrl();\n            theme = this.resolveUrls(theme, options);\n        } else {\n            theme = this.convertFlatTheme(theme);\n        }\n\n        if (theme === null || theme === undefined) {\n            throw new Error(\"ThemeLoader#load: loaded resource is not valid JSON\");\n        }\n\n        ThemeLoader.checkTechniqueSupport(theme);\n\n        const resolveDefinitions = getOptionValue<boolean>(options.resolveDefinitions, false);\n        theme = await ThemeLoader.resolveBaseThemes(theme, options);\n        if (resolveDefinitions) {\n            const contextLoader = new ContextLogger(\n                options.logger || console,\n                `when processing Theme ${theme.url}:`\n            );\n            ThemeLoader.resolveThemeReferences(theme, contextLoader);\n        }\n        return theme;\n    }\n\n    /**\n     * Checks if `theme` instance is completely loaded, meaning that `extends` property is resolved.\n     *\n     * @param theme -\n     */\n    static isThemeLoaded(theme: Theme | FlatTheme): boolean {\n        return theme.extends === undefined;\n    }\n\n    /**\n     * @deprecated Please use `ThemeLoader.load`\n     *\n     * Loads a {@link @here/harp-datasource-protocol#Theme} from a remote resource,\n     * provided as a URL that points to a JSON-encoded\n     * theme.\n     *\n     * @param themeUrl - The URL to the theme.\n     *\n     */\n    static async loadAsync(themeUrl: string): Promise<Theme> {\n        return ThemeLoader.load(themeUrl);\n    }\n\n    /**\n     * Resolves all {@link @here/harp-datasource-protocol#Theme}'s relatives URLs\n     * to full URL using the {@link @here/harp-datasource-protocol#Theme}'s URL\n     * (see: https://www.w3.org/TR/WD-html40-970917/htmlweb.html#h-5.1.2).\n     *\n     * This method mutates original `theme` instance.\n     *\n     * @param theme - The {@link @here/harp-datasource-protocol#Theme} to resolve.\n     */\n    private static resolveUrls(theme: Theme | FlatTheme, options?: ThemeLoadOptions): Theme {\n        // Ensure that all resources referenced in theme by relative URIs are in fact relative to\n        // theme.\n        theme = ThemeLoader.convertFlatTheme(theme);\n        if (theme.url === undefined) {\n            return theme;\n        }\n\n        const childUrlResolver = composeUriResolvers(\n            options?.uriResolver,\n            new RelativeUriResolver(theme.url)\n        );\n\n        const resolveIncludes = options === undefined || !(options.resolveIncludeUris === false);\n        if (theme.extends && resolveIncludes) {\n            theme.extends = (Array.isArray(theme.extends) ? theme.extends : [theme.extends]).map(\n                baseTheme => {\n                    if (typeof baseTheme === \"string\") {\n                        return childUrlResolver.resolveUri(baseTheme);\n                    } else {\n                        if (baseTheme.url !== undefined) {\n                            return baseTheme;\n                        } else {\n                            baseTheme.url = theme.url;\n                            return this.resolveUrls(baseTheme, options);\n                        }\n                    }\n                }\n            );\n        }\n\n        if (!ThemeLoader.convertFlatTheme(theme)) {\n            return theme;\n        }\n\n        const resolveResources = options === undefined || !(options.resolveResourceUris === false);\n        if (resolveResources) {\n            ThemeLoader.resolveResources(theme, childUrlResolver);\n        }\n\n        return theme;\n    }\n\n    private static checkTechniqueSupport(theme: Theme) {\n        if (theme.styles !== undefined) {\n            for (const styleSetName in theme.styles) {\n                if (!theme.styles.hasOwnProperty(styleSetName)) {\n                    continue;\n                }\n                for (const style of theme.styles[styleSetName]) {\n                    switch ((style as any).technique) {\n                        // TODO: Re-enable this once \"dashed-line\" is deprecated.\n                        /* case \"dashed-line\":\n                            console.warn(\n                                `Using deprecated \"dashed-line\" technique.\n                                Use \"solid-line\" technique instead`\n                            ); */\n                        default:\n                            break;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Expand all `ref` expressions in {@link @here/harp-datasource-protocol#Theme}\n     * basing on `definitions`.\n     *\n     * @remarks\n     * This method mutates original `theme` instance.\n     */\n    private static resolveThemeReferences(theme: Theme, contextLogger: IContextLogger): Theme {\n        if (theme.definitions !== undefined) {\n            contextLogger.pushAttr(\"definitions\");\n            /**\n             * First, try to resolve all internal references in definitions, so if we may save few\n             * CPU cycles if some definition is used many times in actual style sets.\n             */\n            for (const definitionName in theme.definitions) {\n                if (!theme.definitions.hasOwnProperty(definitionName)) {\n                    continue;\n                }\n\n                const def = theme.definitions[definitionName];\n                if (isActualSelectorDefinition(def)) {\n                    contextLogger.pushAttr(definitionName);\n                    const resolvedDef = ThemeLoader.resolveStyle(\n                        def,\n                        theme.definitions,\n                        contextLogger\n                    );\n                    contextLogger.pop();\n                    if (resolvedDef === undefined) {\n                        contextLogger.pushAttr(definitionName);\n                        contextLogger.warn(\"skipping invalid style in definition\");\n                        contextLogger.pop();\n                        delete theme.definitions[definitionName];\n                    } else {\n                        theme.definitions[definitionName] = resolvedDef;\n                    }\n                }\n            }\n            contextLogger.pop();\n        }\n        if (theme.styles !== undefined) {\n            for (const styleSetName in theme.styles) {\n                if (!theme.styles.hasOwnProperty(styleSetName)) {\n                    continue;\n                }\n                contextLogger.pushAttr(\"styles\");\n                contextLogger.pushAttr(styleSetName);\n\n                theme.styles[styleSetName] = ThemeLoader.resolveStyleSet(\n                    theme.styles[styleSetName],\n                    theme.definitions,\n                    contextLogger\n                );\n                contextLogger.pop();\n                contextLogger.pop();\n            }\n        }\n        return theme;\n    }\n\n    /**\n     * Expand all `ref` in [[StyleSet]] basing on `definitions`.\n     */\n    private static resolveStyleSet(\n        styleSet: StyleSet,\n        definitions: Definitions | undefined,\n        contextLogger: IContextLogger\n    ): ResolvedStyleSet {\n        const result: ResolvedStyleSet = [];\n\n        for (let index = 0; index < styleSet.length; ++index) {\n            const currentStyle = styleSet[index];\n            contextLogger.pushIndex(index);\n            const resolvedStyle = ThemeLoader.resolveStyle(\n                currentStyle,\n                definitions,\n                contextLogger\n            );\n            if (resolvedStyle !== undefined) {\n                result.push(resolvedStyle);\n            } else {\n                contextLogger.warn(\"invalid style, ignored\");\n            }\n            contextLogger.pop();\n        }\n        return result;\n    }\n\n    /**\n     * Expand all `ref` in [[Style]] instance basing on `definitions`.\n     */\n    private static resolveStyle(\n        style: StyleDeclaration,\n        definitions: Definitions | undefined,\n        contextLogger: IContextLogger\n    ): ResolvedStyleDeclaration | undefined {\n        if (isJsonExprReference(style)) {\n            // expand and instantiate references to style definitions.\n\n            const def = definitions && definitions[style[1]];\n\n            if (!def) {\n                contextLogger.warn(`invalid reference '${style[1]}' - not found`);\n                return undefined;\n            }\n            if (!isActualSelectorDefinition(def)) {\n                contextLogger.warn(`invalid reference '${style[1]}' - expected style definition`);\n                return undefined;\n            }\n\n            // instantiate the style\n            style = cloneDeep(def);\n        }\n        style = style as ResolvedStyleDeclaration;\n\n        if (Array.isArray(style.when)) {\n            contextLogger.pushAttr(\"when\");\n            const resolvedWhen = this.resolveExpressionReferences(\n                style.when,\n                definitions,\n                contextLogger\n            );\n            contextLogger.pop();\n            if (resolvedWhen === undefined) {\n                return undefined;\n            }\n            style.when = resolvedWhen;\n        }\n\n        if (style.attr !== undefined) {\n            const attr = style.attr as any;\n\n            contextLogger.pushAttr(\"attr\");\n            for (const prop in attr) {\n                if (!attr.hasOwnProperty(prop)) {\n                    continue;\n                }\n\n                const value = attr[prop];\n\n                if (!Array.isArray(value)) {\n                    continue; // nothing to do\n                }\n\n                contextLogger.pushAttr(prop);\n                const resolvedValue = this.resolveExpressionReferences(\n                    value,\n                    definitions,\n                    contextLogger\n                );\n                contextLogger.pop();\n\n                if (resolvedValue !== undefined) {\n                    attr[prop] = resolvedValue;\n                } else {\n                    delete attr[prop];\n                }\n            }\n            contextLogger.pop();\n        }\n        return style;\n    }\n\n    /**\n     * Resolve `[ref, ...]` in expressions.\n     *\n     * Returns `undefined` some reference was invalid (missing or wrong type).\n     */\n    private static resolveExpressionReferences<T>(\n        value: T,\n        definitions: Definitions | undefined,\n        contextLogger: IContextLogger\n    ): T | undefined {\n        let failed = false;\n        function resolveInternal(node: any) {\n            if (isJsonExprReference(node)) {\n                const defName = node[1];\n                const def = definitions && definitions[defName];\n                if (def === undefined) {\n                    contextLogger.warn(`invalid reference '${defName}' - not found`);\n                    failed = true;\n                    return undefined;\n                }\n                if (isLiteralDefinition(def) || isJsonExpr(def)) {\n                    return def;\n                }\n                if (isBoxedDefinition(def)) {\n                    return def.value;\n                }\n                contextLogger.warn(`invalid reference '${defName}' - expected value definition`);\n                failed = true;\n                return undefined;\n            } else if (Array.isArray(node)) {\n                const result = [...node];\n                for (let i = 1; i < result.length; ++i) {\n                    result[i] = resolveInternal(result[i]);\n                }\n                return result;\n            } else {\n                return node;\n            }\n        }\n        const r = resolveInternal(value);\n        if (failed) {\n            return undefined;\n        }\n        return r;\n    }\n\n    /**\n     * Realize `extends` clause by merging `theme` with\n     * its base {@link @here/harp-datasource-protocol#Theme}.\n     *\n     * @param theme - {@link @here/harp-datasource-protocol#Theme} object\n     * @param options - Optional, a {@link ThemeLoadOptions} objects\n     *                  containing any custom settings for\n     *                  this load request.\n     */\n    private static async resolveBaseThemes(\n        theme: Theme,\n        options?: ThemeLoadOptions\n    ): Promise<Theme> {\n        options = options || {};\n        if (theme.extends === undefined) {\n            return theme;\n        }\n\n        const maxInheritanceDepth = getOptionValue(\n            options.maxInheritanceDepth,\n            DEFAULT_MAX_THEME_INTHERITANCE_DEPTH\n        );\n        if (maxInheritanceDepth <= 0) {\n            throw new Error(`maxInheritanceDepth reached when attempting to load base theme`);\n        }\n\n        const baseThemes = !Array.isArray(theme.extends) ? [theme.extends] : theme.extends;\n        delete theme.extends;\n        let baseThemesMerged: Theme = {};\n        for (const baseTheme of baseThemes) {\n            const actualBaseTheme = await ThemeLoader.load(baseTheme, {\n                ...options,\n                resolveDefinitions: false,\n                maxInheritanceDepth: maxInheritanceDepth - 1\n            });\n\n            baseThemesMerged = ThemeLoader.mergeThemes(actualBaseTheme, baseThemesMerged);\n        }\n        return ThemeLoader.mergeThemes(theme, baseThemesMerged);\n    }\n\n    private static mergeThemes(theme: Theme, baseTheme: Theme): Theme {\n        const definitions = { ...baseTheme.definitions, ...theme.definitions };\n\n        let styles!: Styles;\n\n        if (baseTheme.styles && theme.styles) {\n            const currentStyleSets = Object.keys(baseTheme.styles);\n            const incomingStyleSets = Object.keys(theme.styles);\n\n            styles = {};\n\n            currentStyleSets.forEach(styleSetName => {\n                const index = incomingStyleSets.indexOf(styleSetName);\n\n                if (index !== -1) {\n                    // merge the current and incoming styleset\n                    // and add the result to `styles`.\n                    styles[styleSetName] = [\n                        ...baseTheme.styles![styleSetName],\n                        ...theme.styles![styleSetName]\n                    ];\n                    // remove the styleset from the incoming list\n                    incomingStyleSets.splice(index, 1);\n                } else {\n                    // copy the existing style set to `styles`.\n                    styles[styleSetName] = baseTheme.styles![styleSetName];\n                }\n            });\n\n            // add the remaining stylesets to styles.\n            incomingStyleSets.forEach(p => {\n                styles[p] = theme.styles![p];\n            });\n        } else if (baseTheme.styles) {\n            styles = { ...baseTheme.styles };\n        } else if (theme.styles) {\n            styles = { ...theme.styles };\n        }\n        return { ...baseTheme, ...theme, definitions, styles };\n    }\n\n    private static convertFlatTheme(theme: Theme | FlatTheme): Theme {\n        if (Array.isArray(theme.styles)) {\n            // Convert the flat theme to a standard theme.\n            const styles: Styles = {};\n            theme.styles.forEach(style => {\n                if (isJsonExpr(style)) {\n                    throw new Error(\"invalid usage of theme reference\");\n                }\n                const styleSetName = style.styleSet;\n                if (styleSetName === undefined) {\n                    throw new Error(\"missing reference to style set\");\n                }\n                if (!styles[styleSetName]) {\n                    styles[styleSetName] = [];\n                }\n                styles[styleSetName].push(style);\n            });\n            theme.styles = styles;\n        }\n        return theme as Theme;\n    }\n\n    private static resolveResources(theme: Theme, childUrlResolver: UriResolver) {\n        if (theme.sky && theme.sky.type === \"cubemap\") {\n            for (let i = 0; i < SKY_CUBEMAP_FACE_COUNT; ++i) {\n                const faceUrl: string | undefined = (theme.sky as any)[SkyCubemapFaceId[i]];\n                if (faceUrl !== undefined) {\n                    (theme.sky as any)[SkyCubemapFaceId[i]] = childUrlResolver.resolveUri(faceUrl);\n                }\n            }\n        }\n        if (theme.images) {\n            for (const name of Object.keys(theme.images)) {\n                const image = theme.images[name];\n                image.url = childUrlResolver.resolveUri(image.url);\n                if (image.atlas !== undefined) {\n                    image.atlas = childUrlResolver.resolveUri(image.atlas);\n                }\n            }\n        }\n        if (theme.fontCatalogs) {\n            for (const font of theme.fontCatalogs) {\n                font.url = childUrlResolver.resolveUri(font.url);\n            }\n        }\n        if (theme.poiTables) {\n            for (const poiTable of theme.poiTables) {\n                poiTable.url = childUrlResolver.resolveUri(poiTable.url);\n            }\n        }\n\n        if (theme.styles !== undefined) {\n            for (const styleSetName in theme.styles) {\n                if (!theme.styles.hasOwnProperty(styleSetName)) {\n                    continue;\n                }\n                const styleSet = theme.styles[styleSetName] as ResolvedStyleDeclaration[];\n                for (const style of styleSet) {\n                    if (!style.attr) {\n                        continue;\n                    }\n                    [\"map\", \"normalMap\", \"displacementMap\", \"roughnessMap\"].forEach(\n                        texturePropertyName => {\n                            const textureProperty = (style.attr! as any)[texturePropertyName];\n                            if (textureProperty && typeof textureProperty === \"string\") {\n                                (style.attr! as any)[\n                                    texturePropertyName\n                                ] = childUrlResolver.resolveUri(textureProperty);\n                            }\n                        }\n                    );\n                }\n            }\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { ViewRanges } from \"@here/harp-datasource-protocol/lib/ViewRanges\";\nimport {\n    GeoCoordinates,\n    Projection,\n    ProjectionType,\n    TileKey,\n    TileKeyUtils,\n    TilingScheme\n} from \"@here/harp-geoutils\";\nimport { LRUCache } from \"@here/harp-lrucache\";\nimport { assert, MathUtils } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\nimport { BackgroundDataSource } from \"./BackgroundDataSource\";\nimport { ClipPlanesEvaluator } from \"./ClipPlanesEvaluator\";\nimport { DataSource } from \"./DataSource\";\nimport { ElevationRangeSource } from \"./ElevationRangeSource\";\nimport { FrustumIntersection, TileKeyEntry } from \"./FrustumIntersection\";\nimport { TileGeometryManager } from \"./geometry/TileGeometryManager\";\nimport { Tile } from \"./Tile\";\nimport { TileOffsetUtils } from \"./Utils\";\n\n/**\n * Way the memory consumption of a tile is computed. Either in number of tiles, or in MegaBytes. If\n * it is in MB, an estimation is used.\n */\nexport enum ResourceComputationType {\n    EstimationInMb = 0,\n    NumberOfTiles\n}\n\n// Direction in quad tree to search: up -> shallower levels, down -> deeper levels.\nenum SearchDirection {\n    NONE,\n    UP,\n    DOWN,\n    BOTH\n}\n\n/**\n * Limited set of {@link MapViewOptions} used for {@link VisibleTileSet}.\n */\nexport interface VisibleTileSetOptions {\n    /**\n     * The projection of the view.\n     */\n    projection: Projection;\n\n    /**\n     * User-defined camera clipping planes evaluator.\n     */\n    clipPlanesEvaluator: ClipPlanesEvaluator;\n\n    /**\n     * Limit of tiles that can be visible per datasource.\n     */\n    maxVisibleDataSourceTiles: number;\n\n    /**\n     * In addition to the simple frustum culling also do additional checks with [[MapTileCuller]].\n     */\n    extendedFrustumCulling: boolean;\n\n    /**\n     * Missing Typedoc\n     */\n    tileCacheSize: number;\n\n    /**\n     * Missing Typedoc\n     */\n    resourceComputationType: ResourceComputationType;\n\n    /**\n     * Number of levels to go up when searching for fallback tiles.\n     */\n    quadTreeSearchDistanceUp: number;\n\n    /**\n     * Number of levels to go down when searching for fallback tiles.\n     */\n    quadTreeSearchDistanceDown: number;\n}\n\nconst MB_FACTOR = 1.0 / (1024.0 * 1024.0);\n\ntype TileCacheId = string;\n\n/**\n * Wrapper for LRU cache that encapsulates tiles caching for any {@link DataSource} used.\n *\n * Provides LRU based caching mechanism where each tile is identified by its tile key\n * (morton code) and data source name.\n * Tiles are kept in the cache based on last recently used policy, cached tile may be evicted\n * only when cache reaches full saturation and tile is no longer visible.\n * @note Currently cached entries (tiles) are identified by unique tile code (morton code) and\n * data source name, thus it is required that each {@link DataSource} used should have unique\n * name, but implementation could be improved to omit this limitation.\n */\nclass DataSourceCache {\n    /**\n     * Creates unique tile key for caching based on morton code, tile offset and its data source.\n     *\n     * @param mortonCode - The tile morton code.\n     * @param offset - The tile offset.\n     * @param dataSource - The {@link DataSource} from which tile was loaded.\n     */\n    static getKey(mortonCode: number, offset: number, dataSource: DataSource): TileCacheId {\n        return `${dataSource.name}_${mortonCode}_${offset}`;\n    }\n\n    /**\n     * Create unique tile identifier for caching, based on tile object passed in.\n     *\n     * @param tile - The tile for which key is generated.\n     */\n    static getKeyForTile(tile: Tile): TileCacheId {\n        return DataSourceCache.getKey(tile.tileKey.mortonCode(), tile.offset, tile.dataSource);\n    }\n\n    private readonly m_tileCache: LRUCache<TileCacheId, Tile>;\n    private readonly m_disposedTiles: Tile[] = [];\n    private m_resourceComputationType: ResourceComputationType;\n\n    constructor(\n        cacheSize: number,\n        rct: ResourceComputationType = ResourceComputationType.EstimationInMb\n    ) {\n        this.m_resourceComputationType = rct;\n        this.m_tileCache = new LRUCache<string, Tile>(cacheSize, (tile: Tile) => {\n            if (this.m_resourceComputationType === ResourceComputationType.EstimationInMb) {\n                // Default is size in MB.\n                return tile.memoryUsage * MB_FACTOR;\n            } else {\n                return 1;\n            }\n        });\n        this.m_tileCache.evictionCallback = (_, tile) => {\n            if (tile.tileLoader !== undefined) {\n                // Cancel downloads as early as possible.\n                tile.tileLoader.cancel();\n            }\n            this.m_disposedTiles.push(tile);\n        };\n        this.m_tileCache.canEvict = (_, tile) => {\n            // Tiles can be evicted that weren't requested in the last frame.\n            return !tile.isVisible;\n        };\n    }\n\n    /**\n     * Get information how cached tiles affects cache space available.\n     *\n     * The way how cache evaluates the __resources size__ have a big influence on entire\n     * caching mechanism, if [[resourceComputationType]] is set to:\n     * [[ResourceComputationType.EstimationInMb]] then each tiles contributes to cache size\n     * differently depending on the memory consumed, on other side\n     * [[ResourceComputationType.NumberOfTiles]] says each tile occupies single slot in cache,\n     * so its real memory consumed does not matter affect caching behavior. Of course in\n     * the second scenario cache may grow significantly in terms of memory usage and thus it\n     * is out of control.\n     *\n     * @return [[ResourceComputationType]] enum that describes if resources are counted by\n     * space occupied in memory or just by number of them.\n     */\n    get resourceComputationType(): ResourceComputationType {\n        return this.m_resourceComputationType;\n    }\n\n    /**\n     * Get the cache capacity measured as number if megabytes or number of entries.\n     *\n     * The total cached tiles size determines cache saturation, if it reaches the capacity value\n     * then the resources becomes evicted (released) starting from the oldest (the latest used).\n     *\n     * @see size.\n     * @see resourceComputationType.\n     */\n    get capacity(): number {\n        return this.m_tileCache.capacity;\n    }\n\n    /**\n     * Get total cache size described as number of megabytes consumed or number of tiles stored.\n     *\n     * @see capacity.\n     * @see resourceComputationType.\n     */\n    get size(): number {\n        return this.m_tileCache.size;\n    }\n\n    /**\n     * Set cache capacity and the algorithm used for cache size calculation.\n     *\n     * @see capacity.\n     * @see resourceComputationType.\n     * @param size - The new capacity declared in megabytes or number of entires.\n     * @param rct - The enum value that determines how size and capacity are evaluated.\n     */\n    setCapacity(size: number, rct: ResourceComputationType) {\n        this.m_resourceComputationType = rct;\n        this.m_tileCache.setCapacityAndMeasure(size, (tile: Tile) => {\n            if (this.m_resourceComputationType === ResourceComputationType.EstimationInMb) {\n                // Default is size in MB.\n                return tile.memoryUsage * MB_FACTOR;\n            } else {\n                return 1;\n            }\n        });\n    }\n\n    /**\n     * Get tile cached or __undefined__ if tile is not yet in cache.\n     *\n     * @param mortonCode - An unique tile morton code.\n     * @param offset - Tile offset.\n     * @param dataSource - A {@link DataSource} the tile comes from.\n     */\n    get(mortonCode: number, offset: number, dataSource: DataSource): Tile | undefined {\n        return this.m_tileCache.get(DataSourceCache.getKey(mortonCode, offset, dataSource));\n    }\n\n    /**\n     * Add new tile to the cache.\n     *\n     * @param mortonCode - En unique tile code (morton code).\n     * @param offset - The tile offset.\n     * @param dataSource - A {@link DataSource} the tile comes from.\n     * @param tile - The tile reference.\n     */\n    set(mortonCode: number, offset: number, dataSource: DataSource, tile: Tile) {\n        this.m_tileCache.set(DataSourceCache.getKey(mortonCode, offset, dataSource), tile);\n    }\n\n    /**\n     * Delete tile from cache.\n     *\n     * @note This method will not call eviction callback.\n     * @param tile - The tile reference to be removed from cache.\n     */\n    delete(tile: Tile) {\n        const tileKey = DataSourceCache.getKeyForTile(tile);\n        this.deleteByKey(tileKey);\n    }\n\n    /**\n     * Delete tile using its unique identifier.\n     *\n     * @note Tile identifier its constructed using information about tile code (morton code) and its\n     * {@link DataSource}.\n     * @note This is explicit removal thus eviction callback will not be processed.\n     * @see DataSourceCache.getKey.\n     * @param tileKey - The unique tile identifier.\n     */\n    deleteByKey(tileKey: TileCacheId) {\n        this.m_tileCache.delete(tileKey);\n    }\n\n    /**\n     * Dispose all tiles releasing their internal data.\n     */\n    disposeTiles() {\n        this.m_disposedTiles.forEach(tile => {\n            tile.dispose();\n        });\n\n        this.m_disposedTiles.length = 0;\n    }\n\n    /**\n     * Shrink cache to its allowed capacity.\n     *\n     * This method should be called each time after operations are performed on the cache entries,\n     * in order to keep cache size consistent. It informs caching mechanism to invalidate memory\n     * consumed by its entries and check if cache is overgrown, is such case some tiles will be\n     * evicted.\n     */\n    shrinkToCapacity() {\n        this.m_tileCache.shrinkToCapacity();\n    }\n\n    /**\n     * Evict all cached tiles implicitly even without checking if still in use.\n     */\n    evictAll() {\n        this.m_tileCache.evictAll();\n    }\n\n    /**\n     * Evict selected tiles implicitly.\n     *\n     * @param selector - The callback used to determine if tile should be evicted.\n     */\n    evictSelected(selector: (tile: Tile, key: TileCacheId) => boolean) {\n        this.m_tileCache.evictSelected(selector);\n    }\n\n    /**\n     * Call functor (callback) on each tile store in cache.\n     *\n     * Optionally you may specify from which {@link DataSource} tiles should be processed.\n     * This limits the tiles visited to a sub-set originating from single {@link DataSource}.\n     * @param callback - The function to be called for each visited tile.\n     * @param inDataSource - The optional {@link DataSource} to which tiles should belong.\n     */\n    forEach(callback: (tile: Tile, key: TileCacheId) => void, inDataSource?: DataSource): void {\n        this.m_tileCache.forEach((entry: Tile, key: TileCacheId) => {\n            if (inDataSource === undefined || entry.dataSource === inDataSource) {\n                callback(entry, key);\n            }\n        });\n    }\n}\n\n/**\n * List of visible tiles for a {@link DataSource}.\n */\nexport interface DataSourceTileList {\n    /**\n     * The datasource that was producing the tiles.\n     */\n    dataSource: DataSource;\n\n    /**\n     * The current {@link MapView} zoom level.\n     */\n    zoomLevel: number;\n\n    /**\n     * The storage level of the visibleTiles.\n     * Note: renderedTiles might contain tiles from different levels.\n     */\n    storageLevel: number;\n\n    /**\n     * True if all [[visibleTiles]] are loaded.\n     */\n    allVisibleTileLoaded: boolean;\n\n    /**\n     * The number of tiles which are still loading.\n     */\n    numTilesLoading: number;\n\n    /**\n     * List of tiles we want to render (i.e. the tiles computed from the zoom level and view\n     * frustum). However some might not be renderable yet (e.g. loading). See [[renderedTiles]] for\n     * the actual list of tiles that the user will see.\n     */\n    visibleTiles: Tile[];\n\n    /**\n     * Map of tiles that will be rendered, key is the the combination of tile key and offset, see\n     * [[getKeyForTileKeyAndOffset]]. This includes tiles that are not in the [[visibleTiles]]\n     * list but that are used as fallbacks b/c they are still in the cache.\n     */\n    renderedTiles: Map<number, Tile>;\n}\n\n/**\n * Manages visible {@link Tile}s for {@link MapView}.\n *\n * Responsible for election of rendered tiles:\n *  - quad-tree traversal\n *  - frustum culling\n *  - sorting tiles by relevance (visible area) to prioritize load\n *  - limiting number of visible tiles\n *  - caching tiles\n *  - searching cache to replace visible but yet empty tiles with already loaded siblings in nearby\n *    zoom levels\n */\nexport class VisibleTileSet {\n    dataSourceTileList: DataSourceTileList[] = [];\n    allVisibleTilesLoaded: boolean = false;\n\n    private readonly m_cameraOverride = new THREE.PerspectiveCamera();\n    private m_dataSourceCache: DataSourceCache;\n    private m_viewRange: ViewRanges = { near: 0.1, far: Infinity, minimum: 0.1, maximum: Infinity };\n    // Maps morton codes to a given Tile, used to find overlapping Tiles. We only need to have this\n    // for a single TilingScheme, i.e. that of the BackgroundDataSource.\n    private m_coveringMap = new Map<number, Tile>();\n\n    private m_resourceComputationType: ResourceComputationType =\n        ResourceComputationType.EstimationInMb;\n\n    constructor(\n        private readonly m_frustumIntersection: FrustumIntersection,\n        private readonly m_tileGeometryManager: TileGeometryManager,\n        public options: VisibleTileSetOptions\n    ) {\n        this.m_resourceComputationType =\n            options.resourceComputationType === undefined\n                ? ResourceComputationType.EstimationInMb\n                : options.resourceComputationType;\n        this.m_dataSourceCache = new DataSourceCache(\n            this.options.tileCacheSize,\n            this.m_resourceComputationType\n        );\n    }\n\n    /**\n     * Returns cache size.\n     */\n    getDataSourceCacheSize(): number {\n        return this.options.tileCacheSize;\n    }\n\n    /**\n     * Sets cache size.\n     *\n     * @param size - cache size\n     * @param computationType - Optional value specifying the way a {@link Tile}s cache usage is\n     *      computed, either based on size in MB (mega bytes) or in number of tiles. Defaults to\n     *      `ResourceComputationType.EstimationInMb`.\n     */\n    setDataSourceCacheSize(\n        size: number,\n        computationType: ResourceComputationType = ResourceComputationType.EstimationInMb\n    ): void {\n        this.options.tileCacheSize = size;\n        // This effectively invalidates DataSourceCache\n        this.resourceComputationType = computationType;\n    }\n\n    /**\n     * Retrieves maximum number of visible tiles.\n     */\n    getNumberOfVisibleTiles() {\n        return this.options.maxVisibleDataSourceTiles;\n    }\n\n    /**\n     * Sets maximum number of visible tiles.\n     *\n     * @param size - size of visible tiles array\n     */\n    setNumberOfVisibleTiles(size: number) {\n        this.options.maxVisibleDataSourceTiles = size;\n    }\n\n    /**\n     * The way the cache usage is computed, either based on size in MB (mega bytes) or in number of\n     * tiles.\n     */\n    get resourceComputationType(): ResourceComputationType {\n        return this.m_resourceComputationType;\n    }\n\n    /**\n     * Sets the way tile cache is managing its elements.\n     *\n     * Cache may be either keeping number of elements stored or the memory consumed by them.\n     *\n     * @param computationType - Type of algorith used in cache for checking full saturation,\n     * may be counting number of elements or memory consumed by them.\n     */\n    set resourceComputationType(computationType: ResourceComputationType) {\n        this.m_resourceComputationType = computationType;\n        this.m_dataSourceCache.setCapacity(this.options.tileCacheSize, computationType);\n    }\n\n    /**\n     * Evaluate frustum near/far clip planes and visibility ranges.\n     */\n    updateClipPlanes(maxElevation?: number, minElevation?: number): ViewRanges {\n        if (maxElevation !== undefined) {\n            this.options.clipPlanesEvaluator.maxElevation = maxElevation;\n        }\n        if (minElevation !== undefined) {\n            this.options.clipPlanesEvaluator.minElevation = minElevation;\n        }\n        const { camera, projection, elevationProvider } = this.m_frustumIntersection.mapView;\n        this.m_viewRange = this.options.clipPlanesEvaluator.evaluateClipPlanes(\n            camera,\n            projection,\n            elevationProvider\n        );\n        return this.m_viewRange;\n    }\n\n    /**\n     * Calculates a new set of visible tiles.\n     * @param storageLevel - The camera storage level, see {@link MapView.storageLevel}.\n     * @param zoomLevel - The camera zoom level.\n     * @param dataSources - The data sources for which the visible tiles will be calculated.\n     * @param elevationRangeSource - Source of elevation range data if any.\n     * @returns view ranges and their status since last update (changed or not).\n     */\n    updateRenderList(\n        storageLevel: number,\n        zoomLevel: number,\n        dataSources: DataSource[],\n        elevationRangeSource?: ElevationRangeSource\n    ): { viewRanges: ViewRanges; viewRangesChanged: boolean } {\n        let allVisibleTilesLoaded: boolean = true;\n\n        const visibleTileKeysResult = this.getVisibleTileKeysForDataSources(\n            zoomLevel,\n            dataSources,\n            elevationRangeSource\n        );\n        this.dataSourceTileList = [];\n        this.m_coveringMap.clear();\n        for (const { dataSource, visibleTileKeys } of visibleTileKeysResult.tileKeys) {\n            // Sort by distance to camera, now the tiles that are further away are at the end\n            // of the list.\n            //\n            // Sort is unstable if distance is equal, which happens a lot when looking top-down.\n            // Unstable sorting makes label placement unstable at tile borders, leading to\n            // flickering.\n            visibleTileKeys.sort((a: TileKeyEntry, b: TileKeyEntry) => {\n                const distanceDiff = a.distance - b.distance;\n\n                // Take care or numerical precision issues\n                const minDiff = (a.distance + b.distance) * 0.000001;\n\n                return Math.abs(distanceDiff) < minDiff\n                    ? a.tileKey.mortonCode() - b.tileKey.mortonCode()\n                    : distanceDiff;\n            });\n\n            const actuallyVisibleTiles: Tile[] = [];\n            let allDataSourceTilesLoaded = true;\n            let numTilesLoading = 0;\n            // Create actual tiles only for the allowed number of visible tiles\n            const dataZoomLevel = dataSource.getDataZoomLevel(zoomLevel);\n            for (\n                let i = 0;\n                i < visibleTileKeys.length &&\n                actuallyVisibleTiles.length < this.options.maxVisibleDataSourceTiles;\n                i++\n            ) {\n                const tileEntry = visibleTileKeys[i];\n\n                const tile = this.getTile(dataSource, tileEntry.tileKey, tileEntry.offset);\n                if (tile === undefined) {\n                    continue;\n                }\n\n                allDataSourceTilesLoaded = allDataSourceTilesLoaded && tile.allGeometryLoaded;\n                if (!tile.allGeometryLoaded) {\n                    numTilesLoading++;\n                } else {\n                    tile.numFramesVisible++;\n                    // If this tile's data source is \"covering\" then other tiles beneath it have\n                    // their rendering skipped, see [[Tile.willRender]].\n                    this.skipOverlappedTiles(dataSource, tile);\n\n                    if (tile.frameNumVisible < 0) {\n                        // Store the fist frame the tile became visible.\n                        tile.frameNumVisible = dataSource.mapView.frameNumber;\n                    }\n                }\n                // Update the visible area of the tile. This is used for those tiles that are\n                // currently loaded and are waiting to be decoded to sort the jobs by area.\n                tile.visibleArea = tileEntry.area;\n                tile.elevationRange = tileEntry;\n\n                actuallyVisibleTiles.push(tile);\n            }\n\n            this.m_tileGeometryManager.updateTiles(actuallyVisibleTiles);\n\n            this.dataSourceTileList.push({\n                dataSource,\n                storageLevel,\n                zoomLevel: dataZoomLevel,\n                allVisibleTileLoaded: allDataSourceTilesLoaded,\n                numTilesLoading,\n                visibleTiles: actuallyVisibleTiles,\n                renderedTiles: new Map<number, Tile>()\n            });\n            allVisibleTilesLoaded = allVisibleTilesLoaded && allDataSourceTilesLoaded;\n        }\n\n        this.allVisibleTilesLoaded =\n            allVisibleTilesLoaded && visibleTileKeysResult.allBoundingBoxesFinal;\n\n        this.populateRenderedTiles();\n\n        this.forEachCachedTile(tile => {\n            // Remove all tiles that are still being loaded, but are no longer visible. They have to\n            // be reloaded when they become visible again. Hopefully, they are still in the browser\n            // cache by then.\n            if (!tile.isVisible && tile.tileLoader !== undefined && !tile.tileLoader.isFinished) {\n                // The internal TileLoader is cancelled automatically when the Tile is disposed.\n                this.disposeTile(tile);\n            }\n        });\n\n        this.m_dataSourceCache.shrinkToCapacity();\n\n        let minElevation: number | undefined;\n        let maxElevation: number | undefined;\n        this.dataSourceTileList.forEach(renderListEntry => {\n            // Calculate min/max elevation from every data source tiles,\n            // data sources without elevationRangeSource will contribute to\n            // values with zero levels for both elevations.\n            const tiles = renderListEntry.renderedTiles;\n            tiles.forEach(tile => {\n                tile.update(renderListEntry.zoomLevel);\n                minElevation = MathUtils.min2(minElevation, tile.geoBox.minAltitude);\n                maxElevation = MathUtils.max2(maxElevation, tile.geoBox.maxAltitude);\n            });\n        });\n\n        if (minElevation === undefined) {\n            minElevation = 0;\n        }\n        if (maxElevation === undefined) {\n            maxElevation = 0;\n        }\n        // If clip planes evaluator depends on the tiles elevation re-calculate\n        // frustum planes and update the camera near/far plane distances.\n        let viewRangesChanged: boolean = false;\n        const oldViewRanges = this.m_viewRange;\n        const newViewRanges = this.updateClipPlanes(maxElevation, minElevation);\n        viewRangesChanged = viewRangesEqual(newViewRanges, oldViewRanges) === false;\n\n        return {\n            viewRanges: newViewRanges,\n            viewRangesChanged\n        };\n    }\n\n    /**\n     * Gets the tile corresponding to the given data source, key and offset, creating it if\n     * necessary.\n     *\n     * @param dataSource - The data source the tile belongs to.\n     * @param tileKey - The key identifying the tile.\n     * @param offset - Tile offset.\n     * @return The tile if it was found or created, undefined otherwise.\n     */\n    getTile(dataSource: DataSource, tileKey: TileKey, offset: number = 0): Tile | undefined {\n        const cacheOnly = false;\n        return this.getTileImpl(dataSource, tileKey, offset, cacheOnly);\n    }\n\n    /**\n     * Gets the tile corresponding to the given data source, key and offset from the cache.\n     *\n     * @param dataSource - The data source the tile belongs to.\n     * @param tileKey - The key identifying the tile.\n     * @param offset - Tile offset.\n     * @return The tile if found in cache, undefined otherwise.\n     */\n    getCachedTile(dataSource: DataSource, tileKey: TileKey, offset: number = 0): Tile | undefined {\n        assert(dataSource.cacheable);\n        const cacheOnly = true;\n        return this.getTileImpl(dataSource, tileKey, offset, cacheOnly);\n    }\n\n    /**\n     * Gets the tile corresponding to the given data source, key and offset from the rendered tiles.\n     *\n     * @param dataSource - The data source the tile belongs to.\n     * @param tileKey - The key identifying the tile.\n     * @param offset - Tile offset.\n     * @return The tile if found among the rendered tiles, undefined otherwise.\n     */\n    getRenderedTile(\n        dataSource: DataSource,\n        tileKey: TileKey,\n        offset: number = 0\n    ): Tile | undefined {\n        const dataSourceVisibleTileList = this.dataSourceTileList.find(list => {\n            return list.dataSource === dataSource;\n        });\n\n        if (dataSourceVisibleTileList === undefined) {\n            return undefined;\n        }\n\n        return dataSourceVisibleTileList.renderedTiles.get(\n            TileOffsetUtils.getKeyForTileKeyAndOffset(tileKey, offset)\n        );\n    }\n\n    /**\n     * Gets the tile corresponding to the given data source and location from the rendered tiles.\n     *\n     * @param dataSource - The data source the tile belongs to.\n     * @param geoPoint - The geolocation included within the tile.\n     * @return The tile if found among the rendered tiles, undefined otherwise.\n     */\n    getRenderedTileAtLocation(\n        dataSource: DataSource,\n        geoPoint: GeoCoordinates,\n        offset: number = 0\n    ): Tile | undefined {\n        const dataSourceVisibleTileList = this.dataSourceTileList.find(list => {\n            return list.dataSource === dataSource;\n        });\n\n        if (dataSourceVisibleTileList === undefined) {\n            return undefined;\n        }\n\n        const tilingScheme = dataSource.getTilingScheme();\n        const visibleLevel = dataSourceVisibleTileList.zoomLevel;\n        const visibleTileKey = tilingScheme.getTileKey(geoPoint, visibleLevel);\n\n        if (!visibleTileKey) {\n            return undefined;\n        }\n\n        let tile = dataSourceVisibleTileList.renderedTiles.get(\n            TileOffsetUtils.getKeyForTileKeyAndOffset(visibleTileKey, offset)\n        );\n\n        if (tile !== undefined) {\n            return tile;\n        }\n\n        const { searchLevelsUp, searchLevelsDown } = this.getSearchDirection(\n            dataSource,\n            visibleLevel\n        );\n\n        let parentTileKey = visibleTileKey;\n        for (let levelOffset = 1; levelOffset <= searchLevelsUp; ++levelOffset) {\n            parentTileKey = parentTileKey.parent();\n\n            tile = dataSourceVisibleTileList.renderedTiles.get(\n                TileOffsetUtils.getKeyForTileKeyAndOffset(parentTileKey, offset)\n            );\n            if (tile !== undefined) {\n                return tile;\n            }\n        }\n\n        const worldPoint = tilingScheme.projection.projectPoint(geoPoint);\n\n        for (let levelOffset = 1; levelOffset <= searchLevelsDown; ++levelOffset) {\n            const childLevel = visibleLevel + levelOffset;\n            const childTileKey = TileKeyUtils.worldCoordinatesToTileKey(\n                tilingScheme,\n                worldPoint,\n                childLevel\n            );\n            if (childTileKey) {\n                tile = dataSourceVisibleTileList.renderedTiles.get(\n                    TileOffsetUtils.getKeyForTileKeyAndOffset(childTileKey, offset)\n                );\n\n                if (tile !== undefined) {\n                    return tile;\n                }\n            }\n        }\n        return undefined;\n    }\n\n    /**\n     * Removes all internal bookkeeping entries and cache related to specified datasource.\n     *\n     * Called by {@link MapView} when {@link DataSource} has been removed from {@link MapView}.\n     */\n    removeDataSource(dataSource: DataSource) {\n        this.clearTileCache(dataSource);\n        this.dataSourceTileList = this.dataSourceTileList.filter(\n            tileList => tileList.dataSource !== dataSource\n        );\n    }\n\n    /**\n     * Clear the tile cache.\n     *\n     * Remove the {@link Tile} objects created by cacheable {@link DataSource}.\n     * If a {@link DataSource} name is\n     * provided, this method restricts the eviction\n     * the {@link DataSource} with the given name.\n     *\n     * @param dataSourceName - The name of the {@link DataSource}.\n     */\n    clearTileCache(dataSource?: DataSource) {\n        if (dataSource !== undefined) {\n            this.m_dataSourceCache.evictSelected((tile: Tile, _) => {\n                return tile.dataSource === dataSource;\n            });\n        } else {\n            this.m_dataSourceCache.evictAll();\n        }\n    }\n\n    /**\n     * Visit each tile in visible, rendered, and cached sets.\n     *\n     *  * Visible and temporarily rendered tiles will be marked for update and retained.\n     *  * Cached but not rendered/visible will be evicted.\n     *\n     * @param dataSource - If passed, only the tiles from this {@link DataSource} instance\n     *      are processed. If `undefined`, tiles from all {@link DataSource}s are processed.\n     */\n    markTilesDirty(dataSource?: DataSource) {\n        if (dataSource === undefined) {\n            this.dataSourceTileList.forEach(renderListEntry => {\n                this.markDataSourceTilesDirty(renderListEntry);\n            });\n        } else {\n            const renderListEntry = this.dataSourceTileList.find(e => e.dataSource === dataSource);\n            if (renderListEntry === undefined) {\n                return;\n            }\n            this.markDataSourceTilesDirty(renderListEntry);\n        }\n    }\n\n    /**\n     * Dispose tiles that are marked for removal by {@link @here/harp-lrucache#LRUCache} algorithm.\n     */\n    disposePendingTiles() {\n        this.m_dataSourceCache.disposeTiles();\n    }\n\n    /**\n     * Process callback function [[fun]] with each visible tile in set.\n     *\n     * @param fun - The callback function to be called.\n     */\n    forEachVisibleTile(fun: (tile: Tile) => void): void {\n        for (const listEntry of this.dataSourceTileList) {\n            listEntry.renderedTiles.forEach(fun);\n        }\n    }\n\n    /**\n     * Process callback function [[fun]] with each tile in the cache.\n     *\n     * Optional [[dataSource]] parameter limits processing to the tiles that belongs to\n     * DataSource passed in.\n     *\n     * @param fun - The callback function to be called.\n     * @param dataSource - The optional DataSource reference for tiles selection.\n     */\n    forEachCachedTile(fun: (tile: Tile) => void, dataSource?: DataSource): void {\n        this.m_dataSourceCache.forEach((tile, _) => fun(tile), dataSource);\n    }\n\n    /**\n     * Dispose a `Tile` from cache, 'dispose()' is also called on the tile to free its resources.\n     */\n    disposeTile(tile: Tile): void {\n        // TODO: Consider using evict here!\n        this.m_dataSourceCache.delete(tile);\n        tile.dispose();\n    }\n\n    /**\n     * Skips rendering of tiles that are overlapped. The overlapping {@link Tile} comes from a\n     * {@link DataSource} which is fully covering, i.e. there it is fully opaque.\n     **/\n    private skipOverlappedTiles(dataSource: DataSource, tile: Tile) {\n        if (this.options.projection.type === ProjectionType.Spherical) {\n            // HARP-7899, currently the globe has no background planes in the tiles (it relies on\n            // the BackgroundDataSource), because the LOD mismatches, hence disabling for globe.\n            return;\n        }\n        if (dataSource.isFullyCovering()) {\n            const key = tile.uniqueKey;\n            const entry = this.m_coveringMap.get(key);\n            if (entry === undefined) {\n                // We need to reset the flag so that if the covering datasource is disabled, that\n                // the tiles beneath then start to render.\n                tile.skipRendering = false;\n                this.m_coveringMap.set(key, tile);\n            } else {\n                // Skip the Tile if either the stored entry or the tile to consider is from the\n                // [[BackgroundDataSource]]\n                if (entry.dataSource instanceof BackgroundDataSource) {\n                    entry.skipRendering = true;\n                } else if (dataSource instanceof BackgroundDataSource) {\n                    tile.skipRendering = true;\n                }\n            }\n        }\n    }\n\n    // Returns the search direction and the number of levels up / down that can be searched.\n    private getSearchDirection(\n        dataSource: DataSource,\n        visibleLevel: number\n    ): { searchDirection: SearchDirection; searchLevelsUp: number; searchLevelsDown: number } {\n        const searchLevelsUp = Math.min(\n            this.options.quadTreeSearchDistanceUp,\n            Math.max(0, visibleLevel - dataSource.minDataLevel)\n        );\n        const searchLevelsDown = Math.min(\n            this.options.quadTreeSearchDistanceDown,\n            Math.max(0, dataSource.maxDataLevel - visibleLevel)\n        );\n        const searchDirection =\n            searchLevelsDown > 0 && searchLevelsUp > 0\n                ? SearchDirection.BOTH\n                : searchLevelsDown > 0\n                ? SearchDirection.DOWN\n                : searchLevelsUp > 0\n                ? SearchDirection.UP\n                : SearchDirection.NONE;\n        return { searchDirection, searchLevelsUp, searchLevelsDown };\n    }\n\n    /**\n     * Populates the list of tiles to render, see \"renderedTiles\". Tiles that are loaded and which\n     * are an exact match are added straight to the list, tiles that are still loading are replaced\n     * with tiles in the cache that are either a parent or child of the requested tile. This helps\n     * to prevent flickering when zooming in / out. The distance to search is based on the options\n     * [[quadTreeSearchDistanceDown]] and [[quadTreeSearchDistanceUp]].\n     *\n     * Each {@link DataSource} can also switch this behaviour on / off using the\n     * [[allowOverlappingTiles]] flag.\n     *\n     */\n    private populateRenderedTiles() {\n        this.dataSourceTileList.forEach(renderListEntry => {\n            const renderedTiles = renderListEntry.renderedTiles;\n\n            // Tiles for which we need to fall(back/forward) to.\n            const incompleteTiles: number[] = [];\n\n            // Populate the list of tiles which can be shown (\"renderedTiles\"), and the list of\n            // tiles that are incomplete, and for which we search for an alternative\n            // (\"incompleteTiles\").\n            renderListEntry.visibleTiles.forEach(tile => {\n                tile.levelOffset = 0;\n                if (tile.hasGeometry) {\n                    renderedTiles.set(tile.uniqueKey, tile);\n                } else {\n                    // if dataSource supports cache and it was existing before this render\n                    // then enable searching for loaded tiles in cache\n                    incompleteTiles.push(tile.uniqueKey);\n                }\n            });\n\n            const dataSource = renderListEntry.dataSource;\n            if (incompleteTiles.length === 0 || dataSource.allowOverlappingTiles === false) {\n                // Either all tiles are loaded or the datasource doesn't support using cached tiles\n                // from other levels.\n                return;\n            }\n\n            const dataZoomLevel = renderListEntry.zoomLevel;\n            const { searchDirection } = this.getSearchDirection(dataSource, dataZoomLevel);\n\n            // Minor optimization for the fallback search, only check parent tiles once, otherwise\n            // the recursive algorithm checks all parent tiles multiple times, the key is the code\n            // of the tile that is checked and the value is whether a parent was found or not.\n            const checkedTiles = new Map<number, boolean>();\n            // Iterate over incomplete (not loaded tiles) and find their parents or children that\n            // are in cache that can be rendered temporarily until tile is loaded. Note, we favour\n            // falling back to parent tiles rather than children.\n            for (const tileKeyCode of incompleteTiles) {\n                if (\n                    searchDirection === SearchDirection.BOTH ||\n                    searchDirection === SearchDirection.UP\n                ) {\n                    if (\n                        this.findUp(\n                            tileKeyCode,\n                            dataZoomLevel,\n                            renderedTiles,\n                            checkedTiles,\n                            dataSource\n                        )\n                    ) {\n                        // Continue to next entry so we don't search down.\n                        continue;\n                    }\n                }\n\n                if (\n                    searchDirection === SearchDirection.BOTH ||\n                    searchDirection === SearchDirection.DOWN\n                ) {\n                    this.findDown(tileKeyCode, dataZoomLevel, renderedTiles, dataSource);\n                }\n            }\n        });\n    }\n\n    private findDown(\n        tileKeyCode: number,\n        dataZoomLevel: number,\n        renderedTiles: Map<number, Tile>,\n        dataSource: DataSource\n    ) {\n        const { offset, mortonCode } = TileOffsetUtils.extractOffsetAndMortonKeyFromKey(\n            tileKeyCode\n        );\n        const tileKey = TileKey.fromMortonCode(mortonCode);\n\n        const tilingScheme = dataSource.getTilingScheme();\n        for (const childTileKey of tilingScheme.getSubTileKeys(tileKey)) {\n            const childTileCode = TileOffsetUtils.getKeyForTileKeyAndOffset(childTileKey, offset);\n            const childTile = this.m_dataSourceCache.get(\n                childTileKey.mortonCode(),\n                offset,\n                dataSource\n            );\n\n            const nextLevelDiff = Math.abs(childTileKey.level - dataZoomLevel);\n            if (childTile !== undefined && childTile.hasGeometry) {\n                // childTile has geometry, so can be reused as fallback\n                renderedTiles.set(childTileCode, childTile);\n                childTile.levelOffset = nextLevelDiff;\n                continue;\n            }\n\n            // Recurse down until the max distance is reached.\n            if (nextLevelDiff < this.options.quadTreeSearchDistanceDown) {\n                this.findDown(childTileCode, dataZoomLevel, renderedTiles, dataSource);\n            }\n        }\n    }\n\n    /**\n     * Returns true if a tile was found in the cache which is a parent\n     * @param tileKeyCode - Morton code of the current tile that should be searched for.\n     * @param dataZoomLevel - The current data zoom level of tiles that are to be displayed.\n     * @param renderedTiles - The list of tiles that are shown to the user.\n     * @param checkedTiles - Used to map a given code to a boolean which tells us if an ancestor is\n     * displayed or not.\n     * @param dataSource - The provider of tiles.\n     * @returns Whether a parent tile exists.\n     */\n    private findUp(\n        tileKeyCode: number,\n        dataZoomLevel: number,\n        renderedTiles: Map<number, Tile>,\n        checkedTiles: Map<number, boolean>,\n        dataSource: DataSource\n    ): boolean {\n        const parentCode = TileOffsetUtils.getParentKeyFromKey(tileKeyCode);\n        // Check if another sibling has already added the parent.\n        if (renderedTiles.get(parentCode) !== undefined) {\n            return true;\n        }\n        const exists = checkedTiles.get(parentCode)!;\n        if (exists !== undefined) {\n            return exists;\n        }\n\n        const { offset, mortonCode } = TileOffsetUtils.extractOffsetAndMortonKeyFromKey(parentCode);\n        const parentTile = this.m_dataSourceCache.get(mortonCode, offset, dataSource);\n        const parentTileKey = parentTile ? parentTile.tileKey : TileKey.fromMortonCode(mortonCode);\n        const nextLevelDiff = Math.abs(dataZoomLevel - parentTileKey.level);\n        if (parentTile !== undefined && parentTile.hasGeometry) {\n            checkedTiles.set(parentCode, true);\n            // parentTile has geometry, so can be reused as fallback\n            renderedTiles.set(parentCode, parentTile);\n\n            // We want to have parent tiles as -ve, hence the minus.\n            parentTile.levelOffset = -nextLevelDiff;\n\n            return true;\n        } else {\n            checkedTiles.set(parentCode, false);\n        }\n\n        // Recurse up until the max distance is reached or we go to the parent of all parents.\n        if (nextLevelDiff < this.options.quadTreeSearchDistanceUp && parentTileKey.level !== 0) {\n            const foundUp = this.findUp(\n                parentCode,\n                dataZoomLevel,\n                renderedTiles,\n                checkedTiles,\n                dataSource\n            );\n            // If there was a tile upstream found, then add it to the list, so we can\n            // early skip checkedTiles.\n            checkedTiles.set(parentCode, foundUp);\n            if (foundUp) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private getTileImpl(\n        dataSource: DataSource,\n        tileKey: TileKey,\n        offset: number,\n        cacheOnly: boolean\n    ): Tile | undefined {\n        function updateTile(tileToUpdate?: Tile) {\n            if (tileToUpdate === undefined) {\n                return;\n            }\n            // Keep the tile from being removed from the cache.\n            tileToUpdate.frameNumLastRequested = dataSource.mapView.frameNumber;\n        }\n\n        if (!dataSource.cacheable && !cacheOnly) {\n            const resultTile = dataSource.getTile(tileKey);\n            updateTile(resultTile);\n            return resultTile;\n        }\n\n        const tileCache = this.m_dataSourceCache;\n        let tile = tileCache.get(tileKey.mortonCode(), offset, dataSource);\n\n        if (tile !== undefined && tile.offset === offset) {\n            updateTile(tile);\n            return tile;\n        }\n\n        if (cacheOnly) {\n            return undefined;\n        }\n\n        tile = dataSource.getTile(tileKey);\n        // TODO: Update all tile information including area, min/max elevation from TileKeyEntry\n        if (tile !== undefined) {\n            tile.offset = offset;\n            updateTile(tile);\n            tileCache.set(tileKey.mortonCode(), offset, dataSource, tile);\n            this.m_tileGeometryManager.initTile(tile);\n        }\n        return tile;\n    }\n\n    private markDataSourceTilesDirty(renderListEntry: DataSourceTileList) {\n        const dataSourceCache = this.m_dataSourceCache;\n        const retainedTiles: Set<TileCacheId> = new Set();\n\n        function markTileDirty(tile: Tile, tileGeometryManager: TileGeometryManager) {\n            const tileKey = DataSourceCache.getKeyForTile(tile);\n            if (!retainedTiles.has(tileKey)) {\n                retainedTiles.add(tileKey);\n                if (tile.tileGeometryLoader !== undefined) {\n                    tile.tileGeometryLoader.reset();\n                }\n\n                // Prevent label rendering issues when the style set is changing. Prevent Text\n                // element rendering that depends on cleaned font catalog data.\n                tile.clearTextElements();\n\n                tile.load();\n            }\n        }\n\n        renderListEntry.visibleTiles.forEach(tile => {\n            markTileDirty(tile, this.m_tileGeometryManager);\n        });\n        renderListEntry.renderedTiles.forEach(tile => {\n            markTileDirty(tile, this.m_tileGeometryManager);\n        });\n\n        dataSourceCache.forEach((tile, key) => {\n            if (!retainedTiles.has(key)) {\n                dataSourceCache.deleteByKey(key);\n                tile.dispose();\n            }\n        }, renderListEntry.dataSource);\n    }\n\n    // Computes the visible tile keys for each supplied data source.\n    private getVisibleTileKeysForDataSources(\n        zoomLevel: number,\n        dataSources: DataSource[],\n        elevationRangeSource: ElevationRangeSource | undefined\n    ): {\n        tileKeys: Array<{ dataSource: DataSource; visibleTileKeys: TileKeyEntry[] }>;\n        allBoundingBoxesFinal: boolean;\n    } {\n        const tileKeys = Array<{ dataSource: DataSource; visibleTileKeys: TileKeyEntry[] }>();\n        let allBoundingBoxesFinal: boolean = true;\n\n        if (dataSources.length === 0) {\n            return { tileKeys, allBoundingBoxesFinal };\n        }\n\n        const dataSourceBuckets = new Map<TilingScheme, DataSource[]>();\n        dataSources.forEach(dataSource => {\n            const tilingScheme = dataSource.getTilingScheme();\n            const bucket = dataSourceBuckets.get(tilingScheme);\n            if (bucket === undefined) {\n                dataSourceBuckets.set(tilingScheme, [dataSource]);\n            } else {\n                bucket.push(dataSource);\n            }\n        });\n\n        // If elevation is to be taken into account extend view frustum:\n        // (near ~0, far: maxVisibilityRange) that allows to consider tiles that\n        // are far below ground plane and high enough to intersect the frustum.\n        if (elevationRangeSource !== undefined) {\n            this.m_cameraOverride.copy(this.m_frustumIntersection.camera);\n            this.m_cameraOverride.near = Math.min(\n                this.m_cameraOverride.near,\n                this.m_viewRange.minimum\n            );\n            this.m_cameraOverride.far = Math.max(\n                this.m_cameraOverride.far,\n                this.m_viewRange.maximum\n            );\n            this.m_cameraOverride.updateProjectionMatrix();\n            this.m_frustumIntersection.updateFrustum(this.m_cameraOverride.projectionMatrix);\n        } else {\n            this.m_frustumIntersection.updateFrustum();\n        }\n\n        // For each bucket of data sources with same tiling scheme, calculate frustum intersection\n        // once using the maximum display level.\n        for (const [tilingScheme, bucket] of dataSourceBuckets) {\n            const zoomLevels = bucket.map(dataSource => dataSource.getDataZoomLevel(zoomLevel));\n            const result = this.m_frustumIntersection.compute(\n                tilingScheme,\n                elevationRangeSource,\n                zoomLevels,\n                bucket\n            );\n\n            allBoundingBoxesFinal = allBoundingBoxesFinal && result.calculationFinal;\n\n            for (const dataSource of bucket) {\n                // For each data source check what tiles from the intersection should be rendered\n                // at this zoom level.\n                const visibleTileKeys: TileKeyEntry[] = [];\n                const dataZoomLevel = dataSource.getDataZoomLevel(zoomLevel);\n                for (const tileKeyEntry of result.tileKeyEntries.get(dataZoomLevel)!.values()) {\n                    if (dataSource.canGetTile(dataZoomLevel, tileKeyEntry.tileKey)) {\n                        visibleTileKeys.push(tileKeyEntry);\n                    }\n                }\n                tileKeys.push({ dataSource, visibleTileKeys });\n            }\n        }\n\n        return { tileKeys, allBoundingBoxesFinal };\n    }\n}\n\nfunction viewRangesEqual(a: ViewRanges, b: ViewRanges) {\n    return (\n        a.far === b.far && a.maximum === b.maximum && a.minimum === b.minimum && a.near === b.near\n    );\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeoBox } from \"@here/harp-geoutils\";\nimport { getOptionValue, ILogger, LoggerManager } from \"@here/harp-utils\";\nimport { CopyrightInfo } from \"./CopyrightInfo\";\nimport { CopyrightProvider } from \"./CopyrightProvider\";\n\ndeclare const require: any;\n\n// tslint:disable-next-line:no-var-requires\nconst RBush = require(\"rbush\");\n\n/**\n * Schema of [Map Tile API copyright\n * endpoint](https://developer.here.com/documentation/map-tile/topics/resource-copyright.html) JSON\n * response.\n */\nexport interface AreaCopyrightInfo {\n    /**\n     * Minimum zoom level for the specified copyright label.\n     */\n    minLevel?: number;\n\n    /**\n     * Maximum zoom level for the specified copyright label.\n     */\n    maxLevel?: number;\n\n    /**\n     * Copyright text to display after the copyright symbol on the map.\n     */\n    label: string;\n\n    /**\n     * Verbose copyright text of the label to display by mouse over label or info menu entry.\n     */\n    alt?: string;\n\n    /**\n     * The bounding boxes define areas where specific copyrights are valid. A bounding box is\n     * defined by bottom (latitude), left (longitude) and top (latitude), right (longitude).\n     *\n     * The default copyright has no boxes element and covers all other areas.\n     */\n    boxes?: Array<[number, number, number, number]>;\n}\n\n/**\n * Schema of [Map Tile API copyright\n * endpoint](https://developer.here.com/documentation/map-tile/topics/resource-copyright.html) JSON\n * response.\n */\nexport interface CopyrightCoverageResponse {\n    [scheme: string]: AreaCopyrightInfo[];\n}\n\n/**\n * Base class to provide copyrights based on copyright coverage information, defined by geographical\n * bounding boxes and relevant zoom level ranges.\n */\nexport abstract class CopyrightCoverageProvider implements CopyrightProvider {\n    /** Logger instance. */\n    protected readonly logger: ILogger = LoggerManager.instance.create(\"CopyrightCoverageProvider\");\n\n    private m_cachedTreePromise: Promise<any> | undefined;\n\n    /** Asynchronously retrieves copyright coverage data. */\n    abstract async getCopyrightCoverageData(): Promise<AreaCopyrightInfo[]>;\n\n    /** @inheritdoc */\n    getTree(): Promise<any> {\n        if (this.m_cachedTreePromise !== undefined) {\n            return this.m_cachedTreePromise;\n        }\n\n        this.m_cachedTreePromise = this.getCopyrightCoverageData()\n            .then(coverageInfo => this.initRBush(coverageInfo))\n            .catch(error => {\n                this.logger.error(error);\n                return new RBush();\n            });\n\n        return this.m_cachedTreePromise;\n    }\n\n    /** @inheritdoc */\n    async getCopyrights(geoBox: GeoBox, level: number): Promise<CopyrightInfo[]> {\n        const tree = await this.getTree();\n\n        const result: CopyrightInfo[] = [];\n\n        const matchingEntries: AreaCopyrightInfo[] = tree.search({\n            minX: geoBox.west,\n            minY: geoBox.south,\n            maxX: geoBox.east,\n            maxY: geoBox.north\n        });\n\n        for (const entry of matchingEntries) {\n            const minLevel = getOptionValue(entry.minLevel, 0);\n            const maxLevel = getOptionValue(entry.maxLevel, Infinity);\n\n            if (level >= minLevel && level <= maxLevel) {\n                if (result.find(item => item.id === entry.label) === undefined) {\n                    result.push({ id: entry.label });\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Initializes RBush.\n     *\n     * @param entries - Entries for tree.\n     * @returns RBush instance.\n     */\n    initRBush(entries: AreaCopyrightInfo[]): any {\n        const tree = new RBush();\n\n        if (!entries) {\n            this.logger.warn(\"No copyright coverage data provided\");\n            return tree;\n        }\n\n        for (const entry of entries) {\n            const { minLevel, maxLevel, label, alt } = entry;\n\n            if (!entry.boxes) {\n                tree.insert({\n                    minX: -180,\n                    minY: -90,\n                    maxX: 180,\n                    maxY: 180,\n                    minLevel,\n                    maxLevel,\n                    label,\n                    alt\n                });\n            } else {\n                for (const box of entry.boxes) {\n                    const [minY, minX, maxY, maxX] = box;\n                    tree.insert({\n                        minX,\n                        minY,\n                        maxX,\n                        maxY,\n                        minLevel,\n                        maxLevel,\n                        label,\n                        alt\n                    });\n                }\n            }\n        }\n\n        return tree;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Provides a manager that orchestrates downloading URLs, particularly static map resources.\n *\n * @remarks\n *\n * @packageDocumentation\n */\n\nexport * from \"./src/TransferManager\";\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { GeometryType } from \"@here/harp-datasource-protocol\";\nimport { reconstructLineWidth } from \"@here/harp-lines\";\nimport { assert, LoggerManager } from \"@here/harp-utils\";\n\nconst logger = LoggerManager.instance.create(\"TileGeometry\");\n\n/**\n * Interface to access lines. Allows read access for some important attributes.\n */\nexport interface ILineAccessor {\n    /**\n     * Hint for the original type of geometry.\n     */\n    geometryType: GeometryType;\n\n    /**\n     * Get the color from materials.\n     */\n    color: THREE.Color | undefined | Array<THREE.Color | undefined>;\n\n    /**\n     * Get the width. May have to be reconstructed from triangulated line mesh.\n     */\n    width: number | undefined;\n\n    /**\n     * Render order.\n     */\n    renderOrder: number;\n\n    /**\n     * Helper for function `isLineAccessor`.\n     *\n     * @returns `true` if it is a line accessor.\n     */\n    isLineAccessor(): boolean;\n\n    /**\n     * Clear the object from the mesh.\n     */\n    clear(): void;\n\n    /**\n     * Get vertices from the object.\n     */\n    getVertices(): Float32Array | undefined;\n}\n\n/**\n * Helper function to check if an accessor is of type `ILineAccessor`.\n *\n * @param arg - `true` if `arg` is `ILineAccessor`.\n */\nexport function isLineAccessor(arg: any): arg is ILineAccessor {\n    /**\n     * Get vertices from the object.\n     *\n     * @param mode - Specifies which part of the vertices should be returned.\n     */\n\n    return typeof arg.isLineAccessor === \"function\" && arg.isLineAccessor() === true;\n}\n\n/**\n * Accessor for unspecified 3D objects, like landmarks.\n */\nexport interface IObject3dAccessor {\n    /**\n     * Hint for the original type of geometry.\n     */\n    geometryType: GeometryType;\n\n    /**\n     * Get the color from materials.\n     */\n    color: THREE.Color | undefined | Array<THREE.Color | undefined>;\n\n    /**\n     * Render order.\n     */\n    renderOrder: number;\n\n    /**\n     * Helper for function `isObject3dAccessor`.\n     *\n     * @returns `true` if it is a line accessor.\n     */\n    isObject3dAccessor(): boolean;\n\n    /**\n     * Clear the object from the mesh.\n     */\n    clear(): void;\n\n    getVertices(): Float32Array | undefined;\n}\n\n/**\n * Helper function to check if an accessor is of type `IObject3dAccessor`.\n *\n * @param arg - `true` if `arg` is `IObject3dAccessor`.\n */\nexport function isObject3dAccessor(arg: any): arg is IObject3dAccessor {\n    return typeof arg.isObject3dAccessor === \"function\" && arg.isObject3dAccessor() === true;\n}\n\n/**\n * Basic interface for geometry accessors.\n */\nexport interface IGeometryAccessor {\n    /**\n     * Get the number of primitives (vertices of triangles).\n     *\n     * @returns Number of primitives.\n     */\n    getCount(): number;\n\n    /**\n     * Set range of primitives in this object related to one or more buffers.\n     *\n     * @param start - Start index in buffers.\n     * @param end - End index in buffers (+1).\n     */\n    setRange(start: number, end: number): void;\n}\n\n/**\n * Geometry accessor for both indexed and nonindexed `BufferedGeometry`.\n */\nexport abstract class BufferedGeometryAccessorBase implements IGeometryAccessor {\n    protected start: number = -1;\n    protected end: number = -1;\n    protected startCapSize: number = 0;\n    protected endCapSize: number = 0;\n    protected position: THREE.BufferAttribute;\n    protected itemSize: number;\n\n    constructor(\n        readonly object: THREE.Mesh,\n        readonly geometryType: GeometryType,\n        protected readonly bufferGeometry: THREE.BufferGeometry\n    ) {\n        assert(!!object);\n\n        if (bufferGeometry.type !== \"BufferGeometry\") {\n            logger.error(\n                \"IndexedBufferedGeometryAccessor#constructor: BufferGeometry has wrong \" + \"type\"\n            );\n        }\n        assert(\n            bufferGeometry.type === \"BufferGeometry\",\n            \"IndexedBufferedGeometryAccessor#constructor: BufferGeometry has wrong type\"\n        );\n\n        // we know its a BufferAttribute because it is a BufferGeometry\n        this.position = this.bufferGeometry.getAttribute(\"position\") as THREE.BufferAttribute;\n        this.itemSize = this.position.itemSize;\n\n        if (!this.position) {\n            logger.warn(\n                \"BufferedGeometryAccessor#constructor: BufferGeometry has no position \" +\n                    \"attribute\"\n            );\n        }\n\n        if (this.position.array.constructor !== Float32Array) {\n            logger.warn(\n                \"BufferedGeometryAccessor#constructor: BufferGeometry.position: \" +\n                    \"unsupported ArrayBuffer\"\n            );\n        }\n    }\n\n    /**\n     * Get the number of accessible geometries in this buffer.\n     *\n     * @returns Number of primitives in this geometry.\n     */\n    getCount(): number {\n        return this.position.count;\n    }\n\n    /**\n     * Get `renderOrder` of object.\n     *\n     * @returns `renderOrder` of the object.\n     */\n    get renderOrder(): number {\n        return this.object.renderOrder;\n    }\n\n    setRange(start: number, end: number, startCapSize: number = 0, endCapSize: number = 0) {\n        assert(start >= 0);\n        assert(end >= 0);\n        assert(start <= end);\n        this.start = start;\n        this.end = end;\n        this.startCapSize = startCapSize;\n        this.endCapSize = endCapSize;\n    }\n\n    /**\n     * Get one or more colors from materials.\n     */\n    get color(): THREE.Color | undefined | Array<THREE.Color | undefined> {\n        /**\n         * TODO: Get color(s) from vertex colors\n         */\n        const getColor = (material: THREE.Material) => {\n            const meshMaterial = material as THREE.MeshBasicMaterial;\n            if (\n                meshMaterial.type === \"MeshBasicMaterial\" ||\n                meshMaterial.type === \"MeshStandardMaterial\"\n            ) {\n                return meshMaterial.color;\n            } else if (meshMaterial.type === \"RawShaderMaterial\") {\n                const rawShaderMaterial = material as THREE.RawShaderMaterial;\n\n                if (rawShaderMaterial.name === \"SolidLineMaterial\") {\n                    return rawShaderMaterial.uniforms.diffuse.value as THREE.Color;\n                }\n\n                logger.warn(\n                    \"BufferedGeometryAccessor#color: unknown shader material name\",\n                    rawShaderMaterial.name\n                );\n            } else {\n                logger.warn(\n                    \"BufferedGeometryAccessor#color: unknown material type\",\n                    meshMaterial.type\n                );\n            }\n\n            return undefined;\n        };\n\n        if (Array.isArray(this.object.material)) {\n            const results = new Array<THREE.Color | undefined>();\n            const materials = this.object.material as THREE.Material[];\n\n            for (const material of materials) {\n                results.push(getColor(material));\n            }\n\n            return results;\n        } else {\n            return getColor(this.object.material);\n        }\n    }\n}\n\n/**\n * Abstract base class of an accessor for nonindexed geometry.\n */\nexport abstract class BufferedGeometryAccessor extends BufferedGeometryAccessorBase {\n    /**\n     * Create an object of type `BufferedGeometryAccessor`\n     *\n     * @param object - mesh object\n     * @param geometryType - type of geometry to be used\n     * @param bufferGeometry - which buffer geometry to use\n     * @param stride - geometry stride length\n     */\n    constructor(\n        readonly object: THREE.Mesh,\n        readonly geometryType: GeometryType,\n        protected readonly bufferGeometry: THREE.BufferGeometry,\n        protected stride: number\n    ) {\n        super(object, geometryType, bufferGeometry);\n    }\n\n    clear(): void {\n        assert(this.checkSetUp(), \"BufferedGeometryAccessor not setup\");\n\n        const positionsArray = this.position.array as number[];\n\n        const start = this.start * this.itemSize;\n        const end = this.end * this.itemSize;\n\n        for (let i = start; i < end; i++) {\n            positionsArray[i] = 0;\n        }\n\n        this.position.needsUpdate = true;\n    }\n\n    getVertices(): Float32Array | undefined {\n        assert(this.checkSetUp(), \"BufferedGeometryAccessor not setup\");\n\n        const start = this.start;\n        const end = this.end;\n\n        return (this.position.array as Float32Array).subarray(\n            start * this.itemSize,\n            end * this.itemSize\n        );\n    }\n\n    protected checkSetUp(): boolean {\n        return (\n            this.position !== undefined &&\n            this.start !== undefined &&\n            this.end !== undefined &&\n            this.start >= 0 &&\n            this.end <= this.position.count &&\n            this.start <= this.end\n        );\n    }\n}\n\n/**\n * Accessor for nonindexed line geometry.\n */\nexport class BufferedGeometryLineAccessor extends BufferedGeometryAccessor\n    implements ILineAccessor {\n    constructor(\n        readonly object: THREE.Mesh,\n        readonly geometryType: GeometryType,\n        readonly bufferGeometry: THREE.BufferGeometry\n    ) {\n        super(object, geometryType, bufferGeometry, 3);\n    }\n\n    isLineAccessor(): boolean {\n        return true;\n    }\n\n    get width(): number | undefined {\n        //TODO: There is no implementation of such a line, yet...\n        assert(this.checkSetUp(), \"RoBufferedGeometryLineAccessor not setup\");\n        return undefined;\n    }\n}\n\n/**\n * Accessor for nonindexed unspecified (`Object3D`) geometry.\n */\nexport class BufferedGeometryObject3dAccessor extends BufferedGeometryAccessor\n    implements IObject3dAccessor {\n    constructor(\n        readonly object: THREE.Mesh,\n        readonly geometryType: GeometryType,\n        readonly bufferGeometry: THREE.BufferGeometry\n    ) {\n        super(object, geometryType, bufferGeometry, 1);\n    }\n\n    isObject3dAccessor(): boolean {\n        return true;\n    }\n\n    /** @override */\n    getVertices(): Float32Array | undefined {\n        return super.getVertices();\n    }\n}\n\n/**\n * Abstract base class of indexed geometry.\n */\nexport abstract class IndexedBufferedGeometryAccessor extends BufferedGeometryAccessorBase {\n    indices: number[];\n\n    /**\n     * Creates an abstract class `IndexedBufferedGeometryAccessor`.\n     *\n     * @param object - mesh to be used\n     * @param geometryType - type of geometry\n     * @param bufferGeometry - geometry used\n     * @param start -\n     * @param end -\n     */\n    constructor(\n        readonly object: THREE.Mesh,\n        readonly geometryType: GeometryType,\n        protected readonly bufferGeometry: THREE.BufferGeometry,\n        // tslint:disable-next-line:no-unused-variable\n        start?: number,\n        // tslint:disable-next-line:no-unused-variable\n        end?: number\n    ) {\n        super(object, geometryType, bufferGeometry);\n\n        this.indices =\n            this.bufferGeometry.index !== null\n                ? (this.bufferGeometry.index.array as number[])\n                : ((undefined as any) as number[]);\n\n        if (!this.indices) {\n            logger.warn(\n                \"IndexedBufferedGeometryAccessor#constructor: BufferGeometry has no \" + \"index\"\n            );\n            assert(!!this.indices);\n        } else {\n            if (!(this.indices instanceof Uint32Array)) {\n                logger.warn(\n                    \"IndexedBufferedGeometryAccessor#constructor: BufferGeometry index \" +\n                        \"has wrong type\"\n                );\n                assert(this.indices instanceof Uint32Array);\n            }\n        }\n    }\n\n    /**\n     * Returns number of primitives, which is not known in this base class, so we return the number\n     * of indices.\n     *\n     * @returns The number of indices in the geometry.\n     * @override\n     */\n    getCount(): number {\n        return this.indices.length;\n    }\n\n    protected checkSetUp(): boolean {\n        return (\n            !!this.indices &&\n            this.start !== undefined &&\n            this.end !== undefined &&\n            this.start >= 0 &&\n            this.end <= this.indices.length &&\n            this.start <= this.end\n        );\n    }\n}\n\n/**\n * Accessor for lines in an indexed geometry.\n */\nexport class IndexedBufferedGeometryLineAccessor extends IndexedBufferedGeometryAccessor\n    implements ILineAccessor {\n    constructor(\n        readonly object: THREE.Mesh,\n        readonly geometryType: GeometryType,\n        readonly bufferGeometry: THREE.BufferGeometry\n    ) {\n        super(object, geometryType, bufferGeometry, 3);\n    }\n\n    isLineAccessor(): boolean {\n        return true;\n    }\n\n    /**\n     * Reconstructs line width from triangulated geometry.\n     *\n     * @returns Line width.\n     */\n    get width(): number | undefined {\n        assert(this.checkSetUp(), \"RoIndexedBufferedGeometryLineAccessor not setup\");\n\n        if (this.geometryType === GeometryType.ExtrudedLine) {\n            const start = this.start + this.startCapSize;\n            const positionArray = this.position.array as Float32Array;\n            return reconstructLineWidth(positionArray, start);\n        }\n\n        return undefined;\n    }\n\n    clear(): void {\n        assert(this.checkSetUp(), \"RoIndexedBufferedGeometryLineAccessor not setup\");\n\n        const start = this.start;\n        const end = this.end;\n\n        for (let i = start; i < end; i++) {\n            this.indices[i] = 0;\n        }\n\n        if (this.bufferGeometry.index !== null) {\n            this.bufferGeometry.index.needsUpdate = true;\n        }\n    }\n\n    getVertices(): Float32Array | undefined {\n        assert(this.checkSetUp(), \"RoIndexedBufferedGeometryLineAccessor not setup\");\n\n        const itemSize = this.itemSize;\n\n        const start = this.start;\n        const end = this.end;\n\n        const result = new Float32Array((end - start) * itemSize);\n        const positionArray = this.position.array;\n\n        if (itemSize === 2) {\n            for (let i = start, j = 0; i < end; i++, j += itemSize) {\n                const index = this.indices[i];\n                result[j + 0] = positionArray[index * itemSize + 0];\n                result[j + 1] = positionArray[index * itemSize + 1];\n            }\n        }\n        if (itemSize === 3) {\n            for (let i = start, j = 0; i < end; i++, j += itemSize) {\n                const index = this.indices[i];\n                result[j + 0] = positionArray[index * itemSize + 0];\n                result[j + 1] = positionArray[index * itemSize + 1];\n                result[j + 2] = positionArray[index * itemSize + 2];\n            }\n        } else {\n            for (let i = start, j = 0; i < end; i++, j++) {\n                const index = this.indices[i];\n                for (let k = 0; k < itemSize; k++) {\n                    result[j * itemSize + k] = positionArray[index * itemSize + k];\n                }\n            }\n        }\n\n        return result;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nconst UNIT_Z = new THREE.Vector3(0, 0, 1);\nconst POINTS = [0, 1, 2, 1, 3, 2];\nconst BEVEL_POINTS = [0, 1, 3, 3, 1, 2, 0, 3, 4, 5, 4, 3];\n\nconst SECTORS_IN_CIRCLE = 8;\nconst STEP = Math.PI / SECTORS_IN_CIRCLE;\n\n/**\n * Adds a half-circle geometry to original line\n *\n * @param x - The line end X (used as circle center X)\n * @param y - The line end Y (used as circle center Y)\n * @param lineAngle - The cap incline angle\n * @param radius - The cap (circle) radius\n * @param vertices - The input vertex buffer (cap vertices are added there)\n * @param indices - The input index buffer (cap indices are is added there)\n */\nfunction addCircle(\n    x: number,\n    y: number,\n    lineAngle: number,\n    radius: number,\n    vertices: number[],\n    indices: number[]\n) {\n    const baseVertex = vertices.length / 3;\n\n    // Add cap center to vertices directly (it doesn't need rotation)\n    vertices.push(x, y, 0);\n\n    for (let i = 0; i < SECTORS_IN_CIRCLE + 1; ++i) {\n        const angle = STEP * i + Math.PI / 2 + lineAngle; // Start angle is -90deg\n        vertices.push(x + radius * Math.cos(angle), y + radius * Math.sin(angle), 0);\n\n        indices.push(\n            baseVertex,\n            baseVertex + i + 1,\n            baseVertex + ((i + 1) % (SECTORS_IN_CIRCLE + 1)) + 1\n        );\n    }\n}\n\n/**\n * Returns the number of points in circle used for caps.\n *\n * @param lineWidth - Width of line.\n */\n// tslint:disable-next-line:no-unused-variable\nexport function numCirclePoints(lineWidth: number): number {\n    return SECTORS_IN_CIRCLE + 1;\n}\n\n/**\n * Create a triangle mesh from the given polyline.\n *\n * @param points - Sequence of (x,y,z) coordinates.\n * @param width - The width of the extruded line.\n * @param vertices - The output vertex buffer.\n * @param indices - The output index buffer.\n * @param startWithCircle - `true` if the line should start will a circle.\n * @param endWithCircle - `true` if the line should end with a circle.\n */\nexport function triangulateLine(\n    points: ArrayLike<number>,\n    width: number,\n    vertices: number[],\n    indices: number[],\n    startWithCircle = true,\n    endWithCircle = startWithCircle\n) {\n    if (points.length < 3) {\n        return;\n    }\n\n    // This vector is used for computing cap angle\n    const angleVec = new THREE.Vector2();\n\n    if (startWithCircle) {\n        // Define lineAngle as (direction - origin) vector angle to X axis\n        const lineAngle =\n            points.length !== 3\n                ? angleVec.set(points[3] - points[0], points[4] - points[1]).angle()\n                : 0;\n\n        addCircle(points[0], points[1], lineAngle, width, vertices, indices);\n    }\n\n    const baseVertex = vertices.length / 3;\n\n    // bt = Bitangent (i.e. extrusion vector)\n    const prevBt = new THREE.Vector3();\n    const p = new THREE.Vector3(); // current point\n    const n = new THREE.Vector3(); // next point\n    const bt = new THREE.Vector3();\n    const averageBt = new THREE.Vector3();\n    const p0 = new THREE.Vector3();\n    const p1 = new THREE.Vector3();\n    const p2 = new THREE.Vector3();\n    const p3 = new THREE.Vector3();\n\n    const N = points.length / 3;\n\n    let vertexOffset = 0;\n    for (let i = 0; i < N; ++i) {\n        let useBevel = false;\n        p.set(points[i * 3], points[i * 3 + 1], points[i * 3 + 2]);\n\n        if (i + 1 < N) {\n            n.set(points[(i + 1) * 3], points[(i + 1) * 3 + 1], points[(i + 1) * 3 + 2]);\n\n            bt.copy(n)\n                .sub(p)\n                .normalize()\n                .cross(UNIT_Z);\n\n            averageBt.copy(bt);\n\n            if (i > 0) {\n                averageBt.add(prevBt).multiplyScalar(1.0 - 0.5 * bt.dot(prevBt));\n\n                useBevel = prevBt.angleTo(bt) > Math.PI / 2;\n\n                if (useBevel) {\n                    const inclineWidth = width / Math.cos(bt.angleTo(prevBt) / 2);\n\n                    p0.copy(bt)\n                        .add(prevBt)\n                        .normalize()\n                        .multiplyScalar(-inclineWidth)\n                        .add(p);\n\n                    p1.copy(prevBt)\n                        .multiplyScalar(width)\n                        .add(p);\n\n                    // p2 is used for \"miter\" connections\n                    p2.copy(bt)\n                        .add(prevBt)\n                        .normalize()\n                        .multiplyScalar(inclineWidth)\n                        .add(p);\n\n                    p3.copy(bt)\n                        .multiplyScalar(width)\n                        .add(p);\n                }\n            }\n\n            if (useBevel) {\n                vertices.push(\n                    p0.x,\n                    p0.y,\n                    p0.z,\n                    p1.x,\n                    p1.y,\n                    p1.z,\n                    p2.x,\n                    p2.y,\n                    p2.z,\n                    p3.x,\n                    p3.y,\n                    p3.z\n                );\n            } else {\n                p0.copy(averageBt)\n                    .multiplyScalar(-width)\n                    .add(p);\n\n                p1.copy(averageBt)\n                    .multiplyScalar(width)\n                    .add(p);\n\n                vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z);\n            }\n\n            prevBt.copy(bt);\n        } else {\n            p0.copy(prevBt)\n                .multiplyScalar(-width)\n                .add(p);\n\n            p1.copy(prevBt)\n                .multiplyScalar(width)\n                .add(p);\n\n            vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z);\n        }\n\n        if (i !== N - 1) {\n            (useBevel ? BEVEL_POINTS : POINTS).forEach(o =>\n                indices.push(baseVertex + vertexOffset + o)\n            );\n            vertexOffset += useBevel ? 4 : 2;\n        }\n    }\n\n    if (endWithCircle) {\n        const lineAngle =\n            points.length !== 2\n                ? angleVec\n                      .set(\n                          points[(N - 3) * 3] - points[(N - 2) * 3],\n                          points[(N - 3) * 3 + 1] - points[(N - 2) * 3 + 1]\n                      )\n                      .angle()\n                : Math.PI;\n\n        addCircle(\n            points[(N - 2) * 3],\n            points[(N - 2) * 3 + 1],\n            lineAngle,\n            width,\n            vertices,\n            indices\n        );\n    }\n}\n\n/**\n * Reconstruct the original points of a line from the vertices of the triangulated line.\n *\n * @param inBuffer - Buffer with vertices.\n * @param startOffset - Start index, will differ from `0` if the line has caps.\n * @returns Buffer containing the original points of the triangulated line.\n */\nexport function reconstructLine(inBuffer: Float32Array, startOffset: number): Float32Array {\n    const outBuffer = new Float32Array(inBuffer.length / 2);\n\n    for (let i = startOffset * 3, i2 = i * 2; i < outBuffer.length; i += 3, i2 += 6) {\n        outBuffer[i] = inBuffer[i2] + (inBuffer[i2 + 3] - inBuffer[i2]) * 0.5;\n        outBuffer[i + 1] = inBuffer[i2 + 1] + (inBuffer[i2 + 3 + 1] - inBuffer[i2 + 1]) * 0.5;\n        outBuffer[i + 2] = inBuffer[i2 + 2] + (inBuffer[i2 + 3 + 2] - inBuffer[i2 + 2]) * 0.5;\n    }\n    return outBuffer;\n}\n\n/**\n * Extract the line width from a triangulated line.\n *\n * @param inBuffer - Array of vertex elements of a triangulated line.\n * @param startIndex - Start index, will differ from `0` if the line has caps.\n */\nexport function reconstructLineWidth(inBuffer: Float32Array, startIndex: number): number {\n    const xd = inBuffer[startIndex * 2 + 3] - inBuffer[startIndex * 2];\n    const yd = inBuffer[startIndex * 2 + 3 + 1] - inBuffer[startIndex * 2 + 1];\n    const zd = inBuffer[startIndex * 2 + 3 + 2] - inBuffer[startIndex * 2 + 2];\n\n    return Math.sqrt(xd * xd + yd * yd + zd * zd) * 0.5;\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { HighPrecisionLineMaterial } from \"@here/harp-materials\";\n\nimport * as THREE from \"three\";\nimport { HighPrecisionUtils } from \"./HighPrecisionUtils\";\n\n/**\n * Declare interface for `HighPrecisionObject` which describes additional functionality to render\n * high-precision vertices.\n */\nexport interface HighPrecisionObject extends THREE.Object3D {\n    /**\n     * Allow direct access to [[BufferGeometry]] without cast.\n     */\n    bufferGeometry: THREE.BufferGeometry;\n\n    /**\n     * Allow direct access to [[ShaderMaterial]] without cast.\n     */\n    shaderMaterial: THREE.ShaderMaterial;\n\n    /**\n     * Inversed World Matrix.\n     */\n    matrixWorldInverse: THREE.Matrix4;\n\n    /**\n     * Sets up attributes for position (one attribute for major 32 bits position \"halve\", and one\n     * attribute for lower 32 bits).\n     */\n    setPositions(positions: number[] | THREE.Vector3[]): void;\n\n    /**\n     * Prepare the objects \"`onBeforeRender()`\" callback to generate proper high-precision camera\n     * position.\n     */\n    setupForRendering(): void;\n}\n\n/**\n * Class used to render high-precision wireframe lines.\n */\nexport class HighPrecisionWireFrameLine extends THREE.Line implements HighPrecisionObject {\n    matrixWorldInverse: THREE.Matrix4;\n\n    /**\n     * Creates a `HighPrecisionWireFrameLine` object.\n     *\n     * @param geometry - [[BufferGeometry]] used to render this object.\n     * @param material - [[HighPrecisionLineMaterial]] used to render this object.\n     *     instances.\n     * @param positions - Array of 2D/3D positions.\n     * @param color - Color of the rendered line.\n     * @param opacity - Opacity of the rendered line.\n     */\n    constructor(\n        geometry?: THREE.BufferGeometry,\n        material?: HighPrecisionLineMaterial,\n        positions?: number[] | THREE.Vector3[],\n        color?: THREE.Color,\n        opacity?: number\n    ) {\n        super(geometry === undefined ? new THREE.BufferGeometry() : geometry, material);\n\n        if (material === undefined) {\n            material = new HighPrecisionLineMaterial({\n                color: color ? color : HighPrecisionLineMaterial.DEFAULT_COLOR,\n                opacity: opacity !== undefined ? opacity : HighPrecisionLineMaterial.DEFAULT_OPACITY\n            });\n        }\n\n        this.matrixWorldInverse = new THREE.Matrix4();\n\n        if (positions) {\n            this.setPositions(positions);\n        }\n    }\n\n    get bufferGeometry(): THREE.BufferGeometry {\n        return this.geometry as THREE.BufferGeometry;\n    }\n\n    get shaderMaterial(): THREE.ShaderMaterial {\n        return this.material as THREE.ShaderMaterial;\n    }\n\n    setPositions(positions: number[] | THREE.Vector3[]): void {\n        HighPrecisionUtils.setPositions(this, positions);\n    }\n\n    setupForRendering(): void {\n        this.onBeforeRender = (\n            _renderer: THREE.WebGLRenderer,\n            _scene: THREE.Scene,\n            camera: THREE.Camera,\n            _geometry: THREE.Geometry | THREE.BufferGeometry,\n            _material: THREE.Material,\n            _group: THREE.Group\n        ) => {\n            HighPrecisionUtils.updateHpUniforms(this, camera, this.shaderMaterial);\n        };\n    }\n\n    updateMatrixWorld(force: boolean) {\n        const doUpdateMatrixWorldInverse = this.matrixWorldNeedsUpdate || force;\n\n        super.updateMatrixWorld(force);\n\n        if (doUpdateMatrixWorldInverse) {\n            this.matrixWorldInverse.getInverse(this.matrixWorld);\n        }\n    }\n}\n\n/**\n * Class used to render high-precision lines.\n */\nexport class HighPrecisionLine extends THREE.Mesh implements HighPrecisionObject {\n    matrixWorldInverse: THREE.Matrix4;\n\n    /**\n     * Creates a `HighPrecisionLine` object.\n     *\n     * @param geometry - [[BufferGeometry]] used to render this object.\n     * @param material - [[HighPrecisionLineMaterial]] used to render this object.\n     *     instances.\n     * @param positions - Array of 2D/3D positions.\n     * @param color - Color of the rendered line.\n     * @param opacity - Opacity of the rendered line.\n     */\n    constructor(\n        geometry?: THREE.BufferGeometry,\n        material?: HighPrecisionLineMaterial,\n        positions?: number[] | THREE.Vector3[],\n        color?: THREE.Color,\n        opacity?: number\n    ) {\n        super(geometry === undefined ? new THREE.BufferGeometry() : geometry, material);\n\n        if (material === undefined) {\n            material = new HighPrecisionLineMaterial({\n                color: color ? color : HighPrecisionLineMaterial.DEFAULT_COLOR,\n                opacity: opacity !== undefined ? opacity : HighPrecisionLineMaterial.DEFAULT_OPACITY\n            });\n        }\n\n        this.matrixWorldInverse = new THREE.Matrix4();\n\n        if (positions) {\n            this.setPositions(positions);\n        }\n    }\n\n    get bufferGeometry(): THREE.BufferGeometry {\n        return this.geometry as THREE.BufferGeometry;\n    }\n\n    get shaderMaterial(): THREE.ShaderMaterial {\n        return this.material as THREE.ShaderMaterial;\n    }\n\n    setPositions(positions: number[] | THREE.Vector3[]): void {\n        HighPrecisionUtils.setPositions(this, positions);\n    }\n\n    setupForRendering(): void {\n        this.onBeforeRender = (\n            _renderer: THREE.WebGLRenderer,\n            _scene: THREE.Scene,\n            camera: THREE.Camera,\n            _geometry: THREE.Geometry | THREE.BufferGeometry,\n            _material: THREE.Material,\n            _group: THREE.Group\n        ) => {\n            HighPrecisionUtils.updateHpUniforms(this, camera, this.shaderMaterial);\n        };\n    }\n\n    updateMatrixWorld(force: boolean) {\n        const doUpdateMatrixWorldInverse = this.matrixWorldNeedsUpdate || force;\n\n        super.updateMatrixWorld(force);\n\n        if (doUpdateMatrixWorldInverse) {\n            this.matrixWorldInverse.getInverse(this.matrixWorld);\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport \"@here/harp-fetch\";\n\nimport {\n    DecodedTile,\n    ITileDecoder,\n    RequestController,\n    TileInfo\n} from \"@here/harp-datasource-protocol\";\nimport { TileKey } from \"@here/harp-geoutils\";\nimport { DataSource, TileLoaderState } from \"@here/harp-mapview\";\nimport { LoggerManager } from \"@here/harp-utils\";\n\nimport { DataProvider } from \"./DataProvider\";\n\n/**\n * Logger to write to console etc.\n */\nconst logger = LoggerManager.instance.create(\"TileLoader\");\n\n/**\n * The [[TileLoader]] manages the different states of loading and decoding for a [[Tile]]. Used by\n * the [[TileDataSource]].\n */\nexport class TileLoader {\n    /**\n     * Current state of `TileLoader`.\n     */\n    state: TileLoaderState = TileLoaderState.Initialized;\n\n    /**\n     * Error object if loading or decoding failed.\n     */\n    error?: Error;\n\n    /**\n     * The binary data in form of [[ArrayBufferLike]], or any object.\n     */\n    payload?: ArrayBufferLike | {};\n\n    /**\n     * The result of decoding the `payload`: The [[DecodedTile]].\n     */\n    decodedTile?: DecodedTile;\n\n    /**\n     * The abort controller notifying the [[DataProvider]] to cancel loading.\n     */\n    protected loadAbortController = new AbortController();\n\n    /**\n     * The  notifying the [[ITileDecoder]] to cancel decoding.\n     */\n    protected requestController?: RequestController;\n\n    /**\n     * The promise which is resolved when loading and decoding have finished.\n     */\n    protected donePromise?: Promise<TileLoaderState>;\n\n    /**\n     * The internal function that is called when loading and decoding have finished successfully.\n     */\n    protected resolveDonePromise?: (state: TileLoaderState) => void;\n\n    /**\n     * The internal function that is called when loading and decoding failed.\n     */\n    protected rejectedDonePromise?: (state: TileLoaderState) => void;\n\n    /**\n     * Set up loading of a single [[Tile]].\n     *\n     * @param dataSource - The [[DataSource]] the tile belongs to.\n     * @param tileKey - The quadtree address of a [[Tile]].\n     * @param dataProvider - The [[DataProvider]] that retrieves the binary tile data.\n     * @param tileDecoder - The [[ITileDecoder]] that decodes the binary tile to a [[DecodeTile]].\n     * @param priority - The priority given to the loading job. Highest number will be served first.\n     */\n    constructor(\n        protected dataSource: DataSource,\n        protected tileKey: TileKey,\n        protected dataProvider: DataProvider,\n        protected tileDecoder: ITileDecoder,\n        public priority: number\n    ) {}\n\n    /**\n     * Start loading and/or proceed through the various states of loading of this tile.\n     *\n     * @returns A promise which resolves the [[TileLoaderState]].\n     */\n    loadAndDecode(): Promise<TileLoaderState> {\n        switch (this.state) {\n            case TileLoaderState.Loading:\n            case TileLoaderState.Loaded:\n            case TileLoaderState.Decoding:\n                // tile is already loading\n                return this.donePromise!;\n\n            case TileLoaderState.Ready:\n            case TileLoaderState.Failed:\n            case TileLoaderState.Initialized:\n            case TileLoaderState.Canceled:\n                // restart loading\n                this.startLoading();\n                return this.donePromise!;\n        }\n    }\n\n    /**\n     * Return the current state in form of a promise. Caller can then wait for the promise to be\n     * resolved.\n     *\n     * @returns A promise which resolves the current [[TileLoaderState]].\n     */\n    waitSettled(): Promise<TileLoaderState> {\n        if (!this.donePromise) {\n            return Promise.resolve(this.state);\n        }\n        return this.donePromise;\n    }\n\n    /**\n     * Cancel loading of the [[Tile]].\n     * Cancellation token is notified, an internal state is cleaned up.\n     */\n    cancel() {\n        switch (this.state) {\n            case TileLoaderState.Loading:\n                this.loadAbortController.abort();\n                this.loadAbortController = new AbortController();\n                break;\n\n            case TileLoaderState.Decoding:\n                if (this.requestController) {\n                    this.requestController.abort();\n                    this.requestController = undefined;\n                }\n                break;\n        }\n\n        this.onDone(TileLoaderState.Canceled);\n    }\n\n    /**\n     * Return `true` if [[Tile]] is still loading, `false` otherwise.\n     */\n    get isFinished(): boolean {\n        return (\n            this.state === TileLoaderState.Ready ||\n            this.state === TileLoaderState.Canceled ||\n            this.state === TileLoaderState.Failed\n        );\n    }\n\n    /**\n     * Update the priority of this [[Tile]]'s priority. Is effective to sort the decoding requests\n     * in the request queue (used during heavy load).\n     */\n    updatePriority(priority: number): void {\n        this.priority = priority;\n        if (this.requestController !== undefined) {\n            this.requestController.priority = priority;\n        }\n    }\n\n    /**\n     * Start loading. Only call if loading did not start yet.\n     */\n    protected startLoading() {\n        const myLoadCancellationToken = this.loadAbortController.signal;\n        this.dataProvider\n            .getTile(this.tileKey, myLoadCancellationToken)\n            .then(payload => {\n                if (myLoadCancellationToken.aborted) {\n                    // safety belt if getTile doesn't really support cancellation tokens\n                    const err = new Error(\"Aborted\");\n                    err.name = \"AbortError\";\n                    throw err;\n                }\n                this.onLoaded(payload);\n            })\n            .catch(error => {\n                // Handle abort messages from fetch and also our own.\n                if (error.name === \"AbortError\" || error.message === \"AbortError: Aborted\") {\n                    return;\n                }\n                this.onError(error);\n            });\n\n        if (this.donePromise === undefined) {\n            this.donePromise = new Promise<TileLoaderState>((resolve, reject) => {\n                this.resolveDonePromise = resolve;\n                this.rejectedDonePromise = reject;\n            });\n        }\n        this.state = TileLoaderState.Loading;\n    }\n\n    /**\n     * Called when binary data has been loaded. The loading state is now progressing to decoding.\n     *\n     * @param payload - Binary data in form of [[ArrayBufferLike]], or any object.\n     */\n    protected onLoaded(payload: ArrayBufferLike | {}) {\n        this.state = TileLoaderState.Loaded;\n        this.payload = payload;\n\n        const byteLength = (payload as ArrayBufferLike).byteLength;\n        if (\n            byteLength === 0 ||\n            (payload.constructor === Object && Object.keys(payload).length === 0)\n        ) {\n            // Object is empty\n            this.onDone(TileLoaderState.Ready);\n            return;\n        }\n\n        // TBD: we might suspend decode if tile is not visible ... ?\n        this.startDecodeTile();\n    }\n\n    /**\n     * Start decoding the payload.\n     */\n    protected startDecodeTile() {\n        const payload = this.payload;\n        if (payload === undefined) {\n            logger.error(\"TileLoader#startDecodeTile: Cannot decode without payload\");\n            return;\n        }\n\n        this.state = TileLoaderState.Decoding;\n        this.payload = undefined;\n\n        // Save our cancellation point, so we can be reliably cancelled by any subsequent decode\n        // attempts\n        const requestController = new RequestController(this.priority);\n        this.requestController = requestController;\n\n        const dataSource = this.dataSource;\n        this.tileDecoder\n            .decodeTile(payload, this.tileKey, dataSource.projection, requestController)\n            .then(decodedTile => {\n                if (requestController.signal.aborted) {\n                    // our flow is cancelled, silently return\n                    return;\n                }\n\n                this.onDecoded(decodedTile);\n            })\n            .catch(error => {\n                // Handle abort messages from fetch and also our own.\n                if (error.name === \"AbortError\" || error.message === \"AbortError: Aborted\") {\n                    // our flow is cancelled, silently return\n                    return;\n                }\n                this.onError(error);\n            });\n    }\n\n    /**\n     * Called when the decoding is finished, and the [[DecodedTile]] has been created.\n     *\n     * @param decodedTile - The [[DecodedTile]].\n     */\n    protected onDecoded(decodedTile: DecodedTile) {\n        this.decodedTile = decodedTile;\n        this.onDone(TileLoaderState.Ready);\n    }\n\n    /**\n     * Cancel the decoding process.\n     */\n    protected cancelDecoding() {\n        if (this.requestController !== undefined) {\n            // we should cancel any decodes already in progress!\n            this.requestController.abort();\n            this.requestController = undefined;\n        }\n    }\n\n    /**\n     * Called when loading and decoding has finished successfully. Resolves loading promise if the\n     * state is Ready, otherwise it rejects the promise with the supplied state.\n     *\n     * @param doneState - The latest state of loading.\n     */\n    protected onDone(doneState: TileLoaderState) {\n        if (this.resolveDonePromise && doneState === TileLoaderState.Ready) {\n            this.resolveDonePromise(doneState);\n        } else if (this.rejectedDonePromise) {\n            this.rejectedDonePromise(doneState);\n        }\n        this.resolveDonePromise = undefined;\n        this.rejectedDonePromise = undefined;\n        this.donePromise = undefined;\n        this.state = doneState;\n    }\n\n    /**\n     * Called when loading or decoding has finished with an error.\n     *\n     * @param error - Error object describing the failing.\n     */\n    protected onError(error: Error) {\n        if (this.state === TileLoaderState.Canceled) {\n            // If we're canceled, we should simply ignore any state transitions and errors from\n            // underlying load/decode ops.\n            return;\n        }\n        const dataSource = this.dataSource;\n        logger.error(\n            `[${dataSource.name}]: failed to load tile ${this.tileKey.mortonCode()}`,\n            error\n        );\n\n        this.error = error;\n\n        this.onDone(TileLoaderState.Failed);\n    }\n}\n\n/**\n * Subclass of [[TileLoader]] which is used by [[TileDataSource]] to load the [[TileInfo]] meta\n * data, not the tile data itself.\n */\nexport class TileInfoLoader extends TileLoader {\n    tileInfo?: TileInfo;\n\n    /** @override */\n    protected startDecodeTile() {\n        const payload = this.payload;\n        if (payload === undefined) {\n            logger.error(\"TileInfoLoader#startDecodeTile: Cannot decode without payload\");\n            return;\n        }\n\n        this.state = TileLoaderState.Decoding;\n        this.payload = undefined;\n\n        // Save our cancellation point, so we can be reliably cancelled by any subsequent decode\n        // attempts\n        const requestController = new RequestController(this.priority);\n        this.requestController = requestController;\n\n        const dataSource = this.dataSource;\n        this.tileDecoder\n            .getTileInfo(payload, this.tileKey, dataSource.projection, requestController)\n            .then(tileInfo => {\n                if (requestController.signal.aborted) {\n                    // our flow is cancelled, silently return\n                    return;\n                }\n                this.tileInfo = tileInfo;\n\n                this.onDone(TileLoaderState.Ready);\n            })\n            .catch(error => {\n                // Handle abort messages from fetch and also our own.\n                if (error.name === \"AbortError\" || error.message === \"AbortError: Aborted\") {\n                    // our flow is cancelled, silently return\n                    return;\n                }\n                this.onError(error);\n            });\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport \"@here/harp-fetch\";\nimport { TileKey, TilingScheme } from \"@here/harp-geoutils\";\nimport { DataProvider } from \"@here/harp-mapview-decoder\";\nimport { ITransferManager, TransferManager } from \"@here/harp-transfer-manager\";\nimport { LoggerManager } from \"@here/harp-utils\";\n\nconst logger = LoggerManager.instance.create(\"OmvRestClient\");\n\n// tslint:disable:max-line-length\nexport enum APIFormat {\n    /**\n     * Use the REST API format of HERE Vector Tiles Server component version 1.\n     *\n     * Documentation:\n     *  https://developer.here.com/documentation/vector-tiles-api/dev_guide/index.html\n     *\n     * Usage:\n     *\n     *     <OmvRestClientParams.baseUrl>/<zoom>/<X>/<Y>/omv\n     *\n     * If [[OmvRestClientParams.authenticationToken]] is provided, it will be added as HTTP header:\n     *\n     *     Authorization: Bearer $authenticationToken\n     *\n     * Format definition:\n     * `//http|s://<base-url>/{API version}/{layers}/{projection}/{z}/{x}/{y}/{format}`\n     *\n     * Default authentication method used: [[AuthenticationTypeBearer]].\n     */\n    HereV1,\n\n    /**\n     * Use the REST API format of Mapbox Vector Tile API v4.\n     *\n     * Usage:\n     * `<OmvRestClientParams.baseUrl>/<zoom>/<X>/<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`\n     *\n     * Format definition:\n     * `http|s://<base-url>/v4/{map_id}/{z}/{x}/{y}{@2x}.{format}?[style]&access_token={access_token}`\n     *\n     * Sample URL:\n     * `http://a.tiles.mapbox.com/v4/mapbox.mapbox-streets-v7/14/4823/6160.mvt?access_token=your-mapbox-access-token`\n     *\n     * Default authentication method used: [[AuthenticationTypeAccessToken]].\n     */\n    MapboxV4,\n\n    /**\n     * Use the REST API format of XYZ Vector Tile API in MVT format.\n     *\n     * Usage:\n     * `<OmvRestClientParams.baseUrl>/tiles/omsbase/256/<zoom>/<X>/<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`\n     *\n     * Format definition:\n     * `http|s://<base-url>/tiles/{layers}/{z}/{x}/{y}/{format}?access_token={access_token}`\n     *\n     * Sample URL:\n     * `https://xyz.api.here.com/tiles/osmbase/256/all/16/19293/24641.mvt?access_token=your-xyz-access-token`\n     *\n     * Default authentication method used: [[AuthenticationTypeAccessToken]].\n     */\n    XYZMVT,\n\n    /**\n     * Use the REST API format of XYZ Vector Tile API in JSON format.\n     *\n     * Usage:\n     * `<OmvRestClientParams.baseUrl>/tiles/omsbase/256/<zoom>/<X>/<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`\n     *\n     * Format definition:\n     * `http|s://<base-url>/tiles/{layers}/{z}/{x}/{y}/{format}?access_token={access_token}`\n     *\n     * Sample URL:\n     * `https://xyz.api.here.com/tiles/osmbase/256/all/16/19293/24641.json?access_token=your-xyz-api-key`\n     *\n     * Default authentication method used: [[AuthenticationTypeAccessToken]].\n     */\n    XYZJson,\n\n    /**\n     * Use the REST API format of XYZ Vector Tile API in OMV format.\n     *\n     * Usage:\n     * `<OmvRestClientParams.baseUrl>/tiles/herebase.02/<zoom>/<X>/<Y>/omv?access_token=<OmvRestClientParams.authenticationCode>`\n     *\n     * Format definition:\n     * `http|s://<base-url>/tiles/herebase.02/{z}/{x}/{y}/{format}?access_token={access_token}`\n     *\n     * Sample URL:\n     * `https://xyz.api.here.com/tiles/herebase.02/14/2649/6338/omv?access_token=your-xyz-access-token`\n     *\n     * Default authentication method used: [[AuthenticationTypeAccessToken]].\n     */\n    XYZOMV,\n\n    /**\n     * Use the REST API format of Tomtoms Vector Tile API v1.\n     *\n     * Usage:\n     * `<OmvRestClientParams.baseUrl>/<zoom>/<X>/<Y>.pbf?key=<OmvRestClientParams.authenticationCode>`\n     *\n     * Format definition:\n     * `<http|https>://<baseURL>/map/<versionNumber>/tile/<layer>/<style>/<zoom>/<X>/<Y>.<format>?key=<apiKey>[&view=<view>][&language=<language>]`\n     *\n     * Sample URL:\n     * `http://api.tomtom.com/map/1/tile/basic/main/0/0/0.pbf?key=<apiKey>`\n     *\n     * Default authentication method used: [[AuthenticationTypeTomTomV1]].\n     */\n    TomtomV1,\n\n    /**\n     * Use the REST API format of XYZ Space Vector Tile API in OMV format.\n     *\n     * Usage:\n     * `<OmvRestClientParams.baseUrl>/hub/spaces/<space-id>/tile/web/<zoom>_<X>_<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`\n     *\n     * Format definition:\n     * `http|s://<base-url>/hub/spaces/{spaceId}/tile/web/{z}_{x}_{y}.mvt?access_token={access_token}`\n     *\n     * Sample URL:\n     * `https://xyz.api.here.com/hub/spaces/your-space-id/tile/web/{z}_{x}_{y}.mvt?access_token=your-access-token`\n     *\n     * Default authentication method used: [[AuthenticationTypeAccessToken]].\n     */\n    XYZSpace\n}\n// tslint:enable:max-line-length\n\n/**\n * Authentication token/code provider used by [[OmvRestClient]] before each call to currently valid\n * authentication code/token.\n */\nexport type AuthenticationCodeProvider = () => Promise<string>;\n\nexport enum AuthenticationMethod {\n    QueryString,\n    AuthorizationHeader\n}\n\nexport interface AuthenticationMethodInfo {\n    method: AuthenticationMethod;\n    name?: string;\n}\n\n/**\n * Authentication method, where token will be provided as HTTP Header:\n *\n *    Authorization: Bearer $authenticationToken\n */\nexport const AuthenticationTypeBearer: AuthenticationMethodInfo = {\n    method: AuthenticationMethod.AuthorizationHeader,\n    name: \"Bearer\"\n};\n\n/**\n * TomTomV1 API compatible authorization method, where token will be provided as HTTP Header:\n *\n *    Authorization: Bearer $authenticationToken\n */\nexport const AuthenticationTypeTomTomV1: AuthenticationMethodInfo = {\n    method: AuthenticationMethod.QueryString,\n    name: \"key\"\n};\n\nexport const AuthenticationTypeAccessToken: AuthenticationMethodInfo = {\n    method: AuthenticationMethod.QueryString,\n    name: \"access_token\"\n};\n\nexport interface OmvRestClientParameters {\n    /**\n     * `URL` pattern used to fetch tile files.\n     *\n     * `URL` with special keywords replaced to retrieve specific tile:\n     *  - `{z}` - zoom level of tile, @see [[TileKey.level]]\n     *  - `{x}` - horizontal coordinate of tile (column number), @see [[TileKey.column]]\n     *  - `{y}` - vertical coordinate of Tile (row number), @see [[TileKey.row]]\n     *\n     * Examples of `url` patterns:\n     * ```\n     *   https://my-base-url.com/vector-tiles/{z}/{x}/{y}.mvt\n     *   https://xyz.api.here.com/tiles/herebase.02/{z}/{x}/{y}/omv\n     *   https://xyz.api.here.com/tiles/osmbase/512/all/{z}/{x}/{y}.mvt\n     * ```\n     *\n     * Note: To add authentication headers and/or query params, use [[authMethod]], [[urlParams]]\n     * properties or embed token directly in `url`.\n     *\n     * Complete examples:\n     * ```\n     * // XYZ OSM with authentication using query param\n     * {\n     *     url: \"https://xyz.api.here.com/tiles/osmbase/512/all/{z}/{x}/{y}.mvt\",\n     *     urlParams: {\n     *           access_token: accessToken\n     *     },\n     * }\n     * // HERE Vector Tile with authentication using bearer token retrieved by callback\n     * {\n     *     url: \"https://vector.hereapi.com/v2/vectortiles/base/mc/{z}/{x}/{y}/omv\",\n     *     authenticationMethod: AuthenticationTypeBearer,\n     *     authenticationCode: () => getBearerToken()\n     * }\n     * ```\n     */\n    url?: string;\n\n    /**\n     * The base URL of the REST Tile Service.\n     * @see [[APIFormat]] for the definition of `baseUrl`.\n     */\n    baseUrl?: string;\n\n    /**\n     * Authentication code used for the different APIs.\n     *\n     * When [[AuthenticationCodeProvider]] is is used as value, the provider is called before each\n     * to get currently valid authentication code/token.\n     *\n     * @see [[APIFormat]] for the query parameter this is used with.\n     */\n    authenticationCode?: string | AuthenticationCodeProvider;\n\n    /**\n     * Specifies [[AuthMethod]] to be used when requesting tiles.\n     *\n     * Defaults for each [[APIFormat]] are documented with each format type.\n     */\n    authenticationMethod?: AuthenticationMethodInfo;\n\n    /**\n     * The REST API format to use for the tile path generation, will default to the HERE Vector Tile\n     * API.\n     */\n    apiFormat?: APIFormat;\n\n    /**\n     * Tiling scheme is used in some of the APIs, not implemented yet.\n     */\n    tilingScheme?: TilingScheme;\n\n    /**\n     * Transfer Manager to use; creates an own instance if none passed.\n     */\n    downloadManager?: ITransferManager;\n\n    /**\n     * Function to retrieve the Bearer Token\n     *\n     * @deprecated Please use [[authenticationCode]].\n     */\n    getBearerToken?: () => Promise<string>;\n\n    /**\n     * Array of query parameters to be appended at the end of the url.\n     * It is empty by default.\n     */\n    urlParams?: { [key: string]: string };\n}\n\n/**\n * REST client supporting getting protobuf OMV Tile from REST-based servers.\n */\nexport class OmvRestClient implements DataProvider {\n    private readonly downloadManager: ITransferManager;\n    private readonly urlParams: { [key: string]: string };\n\n    constructor(readonly params: OmvRestClientParameters) {\n        this.downloadManager =\n            params.downloadManager === undefined\n                ? TransferManager.instance()\n                : params.downloadManager;\n        this.urlParams = params.urlParams === undefined ? {} : params.urlParams;\n    }\n\n    /** Overriding abstract method, in this case doing nothing. */\n    async connect(): Promise<void> {\n        // not needed\n    }\n\n    /** Overriding abstract method, in this case always returning `true`. */\n    ready(): boolean {\n        return true;\n    }\n\n    /**\n     * Asynchronously fetches a tile from this restful server.\n     *\n     * **Note:** If the tile doesn't exist, a successful response with a `404` status code is\n     * returned.\n     *\n     * @example\n     * ```typescript\n     * const response = layer.getTile(tileKey);\n     * if (!response.ok) {\n     *     // a network error happened\n     *     console.error(\"Unable to download tile\", response.statusText);\n     *     return;\n     * }\n     * if (response.status === 404) {\n     *     // 404 -, no data exists at the given tile. Do nothing.\n     *     return;\n     * }\n     *\n     * // the response is ok and contains data, access it e.g. as arrayBuffer:\n     * const payload = await response.arrayBuffer();\n     * ```\n     *\n     * @param tileKey - The tile key of the tile.\n     * @param tileRequestInit - Optional request options to be passed to fetch when downloading a\n     * tile.\n     * @returns A `Promise` of the HTTP response that contains the payload of the requested tile.\n     */\n    async getTile(\n        tileKey: TileKey,\n        abortSignal?: AbortSignal | undefined\n    ): Promise<ArrayBufferLike | {}> {\n        const init: RequestInit = { signal: abortSignal };\n\n        let tileUrl = this.dataUrl(tileKey);\n\n        const authenticationCode = await this.getActualAuthenticationCode();\n\n        tileUrl = this.applyAuthCode(tileUrl, init, authenticationCode);\n        tileUrl = this.addQueryParams(tileUrl, this.urlParams);\n\n        if (this.params.apiFormat === APIFormat.XYZJson) {\n            return this.downloadManager.downloadJson(tileUrl, init);\n        }\n\n        return this.downloadManager.downloadArrayBuffer(tileUrl, init);\n    }\n\n    /**\n     * Get actual authentication code/token for this request according to configuration.\n     */\n    private async getActualAuthenticationCode() {\n        if (typeof this.params.authenticationCode === \"string\") {\n            return this.params.authenticationCode;\n        } else if (this.params.authenticationCode !== undefined) {\n            return this.params.authenticationCode();\n            // tslint:disable-next-line: deprecation\n        } else if (this.params.getBearerToken !== undefined) {\n            // tslint:disable-next-line: deprecation\n            return this.params.getBearerToken();\n        } else {\n            return undefined;\n        }\n    }\n\n    /**\n     * Get default authnentication method basing on apiFormat and other params.\n     */\n    private getDefaultAuthMethod() {\n        // tslint:disable-next-line: deprecation\n        if (this.params.getBearerToken !== undefined) {\n            return AuthenticationTypeBearer;\n        }\n\n        switch (this.params.apiFormat) {\n            case APIFormat.HereV1:\n                return AuthenticationTypeBearer;\n            case APIFormat.MapboxV4:\n            case APIFormat.XYZOMV:\n            case APIFormat.XYZMVT:\n            case APIFormat.XYZSpace:\n            case APIFormat.XYZJson:\n                return AuthenticationTypeAccessToken;\n            case APIFormat.TomtomV1:\n                return AuthenticationTypeTomTomV1;\n            default:\n                logger.warn(\n                    `#getDefaultAuthMethod: Not supported API format: ${this.params.apiFormat}`\n                );\n                return undefined;\n        }\n    }\n\n    /**\n     * Apply athentication code/token using configured (or default) authentication method.\n     *\n     * @param url -\n     * @param init - request extra data\n     * @param authenticationCode - authentication/token to be applied\n     * @return new url to be used\n     */\n    private applyAuthCode(url: string, init: RequestInit, authenticationCode: string | undefined) {\n        if (authenticationCode === undefined) {\n            return url;\n        }\n        const authMethod = this.params.authenticationMethod || this.getDefaultAuthMethod();\n        if (authMethod === undefined) {\n            return url;\n        }\n\n        if (authMethod.method === AuthenticationMethod.AuthorizationHeader) {\n            if (init.headers === undefined) {\n                init.headers = new Headers();\n            }\n            const authType = authMethod.name || \"Bearer\";\n            (init.headers as Headers).append(\"Authorization\", `${authType} ${authenticationCode}`);\n        } else if (authMethod.method === AuthenticationMethod.QueryString) {\n            const attrName: string = authMethod.name || \"access_token\";\n            const authParams: { [key: string]: string } = {};\n            authParams[attrName] = authenticationCode;\n            url = this.addQueryParams(url, authParams);\n        }\n        return url;\n    }\n\n    /**\n     * Get actual tile URL depending on configured API format.\n     */\n    private dataUrl(tileKey: TileKey): string {\n        if (this.params.url !== undefined) {\n            return this.params.url\n                .replace(\"{x}\", String(tileKey.column))\n                .replace(\"{y}\", String(tileKey.row))\n                .replace(\"{z}\", String(tileKey.level));\n        }\n        let path = [`/${tileKey.level}`, tileKey.column, tileKey.row].join(\n            this.params.apiFormat === APIFormat.XYZSpace ||\n                this.params.apiFormat === APIFormat.XYZJson\n                ? \"_\"\n                : \"/\"\n        );\n        switch (this.params.apiFormat) {\n            case APIFormat.HereV1:\n            case APIFormat.XYZOMV:\n                path += \"/omv\";\n                break;\n            case APIFormat.MapboxV4:\n                path += \".mvt\";\n                break;\n            case APIFormat.XYZMVT:\n                path += \".mvt\";\n                break;\n            case APIFormat.XYZJson:\n                break;\n            case APIFormat.XYZSpace:\n                path += \".mvt\";\n                break;\n            case APIFormat.TomtomV1:\n                path += \".pbf\";\n                break;\n            default:\n                logger.warn(`Not supported API format: ${this.params.apiFormat}`);\n                break;\n        }\n\n        return this.params.baseUrl + path;\n    }\n\n    private addQueryParams(url: string, queryParams: { [key: string]: string }): string {\n        let queryString = \"\";\n        let concatinator = url.indexOf(\"?\") !== -1 ? \"&\" : \"?\";\n        Object.getOwnPropertyNames(queryParams).forEach(property => {\n            const prop = property as keyof typeof queryParams;\n            queryString += concatinator + prop + \"=\" + queryParams[prop];\n            if (concatinator === \"?\") {\n                concatinator = \"&\";\n            }\n        });\n        return url + queryString;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// tslint:disable-next-line:no-implicit-dependencies\nimport { Theme } from \"@here/harp-datasource-protocol\";\nimport { GeoCoordinates } from \"@here/harp-geoutils\";\nimport { MapView, MapViewEventNames, MapViewUtils } from \"@here/harp-mapview\";\nimport { APIFormat, AuthenticationMethod, OmvDataSource } from \"@here/harp-omv-datasource\";\nimport { apikey, copyrightInfo } from \"../../@here/harp-examples/config\";\n\n// tslint:disable-next-line:no-var-requires\nconst theme = require(\"../resources/theme.json\");\n\nimport \"../css/index.css\";\n\nconst s3Base = \"https://www.harp.gl/docs/\";\n\n//Update initial links to s3 base\ndocument.querySelector<HTMLAnchorElement>(\".examples-link\")!.href = s3Base + \"master/examples/\";\ndocument.querySelector<HTMLAnchorElement>(\".docs-link\")!.href = s3Base + \"master/doc/\";\ndocument.querySelector<HTMLAnchorElement>(\"#docs-nav\")!.href = s3Base + \"master/doc/\";\ndocument.querySelector<HTMLAnchorElement>(\"#examples-nav\")!.href = s3Base + \"master/examples/\";\ndocument.querySelector<HTMLAnchorElement>(\"#docs-nav-mobile\")!.href = s3Base + \"master/doc/\";\n\n//Update year\n(document.getElementById(\"year\") as HTMLDivElement).innerText = `${new Date().getFullYear()}`;\n\nconst releases = [\n    {\n        date: \"latest\",\n        hash: \"master\",\n        version: \"latest-dev\"\n    }\n];\nconst dropdown = document.querySelector(\"select[name=versions]\") as HTMLSelectElement;\n\nfetch(\"./releases.json\")\n    .then(res => res.json())\n    .then(res => {\n        releases.push(...res);\n        releases.forEach(release => {\n            const option = document.createElement(\"option\");\n            option.innerText = release.version;\n            dropdown.appendChild(option);\n        });\n\n        dropdown.onchange = () => {\n            const selected = dropdown.querySelector<HTMLOptionElement>(\"option:checked\")!;\n            const release = releases.find(x => x.version === selected.innerText);\n            if (!release) {\n                return;\n            }\n            const hash = release.hash;\n            const version = release.version;\n\n            //Update examples button and link\n            document.querySelector<HTMLAnchorElement>(\".examples-link\")!.href =\n                s3Base + hash + \"/examples/\";\n            document.querySelector<HTMLAnchorElement>(\".examples-link\")!.innerText =\n                \"Examples\" + (hash !== \"master\" ? ` (${version})` : \"\");\n\n            //Update docs button and link\n            document.querySelector<HTMLAnchorElement>(\".docs-link\")!.href = s3Base + hash + \"/doc/\";\n            document.querySelector<HTMLAnchorElement>(\".docs-link\")!.innerText =\n                \"Documentation\" + (hash !== \"master\" ? ` (${version})` : \"\");\n        };\n    })\n    .catch(() => {\n        //In case network request to build information fails, add master link\n        const option = document.createElement(\"option\");\n        option.innerText = \"master\";\n        dropdown.appendChild(option);\n    });\n\nfunction main() {\n    const canvas = document.getElementById(\"map\") as HTMLCanvasElement;\n    const map = new MapView({\n        canvas,\n        decoderUrl: \"decoder.bundle.js\",\n        theme: (theme as unknown) as Theme,\n        maxVisibleDataSourceTiles: 40,\n        enableMixedLod: false,\n        tileCacheSize: 100\n    });\n    map.animatedExtrusionHandler.enabled = false;\n\n    const omvDataSource = new OmvDataSource({\n        baseUrl: \"https://vector.hereapi.com/v2/vectortiles/base/mc\",\n        apiFormat: APIFormat.XYZOMV,\n        styleSetName: \"tilezen\",\n        authenticationCode: apikey,\n        authenticationMethod: {\n            method: AuthenticationMethod.QueryString,\n            name: \"apikey\"\n        },\n        copyrightInfo\n    });\n    map.addDataSource(omvDataSource);\n\n    map.resize(window.innerWidth, 500);\n    window.addEventListener(\"resize\", () => map.resize(window.innerWidth, 500));\n\n    const zoomLevel = MapViewUtils.calculateZoomLevelFromDistance(map, 1400);\n    const Boston = new GeoCoordinates(42.361145, -71.057083);\n    const options = { target: Boston, zoomLevel, tilt: 34.3, heading: 135 };\n    map.lookAt(options);\n\n    map.addEventListener(MapViewEventNames.FrameComplete, () => {\n        canvas.style.opacity = \"1\";\n\n        map.addEventListener(MapViewEventNames.Render, () =>\n            map.lookAt({ heading: map.heading + 0.1 })\n        );\n        setTimeout(() => {\n            map.beginAnimation();\n        }, 0.5);\n    });\n}\n\nmain();\n","/*\n * Copyright (C) 2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Represents an object that carry {@link GeoBox} extents like interface.\n */\nexport interface GeoBoxExtentLike {\n    /**\n     * Latitude span in degrees.\n     */\n    readonly latitudeSpan: number;\n\n    /**\n     * Longitude span in degrees\n     */\n    readonly longitudeSpan: number;\n}\n\n/**\n * Type guard to assert that `object` conforms to {@link GeoBoxExtentLike} interface.\n */\nexport function isGeoBoxExtentLike(obj: any): obj is GeoBoxExtentLike {\n    return (\n        obj &&\n        typeof obj === \"object\" &&\n        typeof obj.latitudeSpan === \"number\" &&\n        typeof obj.longitudeSpan === \"number\"\n    );\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeoBox } from \"../coordinates/GeoBox\";\nimport { GeoCoordinates } from \"../coordinates/GeoCoordinates\";\nimport { GeoCoordinatesLike } from \"../coordinates/GeoCoordinatesLike\";\nimport { Box3Like, isBox3Like } from \"../math/Box3Like\";\nimport { MathUtils } from \"../math/MathUtils\";\nimport { isOrientedBox3Like, OrientedBox3Like } from \"../math/OrientedBox3Like\";\nimport { Vector3Like } from \"../math/Vector3Like\";\nimport { Projection, ProjectionType } from \"./Projection\";\n\nimport * as THREE from \"three\";\n\nclass IdentityProjection extends Projection {\n    /** @override */\n    readonly type: ProjectionType = ProjectionType.Planar;\n\n    /** @override */\n    getScaleFactor(_worldPoint: Vector3Like): number {\n        return 1;\n    }\n\n    /** @override */\n    worldExtent<WorldBoundingBox extends Box3Like>(\n        minAltitude: number,\n        maxAltitude: number,\n        result?: WorldBoundingBox\n    ): WorldBoundingBox {\n        if (!result) {\n            result = (new THREE.Box3() as Box3Like) as WorldBoundingBox;\n        }\n        result.min.x = -Math.PI;\n        result.min.y = -Math.PI * 0.5;\n        result.min.z = minAltitude;\n        result.max.x = Math.PI;\n        result.max.y = Math.PI * 0.5;\n        result.max.z = maxAltitude;\n        return result;\n    }\n\n    /** @override */\n    projectPoint<WorldCoordinates extends Vector3Like>(\n        geoPoint: GeoCoordinatesLike,\n        result?: WorldCoordinates\n    ): WorldCoordinates {\n        if (!result) {\n            // tslint:disable-next-line:no-object-literal-type-assertion\n            result = { x: 0, y: 0, z: 0 } as WorldCoordinates;\n        }\n        result.x = THREE.MathUtils.degToRad(geoPoint.longitude);\n        result.y = THREE.MathUtils.degToRad(geoPoint.latitude);\n        result.z = geoPoint.altitude || 0;\n        return result;\n    }\n\n    /** @override */\n    unprojectPoint(worldPoint: Vector3Like): GeoCoordinates {\n        const geoPoint = GeoCoordinates.fromRadians(worldPoint.y, worldPoint.x, worldPoint.z);\n        return geoPoint;\n    }\n\n    /** @override */\n    unprojectAltitude(worldPoint: Vector3Like): number {\n        return worldPoint.z;\n    }\n\n    /** @override */\n    projectBox<WorldBoundingBox extends Box3Like | OrientedBox3Like>(\n        geoBox: GeoBox,\n        result?: WorldBoundingBox\n    ): WorldBoundingBox {\n        if (!result) {\n            result = (new THREE.Box3() as Box3Like) as WorldBoundingBox;\n        }\n        const min = this.projectPoint(\n            new GeoCoordinates(geoBox.south, geoBox.west, geoBox.minAltitude)\n        );\n        const max = this.projectPoint(\n            new GeoCoordinates(geoBox.north, geoBox.east, geoBox.maxAltitude)\n        );\n        if (isBox3Like(result)) {\n            result.min.x = min.x;\n            result.min.y = min.y;\n            result.min.z = min.z;\n            result.max.x = max.x;\n            result.max.y = max.y;\n            result.max.z = max.z;\n        } else if (isOrientedBox3Like(result)) {\n            MathUtils.newVector3(1, 0, 0, result.xAxis);\n            MathUtils.newVector3(0, 1, 0, result.yAxis);\n            MathUtils.newVector3(0, 0, 1, result.zAxis);\n            result.position.x = (min.x + max.x) * 0.5;\n            result.position.y = (min.y + max.y) * 0.5;\n            result.position.z = (min.z + max.z) * 0.5;\n            result.extents.x = (max.x - min.x) * 0.5;\n            result.extents.y = (max.y - min.y) * 0.5;\n            result.extents.z = Math.max(Number.EPSILON, (max.z - min.z) * 0.5);\n        }\n        return result;\n    }\n\n    /** @override */\n    unprojectBox(worldBox: Box3Like): GeoBox {\n        const minGeo = this.unprojectPoint(worldBox.min);\n        const maxGeo = this.unprojectPoint(worldBox.max);\n        return GeoBox.fromCoordinates(minGeo, maxGeo);\n    }\n\n    /** @override */\n    groundDistance(worldPoint: Vector3Like): number {\n        return worldPoint.z;\n    }\n\n    /** @override */\n    scalePointToSurface(worldPoint: Vector3Like): Vector3Like {\n        worldPoint.z = 0;\n        return worldPoint;\n    }\n\n    /** @override */\n    surfaceNormal(_worldPoint: Vector3Like, normal?: Vector3Like) {\n        if (normal === undefined) {\n            normal = { x: 0, y: 0, z: 1 };\n        } else {\n            normal.x = 0;\n            normal.y = 0;\n            normal.z = 1;\n        }\n        return normal;\n    }\n}\n\n/**\n * Identity {@link Projection} used to convert geo coordinates to unit coordinates and vice versa.\n */\nexport const identityProjection: Projection = new IdentityProjection(1);\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeoBox } from \"../coordinates/GeoBox\";\nimport { GeoCoordinates } from \"../coordinates/GeoCoordinates\";\nimport { GeoCoordinatesLike, isGeoCoordinatesLike } from \"../coordinates/GeoCoordinatesLike\";\nimport { Box3Like, isBox3Like } from \"../math/Box3Like\";\nimport { MathUtils } from \"../math/MathUtils\";\nimport { isOrientedBox3Like, OrientedBox3Like } from \"../math/OrientedBox3Like\";\nimport { TransformLike } from \"../math/TransformLike\";\nimport { Vector3Like } from \"../math/Vector3Like\";\nimport { EarthConstants } from \"./EarthConstants\";\nimport { mercatorProjection, webMercatorProjection } from \"./MercatorProjection\";\nimport { Projection, ProjectionType } from \"./Projection\";\n\nimport * as THREE from \"three\";\n\n/**\n * Transforms the given vector using the provided basis.\n */\nfunction apply(\n    xAxis: Vector3Like,\n    yAxis: Vector3Like,\n    zAxis: Vector3Like,\n    v: Vector3Like\n): Vector3Like {\n    const x = xAxis.x * v.x + yAxis.x * v.y + zAxis.x * v.z;\n    const y = xAxis.y * v.x + yAxis.y * v.y + zAxis.y * v.z;\n    const z = xAxis.z * v.x + yAxis.z * v.y + zAxis.z * v.z;\n    v.x = x;\n    v.y = y;\n    v.z = z;\n    return v;\n}\n\n/**\n * Returns the quadrants for the given longitude. The quadrant is defined as:\n *  - quadrant(+Math.PI * -1.0) = 0\n *  - quadrant(+Math.PI * -0.5) = 1\n *  - quadrant(+Math.PI *  0.0) = 2\n *  - quadrant(+Math.PI *  0.5) = 3\n *  - quadrant(+Math.PI *  1.0) = 4\n *\n * @param longitude - The longitude in radians.\n */\nfunction getLongitudeQuadrant(longitude: number) {\n    const oneOverPI = 1 / Math.PI;\n    const quadrantIndex = Math.floor(2 * (longitude * oneOverPI + 1));\n    return THREE.MathUtils.clamp(quadrantIndex, 0, 4);\n}\n\nfunction lengthOfVector3(worldPoint: Vector3Like): number {\n    const d = Math.sqrt(\n        worldPoint.x * worldPoint.x + worldPoint.y * worldPoint.y + worldPoint.z * worldPoint.z\n    );\n    return d;\n}\n\n/**\n * Creates a Box3 enclosing the geobox.\n *\n * @param geoBox - Ghe given geobox\n * @param worldBox - The resulting axis aligned bounding box.\n */\nfunction makeBox3<Bounds extends Box3Like>(\n    geoBox: GeoBox,\n    worldBox: Bounds,\n    unitScale: number\n): Bounds {\n    const halfEquatorialRadius = (unitScale + (geoBox.maxAltitude || 0)) * 0.5;\n\n    const minLongitude = THREE.MathUtils.degToRad(geoBox.west);\n    const maxLongitude = THREE.MathUtils.degToRad(geoBox.east);\n\n    const minLongitudeQuadrant = getLongitudeQuadrant(minLongitude);\n    const maxLongitudeQuadrant = getLongitudeQuadrant(maxLongitude);\n\n    let xMin = Math.cos(minLongitude);\n    let xMax = xMin;\n    let yMin = Math.sin(minLongitude);\n    let yMax = yMin;\n\n    for (\n        let quadrantIndex = minLongitudeQuadrant + 1;\n        quadrantIndex <= maxLongitudeQuadrant;\n        quadrantIndex++\n    ) {\n        // tslint:disable-next-line: no-bitwise\n        const x = ((quadrantIndex + 1) & 1) * ((quadrantIndex & 2) - 1);\n        xMin = Math.min(x, xMin);\n        xMax = Math.max(x, xMax);\n\n        // tslint:disable-next-line: no-bitwise\n        const y = (quadrantIndex & 1) * ((quadrantIndex & 2) - 1);\n        yMin = Math.min(y, yMin);\n        yMax = Math.max(y, yMax);\n    }\n\n    const cosMaxLongitude = Math.cos(maxLongitude);\n    xMin = Math.min(cosMaxLongitude, xMin);\n    xMax = Math.max(cosMaxLongitude, xMax);\n\n    const sinMaxLongitude = Math.sin(maxLongitude);\n    yMin = Math.min(sinMaxLongitude, yMin);\n    yMax = Math.max(sinMaxLongitude, yMax);\n\n    const xCenter = (xMax + xMin) * halfEquatorialRadius;\n    const xExtent = (xMax - xMin) * halfEquatorialRadius;\n\n    const yCenter = (yMax + yMin) * halfEquatorialRadius;\n    const yExtent = (yMax - yMin) * halfEquatorialRadius;\n\n    // Calculate Z boundaries.\n    const minLatitude = THREE.MathUtils.degToRad(geoBox.south);\n    const maxLatutide = THREE.MathUtils.degToRad(geoBox.north);\n\n    const zMax = Math.sin(maxLatutide);\n    const zMin = Math.sin(minLatitude);\n\n    const zCenter = (zMax + zMin) * halfEquatorialRadius;\n    const zExtent = (zMax - zMin) * halfEquatorialRadius;\n\n    worldBox.min.x = xCenter - xExtent;\n    worldBox.min.y = yCenter - yExtent;\n    worldBox.min.z = zCenter - zExtent;\n    worldBox.max.x = xCenter + xExtent;\n    worldBox.max.y = yCenter + yExtent;\n    worldBox.max.z = zCenter + zExtent;\n\n    return worldBox;\n}\n\n/**\n * Computes the spherical projection of the given geo coordinates.\n *\n * @param geoPoint - The geo coordinates.\n * @param worldpoint - The resulting world coordinates.\n */\nfunction project<WorldCoordinates extends Vector3Like>(\n    geoPoint: GeoCoordinatesLike,\n    worldpoint: WorldCoordinates,\n    unitScale: number\n): typeof worldpoint {\n    const radius = unitScale + (geoPoint.altitude || 0);\n    const latitude = THREE.MathUtils.degToRad(geoPoint.latitude);\n    const longitude = THREE.MathUtils.degToRad(geoPoint.longitude);\n    const cosLatitude = Math.cos(latitude);\n    worldpoint.x = radius * cosLatitude * Math.cos(longitude);\n    worldpoint.y = radius * cosLatitude * Math.sin(longitude);\n    worldpoint.z = radius * Math.sin(latitude);\n    return worldpoint;\n}\n\nclass SphereProjection extends Projection {\n    /** @override */\n    readonly type: ProjectionType = ProjectionType.Spherical;\n\n    /** @override */\n    worldExtent<Bounds extends Box3Like>(\n        _minElevation: number,\n        maxElevation: number,\n        result: Bounds = (new THREE.Box3() as Box3Like) as Bounds\n    ): Bounds {\n        const radius = this.unitScale + maxElevation;\n        result.min.x = -radius;\n        result.min.y = -radius;\n        result.min.z = -radius;\n        result.max.x = radius;\n        result.max.y = radius;\n        result.max.z = radius;\n        return result;\n    }\n\n    /** @override */\n    projectPoint<WorldCoordinates extends Vector3Like>(\n        geoPoint: GeoCoordinatesLike,\n        result: WorldCoordinates = MathUtils.newVector3(0, 0, 0) as WorldCoordinates\n    ): WorldCoordinates {\n        return project(geoPoint, result, this.unitScale);\n    }\n\n    /** @override */\n    unprojectPoint(point: Vector3Like): GeoCoordinates {\n        const parallelRadiusSq = point.x * point.x + point.y * point.y;\n        const parallelRadius = Math.sqrt(parallelRadiusSq);\n        const v = point.z / parallelRadius;\n\n        if (isNaN(v)) {\n            return GeoCoordinates.fromRadians(0, 0, -this.unitScale);\n        }\n\n        const radius = Math.sqrt(parallelRadiusSq + point.z * point.z);\n\n        return GeoCoordinates.fromRadians(\n            Math.atan(v),\n            Math.atan2(point.y, point.x),\n            radius - this.unitScale\n        );\n    }\n\n    /** @override */\n    unprojectAltitude(point: Vector3Like): number {\n        const parallelRadiusSq = point.x * point.x + point.y * point.y + point.z * point.z;\n        return Math.sqrt(parallelRadiusSq) - EarthConstants.EQUATORIAL_RADIUS;\n    }\n\n    /** @override */\n    projectBox<Bounds extends Box3Like | OrientedBox3Like>(\n        geoBox: GeoBox,\n        result: Bounds = (new THREE.Box3() as Box3Like) as Bounds\n    ): Bounds {\n        if (isBox3Like(result)) {\n            return makeBox3(geoBox, result, this.unitScale);\n        } else if (isOrientedBox3Like(result)) {\n            if (geoBox.longitudeSpan >= 90) {\n                const bounds = makeBox3(geoBox, new THREE.Box3() as Box3Like, this.unitScale);\n                MathUtils.newVector3(1, 0, 0, result.xAxis);\n                MathUtils.newVector3(0, 1, 0, result.yAxis);\n                MathUtils.newVector3(0, 0, 1, result.zAxis);\n                result.position.x = (bounds.max.x + bounds.min.x) * 0.5;\n                result.position.y = (bounds.max.y + bounds.min.y) * 0.5;\n                result.position.z = (bounds.max.z + bounds.min.z) * 0.5;\n                result.extents.x = (bounds.max.x - bounds.min.x) * 0.5;\n                result.extents.y = (bounds.max.y - bounds.min.y) * 0.5;\n                result.extents.z = (bounds.max.z - bounds.min.z) * 0.5;\n                return result;\n            }\n\n            const { south, west, north, east, center: mid } = geoBox;\n            const midX = mid.longitude;\n            const midY = mid.latitude;\n            const cosSouth = Math.cos(THREE.MathUtils.degToRad(south));\n            const sinSouth = Math.sin(THREE.MathUtils.degToRad(south));\n            const cosWest = Math.cos(THREE.MathUtils.degToRad(west));\n            const sinWest = Math.sin(THREE.MathUtils.degToRad(west));\n            const cosNorth = Math.cos(THREE.MathUtils.degToRad(north));\n            const sinNorth = Math.sin(THREE.MathUtils.degToRad(north));\n            const cosEast = Math.cos(THREE.MathUtils.degToRad(east));\n            const sinEast = Math.sin(THREE.MathUtils.degToRad(east));\n            const cosMidX = Math.cos(THREE.MathUtils.degToRad(midX));\n            const sinMidX = Math.sin(THREE.MathUtils.degToRad(midX));\n            const cosMidY = Math.cos(THREE.MathUtils.degToRad(midY));\n            const sinMidY = Math.sin(THREE.MathUtils.degToRad(midY));\n\n            // Build the orientation of the OBB using the normal vector and its partial derivates.\n\n            // the sperical coordinates of the mid point of the geobox.\n            MathUtils.newVector3(cosMidX * cosMidY, sinMidX * cosMidY, sinMidY, result.zAxis);\n\n            // the partial derivates of the normal vector.\n            MathUtils.newVector3(-sinMidX, cosMidX, 0, result.xAxis);\n            MathUtils.newVector3(-cosMidX * sinMidY, -sinMidX * sinMidY, cosMidY, result.yAxis);\n\n            let width: number;\n            let minY: number;\n            let maxY: number;\n\n            if (south >= 0) {\n                // abs(dot(southWest - southEast, xAxis))\n                width = Math.abs(\n                    cosSouth * (cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest))\n                );\n\n                // dot(south, yAxis)\n                minY = cosMidY * sinSouth - sinMidY * cosSouth;\n\n                // dot(northEast, zAxis)\n                maxY =\n                    cosMidY * sinNorth -\n                    sinMidY * cosNorth * (cosMidX * cosEast + sinMidX * sinEast);\n            } else {\n                if (north <= 0) {\n                    // abs(dot(northWest - northEast, xAxis))\n                    width = Math.abs(\n                        cosNorth * (cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest))\n                    );\n\n                    // dot(north, yAxis)\n                    maxY = cosMidY * sinNorth - sinMidY * cosNorth;\n                } else {\n                    // abs(dot(west - east, xAxis))\n                    width = Math.abs(cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest));\n\n                    // dot(northEast, yAxis)\n                    maxY =\n                        cosMidY * sinNorth -\n                        sinMidY * cosNorth * (sinMidX * sinEast + cosMidX * cosEast);\n                }\n\n                // dot(southEast, yAxis)\n                minY =\n                    cosMidY * sinSouth -\n                    sinMidY * cosSouth * (cosMidX * cosEast + sinMidX * sinEast);\n            }\n\n            const rMax = (this.unitScale + (geoBox.maxAltitude || 0)) * 0.5;\n            const rMin = (this.unitScale + (geoBox.minAltitude || 0)) * 0.5;\n\n            // min(dot(southEast, zAxis), dot(northEast, zAxis))\n\n            const d = cosMidY * (cosMidX * cosEast + sinMidX * sinEast);\n\n            const minZ = Math.min(\n                cosNorth * d + sinNorth * sinMidY,\n                cosSouth * d + sinSouth * sinMidY\n            );\n\n            MathUtils.newVector3(\n                width * rMax,\n                (maxY - minY) * rMax,\n                rMax - minZ * rMin,\n                result.extents\n            );\n\n            MathUtils.newVector3(0, (minY + maxY) * rMax, rMax + rMax, result.position);\n\n            apply(result.xAxis, result.yAxis, result.zAxis, result.position);\n\n            result.position.x = result.position.x - result.zAxis.x * result.extents.z;\n            result.position.y = result.position.y - result.zAxis.y * result.extents.z;\n            result.position.z = result.position.z - result.zAxis.z * result.extents.z;\n\n            return result;\n        }\n\n        throw new Error(\"Invalid bounding box\");\n    }\n\n    /** @override */\n    unprojectBox(_worldBox: Box3Like): GeoBox {\n        throw new Error(\"Method not implemented.\");\n    }\n\n    /** @override */\n    getScaleFactor(_worldPoint: Vector3Like): number {\n        return 1;\n    }\n\n    /** @override */\n    groundDistance(worldPoint: Vector3Like): number {\n        return lengthOfVector3(worldPoint) - this.unitScale;\n    }\n\n    /** @override */\n    scalePointToSurface(worldPoint: Vector3Like): Vector3Like {\n        const scale = this.unitScale / (lengthOfVector3(worldPoint) || 1);\n        worldPoint.x *= scale;\n        worldPoint.y *= scale;\n        worldPoint.z *= scale;\n        return worldPoint;\n    }\n\n    /** @override */\n    surfaceNormal(worldPoint: Vector3Like, normal?: Vector3Like) {\n        if (normal === undefined) {\n            normal = { x: 0, y: 0, z: 0 };\n        }\n        const scale = 1 / (lengthOfVector3(worldPoint) || 1);\n        normal.x = worldPoint.x * scale;\n        normal.y = worldPoint.y * scale;\n        normal.z = worldPoint.z * scale;\n        return normal;\n    }\n\n    /** @override */\n    reprojectPoint(\n        sourceProjection: Projection,\n        worldPos: Vector3Like,\n        result?: Vector3Like\n    ): Vector3Like {\n        if (sourceProjection === mercatorProjection || sourceProjection === webMercatorProjection) {\n            const { x, y, z } = worldPos;\n            const r = this.unitScale;\n            const mx = x / r - Math.PI;\n            const my = y / r - Math.PI;\n            const w = Math.exp(my);\n            const d = w * w;\n            const gx = (2 * w) / (d + 1);\n            const gy = (d - 1) / (d + 1);\n            const scale = r + z;\n\n            if (result === undefined) {\n                // tslint:disable-next-line: no-object-literal-type-assertion\n                result = {} as Vector3Like;\n            }\n\n            result.x = Math.cos(mx) * gx * scale;\n            result.y = Math.sin(mx) * gx * scale;\n            result.z = gy * scale;\n\n            if (sourceProjection === webMercatorProjection) {\n                result.z = -result.z;\n            }\n\n            return result;\n        }\n\n        return super.reprojectPoint(sourceProjection, worldPos, result!);\n    }\n\n    /** @override */\n    localTangentSpace(\n        point: GeoCoordinatesLike | Vector3Like,\n        result: TransformLike\n    ): TransformLike {\n        let geoPoint: GeoCoordinatesLike;\n        if (isGeoCoordinatesLike(point)) {\n            this.projectPoint(point, result.position);\n            geoPoint = point;\n        } else {\n            MathUtils.copyVector3(point, result.position);\n            geoPoint = this.unprojectPoint(point);\n        }\n\n        const latitude = THREE.MathUtils.degToRad(geoPoint.latitude);\n        const longitude = THREE.MathUtils.degToRad(geoPoint.longitude);\n\n        const cosLongitude = Math.cos(longitude);\n        const sinLongitude = Math.sin(longitude);\n        const cosLatitude = Math.cos(latitude);\n        const sinLatitude = Math.sin(latitude);\n\n        MathUtils.newVector3(\n            cosLongitude * cosLatitude,\n            sinLongitude * cosLatitude,\n            sinLatitude,\n            result.zAxis\n        );\n\n        MathUtils.newVector3(-sinLongitude, cosLongitude, 0, result.xAxis);\n\n        MathUtils.newVector3(\n            -cosLongitude * sinLatitude,\n            -sinLongitude * sinLatitude,\n            cosLatitude,\n            result.yAxis\n        );\n        return result;\n    }\n}\n\nexport const sphereProjection: Projection = new SphereProjection(EarthConstants.EQUATORIAL_RADIUS);\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeoBox } from \"../coordinates/GeoBox\";\nimport { TileKey } from \"./TileKey\";\nimport { TilingScheme } from \"./TilingScheme\";\n\n/**\n * A class used to represent a quadtree.\n */\nexport class QuadTree {\n    /**\n     * Constructs a new `QuadTree` for the given {@link TilingScheme}.\n     *\n     * Example:\n     * ```typescript\n     * const quadTree = new QuadTree(hereTilingScheme);\n     * const geoBox = quadTree.getGeoBox(tileKey);\n     * console.log(geoBox.center);\n     * ```\n     *\n     * @param tilingScheme - The TilingScheme used by this `QuadTree`.\n     */\n    constructor(readonly tilingScheme: TilingScheme) {}\n\n    /**\n     * Visits this `QuadTree` and invoke the given accept method\n     * with the current {@link TileKey} and\n     * its bounding box in geo coordinates.\n     *\n     * Example:\n     * ```typescript\n     * const geoPos = new GeoCoordinates(latitude, longitude);\n     * const quadTree = new QuadTree(hereTilingScheme);\n     * quadTree.visit((tileKey, geoBox) => {\n     *     if (geoBox.contains(geoPos)) {\n     *         console.log(\"tile\", tileKey, \"contains\", geoPos);\n     *         return tileKey.level < 14; // stop visiting the quadtree if the level is >= 14.\n     *     }\n     *     return false; // stop visiting the quadtree,\n     *                   // the tile's geoBox doesn't contain the given coordinates.\n     * });\n     * ```\n     *\n     * @param accept - A function that takes a {@link TileKey}\n     * and its bounding box in geo coordinates\n     * and returns `true` if the visit of the `QuadTree`\n     * should continue; otherwise `false`.\n     */\n    visit(accept: (tileKey: TileKey, geoBox: GeoBox) => boolean) {\n        this.visitTileKey(TileKey.fromRowColumnLevel(0, 0, 0), accept);\n    }\n\n    /**\n     * Visits the subtree starting from the given tile.\n     *\n     * @param tileKey - The root of the subtree that should be visited.\n     * @param accept - A function that takes a {@link TileKey}\n     *                 and its bounding box in geo coordinates\n     *                 and returns `true` if the visit of the\n     *                 `QuadTree` should continue; otherwise `false`.\n     */\n    visitTileKey(tileKey: TileKey, accept: (tileKey: TileKey, geoBox: GeoBox) => boolean) {\n        const geoBox = this.tilingScheme.getGeoBox(tileKey);\n\n        if (!accept(tileKey, geoBox)) {\n            return;\n        }\n\n        for (const subTileKey of this.tilingScheme.getSubTileKeys(tileKey)) {\n            this.visitTileKey(subTileKey, accept);\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { normalizedEquirectangularProjection } from \"../projection/EquirectangularProjection\";\nimport { halfQuadTreeSubdivisionScheme } from \"./HalfQuadTreeSubdivisionScheme\";\nimport { TilingScheme } from \"./TilingScheme\";\n\n/**\n * {@link TilingScheme} used by most of the data published by HERE.\n *\n * The `hereTilingScheme` features a half quadtree subdivision scheme and an equirectangular\n * projection.\n */\nexport const hereTilingScheme = new TilingScheme(\n    halfQuadTreeSubdivisionScheme,\n    normalizedEquirectangularProjection\n);\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { webMercatorProjection } from \"../projection/MercatorProjection\";\nimport { quadTreeSubdivisionScheme } from \"./QuadTreeSubdivisionScheme\";\nimport { TilingScheme } from \"./TilingScheme\";\n\n/**\n * A {@link TilingScheme} featuring quadtree subdivision scheme and web Mercator projection.\n */\nexport const webMercatorTilingScheme = new TilingScheme(\n    quadTreeSubdivisionScheme,\n    webMercatorProjection\n);\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { mercatorProjection } from \"../projection/MercatorProjection\";\nimport { quadTreeSubdivisionScheme } from \"./QuadTreeSubdivisionScheme\";\nimport { TilingScheme } from \"./TilingScheme\";\n\n/**\n * The {@link TilingScheme} used by the HERE web tiles.\n *\n * The `mercatorTilingScheme` features a quadtree subdivision scheme and a Mercator projection.\n */\nexport const mercatorTilingScheme = new TilingScheme(quadTreeSubdivisionScheme, mercatorProjection);\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { transverseMercatorProjection } from \"../projection/TransverseMercatorProjection\";\nimport { quadTreeSubdivisionScheme } from \"./QuadTreeSubdivisionScheme\";\nimport { TilingScheme } from \"./TilingScheme\";\n\n/**\n * A {@link TilingScheme} featuring quadtree subdivision scheme and\n * transverse Mercator projection.\n */\nexport const polarTilingScheme = new TilingScheme(\n    quadTreeSubdivisionScheme,\n    transverseMercatorProjection\n);\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Interface representing a Vector3.\n */\nexport interface Vector3Like {\n    /**\n     * The X position.\n     */\n    x: number;\n\n    /**\n     * The Y position.\n     */\n    y: number;\n\n    /**\n     * The Z position.\n     */\n    z: number;\n}\n\nexport function isVector3Like(v: any): v is Vector3Like {\n    return v && typeof v.x === \"number\" && typeof v.y === \"number\" && typeof v.z === \"number\";\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Vector3Like } from \"./Vector3Like\";\n\n/**\n * The interface {@link TransformLike} is used to represent transforms with\n * only translation and rotation.\n */\nexport interface TransformLike {\n    /**\n     * The position of this transform.\n     */\n    readonly position: Vector3Like;\n\n    /**\n     * The x-axis of this transform.\n     */\n    readonly xAxis: Vector3Like;\n\n    /**\n     * The y-axis of this transform.\n     */\n    readonly yAxis: Vector3Like;\n\n    /**\n     * The z-axis of this transform.\n     */\n    readonly zAxis: Vector3Like;\n}\n\n/**\n * Returns true if the given object implements the interface {@link TransformLike}.\n *\n * @param object - The object.\n */\nexport function isTransformLike(object: {}): object is TransformLike {\n    const transform = object as Partial<TransformLike>;\n    return (\n        transform.position !== undefined &&\n        transform.xAxis !== undefined &&\n        transform.yAxis !== undefined &&\n        transform.zAxis !== undefined\n    );\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Frustum, Matrix4, Plane, Ray, Vector3 } from \"three\";\nimport { OrientedBox3Like } from \"./OrientedBox3Like\";\n\nfunction intersectsSlab(\n    rayDir: Vector3,\n    p: Vector3,\n    axis: Vector3,\n    extent: number,\n    t: { min: number; max: number }\n): boolean {\n    const epsilon = 1e-20;\n    const e = axis.dot(p);\n    const f = axis.dot(rayDir);\n    if (Math.abs(f) < epsilon) {\n        // ray parallel to near/far slab lines.\n        return Math.abs(e) <= extent;\n    }\n\n    // ray intersects near/far slab lines.\n    const finv = 1 / f;\n    const t1 = (e + extent) * finv;\n    const t2 = (e - extent) * finv;\n    if (t1 > t2) {\n        // t1 is far intersect, t2 is near.\n        if (t2 > t.min) {\n            t.min = t2;\n        }\n        if (t1 < t.max) {\n            t.max = t1;\n        }\n    } else {\n        // t1 is near intersect, t2 is far.\n        if (t1 > t.min) {\n            t.min = t1;\n        }\n        if (t2 < t.max) {\n            t.max = t2;\n        }\n    }\n    return t.min <= t.max && t.max >= 0;\n}\n\nconst tmpVec = new Vector3();\nconst tmpT = { min: -Infinity, max: Infinity };\n\nexport class OrientedBox3 implements OrientedBox3Like {\n    /**\n     * The position of the center of this `OrientedBox3`.\n     */\n    readonly position = new Vector3();\n\n    /**\n     * The x-axis of this `OrientedBox3`.\n     */\n    readonly xAxis = new Vector3(1, 0, 0);\n\n    /**\n     * The y-axis of this `OrientedBox3`.\n     */\n    readonly yAxis = new Vector3(0, 1, 0);\n\n    /**\n     * The z-axis of this `OrientedBox3`.\n     */\n    readonly zAxis = new Vector3(0, 0, 1);\n\n    /**\n     * The extents of this `OrientedBox3`.\n     */\n    readonly extents = new Vector3();\n\n    /**\n     * Creates a new `OrientedBox3`.\n     */\n    constructor();\n\n    /**\n     * Creates a new `OrientedBox3` with the given position, orientation and extents.\n     *\n     * @param position - The position of the center of the `OrientedBox3`.\n     * @param rotationMatrix - The rotation of the `OrientedBox3`.\n     * @param extents - The extents of the `OrientedBox3`.\n     */\n    constructor(position: Vector3, rotationMatrix: Matrix4, extents: Vector3);\n\n    /**\n     * Creates a new `OrientedBox3`.\n     *\n     * @hideconstructor\n     */\n    constructor(position?: Vector3, rotationMatrix?: Matrix4, extents?: Vector3) {\n        if (position !== undefined) {\n            this.position.copy(position);\n        }\n\n        if (rotationMatrix !== undefined) {\n            rotationMatrix.extractBasis(this.xAxis, this.yAxis, this.zAxis);\n        }\n\n        if (extents !== undefined) {\n            this.extents.copy(extents);\n        }\n    }\n\n    /**\n     * Create a copy of this [[OrientedBoundingBox]].\n     */\n    clone(): OrientedBox3 {\n        const newBox = new OrientedBox3();\n        newBox.copy(this);\n        return newBox;\n    }\n\n    /**\n     * Copies the values of `other` to this {@link OrientedBox3}.\n     * @param other - The other {@link OrientedBox3} to copy.\n     */\n    copy(other: OrientedBox3) {\n        this.position.copy(other.position);\n        this.xAxis.copy(other.xAxis);\n        this.yAxis.copy(other.yAxis);\n        this.zAxis.copy(other.zAxis);\n        this.extents.copy(other.extents);\n    }\n\n    /**\n     * Gets the center position of this {@link OrientedBox3}.\n     *\n     * @param center - The returned center position.\n     */\n    getCenter(center = new Vector3()): Vector3 {\n        return center.copy(this.position);\n    }\n\n    /**\n     * Gets the size of this {@link OrientedBox3}.\n     *\n     * @param size - The returned size.\n     */\n    getSize(size = new Vector3()): Vector3 {\n        return size.copy(this.extents).multiplyScalar(2);\n    }\n\n    /**\n     * Gets the orientation matrix of this `OrientedBox3`.\n     * @param matrix - The output orientation matrix.\n     */\n    getRotationMatrix(matrix: Matrix4 = new Matrix4()): Matrix4 {\n        return matrix.makeBasis(this.xAxis, this.yAxis, this.zAxis);\n    }\n\n    /**\n     * Checks intersection with the given `THREE.Frustum` or array of `THREE.Plane`s.\n     *\n     * @param frustumOrPlanes - Frustum or array of planes.\n     */\n    intersects(frustumOrPlanes: Plane[] | Frustum): boolean {\n        const planes: Plane[] = Array.isArray(frustumOrPlanes)\n            ? frustumOrPlanes\n            : frustumOrPlanes.planes;\n\n        for (const plane of planes) {\n            const r =\n                Math.abs(plane.normal.dot(this.xAxis) * this.extents.x) +\n                Math.abs(plane.normal.dot(this.yAxis) * this.extents.y) +\n                Math.abs(plane.normal.dot(this.zAxis) * this.extents.z);\n\n            const d = plane.distanceToPoint(this.position);\n\n            if (d + r < 0) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Checks intersection with the given ray.\n     *\n     * @param ray - The ray to test.\n     * @returns distance from ray origin to intersection point if it exist, undefined otherwise.\n     */\n    intersectsRay(ray: Ray): number | undefined {\n        // Slabs intersection algorithm.\n        tmpT.min = -Infinity;\n        tmpT.max = Infinity;\n        tmpVec.copy(this.position).sub(ray.origin);\n        if (!intersectsSlab(ray.direction, tmpVec, this.xAxis, this.extents.x, tmpT)) {\n            return undefined;\n        }\n        if (!intersectsSlab(ray.direction, tmpVec, this.yAxis, this.extents.y, tmpT)) {\n            return undefined;\n        }\n        if (!intersectsSlab(ray.direction, tmpVec, this.zAxis, this.extents.z, tmpT)) {\n            return undefined;\n        }\n\n        return tmpT.min > 0 ? tmpT.min : tmpT.max;\n    }\n\n    /**\n     * Returns true if this {@link OrientedBox3} contains the given point.\n     *\n     * @param point - A valid point.\n     */\n    contains(point: Vector3): boolean {\n        const dx = point.x - this.position.x;\n        const dy = point.y - this.position.y;\n        const dz = point.z - this.position.z;\n        const x = Math.abs(dx * this.xAxis.x + dy * this.xAxis.y + dz * this.xAxis.z);\n        const y = Math.abs(dx * this.yAxis.x + dy * this.yAxis.y + dz * this.yAxis.z);\n        const z = Math.abs(dx * this.zAxis.x + dy * this.zAxis.y + dz * this.zAxis.z);\n        if (x > this.extents.x || y > this.extents.y || z > this.extents.z) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns the distance from this {@link OrientedBox3} and the given `point`.\n     *\n     * @param point - A point.\n     */\n    distanceToPoint(point: Vector3): number {\n        return Math.sqrt(this.distanceToPointSquared(point));\n    }\n\n    /**\n     * Returns the squared distance from this {@link OrientedBox3} and the given `point`.\n     *\n     * @param point - A point.\n     */\n    distanceToPointSquared(point: Vector3): number {\n        const d = new Vector3();\n        d.subVectors(point, this.position);\n\n        const lengths = [d.dot(this.xAxis), d.dot(this.yAxis), d.dot(this.zAxis)];\n\n        let result = 0;\n\n        for (let i = 0; i < 3; ++i) {\n            const length = lengths[i];\n            const extent = this.extents.getComponent(i);\n            if (length < -extent) {\n                const dd = extent + length;\n                result += dd * dd;\n            } else if (length > extent) {\n                const dd = length - extent;\n                result += dd * dd;\n            }\n        }\n\n        return result;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport * from \"./lib/GroupedPriorityList\";\nexport * from \"./lib/Logger\";\nexport * from \"./lib/Math2D\";\nexport * from \"./lib/MathUtils\";\nexport * from \"./lib/Mixins\";\nexport * from \"./lib/assert\";\nexport * from \"./lib/CachedResource\";\nexport * from \"./lib/ContextLogger\";\nexport * from \"./lib/PerformanceTimer\";\nexport * from \"./lib/ObjectUtils\";\nexport * from \"./lib/OptionsUtils\";\nexport * from \"./lib/UriResolver\";\nexport * from \"./lib/UrlUtils\";\nexport * from \"./lib/Functions\";\nexport * from \"./lib/SampleBilinear\";\nexport * from \"./lib/AuthenticationUtils\";\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * A `PriorityListElement` has a priority to assist in sorting. The idea is that the items in a\n * grouped priority list will not modify their priority during processing to such an amount, that\n * they will change into another group. Smaller lists are smaller to sort, and in case of resource\n * limitation (maximum number of rendered objects reached), not all items have to be sorted at all.\n */\nexport interface PriorityListElement {\n    /**\n     * The integer value of this priority is used to group objects of \"same\" priority.\n     */\n    priority: number;\n}\n\n/**\n * The `PriorityListGroup` contains a list of {@link PriorityListElement}s that all have the same\n * (integer) priority.\n */\nexport class PriorityListGroup<T extends PriorityListElement> {\n    constructor(readonly priority: number, public elements: T[] = new Array()) {}\n\n    /**\n     * Create and return a deep copy of the `PriorityListGroup<T>`.\n     *\n     * @returns A clone of the `PriorityListGroup<T>`.\n     */\n    clone(): PriorityListGroup<T> {\n        return new PriorityListGroup<T>(this.priority, this.elements.slice());\n    }\n\n    /**\n     * Removes an element from the group.\n     * @param element - The element to remove.\n     * @returns true if the element was removed, false if it was not found in the group.\n     */\n    remove(element: T): boolean {\n        const foundIndex = this.elements.indexOf(element);\n        if (foundIndex === -1) {\n            return false;\n        }\n        this.elements.splice(foundIndex, 1);\n        return true;\n    }\n}\n\n/**\n * The `PriorityListGroupMap` is a map to map the (integer) priority to a {@link PriorityListGroup}.\n */\nexport type PriorityListGroupMap<T extends PriorityListElement> = Map<number, PriorityListGroup<T>>;\n\n/**\n * The `GroupedPriorityList` contains a [[PriorityListGroupMap]] to manage a larger number of items\n * in priority groups.\n */\nexport class GroupedPriorityList<T extends PriorityListElement> {\n    readonly groups: PriorityListGroupMap<T> = new Map();\n    /**\n     * Add an element to the `GroupedPriorityList`. Selects group based on the elements priority.\n     *\n     * @param element - Element to be added.\n     */\n    add(element: T): void {\n        this.getGroup(element.priority).elements.push(element);\n    }\n\n    /**\n     * Remove an element from the `GroupedPriorityList`.\n     *\n     * Note: It is required that the priority is the same as it was when the element has been added.\n     * Otherwise, the removal will fail.\n     *\n     * @param element - Element to be removed.\n     * @returns `True` if the element was removed, `false` otherwise.\n     */\n    remove(element: T): boolean {\n        const group = this.findGroup(element.priority);\n        if (group !== undefined && group.remove(element)) {\n            if (group.elements.length === 0) {\n                this.groups.delete(group.priority);\n            }\n\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Remove all internal {@link PriorityListGroup}s.\n     */\n    clear(): void {\n        this.groups.clear();\n    }\n\n    /**\n     * Merge another {@link GroupedPriorityList} into this one.\n     *\n     * @param other - Other group to merge.\n     */\n    merge(other: GroupedPriorityList<T>): GroupedPriorityList<T> {\n        for (const otherGroup of other.groups) {\n            const group = this.findGroup(otherGroup[1].priority);\n            if (group === undefined) {\n                this.groups.set(Math.floor(otherGroup[1].priority), otherGroup[1].clone());\n                continue;\n            }\n            group.elements = group.elements.concat(otherGroup[1].elements);\n        }\n        return this;\n    }\n\n    clone(): GroupedPriorityList<T> {\n        const clone = new GroupedPriorityList<T>();\n        for (const [priority, group] of this.groups) {\n            clone.groups.set(priority, group.clone());\n        }\n        return clone;\n    }\n\n    /**\n     * Apply function to all elements in this `GroupedPriorityList`.\n     *\n     * @param {(element: T) => void} fun Function to apply.\n     */\n    forEach(fun: (element: T) => void): void {\n        for (const group of this.groups) {\n            group[1].elements.forEach(fun);\n        }\n    }\n\n    /**\n     * Count the number of elements in this `GroupedPriorityList`.\n     */\n    count(): number {\n        let n = 0;\n        for (const group of this.groups) {\n            n += group[1].elements.length;\n        }\n        return n;\n    }\n\n    /**\n     * Get group of elements that have the same (integer) priority.\n     *\n     * @param priority - The priority to retrieve all elements from.\n     */\n    private findGroup(priority: number): PriorityListGroup<T> | undefined {\n        const normalizedPriority = Math.floor(priority);\n        const group = this.groups.get(normalizedPriority);\n        return group;\n    }\n\n    /**\n     * Get group of elements that have the same (integer) priority.\n     *\n     * @param priority - The priority to retrieve all elements from.\n     */\n    private getGroup(priority: number): PriorityListGroup<T> {\n        let group = this.findGroup(priority);\n\n        if (group === undefined) {\n            const normalizedPriority = Math.floor(priority);\n            group = new PriorityListGroup<T>(normalizedPriority);\n            this.groups.set(group.priority, group);\n        }\n\n        return group;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport * from \"./ConsoleChannel\";\nexport * from \"./IChannel\";\nexport * from \"./ILogger\";\nexport * from \"./Logger\";\nexport * from \"./LoggerManager\";\nexport * from \"./MultiChannel\";\nexport * from \"./WorkerChannel\";\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ILoggerManager } from \"./ILoggerManager\";\nimport { LoggerManagerImpl } from \"./LoggerManagerImpl\";\n\n/**\n * The LoggerManager class implements a singleton object that handles logging.\n *\n * Example:\n *\n * ```typescript\n *\n * const logger = LoggerManager.instance.create(\"MyFontLoaderClass\");\n * if (missingFonts.length > 0) {\n *     logger.error(\"These fonts can not be loaded: \", missingFonts);\n * } else {\n *     logger.log(\"All fonts have been loaded.\");\n * }\n * ```\n */\nexport class LoggerManager {\n    private static m_instance: ILoggerManager;\n\n    static get instance(): ILoggerManager {\n        return this.m_instance || (this.m_instance = new LoggerManagerImpl());\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ConsoleChannel } from \"./ConsoleChannel\";\nimport { IChannel } from \"./IChannel\";\nimport { ILogger, LoggerOptions, LogLevel } from \"./ILogger\";\nimport { ILoggerManager } from \"./ILoggerManager\";\nimport { Logger } from \"./Logger\";\nimport { WorkerChannel } from \"./WorkerChannel\";\n\n/**\n * LoggerManagerImpl is the class for the singleton instance of the logger manager.\n * It handles channels and loggers.\n */\n\nexport class LoggerManagerImpl implements ILoggerManager {\n    channel: IChannel;\n    private readonly m_loggers: ILogger[] = [];\n    private m_levelSetForAll?: LogLevel;\n\n    constructor() {\n        this.channel =\n            typeof self === \"undefined\" || typeof self.document !== \"undefined\"\n                ? new ConsoleChannel()\n                : new WorkerChannel();\n    }\n\n    getLoggerNames(): string[] {\n        return this.m_loggers.map(logger => logger.name);\n    }\n\n    getLogger(name: string): ILogger | undefined {\n        return this.m_loggers.find(logger => logger.name === name);\n    }\n\n    create(loggerName: string, options: LoggerOptions = {}): ILogger {\n        if (\n            this.m_levelSetForAll !== undefined &&\n            (options.level === undefined || options.level < this.m_levelSetForAll)\n        ) {\n            options.level = this.m_levelSetForAll;\n        }\n        const logger = new Logger(loggerName, this.channel, options);\n        this.m_loggers.push(logger);\n        return logger;\n    }\n\n    dispose(logger: ILogger) {\n        const found = this.m_loggers.indexOf(logger);\n        if (found < 0) {\n            throw new Error(`Cannot unregister \"${logger}\" : no such logger registered.`);\n        }\n        this.m_loggers.splice(found, 1);\n    }\n\n    updateAll(options: LoggerOptions) {\n        for (const logger of this.m_loggers) {\n            logger.update(options);\n        }\n    }\n\n    update(loggerName: string, config: LoggerOptions) {\n        for (const logger of this.m_loggers) {\n            if (logger.name === loggerName) {\n                logger.update(config);\n            }\n        }\n    }\n\n    enableAll(enabled: boolean) {\n        for (const logger of this.m_loggers) {\n            logger.enabled = enabled;\n        }\n    }\n\n    enable(loggerName: string, value: boolean) {\n        this.update(loggerName, { enabled: value });\n    }\n\n    setLogLevelForAll(level: LogLevel) {\n        this.m_levelSetForAll = level;\n        for (const logger of this.m_loggers) {\n            logger.level = level;\n        }\n    }\n\n    setLogLevel(loggerName: string, level: LogLevel) {\n        this.update(loggerName, { level });\n    }\n\n    setChannel(channel: IChannel) {\n        this.channel = channel;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { IChannel } from \"./IChannel\";\n\n/**\n * Class allowing mixing several channels.\n */\nexport class MultiChannel implements IChannel {\n    private readonly channels: IChannel[] = [];\n    constructor(...channels: IChannel[]) {\n        this.channels = channels;\n    }\n\n    error(message?: any, ...optionalParams: any[]) {\n        for (const channel of this.channels) {\n            channel.error(message, ...optionalParams);\n        }\n    }\n\n    debug(message?: any, ...optionalParams: any[]) {\n        for (const channel of this.channels) {\n            channel.debug(message, ...optionalParams);\n        }\n    }\n\n    info(message?: any, ...optionalParams: any[]) {\n        for (const channel of this.channels) {\n            channel.info(message, ...optionalParams);\n        }\n    }\n\n    log(message?: any, ...optionalParams: any[]) {\n        for (const channel of this.channels) {\n            channel.log(message, ...optionalParams);\n        }\n    }\n\n    trace(message?: any, ...optionalParams: any[]) {\n        for (const channel of this.channels) {\n            channel.trace(message, ...optionalParams);\n        }\n    }\n\n    warn(message?: any, ...optionalParams: any[]) {\n        for (const channel of this.channels) {\n            channel.warn(message, ...optionalParams);\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport namespace Math2D {\n    /**\n     * Alternative 2D box object with less memory impact (four numbers instead of two min/max\n     * objects with two numbers each). Should be faster.\n     */\n    export class Box {\n        /**\n         * Alternative 2D box object with less memory impact (four numbers instead of two min/max\n         * objects with two numbers each). Should be faster.\n         *\n         * @param x - New X value.\n         * @param y - New y value.\n         * @param w - New w value.\n         * @param h - New h value.\n         */\n        constructor(public x = 0, public y = 0, public w = 0, public h = 0) {}\n\n        /**\n         * Set new values to all properties of the box.\n         *\n         * @param x - New X value.\n         * @param y - New y value.\n         * @param w - New w value.\n         * @param h - New h value.\n         */\n        set(x: number, y: number, w: number, h: number) {\n            this.x = x;\n            this.y = y;\n            this.w = w;\n            this.h = h;\n        }\n\n        /**\n         * Test box for inclusion of point.\n         *\n         * @param x - X coordinate of point.\n         * @param y - Y coordinate of point.\n         */\n        contains(x: number, y: number): boolean {\n            return this.x <= x && this.x + this.w >= x && this.y <= y && this.y + this.h >= y;\n        }\n\n        /**\n         * Test box for inclusion of another box.\n         *\n         * @param other - Box 2 to test for inclusion.\n         */\n        containsBox(other: Box): boolean {\n            const xmax = other.x + other.w;\n            const ymax = other.y + other.h;\n            return (\n                this.contains(other.x, other.y) &&\n                this.contains(xmax, other.y) &&\n                this.contains(other.x, ymax) &&\n                this.contains(xmax, ymax)\n            );\n        }\n\n        /**\n         * Test two boxes for intersection.\n         *\n         * @param other - Box 2 to test for intersection.\n         */\n        intersects(other: Box): boolean {\n            return (\n                this.x <= other.x + other.w &&\n                this.x + this.w >= other.x &&\n                this.y <= other.y + other.h &&\n                this.y + this.h >= other.y\n            );\n        }\n    }\n\n    /**\n     * Box to store UV coordinates.\n     */\n    export interface UvBox {\n        s0: number;\n        t0: number;\n        s1: number;\n        t1: number;\n    }\n\n    /**\n     * Compute squared distance between two 2D points `a` and `b`.\n     *\n     * @param ax - Point a.x\n     * @param ay - Point a.y\n     * @param bx - Point b.x\n     * @param by - Point b.y\n     * @returns Squared distance between the two points\n     */\n    export function distSquared(ax: number, ay: number, bx: number, by: number): number {\n        return (ax - bx) * (ax - bx) + (ay - by) * (ay - by);\n    }\n\n    /**\n     * Computes the squared length of a line.\n     *\n     * @param line - An array of that forms a line via [x,y,z,x,y,z,...] tuples.\n     */\n    export function computeSquaredLineLength(line: number[]): number {\n        let squaredLineLength: number = 0;\n\n        const length = line.length - 4;\n        for (let i = 0; i < length; i += 3) {\n            const xDiff = line[i + 3] - line[i];\n            const yDiff = line[i + 4] - line[i + 1];\n            squaredLineLength += xDiff * xDiff + yDiff * yDiff;\n        }\n        return squaredLineLength;\n    }\n\n    /**\n     * Compute squared distance between a 2D point and a 2D line segment.\n     *\n     * @param px - Test point X\n     * @param py - Test point y\n     * @param l0x - Line segment start X\n     * @param l0y - Line segment start Y\n     * @param l1x - Line segment end X\n     * @param l1y - Line segment end Y\n     * @returns Squared distance between point and line segment\n     */\n    export function distToSegmentSquared(\n        px: number,\n        py: number,\n        l0x: number,\n        l0y: number,\n        l1x: number,\n        l1y: number\n    ): number {\n        const lineLengthSuared = distSquared(l0x, l0y, l1x, l1y);\n        if (lineLengthSuared === 0) {\n            return distSquared(px, py, l0x, l0y);\n        }\n        let t = ((px - l0x) * (l1x - l0x) + (py - l0y) * (l1y - l0y)) / lineLengthSuared;\n        t = Math.max(0, Math.min(1, t));\n        return distSquared(px, py, l0x + t * (l1x - l0x), l0y + t * (l1y - l0y));\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport namespace MathUtils {\n    /**\n     * Ensures that input value fits in a given range.\n     *\n     * @param value - The value to be clamped.\n     * @param min - Minimum value.\n     * @param max - Maximum value.\n     *\n     * @returns Clamped value.\n     */\n    export function clamp(value: number, min: number, max: number): number {\n        return value < min ? min : value > max ? max : value;\n    }\n\n    /**\n     * Returns a linear interpolation between the values of edge0 and edge1 based on the factor.\n     *\n     * Given two known points the linear interpolant between these points may be presented as\n     * straight line. This means that for given factor change the resulting change of return\n     * value is always const.\n     * @see https://en.wikipedia.org/wiki/Linear_interpolation\n     *\n     * @param edge0 -\n     * @param edge1 -\n     * @param factor - Interpolation factor that ranges between: 0 <= x <= 1.\n     */\n    export function lerp(edge0: number, edge1: number, factor: number): number {\n        return edge0 * (1 - factor) + edge1 * factor;\n    }\n\n    /**\n     * Returns a smooth interpolation between the values edge0 and edge1 based on the interpolation\n     * factor x. `0 <= x <= 1`.\n     * @see https://en.wikipedia.org/wiki/Smoothstep\n     *\n     * @param edge0 -\n     * @param edge1 -\n     * @param x -\n     */\n    export function smoothStep(edge0: number, edge1: number, x: number) {\n        // Scale, bias and saturate x to 0..1 range\n        x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n        // Evaluate polynomial\n        return x * x * (3 - 2 * x);\n    }\n\n    /**\n     * Returns a smooth interpolation between the values edge0 and edge1 based on the interpolation\n     * factor x. `0 <= x <= 1`.\n     *\n     * Improved version by Ken Perlin, which has zero 1st- and 2nd-order derivatives at `x = 0` and\n     * `x = 1`:\n     *\n     * @see https://en.wikipedia.org/wiki/Smoothstep\n     *\n     * @param edge0 -\n     * @param edge1 -\n     * @param x -\n     */\n    export function smootherStep(edge0: number, edge1: number, x: number) {\n        // Scale, and clamp x to 0..1 range\n        x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n        // Evaluate polynomial\n        return x * x * x * (x * (x * 6 - 15) + 10);\n    }\n\n    /**\n     * Maps a number from one range to another.\n     *\n     * @param val - The incoming value to be converted.\n     * @param inMin - Lower bound of the value's current range.\n     * @param inMax - Upper bound of the value's current range.\n     * @param outMin - Lower bound of the value's target range.\n     * @param outMax - Upper bound of the value's target range.\n     */\n    export function map(val: number, inMin: number, inMax: number, outMin: number, outMax: number) {\n        return ((val - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;\n    }\n\n    /**\n     * Returns the smaller of the two given numbers. Both numbers may be undefined, in which case\n     * the result is undefined. If only one of the numbers is undefined, the other number is\n     * returned.\n     *\n     * @param a - First number.\n     * @param b - Second number.\n     */\n    export function min2(a: number | undefined, b: number | undefined): number | undefined {\n        let result: number | undefined;\n\n        if (a !== undefined) {\n            result = a;\n        }\n        if (b !== undefined) {\n            result = result === undefined ? b : Math.min(result, b);\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns the larger of the two given numbers. Both numbers may be undefined, in which case\n     * the result is undefined. If only one of the numbers is undefined, the other number is\n     * returned.\n     *\n     * @param a - First number.\n     * @param b - Second number.\n     */\n    export function max2(a: number | undefined, b: number | undefined): number | undefined {\n        let result: number | undefined;\n\n        if (a !== undefined) {\n            result = a;\n        }\n        if (b !== undefined) {\n            result = result === undefined ? b : Math.max(result, b);\n        }\n\n        return result;\n    }\n\n    /**\n     * Checks if the value of a given number is inside an upper or lower bound. The bounds may be\n     * undefined, in which case their value is ignored.\n     *\n     * @param value - Value to check.\n     * @param lowerBound - The lower bound to check the value against.\n     * @param upperBound - The upper bound to check the value against.\n     *\n     * @returns `true` if value is inside the bounds or if the bounds are `undefined`, `false`\n     *          otherwise.\n     */\n    export function isClamped(\n        value: number,\n        lowerBound: number | undefined,\n        upperBound: number | undefined\n    ): boolean {\n        if (lowerBound !== undefined && value < lowerBound) {\n            return false;\n        }\n        if (upperBound !== undefined && value > upperBound) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Smoothly interpolates between two values using cubic formula\n     *\n     * @param startValue -\n     * @param endValue -\n     * @param time -\n     * @returns Result of the interpolation within the range of `[startValue, endValue]`\n     */\n    export function easeInOutCubic(startValue: number, endValue: number, time: number): number {\n        const timeValue =\n            time < 0.5 ? 4 * time * time * time : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1;\n        return startValue + (endValue - startValue) * timeValue;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Copy methods and properties from one prototype into another.\n *\n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n *\n * @param derivedCtor - Class to mix methods and properties into.\n * @param baseCtors - Class to take all methods and properties from.\n */\nexport function applyMixins(derivedCtor: any, baseCtors: any[]) {\n    baseCtors.forEach(baseCtor => {\n        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n            derivedCtor.prototype[name] = baseCtor.prototype[name];\n        });\n    });\n}\n\n/**\n * Copy methods from one prototype into another.\n *\n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n *\n * @param derivedCtor - Class to mix methods into.\n * @param baseCtors - Class to take all methods from.\n */\nexport function applyMixinsWithoutProperties(derivedCtor: any, baseCtors: any[]) {\n    baseCtors.forEach(baseCtor => {\n        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n            const descriptor = Object.getOwnPropertyDescriptor(baseCtor.prototype, name);\n            if (\n                descriptor !== undefined &&\n                descriptor.get === undefined &&\n                name !== \"constructor\"\n            ) {\n                derivedCtor.prototype[name] = baseCtor.prototype[name];\n            }\n        });\n    });\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\ndeclare const process: any;\n\n// cache value, because access to process.env.NODE_ENV is SLOW!\nconst isProduction = process.env.NODE_ENV === \"production\";\n\n//TODO: Make assertHandler configurable\n\n/**\n * Implementation of assert as a development help\n *\n * Note - this is deliberately a global function so that minimizers remove the\n * entire call when building for production.\n *\n * @hidden\n * @param condition - Condition to match, if false, throws an Error(message)\n * @param message - Optional message, defaults to \"ASSERTION failed\"\n */\nexport function assert(condition: boolean, message?: string): void {\n    if (!isProduction) {\n        if (!condition) {\n            throw new Error(message !== undefined ? message : \"ASSERTION failed\");\n        }\n    }\n}\n\nexport function assertExists<T>(element: T | undefined, message?: string): T {\n    if (!isProduction) {\n        if (element === undefined || element === null) {\n            throw new Error(\n                message !== undefined ? message : \"ASSERTION failed: Element is undefined or null\"\n            );\n        }\n    }\n    return element!;\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Refinement of `console` interface only for important information i.e `info`, `warn` and `errors`.\n */\nexport interface ISimpleChannel {\n    info(message?: any, ...optionalParams: any[]): void;\n    warn(message?: any, ...optionalParams: any[]): void;\n    error(message?: any, ...optionalParams: any[]): void;\n}\n\n/**\n * Extension of {@link ISimpleChannel} to support contextual logging by adding stack of prefixes.\n */\nexport interface IContextLogger extends ISimpleChannel {\n    /**\n     * Push \"attribute-like\" context.\n     */\n    pushAttr(name: string): void;\n\n    /**\n     * Push \"index-like\" context.\n     *\n     * Following log messages will be prefixed with `[index]`.\n     */\n    pushIndex(index: string | number): void;\n\n    /**\n     * Remove current context from top of stack.\n     */\n    pop(): void;\n}\n\n/**\n * Context-aware logger that decorates log message with stack-based prefix, emits `headerMessage`\n * before first actual log message.\n */\nexport class ContextLogger implements IContextLogger {\n    private readonly context: string[] = [];\n    private m_headerLogged = false;\n\n    /**\n     * Construct a context-aware logger that logs to `m_logger`.\n     */\n    constructor(readonly m_logger: ISimpleChannel, readonly headerMessage: string) {}\n\n    /**\n     * Push \"attribute-like\" context.\n     *\n     * Following log messages will be prefixed with `name` or `.name` depending on current context.\n     */\n    pushAttr(name: string) {\n        this.context.push(`${this.context.length > 0 ? \".\" : \"\"}${name}`);\n    }\n\n    /**\n     * Push \"index-like\" context.\n     *\n     * Following log messages will be prefixed with `[index]`.\n     */\n    pushIndex(index: string | number) {\n        this.context.push(`[${index}]`);\n    }\n\n    pop() {\n        this.context.pop();\n    }\n\n    // They, are public member functions it's just tslint who doesn't understand this.\n\n    // tslint:disable:member-ordering\n    warn = this.createLogMethod(\"warn\");\n    info = this.createLogMethod(\"info\");\n    error = this.createLogMethod(\"error\");\n    // tslint:enable:member-ordering\n\n    private createLogMethod(severity: \"warn\" | \"info\" | \"error\") {\n        return (message: string, ...rest: any[]) => {\n            if (!this.m_headerLogged) {\n                this.m_logger.info(this.headerMessage);\n                this.m_headerLogged = true;\n            }\n            this.m_logger[severity](`${this.context.join(\"\")}: ${message}`, ...rest);\n        };\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/* tslint:disable:max-line-length */\n/**\n * See:\n * https://developers.google.com/web/updates/2012/08/When-milliseconds-are-not-enough-performance-now\n */\n/* tslint:ensable:max-line-length */\n\nexport class PerformanceTimer {\n    /**\n     * Returns timestamp in milliseconds since page load.\n     *\n     * If the [[DOMHighResTimeStamp]] is supported, the resolution is up to 5 microseconds,\n     * otherwise it is in milliseconds. Timespans are computed by taking the difference between two\n     * samples.\n     *\n     * Example:\n     * ```typescript\n     * const now = PerformanceTimer.now();\n     * // call some expensive function for which you want to check the duration.\n     * const end = PerformanceTimer.now();\n     * const elapsedTime = end - now;\n     * ```\n     */\n    static now(): number {\n        return PerformanceTimer.nowFunc();\n    }\n\n    // tslint:disable-next-line:no-unused-variable\n    private static readonly instance = new PerformanceTimer();\n\n    private static readonly nowFunc: () => number = PerformanceTimer.getNowFunc();\n\n    private static getNowFunc() {\n        if (typeof performance !== \"undefined\" && typeof performance.now !== \"undefined\") {\n            return () => performance.now();\n        }\n\n        // fall back to Date.getTime()\n        return () => {\n            return new Date().getTime();\n        };\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Deep clone of object.\n *\n * Like `JSON.parse(JSON.stringify(obj))`, but supports basic javascript types (string, number,\n * object), `Date` and `RegExp`s and cycles.\n *\n * Throws error if enounters object with `prototype` assuming that in general class instances\n * cannot be reliably cloned by generic algorithm.\n */\nexport function cloneDeep<T>(obj: T): T {\n    const cache: Map<object, object> = new Map();\n    function cloneInternal(src: any): any {\n        if (src === null) {\n            return null;\n        } else if (typeof src === \"object\") {\n            const cached = cache.get(src);\n            if (cached !== undefined) {\n                return cached;\n            }\n\n            if (Array.isArray(src)) {\n                const result: any[] = [];\n                cache.set(src, result);\n                result.length = src.length;\n                for (let i = 0; i < result.length; ++i) {\n                    result[i] = cloneInternal(src[i]);\n                }\n                return result;\n            } else if (src instanceof Date) {\n                const result = new Date(src.getTime());\n                cache.set(src, result);\n                return result;\n            } else if (src instanceof RegExp) {\n                const result = new RegExp(src.source, src.flags);\n                cache.set(src, result);\n                return result;\n            } else if (src.constructor !== Object) {\n                throw new Error(\"cloneDeep doesn't support objects with custom prototypes\");\n            } else {\n                const result: typeof src = {};\n                cache.set(src, result);\n                for (const key in src) {\n                    if (src.hasOwnProperty(key)) {\n                        result[key] = cloneInternal(src[key]);\n                    }\n                }\n                return result;\n            }\n        } else {\n            // string, number, boolean, undefined and functions are returned as is\n            return src;\n        }\n    }\n\n    const r = cloneInternal(obj);\n    cache.clear();\n    return r;\n}\n\n/**\n * Pick `props` from `object.\n *\n * Runtime version of `Pick<T,K>`.\n */\nexport function pick<T extends object, K extends keyof T>(object: T, props: K[]): Pick<T, K> {\n    const result: any = {};\n    for (const propName of props) {\n        if (object.hasOwnProperty(propName)) {\n            result[propName] = object[propName];\n        }\n    }\n    return result;\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Get first defined value.\n *\n * Specialized \"replacement\" for `a || b || c` used frequently to get value from various sources\n * (defaults, configs  constants).\n * In contrast to `||`, this function provides proper typing for usual use cases (constant as last\n * argument) and correct treatment of `null` and `undefined`.\n *\n * If last parameter is \"defined\" then return type is `T`, otherwise return type is `T | undefined`.\n *\n * Usage example:\n *\n *     interface Config {\n *         x?: number;\n *     }\n *     const someConfig: Config = {};\n *     const val: number | undefined = undefined;\n *     const DEFAULT = 5;\n *     const x = getOptionValue(val, someConfig.x, DEFAULT);\n *         // typeof x === 'number' because DEFAULT is defined\n *     const y = getOptionValue(val, someConfig.x);\n *         // typeof y === 'number | undefined' because someConfig.x is possibly undefined\n */\n// specialized overloads with last param defined params overload\nexport function getOptionValue<T>(a: T): T;\nexport function getOptionValue<T>(a: T | undefined, b: T): T;\nexport function getOptionValue<T>(a: T | undefined, b: T | undefined, c: T): T;\nexport function getOptionValue<T>(a: T | undefined, b: T | undefined, c: T | undefined, d: T): T;\nexport function getOptionValue<T>(...values: Array<T | undefined>): T | undefined;\n\nexport function getOptionValue<T>(...values: Array<T | undefined>): T | undefined {\n    for (const candidate of values) {\n        if (candidate !== undefined && candidate !== null) {\n            return candidate;\n        }\n    }\n    return undefined;\n}\n\n/**\n * Merge options into existing parameters object.\n *\n * Convenience helper with _similar_ semantics as:\n *\n *     const finalParams1 = { ...defaults, ... options };\n *     const finalParams2 = Object.assign({}, defaults, options);\n *\n * This function doesn't copy _extra_ properties of `options` that doesn't exist in `defaults`.\n * `defaults` is used as _parameters_ template.\n *\n * This doc uses following notion of `option` and `parameter` terms:\n * * `parameter` is a variable, or 'almost constant' of procedure/function/algorith/object\n *    * `parameter` usually have sensible and usually used default\n *    * `parameter` is always defined (no `undefined`, `null` or `?` in type)\n *    * `parameter` can be overriden by specyfying `option` with same name\n * * `option` means value that may be passed optionally, overrides `parameter` value with same name\n *\n * Usage:\n *\n *     interface FooParams {\n *         useTextures: boolean;\n *         opacity: number;\n *     }\n *\n *     const FOO_DEFAULTS: FooParams = {\n *         useTextures: true,\n *         opacity: 0.8\n *     };\n *\n *     type FooOptions = Partial<FooParams>;\n *\n *     function doSomething(options: FooOptions) {\n *         const params = mergeWithOptions(FOO_DEFAULTS, options);\n *             // typeof params === FooParams\n *             // params.opacity = 0.5\n *             // params.useTextures = true\n *             // params.someOtherOptionFromOtherApi is not defined\n *     }\n *     const opt = {opacity: 0.5, someOtherOptionFromOtherApi: 'aaa'};\n *     doSomething(opt);\n *\n * Rationale:\n *   * both `Object.assign` and spread operator copy extra options\n *   * `Object.assign` & `spread operator` may copy `undefined` and `null`s if they really exist\n *     in options object\n *\n * @param parameters - parmeters template object holding all expected parameters\n * @param options - options object\n * @returns new object with `parameters` overriden by values from `options`\n */\nexport function mergeWithOptions<T extends object>(parameters: T, options?: Partial<T>): T {\n    // NOTE: `as object` needed due to TypeScript bug:\n    //       https://github.com/Microsoft/TypeScript/issues/14409\n    // tslint:disable-next-line:no-object-literal-type-assertion\n    const result = { ...(parameters as object) } as T;\n    if (options === undefined || options === null) {\n        return result;\n    }\n    for (const prop in parameters) {\n        if (parameters.hasOwnProperty(prop)) {\n            const optionValue = options[prop];\n            if (optionValue !== undefined && optionValue !== null) {\n                result[prop] = optionValue as any;\n            }\n        }\n    }\n    return result;\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { resolveReferenceUri } from \"./UrlUtils\";\n\n/**\n * Custom, app-specific URI resolver interface.\n */\nexport interface UriResolver {\n    /**\n     * Attempt to resolve `URI` to `URL`.\n     *\n     * If given resolver doesn't know about this specific kind of `URI`, it should return string as\n     * received.\n     *\n     * @param input - `URI`\n     * @returns actual `URL` if this handler knows how locate given `uri` or original `uri`\n     */\n    resolveUri(uri: string): string;\n}\n\nexport interface PrefixUriResolverDefinition {\n    [prefix: string]: string;\n}\n\n/**\n * Basic, import-map like {@link UriResolver}.\n *\n * Resolves `uris` basing on exact or prefix match of `key` from `definitions`.\n *\n * In definitions, `key` is matched against input uri with following strategy:\n *  - `key` without trailing `/` -> `key` and input `uri` must be identical\n *  - `key` with trailing `/`, -> `key` is treated as \"package prefix\", so `uri` must start with\n *    `key`\n *\n * Example:\n * ```\n * {\n *     \"local://poiMasterList\": \"/assets/poiMasterList.json\"\n *        // will match only 'local://poiMasterList' and resolve `/assets/poiMasterList.json`\n *     \"local://icons/\": \"/assets/icons/\"\n *        // will match only 'local://icons/ANYPATH' (and similar) and resolve to\n *        // `/assets/icons/ANYPATH\n * }\n * ```\n * Inspired by [`WICG` import maps proposal](https://github.com/WICG/import-maps#the-import-map).\n */\nexport class PrefixMapUriResolver implements UriResolver {\n    constructor(readonly definitions: PrefixUriResolverDefinition) {}\n\n    resolveUri(uri: string) {\n        return Object.keys(this.definitions).reduce((r, key) => {\n            if (key.endsWith(\"/\") && r.startsWith(key)) {\n                const newPrefix = this.definitions[key];\n                return newPrefix + r.substr(key.length);\n            } else if (r === key) {\n                return this.definitions[key];\n            }\n            return r;\n        }, uri);\n    }\n}\n\n/**\n * [UriResolver] that resolve relative `uri`s against to parent resource `uri`.\n */\nexport class RelativeUriResolver implements UriResolver {\n    constructor(readonly parentUri: string) {}\n\n    resolveUri(uri: string) {\n        return resolveReferenceUri(this.parentUri, uri);\n    }\n}\n\n/**\n * Compose URI resolvers.\n *\n * Creates new {@link UriResolver} that applies resolvers in orders or arguments.\n *\n * Example:\n *\n *     const themeUrl = ...; // url of parent object\n *     const childUrlResolver = composeUrlResolvers(\n *           new RelativeUriResolver(themeUrl),\n *           defaultUrlResolver\n *     );\n */\nexport function composeUriResolvers(...resolvers: Array<UriResolver | undefined>): UriResolver {\n    return {\n        resolveUri(originalUrl: string) {\n            return resolvers.reduce((url, resolver) => {\n                if (resolver !== undefined) {\n                    return resolver.resolveUri(url);\n                } else {\n                    return url;\n                }\n            }, originalUrl);\n        }\n    };\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Chains two functions for further assigning as one wrapped callback function\n */\nexport function chainCallbacks<T extends (this: unknown, ...args: any[]) => any>(\n    f1: T | null | undefined,\n    f2: T\n): T {\n    return function(this: any, ...args: any[]): ReturnType<T> {\n        if (f1) {\n            f1.apply(this, args);\n        }\n        return f2.apply(this, args);\n    } as T;\n}\n","/*\n * Copyright (C) 2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\ntype TypedArray =\n    | Int8Array\n    | Uint8Array\n    | Int16Array\n    | Uint16Array\n    | Int32Array\n    | Uint32Array\n    | Uint8ClampedArray\n    | Float32Array\n    | Float64Array;\n\n/**\n * Returns a bilinear-interpolated texture sample for a given texture.\n * @param texture - Two-dimensional texture to sample.\n * @param width - Texture width.\n * @param height - Texture height.\n * @param u - Number between 0 and 1 representing the location to sample in the width dimension.\n * @param v - Number between 0 and 1 representing the location to sample in the height dimension.\n */\nexport function sampleBilinear(\n    texture: TypedArray,\n    width: number,\n    height: number,\n    u: number,\n    v: number\n): number {\n    const maxXIndex = width - 1;\n    const maxYIndex = height - 1;\n    // Compute the x and y coordinates relative to the mesh size.\n    const xIndex = u * maxXIndex;\n    const xIndexFloor = Math.floor(xIndex);\n    const yIndex = v * maxYIndex;\n    const yIndexFloor = Math.floor(yIndex);\n    const swIndex = yIndexFloor * width + xIndexFloor;\n    const seIndex = xIndexFloor < maxXIndex ? swIndex + 1 : swIndex;\n    const nwIndex = yIndexFloor < maxYIndex ? swIndex + width : swIndex;\n    const neIndex = xIndexFloor < maxXIndex ? nwIndex + 1 : nwIndex;\n    const swElevation = texture[swIndex];\n    const seElevation = texture[seIndex];\n    const nwElevation = texture[nwIndex];\n    const neElevation = texture[neIndex];\n    // Get the fractional components to do bilinear interpolation.\n    const xFrac = Number.isInteger(xIndex) ? 0 : xIndex - xIndexFloor;\n    const xFracInverse = 1 - xFrac;\n    const yFrac = Number.isInteger(yIndex) ? 0 : yIndex - yIndexFloor;\n    const yFracInverse = 1 - yFrac;\n    // The interpolation is the sum of the four closest neighbours each\n    // multiplied by the diagonal areas.\n    const result =\n        swElevation * xFracInverse * yFracInverse +\n        seElevation * xFrac * yFracInverse +\n        nwElevation * xFracInverse * yFrac +\n        neElevation * xFrac * yFrac;\n    return result;\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { baseUrl } from \"./UrlUtils\";\n\n/**\n * Get base URL for from where relative URLs will be loaded.\n *\n * * In browser, it resolves to `baseUrl(location.href)` i.e document's base URL\n * (see: https://www.w3.org/TR/WD-html40-970917/htmlweb.html#h-5.1.2).\n *\n * * In node, it resolves to `file://${process.cwd()}`.\n */\nexport function getAppBaseUrl() {\n    return baseUrl(window.location.href);\n}\n","// (c) Dean McNamee <dean@gmail.com>, 2012.\n//\n// https://github.com/deanm/css-color-parser-js\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\n// http://www.w3.org/TR/css3-color/\nvar kCSSColorTable = {\n  \"transparent\": [0,0,0,0], \"aliceblue\": [240,248,255,1],\n  \"antiquewhite\": [250,235,215,1], \"aqua\": [0,255,255,1],\n  \"aquamarine\": [127,255,212,1], \"azure\": [240,255,255,1],\n  \"beige\": [245,245,220,1], \"bisque\": [255,228,196,1],\n  \"black\": [0,0,0,1], \"blanchedalmond\": [255,235,205,1],\n  \"blue\": [0,0,255,1], \"blueviolet\": [138,43,226,1],\n  \"brown\": [165,42,42,1], \"burlywood\": [222,184,135,1],\n  \"cadetblue\": [95,158,160,1], \"chartreuse\": [127,255,0,1],\n  \"chocolate\": [210,105,30,1], \"coral\": [255,127,80,1],\n  \"cornflowerblue\": [100,149,237,1], \"cornsilk\": [255,248,220,1],\n  \"crimson\": [220,20,60,1], \"cyan\": [0,255,255,1],\n  \"darkblue\": [0,0,139,1], \"darkcyan\": [0,139,139,1],\n  \"darkgoldenrod\": [184,134,11,1], \"darkgray\": [169,169,169,1],\n  \"darkgreen\": [0,100,0,1], \"darkgrey\": [169,169,169,1],\n  \"darkkhaki\": [189,183,107,1], \"darkmagenta\": [139,0,139,1],\n  \"darkolivegreen\": [85,107,47,1], \"darkorange\": [255,140,0,1],\n  \"darkorchid\": [153,50,204,1], \"darkred\": [139,0,0,1],\n  \"darksalmon\": [233,150,122,1], \"darkseagreen\": [143,188,143,1],\n  \"darkslateblue\": [72,61,139,1], \"darkslategray\": [47,79,79,1],\n  \"darkslategrey\": [47,79,79,1], \"darkturquoise\": [0,206,209,1],\n  \"darkviolet\": [148,0,211,1], \"deeppink\": [255,20,147,1],\n  \"deepskyblue\": [0,191,255,1], \"dimgray\": [105,105,105,1],\n  \"dimgrey\": [105,105,105,1], \"dodgerblue\": [30,144,255,1],\n  \"firebrick\": [178,34,34,1], \"floralwhite\": [255,250,240,1],\n  \"forestgreen\": [34,139,34,1], \"fuchsia\": [255,0,255,1],\n  \"gainsboro\": [220,220,220,1], \"ghostwhite\": [248,248,255,1],\n  \"gold\": [255,215,0,1], \"goldenrod\": [218,165,32,1],\n  \"gray\": [128,128,128,1], \"green\": [0,128,0,1],\n  \"greenyellow\": [173,255,47,1], \"grey\": [128,128,128,1],\n  \"honeydew\": [240,255,240,1], \"hotpink\": [255,105,180,1],\n  \"indianred\": [205,92,92,1], \"indigo\": [75,0,130,1],\n  \"ivory\": [255,255,240,1], \"khaki\": [240,230,140,1],\n  \"lavender\": [230,230,250,1], \"lavenderblush\": [255,240,245,1],\n  \"lawngreen\": [124,252,0,1], \"lemonchiffon\": [255,250,205,1],\n  \"lightblue\": [173,216,230,1], \"lightcoral\": [240,128,128,1],\n  \"lightcyan\": [224,255,255,1], \"lightgoldenrodyellow\": [250,250,210,1],\n  \"lightgray\": [211,211,211,1], \"lightgreen\": [144,238,144,1],\n  \"lightgrey\": [211,211,211,1], \"lightpink\": [255,182,193,1],\n  \"lightsalmon\": [255,160,122,1], \"lightseagreen\": [32,178,170,1],\n  \"lightskyblue\": [135,206,250,1], \"lightslategray\": [119,136,153,1],\n  \"lightslategrey\": [119,136,153,1], \"lightsteelblue\": [176,196,222,1],\n  \"lightyellow\": [255,255,224,1], \"lime\": [0,255,0,1],\n  \"limegreen\": [50,205,50,1], \"linen\": [250,240,230,1],\n  \"magenta\": [255,0,255,1], \"maroon\": [128,0,0,1],\n  \"mediumaquamarine\": [102,205,170,1], \"mediumblue\": [0,0,205,1],\n  \"mediumorchid\": [186,85,211,1], \"mediumpurple\": [147,112,219,1],\n  \"mediumseagreen\": [60,179,113,1], \"mediumslateblue\": [123,104,238,1],\n  \"mediumspringgreen\": [0,250,154,1], \"mediumturquoise\": [72,209,204,1],\n  \"mediumvioletred\": [199,21,133,1], \"midnightblue\": [25,25,112,1],\n  \"mintcream\": [245,255,250,1], \"mistyrose\": [255,228,225,1],\n  \"moccasin\": [255,228,181,1], \"navajowhite\": [255,222,173,1],\n  \"navy\": [0,0,128,1], \"oldlace\": [253,245,230,1],\n  \"olive\": [128,128,0,1], \"olivedrab\": [107,142,35,1],\n  \"orange\": [255,165,0,1], \"orangered\": [255,69,0,1],\n  \"orchid\": [218,112,214,1], \"palegoldenrod\": [238,232,170,1],\n  \"palegreen\": [152,251,152,1], \"paleturquoise\": [175,238,238,1],\n  \"palevioletred\": [219,112,147,1], \"papayawhip\": [255,239,213,1],\n  \"peachpuff\": [255,218,185,1], \"peru\": [205,133,63,1],\n  \"pink\": [255,192,203,1], \"plum\": [221,160,221,1],\n  \"powderblue\": [176,224,230,1], \"purple\": [128,0,128,1],\n  \"rebeccapurple\": [102,51,153,1],\n  \"red\": [255,0,0,1], \"rosybrown\": [188,143,143,1],\n  \"royalblue\": [65,105,225,1], \"saddlebrown\": [139,69,19,1],\n  \"salmon\": [250,128,114,1], \"sandybrown\": [244,164,96,1],\n  \"seagreen\": [46,139,87,1], \"seashell\": [255,245,238,1],\n  \"sienna\": [160,82,45,1], \"silver\": [192,192,192,1],\n  \"skyblue\": [135,206,235,1], \"slateblue\": [106,90,205,1],\n  \"slategray\": [112,128,144,1], \"slategrey\": [112,128,144,1],\n  \"snow\": [255,250,250,1], \"springgreen\": [0,255,127,1],\n  \"steelblue\": [70,130,180,1], \"tan\": [210,180,140,1],\n  \"teal\": [0,128,128,1], \"thistle\": [216,191,216,1],\n  \"tomato\": [255,99,71,1], \"turquoise\": [64,224,208,1],\n  \"violet\": [238,130,238,1], \"wheat\": [245,222,179,1],\n  \"white\": [255,255,255,1], \"whitesmoke\": [245,245,245,1],\n  \"yellow\": [255,255,0,1], \"yellowgreen\": [154,205,50,1]}\n\nfunction clamp_css_byte(i) {  // Clamp to integer 0 .. 255.\n  i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n  return i < 0 ? 0 : i > 255 ? 255 : i;\n}\n\nfunction clamp_css_float(f) {  // Clamp to float 0.0 .. 1.0.\n  return f < 0 ? 0 : f > 1 ? 1 : f;\n}\n\nfunction parse_css_int(str) {  // int or percentage.\n  if (str[str.length - 1] === '%')\n    return clamp_css_byte(parseFloat(str) / 100 * 255);\n  return clamp_css_byte(parseInt(str));\n}\n\nfunction parse_css_float(str) {  // float or percentage.\n  if (str[str.length - 1] === '%')\n    return clamp_css_float(parseFloat(str) / 100);\n  return clamp_css_float(parseFloat(str));\n}\n\nfunction css_hue_to_rgb(m1, m2, h) {\n  if (h < 0) h += 1;\n  else if (h > 1) h -= 1;\n\n  if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;\n  if (h * 2 < 1) return m2;\n  if (h * 3 < 2) return m1 + (m2 - m1) * (2/3 - h) * 6;\n  return m1;\n}\n\nfunction parseCSSColor(css_str) {\n  // Remove all whitespace, not compliant, but should just be more accepting.\n  var str = css_str.replace(/ /g, '').toLowerCase();\n\n  // Color keywords (and transparent) lookup.\n  if (str in kCSSColorTable) return kCSSColorTable[str].slice();  // dup.\n\n  // #abc and #abc123 syntax.\n  if (str[0] === '#') {\n    if (str.length === 4) {\n      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n      if (!(iv >= 0 && iv <= 0xfff)) return null;  // Covers NaN.\n      return [((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n              (iv & 0xf0) | ((iv & 0xf0) >> 4),\n              (iv & 0xf) | ((iv & 0xf) << 4),\n              1];\n    } else if (str.length === 7) {\n      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n      if (!(iv >= 0 && iv <= 0xffffff)) return null;  // Covers NaN.\n      return [(iv & 0xff0000) >> 16,\n              (iv & 0xff00) >> 8,\n              iv & 0xff,\n              1];\n    }\n\n    return null;\n  }\n\n  var op = str.indexOf('('), ep = str.indexOf(')');\n  if (op !== -1 && ep + 1 === str.length) {\n    var fname = str.substr(0, op);\n    var params = str.substr(op+1, ep-(op+1)).split(',');\n    var alpha = 1;  // To allow case fallthrough.\n    switch (fname) {\n      case 'rgba':\n        if (params.length !== 4) return null;\n        alpha = parse_css_float(params.pop());\n        // Fall through.\n      case 'rgb':\n        if (params.length !== 3) return null;\n        return [parse_css_int(params[0]),\n                parse_css_int(params[1]),\n                parse_css_int(params[2]),\n                alpha];\n      case 'hsla':\n        if (params.length !== 4) return null;\n        alpha = parse_css_float(params.pop());\n        // Fall through.\n      case 'hsl':\n        if (params.length !== 3) return null;\n        var h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n        // NOTE(deanm): According to the CSS spec s/l should only be\n        // percentages, but we don't bother and let float or percentage.\n        var s = parse_css_float(params[1]);\n        var l = parse_css_float(params[2]);\n        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        var m1 = l * 2 - m2;\n        return [clamp_css_byte(css_hue_to_rgb(m1, m2, h+1/3) * 255),\n                clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255),\n                clamp_css_byte(css_hue_to_rgb(m1, m2, h-1/3) * 255),\n                alpha];\n      default:\n        return null;\n    }\n  }\n\n  return null;\n}\n\ntry { exports.parseCSSColor = parseCSSColor } catch(e) { }\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    BooleanLiteralExpr,\n    CallExpr,\n    CaseExpr,\n    Env,\n    Expr,\n    ExprScope,\n    ExprVisitor,\n    HasAttributeExpr,\n    InterpolateExpr,\n    LiteralExpr,\n    MatchExpr,\n    NullLiteralExpr,\n    NumberLiteralExpr,\n    ObjectLiteralExpr,\n    StepExpr,\n    StringLiteralExpr,\n    Value,\n    VarExpr\n} from \"./Expr\";\n\nimport { ArrayOperators } from \"./operators/ArrayOperators\";\nimport { CastOperators } from \"./operators/CastOperators\";\nimport { ColorOperators } from \"./operators/ColorOperators\";\nimport { ComparisonOperators } from \"./operators/ComparisonOperators\";\nimport { FeatureOperators } from \"./operators/FeatureOperators\";\nimport { FlowOperators } from \"./operators/FlowOperators\";\nimport { MapOperators } from \"./operators/MapOperators\";\nimport { MathOperators } from \"./operators/MathOperators\";\nimport { MiscOperators } from \"./operators/MiscOperators\";\nimport { ObjectOperators } from \"./operators/ObjectOperators\";\nimport { StringOperators } from \"./operators/StringOperators\";\nimport { TypeOperators } from \"./operators/TypeOperators\";\nimport { VectorOperators } from \"./operators/VectorOperators\";\nimport { RGBA } from \"./RGBA\";\n\nimport * as THREE from \"three\";\nimport { Pixels } from \"./Pixels\";\n\nexport interface OperatorDescriptor {\n    /**\n     * Returns `true` if this operator requires a dynamic execution context (e.g. [\"zoom\"]).\n     */\n    isDynamicOperator?: (call: CallExpr) => boolean;\n\n    /**\n     * Evaluates the given expression.\n     */\n    call: (context: ExprEvaluatorContext, call: CallExpr) => Value;\n\n    /**\n     * Partial evaluate the `call` expression using the given `context`.\n     */\n    partialEvaluate?: (context: ExprEvaluatorContext, call: CallExpr) => Value;\n}\n\nexport interface OperatorDescriptorMap {\n    [name: string]: OperatorDescriptor;\n}\n\nconst operatorDescriptors = new Map<string, OperatorDescriptor>();\n\n/**\n * Promote string literals and values to color and pixel constants.\n *\n * @hidden\n * @internal\n */\nfunction promoteValue(context: ExprEvaluatorContext, expr: Expr): Value {\n    if (expr instanceof StringLiteralExpr) {\n        return expr.promotedValue ?? expr.value;\n    }\n\n    const value = context.evaluate(expr);\n\n    if (typeof value === \"string\") {\n        return RGBA.parse(value) ?? Pixels.parse(value) ?? value;\n    }\n\n    return value;\n}\n\nfunction cubicInterpolate(\n    context: ExprEvaluatorContext,\n    interp: InterpolateExpr,\n    t: number\n): Value {\n    if (t < interp.stops[0][0]) {\n        return promoteValue(context, interp.stops[0][1]);\n    } else if (t >= interp.stops[interp.stops.length - 1][0]) {\n        return promoteValue(context, interp.stops[interp.stops.length - 1][1]);\n    }\n\n    // indices\n    const i1 = interp.stops.findIndex(stop => stop[0] > t);\n    const i0 = Math.max(0, i1 - 1);\n    const iP = i0 === 0 ? i1 : i0 - 1;\n    const iN = i1 < interp.stops.length - 1 ? i1 + 1 : i1 - 1;\n\n    // keys\n    const tP = interp.stops[iP][0];\n    const t0 = interp.stops[i0][0];\n    const t1 = interp.stops[i1][0];\n    const tN = interp.stops[iN][0];\n\n    const dt = (t1 - t0) * 0.5;\n    const wP = dt / (t0 - tP);\n    const wN = dt / (tN - t1);\n    const p = (t - t0) / (t1 - t0);\n    const pp = p * p;\n    const ppp = pp * p;\n\n    // coefficients\n    const cP = -wP * ppp + 2 * wP * pp - wP * p;\n    const c0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;\n    const c1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;\n    const cN = wN * ppp - wN * pp;\n\n    // values\n    const vP = promoteValue(context, interp.stops[iP][1]);\n    const v0 = promoteValue(context, interp.stops[i0][1]);\n    const v1 = promoteValue(context, interp.stops[i1][1]);\n    const vN = promoteValue(context, interp.stops[iN][1]);\n\n    if (\n        typeof vP === \"number\" &&\n        typeof v0 === \"number\" &&\n        typeof v1 === \"number\" &&\n        typeof vN === \"number\"\n    ) {\n        return cP * vP + c0 * v0 + c1 * v1 + cN * vN;\n    } else if (\n        vP instanceof RGBA &&\n        v0 instanceof RGBA &&\n        v1 instanceof RGBA &&\n        vN instanceof RGBA\n    ) {\n        return new RGBA(\n            THREE.MathUtils.clamp(cP * vP.r + c0 * v0.r + c1 * v1.r + cN * vN.r, 0, 1),\n            THREE.MathUtils.clamp(cP * vP.g + c0 * v0.g + c1 * v1.g + cN * vN.g, 0, 1),\n            THREE.MathUtils.clamp(cP * vP.b + c0 * v0.b + c1 * v1.b + cN * vN.b, 0, 1),\n            THREE.MathUtils.clamp(cP * vP.a + c0 * v0.a + c1 * v1.a + cN * vN.a, 0, 1)\n        );\n    } else if (\n        vP instanceof Pixels &&\n        v0 instanceof Pixels &&\n        v1 instanceof Pixels &&\n        vN instanceof Pixels\n    ) {\n        return new Pixels(cP * vP.value + c0 * v0.value + c1 * v1.value + cN * vN.value);\n    } else if (\n        vP instanceof THREE.Color &&\n        v0 instanceof THREE.Color &&\n        v1 instanceof THREE.Color &&\n        vN instanceof THREE.Color\n    ) {\n        return new THREE.Color(\n            cP * vP.r + c0 * v0.r + c1 * v1.r + cN * vN.r,\n            cP * vP.g + c0 * v0.g + c1 * v1.g + cN * vN.g,\n            cP * vP.b + c0 * v0.b + c1 * v1.b + cN * vN.b\n        );\n    } else if (\n        vP instanceof THREE.Vector2 &&\n        v0 instanceof THREE.Vector2 &&\n        v1 instanceof THREE.Vector2 &&\n        vN instanceof THREE.Vector2\n    ) {\n        return new THREE.Vector2(\n            cP * vP.x + c0 * v0.x + c1 * v1.x + cN * vN.x,\n            cP * vP.y + c0 * v0.y + c1 * v1.y + cN * vN.y\n        );\n    } else if (\n        vP instanceof THREE.Vector3 &&\n        v0 instanceof THREE.Vector3 &&\n        v1 instanceof THREE.Vector3 &&\n        vN instanceof THREE.Vector3\n    ) {\n        return new THREE.Vector3(\n            cP * vP.x + c0 * v0.x + c1 * v1.x + cN * vN.x,\n            cP * vP.y + c0 * v0.y + c1 * v1.y + cN * vN.y,\n            cP * vP.z + c0 * v0.z + c1 * v1.z + cN * vN.z\n        );\n    } else if (\n        vP instanceof THREE.Vector4 &&\n        v0 instanceof THREE.Vector4 &&\n        v1 instanceof THREE.Vector4 &&\n        vN instanceof THREE.Vector4\n    ) {\n        return new THREE.Vector4(\n            cP * vP.x + c0 * v0.x + c1 * v1.x + cN * vN.x,\n            cP * vP.y + c0 * v0.y + c1 * v1.y + cN * vN.y,\n            cP * vP.z + c0 * v0.z + c1 * v1.z + cN * vN.z,\n            cP * vP.w + c0 * v0.w + c1 * v1.w + cN * vN.w\n        );\n    } else if (Array.isArray(vP) && Array.isArray(v0) && Array.isArray(v1) && Array.isArray(vN)) {\n        const N = vP.length;\n        const r: number[] = [];\n        for (let i = 0; i < N; ++i) {\n            r[i] = cP * vP[i] + c0 * v0[i] + c1 * v1[i] + cN * vN[i];\n        }\n        return r;\n    }\n\n    throw new Error(`failed to interpolate values`);\n}\n\n/*\n * @hidden\n */\nexport class ExprEvaluatorContext {\n    constructor(\n        readonly evaluator: ExprEvaluator,\n        readonly env: Env,\n        readonly scope: ExprScope,\n        readonly cache?: Map<Expr, Value>\n    ) {}\n\n    /**\n     * Evaluate the given expression.\n     *\n     * @param expr - The {@link Expr} to evaluate.\n     */\n    evaluate(expr: Expr | undefined) {\n        if (expr === undefined) {\n            throw new Error(\"Failed to evaluate expression\");\n        }\n\n        const cachedResult = this.cache?.get(expr);\n\n        if (cachedResult !== undefined) {\n            return cachedResult;\n        }\n\n        const result = expr.accept(this.evaluator, this);\n        this.cache?.set(expr, result);\n        return result;\n    }\n\n    /**\n     * Wraps the given value in an {@link Expr} if needed.\n     *\n     * @param value -\n     */\n    wrapValue(value: Value | Expr): Expr {\n        return Expr.isExpr(value) ? value : LiteralExpr.fromValue(value);\n    }\n}\n\n/**\n * [[ExprEvaluator]] is used to evaluate {@link Expr} in a given environment.\n *\n * @hidden\n */\nexport class ExprEvaluator implements ExprVisitor<Value, ExprEvaluatorContext> {\n    static defineOperator(op: string, builtin: OperatorDescriptor) {\n        operatorDescriptors.set(op, builtin);\n    }\n\n    static defineOperators(builtins: OperatorDescriptorMap) {\n        Object.getOwnPropertyNames(builtins).forEach(p => {\n            this.defineOperator(p, builtins[p]);\n        });\n    }\n\n    /**\n     * Returns the [[OperatorDescriptor]] for the given operator name.\n     * @hidden\n     */\n    static getOperator(op: string): OperatorDescriptor | undefined {\n        return operatorDescriptors.get(op);\n    }\n\n    visitVarExpr(expr: VarExpr, context: ExprEvaluatorContext): Value {\n        const value = context.env.lookup(expr.name);\n        return value !== undefined ? value : null;\n    }\n\n    visitNullLiteralExpr(expr: NullLiteralExpr, context: ExprEvaluatorContext): Value {\n        return null;\n    }\n\n    visitBooleanLiteralExpr(expr: BooleanLiteralExpr, context: ExprEvaluatorContext): Value {\n        return expr.value;\n    }\n\n    visitNumberLiteralExpr(expr: NumberLiteralExpr, context: ExprEvaluatorContext): Value {\n        return expr.value;\n    }\n\n    visitStringLiteralExpr(expr: StringLiteralExpr, context: ExprEvaluatorContext): Value {\n        return expr.value;\n    }\n\n    visitObjectLiteralExpr(expr: ObjectLiteralExpr, context: ExprEvaluatorContext): Value {\n        return expr.value;\n    }\n\n    visitHasAttributeExpr(expr: HasAttributeExpr, context: ExprEvaluatorContext): Value {\n        return context.env.lookup(expr.name) !== undefined;\n    }\n\n    visitMatchExpr(match: MatchExpr, context: ExprEvaluatorContext): Value {\n        const r = context.evaluate(match.value);\n        for (const [label, body] of match.branches) {\n            if (Array.isArray(label) && (label as any[]).includes(r)) {\n                return context.evaluate(body);\n            } else if (label === r) {\n                return context.evaluate(body);\n            }\n        }\n        return context.evaluate(match.fallback);\n    }\n\n    visitCaseExpr(match: CaseExpr, context: ExprEvaluatorContext): Value {\n        if (context.scope === ExprScope.Value) {\n            const firstDynamicCondition = match.branches.findIndex(([condition, _]) =>\n                condition.isDynamic()\n            );\n\n            if (firstDynamicCondition !== -1) {\n                let branches: Array<[Expr, Expr]> | undefined;\n\n                // tslint:disable-next-line: prefer-for-of\n                for (let i = 0; i < match.branches.length; ++i) {\n                    const [condition, body] = match.branches[i];\n\n                    const evaluatedCondition = context.evaluate(condition);\n                    const evaluatedBody = context.evaluate(body);\n\n                    if (i < firstDynamicCondition && Boolean(evaluatedCondition)) {\n                        return evaluatedBody;\n                    }\n\n                    if (!Expr.isExpr(evaluatedCondition) && !Boolean(evaluatedCondition)) {\n                        // skip this branch, it constantly evaluates to false.\n                        continue;\n                    }\n\n                    if (branches === undefined) {\n                        branches = [];\n                    }\n\n                    branches?.push([\n                        context.wrapValue(evaluatedCondition),\n                        context.wrapValue(evaluatedBody)\n                    ]);\n\n                    if (!Expr.isExpr(evaluatedCondition) && Boolean(evaluatedCondition)) {\n                        // skip unreachble expressions\n                        return new CaseExpr(branches, LiteralExpr.fromValue(null));\n                    }\n                }\n\n                const fallback = context.evaluate(match.fallback);\n\n                return branches === undefined\n                    ? fallback\n                    : new CaseExpr(branches, context.wrapValue(fallback));\n            }\n        }\n\n        for (const [condition, body] of match.branches) {\n            if (context.evaluate(condition)) {\n                return context.evaluate(body);\n            }\n        }\n\n        return context.evaluate(match.fallback);\n    }\n\n    visitCallExpr(expr: CallExpr, context: ExprEvaluatorContext): Value {\n        const descriptor = expr.descriptor ?? operatorDescriptors.get(expr.op);\n\n        if (descriptor) {\n            expr.descriptor = descriptor;\n\n            let result: Value;\n\n            if (context.scope === ExprScope.Value && expr.isDynamic()) {\n                if (expr.descriptor.partialEvaluate) {\n                    return expr.descriptor.partialEvaluate(context, expr);\n                }\n\n                const args = expr.args.map(arg => {\n                    return context.wrapValue(context.evaluate(arg));\n                });\n\n                if (args.every((arg, i) => arg === expr.args[i])) {\n                    return expr;\n                }\n\n                result = new CallExpr(expr.op, args);\n            } else {\n                result = descriptor.call(context, expr);\n            }\n\n            return result;\n        }\n\n        throw new Error(`undefined operator '${expr.op}'`);\n    }\n\n    visitStepExpr(expr: StepExpr, context: ExprEvaluatorContext): Value {\n        if (context.scope === ExprScope.Value) {\n            const input = context.evaluate(expr.input);\n            const defaultValue = context.evaluate(expr.defaultValue);\n            return new StepExpr(\n                context.wrapValue(input),\n                context.wrapValue(defaultValue),\n                // tslint:disable-next-line: no-shadowed-variable\n                expr.stops.map(([key, value]) => {\n                    const v = context.evaluate(value);\n                    return [key, context.wrapValue(v)];\n                })\n            );\n        } else {\n            const input = context.evaluate(expr.input);\n\n            if (typeof input !== \"number\") {\n                throw new Error(`input '${input}' must be a number`);\n            }\n\n            if (input < expr.stops[0][0]) {\n                return context.evaluate(expr.defaultValue);\n            }\n\n            let index = expr.stops.findIndex(s => s[0] > input);\n\n            if (index === -1) {\n                index = expr.stops.length;\n            }\n\n            return context.evaluate(expr.stops[index - 1][1]);\n        }\n    }\n\n    visitInterpolateExpr(expr: InterpolateExpr, context: ExprEvaluatorContext): Value {\n        if (context.scope === ExprScope.Value) {\n            const input = context.evaluate(expr.input);\n            return new InterpolateExpr(\n                expr.mode,\n                context.wrapValue(input),\n                expr.stops.map(([key, value]) => {\n                    const v = context.evaluate(value);\n                    return [key, context.wrapValue(v)];\n                })\n            );\n        } else {\n            const param = context.evaluate(expr.input);\n\n            if (typeof param !== \"number\") {\n                throw new Error(`input must be a number`);\n            }\n\n            if (expr.mode[0] === \"cubic\") {\n                return cubicInterpolate(context, expr, param);\n            }\n\n            const keyIndex = expr.stops.findIndex(stop => stop[0] > param);\n\n            if (keyIndex === -1) {\n                // all the keys are smaller than the parameter\n                return context.evaluate(expr.stops[expr.stops.length - 1][1]);\n            } else if (keyIndex === 0) {\n                return context.evaluate(expr.stops[0][1]);\n            }\n\n            const [key, value] = expr.stops[keyIndex];\n            const [prevKey, prevValue] = expr.stops[keyIndex - 1];\n\n            const v0 = promoteValue(context, prevValue);\n\n            let t = 0;\n\n            switch (expr.mode[0]) {\n                case \"discrete\":\n                    return v0;\n\n                case \"linear\":\n                    t = (param - prevKey) / (key - prevKey);\n                    break;\n\n                case \"exponential\": {\n                    const base = expr.mode[1];\n                    t = (Math.pow(base, param - prevKey) - 1) / (Math.pow(base, key - prevKey) - 1);\n                    break;\n                }\n\n                default:\n                    throw new Error(\n                        `interpolation mode ${JSON.stringify(expr.mode)} is not supported`\n                    );\n            }\n\n            const v1 = promoteValue(context, value);\n\n            if (typeof v0 === \"number\" && typeof v1 === \"number\") {\n                return THREE.MathUtils.lerp(v0, v1, t);\n            } else if (v0 instanceof RGBA && v1 instanceof RGBA) {\n                return v0.clone().lerp(v1, t);\n            } else if (v0 instanceof Pixels && v1 instanceof Pixels) {\n                return new Pixels(THREE.MathUtils.lerp(v0.value, v1.value, t));\n            } else if (v0 instanceof THREE.Color && v1 instanceof THREE.Color) {\n                return v0.clone().lerp(v1, t);\n            } else if (v0 instanceof THREE.Vector2 && v1 instanceof THREE.Vector2) {\n                return v0.clone().lerp(v1, t);\n            } else if (v0 instanceof THREE.Vector3 && v1 instanceof THREE.Vector3) {\n                return v0.clone().lerp(v1, t);\n            } else if (v0 instanceof THREE.Vector4 && v1 instanceof THREE.Vector4) {\n                return v0.clone().lerp(v1, t);\n            } else if (Array.isArray(v0) && Array.isArray(v1) && v0.length === v1.length) {\n                return v0.map((x, i) => THREE.MathUtils.lerp(x, (v1 as number[])[i], t));\n            }\n\n            throw new Error(`todo: mix(${JSON.stringify(v0)}, ${JSON.stringify(v1)}, ${t})`);\n        }\n    }\n}\n\nExprEvaluator.defineOperators(CastOperators);\nExprEvaluator.defineOperators(ComparisonOperators);\nExprEvaluator.defineOperators(MathOperators);\nExprEvaluator.defineOperators(StringOperators);\nExprEvaluator.defineOperators(ColorOperators);\nExprEvaluator.defineOperators(TypeOperators);\nExprEvaluator.defineOperators(MiscOperators);\nExprEvaluator.defineOperators(FlowOperators);\nExprEvaluator.defineOperators(ArrayOperators);\nExprEvaluator.defineOperators(ObjectOperators);\nExprEvaluator.defineOperators(FeatureOperators);\nExprEvaluator.defineOperators(MapOperators);\nExprEvaluator.defineOperators(VectorOperators);\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CallExpr, Expr, JsonArray, NumberLiteralExpr, StringLiteralExpr } from \"../Expr\";\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\n\nconst VALID_ELEMENT_TYPES = [\"boolean\", \"number\", \"string\"];\n\nfunction checkElementTypes(arg: Expr, array: JsonArray) {\n    if (!(arg instanceof StringLiteralExpr) || !VALID_ELEMENT_TYPES.includes(arg.value)) {\n        throw new Error(\n            `expected \"boolean\", \"number\" or \"string\" instead of '${JSON.stringify(arg)}'`\n        );\n    }\n\n    const ty = arg.value;\n\n    array.forEach((element, index) => {\n        if (typeof element !== ty) {\n            throw new Error(`expected array element at index ${index} to have type '${ty}'`);\n        }\n    });\n}\n\nfunction checkArrayLength(arg: Expr, array: JsonArray) {\n    if (!(arg instanceof NumberLiteralExpr)) {\n        throw new Error(`missing expected number of elements`);\n    }\n\n    const length = arg.value;\n\n    if (array.length !== length) {\n        throw new Error(`the array must have ${length} element(s)`);\n    }\n}\n\nfunction checkArray(context: ExprEvaluatorContext, arg: Expr) {\n    const value = context.evaluate(arg);\n    if (!Array.isArray(value)) {\n        throw new Error(`'${value}' is not an array`);\n    }\n    return value;\n}\n\nconst operators = {\n    array: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            switch (call.args.length) {\n                case 0:\n                    throw new Error(\"not enough arguments\");\n                case 1:\n                    return checkArray(context, call.args[0]);\n                case 2: {\n                    const array = checkArray(context, call.args[1]);\n                    checkElementTypes(call.args[0], array);\n                    return array;\n                }\n                case 3: {\n                    const array = checkArray(context, call.args[2]);\n                    checkArrayLength(call.args[1], array);\n                    checkElementTypes(call.args[0], array);\n                    return array;\n                }\n                default:\n                    throw new Error(\"too many arguments\");\n            }\n        }\n    },\n    \"make-array\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            if (call.args.length === 0) {\n                throw new Error(\"not enough arguments\");\n            }\n            return [...call.args.map(arg => context.evaluate(arg))];\n        }\n    },\n    at: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const args = call.args;\n            const index = context.evaluate(args[0]);\n            if (typeof index !== \"number\") {\n                throw new Error(`expected the index of the element to retrieve`);\n            }\n            const value = context.evaluate(args[1]);\n            if (!Array.isArray(value)) {\n                throw new Error(`expected an array`);\n            }\n            return index >= 0 && index < value.length ? value[index] : null;\n        }\n    }\n};\n\nexport const ArrayOperators: OperatorDescriptorMap = operators;\nexport type ArrayOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CallExpr } from \"../Expr\";\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\n\nconst operators = {\n    \"to-boolean\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return Boolean(context.evaluate(call.args[0]));\n        }\n    },\n\n    \"to-string\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return String(context.evaluate(call.args[0]));\n        }\n    },\n\n    \"to-number\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            for (const arg of call.args) {\n                const value = Number(context.evaluate(arg));\n                if (!isNaN(value)) {\n                    return value;\n                }\n            }\n            throw new Error(\"cannot convert the value to a number\");\n        }\n    }\n};\n\nexport const CastOperators: OperatorDescriptorMap = operators;\nexport type CastOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { ColorUtils } from \"../ColorUtils\";\nimport { CallExpr, Value } from \"../Expr\";\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\nimport { parseStringEncodedColor } from \"../StringEncodedNumeral\";\n\nconst operators = {\n    alpha: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            let color: Value | undefined = context.evaluate(call.args[0]);\n            if (typeof color === \"string\") {\n                color = parseStringEncodedColor(color);\n            }\n            const alpha = typeof color === \"number\" ? ColorUtils.getAlphaFromHex(color) : 1;\n            return alpha;\n        }\n    },\n    rgba: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const r = context.evaluate(call.args[0]);\n            const g = context.evaluate(call.args[1]);\n            const b = context.evaluate(call.args[2]);\n            const a = context.evaluate(call.args[3]);\n            if (\n                typeof r === \"number\" &&\n                typeof g === \"number\" &&\n                typeof b === \"number\" &&\n                typeof a === \"number\" &&\n                r >= 0 &&\n                g >= 0 &&\n                b >= 0 &&\n                a >= 0 &&\n                a <= 1\n            ) {\n                return rgbaToHex(r, g, b, a);\n            }\n            throw new Error(`unknown color 'rgba(${r},${g},${b},${a})'`);\n        }\n    },\n    rgb: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const r = context.evaluate(call.args[0]);\n            const g = context.evaluate(call.args[1]);\n            const b = context.evaluate(call.args[2]);\n            if (\n                typeof r === \"number\" &&\n                typeof g === \"number\" &&\n                typeof b === \"number\" &&\n                r >= 0 &&\n                g >= 0 &&\n                b >= 0\n            ) {\n                return rgbToHex(r, g, b);\n            }\n            throw new Error(`unknown color 'rgb(${r},${g},${b})'`);\n        }\n    },\n    // Hsl operator contains angle modulated to <0, 360> range, percent of\n    // saturation and lightness in <0, 100> range, i.e. hsl(360, 100, 100)\n    hsl: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const h = context.evaluate(call.args[0]);\n            const s = context.evaluate(call.args[1]);\n            const l = context.evaluate(call.args[2]);\n            if (\n                typeof h === \"number\" &&\n                typeof s === \"number\" &&\n                typeof l === \"number\" &&\n                h >= 0 &&\n                s >= 0 &&\n                l >= 0\n            ) {\n                return hslToHex(h, s, l);\n            }\n            throw new Error(`unknown color 'hsl(${h},${s}%,${l}%)'`);\n        }\n    }\n};\n\nfunction rgbaToHex(r: number, g: number, b: number, a: number): number {\n    // We decode rgba color channels using custom hex format with transparency.\n    return ColorUtils.getHexFromRgba(\n        THREE.MathUtils.clamp(r, 0, 255) / 255,\n        THREE.MathUtils.clamp(g, 0, 255) / 255,\n        THREE.MathUtils.clamp(b, 0, 255) / 255,\n        THREE.MathUtils.clamp(a, 0, 1)\n    );\n}\n\nfunction rgbToHex(r: number, g: number, b: number): number {\n    return ColorUtils.getHexFromRgb(\n        THREE.MathUtils.clamp(r, 0, 255) / 255,\n        THREE.MathUtils.clamp(g, 0, 255) / 255,\n        THREE.MathUtils.clamp(b, 0, 255) / 255\n    );\n}\n\nfunction hslToHex(h: number, s: number, l: number): number {\n    return ColorUtils.getHexFromHsl(\n        THREE.MathUtils.euclideanModulo(h, 360) / 360,\n        THREE.MathUtils.clamp(s, 0, 100) / 100,\n        THREE.MathUtils.clamp(l, 0, 100) / 100\n    );\n}\n\nexport const ColorOperators: OperatorDescriptorMap = operators;\nexport type ColorOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CallExpr } from \"../Expr\";\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\n\nfunction compare(context: ExprEvaluatorContext, call: CallExpr, strict: boolean = false) {\n    const left = context.evaluate(call.args[0]) as any;\n    const right = context.evaluate(call.args[1]) as any;\n\n    if (\n        !(\n            (typeof left === \"number\" && typeof right === \"number\") ||\n            (typeof left === \"string\" && typeof right === \"string\")\n        )\n    ) {\n        if (strict) {\n            throw new Error(`invalid operands '${left}' and '${right}' for operator '${call.op}'`);\n        }\n    }\n\n    switch (call.op) {\n        case \"<\":\n            return left < right;\n        case \">\":\n            return left > right;\n        case \"<=\":\n            return left <= right;\n        case \">=\":\n            return left >= right;\n        default:\n            throw new Error(`invalid comparison operator '${call.op}'`);\n    }\n}\n\nconst operators = {\n    \"!\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return !context.evaluate(call.args[0]);\n        }\n    },\n\n    \"==\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const left = context.evaluate(call.args[0]);\n            const right = context.evaluate(call.args[1]);\n            return left === right;\n        }\n    },\n\n    \"!=\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const left = context.evaluate(call.args[0]);\n            const right = context.evaluate(call.args[1]);\n            return left !== right;\n        }\n    },\n\n    \"<\": { call: (context: ExprEvaluatorContext, call: CallExpr) => compare(context, call) },\n    \">\": { call: (context: ExprEvaluatorContext, call: CallExpr) => compare(context, call) },\n    \"<=\": { call: (context: ExprEvaluatorContext, call: CallExpr) => compare(context, call) },\n    \">=\": { call: (context: ExprEvaluatorContext, call: CallExpr) => compare(context, call) }\n};\n\nexport const ComparisonOperators: OperatorDescriptorMap = operators;\nexport type ComparisonOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Env } from \"../Env\";\nimport { CallExpr, ExprScope } from \"../Expr\";\n\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\n\nconst operators = {\n    \"geometry-type\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const geometryType = context.env.lookup(\"$geometryType\");\n            switch (geometryType) {\n                case \"point\":\n                    return \"Point\";\n                case \"line\":\n                    return \"LineString\";\n                case \"polygon\":\n                    return \"Polygon\";\n                default:\n                    return null;\n            }\n        }\n    },\n    \"feature-state\": {\n        isDynamicOperator: () => true,\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            if (context.scope !== ExprScope.Dynamic) {\n                throw new Error(\"feature-state cannot be used in this context\");\n            }\n            const property = context.evaluate(call.args[0]);\n            if (typeof property !== \"string\") {\n                throw new Error(`expected the name of the property of the feature state`);\n            }\n            const state = context.env.lookup(\"$state\");\n            if (Env.isEnv(state)) {\n                return state.lookup(property) ?? null;\n            } else if (state instanceof Map) {\n                return state.get(property) ?? null;\n            }\n            return null;\n        }\n    },\n    id: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return context.env.lookup(\"$id\") ?? null;\n        }\n    }\n};\n\nexport const FeatureOperators: OperatorDescriptorMap = operators;\nexport type FeatureOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CallExpr, Expr } from \"../Expr\";\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\n\nfunction conditionalCast(context: ExprEvaluatorContext, type: string, args: Expr[]) {\n    switch (type) {\n        case \"boolean\":\n        case \"number\":\n        case \"string\":\n            for (const childExpr of args) {\n                const value = context.evaluate(childExpr);\n                if (typeof value === type) {\n                    return value;\n                }\n            }\n            throw new Error(`expected a '${type}'`);\n        default:\n            throw new Error(`invalid type '${type}'`);\n    } // switch\n}\n\nconst operators = {\n    all: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            for (const childExpr of call.args) {\n                if (!context.evaluate(childExpr)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    },\n\n    any: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            for (const childExpr of call.args) {\n                if (context.evaluate(childExpr)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    },\n\n    none: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            for (const childExpr of call.args) {\n                if (context.evaluate(childExpr)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    },\n\n    boolean: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return conditionalCast(context, \"boolean\", call.args);\n        }\n    },\n\n    number: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return conditionalCast(context, \"number\", call.args);\n        }\n    },\n\n    string: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return conditionalCast(context, \"string\", call.args);\n        }\n    }\n};\n\nexport const FlowOperators: OperatorDescriptorMap = operators;\nexport type FlowOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CallExpr, ExprScope, Value } from \"../Expr\";\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\n\nconst operators = {\n    \"ppi-scale\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]) as number;\n            const scaleFactor = call.args[1] ? (context.evaluate(call.args[1]) as number) : 1;\n            return value * scaleFactor;\n        }\n    },\n    \"world-ppi-scale\": {\n        isDynamicOperator: (): boolean => {\n            return true;\n        },\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const pixels = context.evaluate(call.args[0]) as number;\n            const scaleFactor = call.args[1] ? (context.evaluate(call.args[1]) as number) : 1;\n            const zoom = context.env.lookup(\"$zoom\") as number;\n            const zoomWidth = Math.pow(2, 17) / Math.pow(2, zoom);\n            const v = pixels * zoomWidth * scaleFactor;\n            return v;\n        }\n    },\n    \"world-discrete-ppi-scale\": {\n        isDynamicOperator: (): boolean => {\n            return true;\n        },\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const pixels = context.evaluate(call.args[0]) as number;\n            const scaleFactor = call.args[1] ? (context.evaluate(call.args[1]) as number) : 1;\n            const zoom = context.env.lookup(\"$zoom\") as number;\n            const zoomWidthDiscrete = Math.pow(2, 17.8) / Math.pow(2, Math.floor(zoom));\n            const v = pixels * zoomWidthDiscrete * scaleFactor;\n            return v;\n        }\n    },\n    ppi: {\n        call: (context: ExprEvaluatorContext) => {\n            const ppi = context.env.lookup(\"$ppi\");\n            if (typeof ppi === \"number\") {\n                return ppi;\n            }\n            return 72;\n        }\n    },\n    zoom: {\n        isDynamicOperator: (): boolean => {\n            return true;\n        },\n        call: (context: ExprEvaluatorContext, call: CallExpr): Value => {\n            if (context.scope === ExprScope.Value) {\n                return call;\n            }\n            return context.env.lookup(\"$zoom\") ?? null;\n        }\n    }\n};\n\nexport const MapOperators: OperatorDescriptorMap = operators;\nexport type MapOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CallExpr } from \"../Expr\";\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\n\nimport * as THREE from \"three\";\n\nconst operators = {\n    \"^\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const a = context.evaluate(call.args[0]);\n            const b = context.evaluate(call.args[1]);\n            if (typeof a !== \"number\" || typeof b !== \"number\") {\n                // tslint:disable-next-line: max-line-length\n                throw new Error(\n                    `invalid operands '${typeof a}' and '${typeof b}' for operator '^'`\n                );\n            }\n            return Math.pow(a, b);\n        }\n    },\n\n    \"-\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            if (call.args.length === 1) {\n                const value = context.evaluate(call.args[0]);\n                if (typeof value !== \"number\") {\n                    throw new Error(`nvalid operand '${typeof value} for operator '-'`);\n                }\n\n                return -value;\n            }\n\n            const a = context.evaluate(call.args[0]);\n            const b = context.evaluate(call.args[1]);\n            if (typeof a !== \"number\" || typeof b !== \"number\") {\n                throw new Error(\n                    `invalid operands '${typeof a}' and '${typeof b}' for operator '-'`\n                );\n            }\n            return a - b;\n        }\n    },\n\n    \"/\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const a = context.evaluate(call.args[0]);\n            const b = context.evaluate(call.args[1]);\n            if (typeof a !== \"number\" || typeof b !== \"number\") {\n                // tslint:disable-next-line: max-line-length\n                throw new Error(\n                    `invalid operands '${typeof a}' and '${typeof b}' for operator '/'`\n                );\n            }\n            return a / b;\n        }\n    },\n\n    \"%\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const a = context.evaluate(call.args[0]);\n            const b = context.evaluate(call.args[1]);\n            if (typeof a !== \"number\" || typeof b !== \"number\") {\n                // tslint:disable-next-line: max-line-length\n                throw new Error(\n                    `invalid operands '${typeof a}' and '${typeof b}' for operator '%'`\n                );\n            }\n            return a % b;\n        }\n    },\n\n    \"+\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return call.args.reduce((a, b) => Number(a) + Number(context.evaluate(b)), 0);\n        }\n    },\n\n    \"*\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return call.args.reduce((a, b) => Number(a) * Number(context.evaluate(b)), 1);\n        }\n    },\n\n    abs: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'abs'`);\n            }\n            return Math.abs(value);\n        }\n    },\n\n    acos: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'acos'`);\n            }\n            return Math.acos(value);\n        }\n    },\n\n    asin: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'asin'`);\n            }\n            return Math.asin(value);\n        }\n    },\n\n    atan: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'atan'`);\n            }\n            return Math.atan(value);\n        }\n    },\n\n    ceil: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'ceil'`);\n            }\n            return Math.ceil(value);\n        }\n    },\n\n    cos: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'cos'`);\n            }\n            return Math.cos(value);\n        }\n    },\n\n    e: {\n        call: () => {\n            return Math.E;\n        }\n    },\n\n    floor: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'floor'`);\n            }\n            return Math.floor(value);\n        }\n    },\n\n    ln: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'ln'`);\n            }\n            return Math.log(value);\n        }\n    },\n\n    ln2: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'ln2'`);\n            }\n            return Math.log2(value);\n        }\n    },\n\n    log10: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'log10'`);\n            }\n            return Math.log10(value);\n        }\n    },\n\n    max: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return Math.max(...call.args.map(v => Number(context.evaluate(v))));\n        }\n    },\n\n    min: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return Math.min(...call.args.map(v => Number(context.evaluate(v))));\n        }\n    },\n\n    /**\n     * Clamp numeric value to given range, inclusive.\n     *\n     * Synopsis:\n     * ```\n     * [\"clamp\", v: number, min: number, max: number]`\n     * ```\n     */\n    clamp: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const v = context.evaluate(call.args[0]);\n            const min = context.evaluate(call.args[1]);\n            const max = context.evaluate(call.args[2]);\n\n            if (typeof v !== \"number\" || typeof min !== \"number\" || typeof max !== \"number\") {\n                throw new Error(`invalid operands '${v}', ${min}, ${max} for operator 'clamp'`);\n            }\n            return THREE.MathUtils.clamp(v, min, max);\n        }\n    },\n\n    pi: {\n        call: () => {\n            return Math.PI;\n        }\n    },\n\n    round: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'round'`);\n            }\n            return Math.round(value);\n        }\n    },\n\n    sin: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'sin'`);\n            }\n            return Math.sin(value);\n        }\n    },\n\n    sqrt: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'sqrt'`);\n            }\n            return Math.sqrt(value);\n        }\n    },\n\n    tan: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'tan'`);\n            }\n            return Math.tan(value);\n        }\n    }\n};\n\nexport const MathOperators: OperatorDescriptorMap = operators;\nexport type MathOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CallExpr } from \"../Expr\";\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\n\nconst operators = {\n    length: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (Array.isArray(value) || typeof value === \"string\") {\n                return value.length;\n            }\n            throw new Error(`invalid operand '${value}' for operator 'length'`);\n        }\n    },\n    coalesce: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            for (const childExpr of call.args) {\n                const value = context.evaluate(childExpr);\n                if (value !== null) {\n                    return value;\n                }\n            }\n            return null;\n        }\n    }\n};\n\nexport const MiscOperators: OperatorDescriptorMap = operators;\nexport type MiscOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CallExpr, Expr, ExprScope } from \"../Expr\";\n\nimport { Env } from \"../Env\";\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nenum LookupMode {\n    get,\n    has\n}\n\nfunction lookupMember(context: ExprEvaluatorContext, args: Expr[], lookupMode: LookupMode) {\n    const memberName = context.evaluate(args[0]);\n\n    if (typeof memberName !== \"string\") {\n        throw new Error(`expected the name of an attribute`);\n    }\n\n    const object = context.evaluate(args[1]) as any;\n\n    if (object && typeof object === \"object\") {\n        if (Env.isEnv(object)) {\n            const value = object.lookup(memberName) ?? null;\n            return lookupMode === LookupMode.get ? value : value !== null;\n        }\n        if (hasOwnProperty.call(object, memberName)) {\n            return lookupMode === LookupMode.get ? object[memberName] : true;\n        }\n    }\n\n    return lookupMode === LookupMode.get ? null : false;\n}\n\nconst operators = {\n    in: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            const object = context.evaluate(call.args[1]);\n            if (typeof value === \"string\" && typeof object === \"string\") {\n                return object.includes(value);\n            } else if (Array.isArray(object)) {\n                return object.includes(value);\n            }\n            return false;\n        }\n    },\n\n    get: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) =>\n            lookupMember(context, call.args, LookupMode.get)\n    },\n\n    has: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) =>\n            lookupMember(context, call.args, LookupMode.has)\n    },\n\n    \"dynamic-properties\": {\n        isDynamicOperator: () => true,\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            if (context.scope === ExprScope.Dynamic) {\n                return context.env;\n            }\n            return call;\n        }\n    }\n};\n\nexport const ObjectOperators: OperatorDescriptorMap = operators;\nexport type ObjectOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CallExpr } from \"../Expr\";\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\n\nconst operators = {\n    concat: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return \"\".concat(...call.args.map(a => String(context.evaluate(a))));\n        }\n    },\n\n    downcase: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return String(context.evaluate(call.args[0])).toLocaleLowerCase();\n        }\n    },\n\n    upcase: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return String(context.evaluate(call.args[0])).toLocaleUpperCase();\n        }\n    },\n\n    \"~=\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const left = context.evaluate(call.args[0]);\n            const right = context.evaluate(call.args[1]);\n            if (typeof left === \"string\" && typeof right === \"string\") {\n                return left.indexOf(right) !== -1;\n            }\n            return false;\n        }\n    },\n\n    \"^=\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const left = context.evaluate(call.args[0]);\n            const right = context.evaluate(call.args[1]);\n            if (typeof left === \"string\" && typeof right === \"string\") {\n                return left.startsWith(right);\n            }\n            return false;\n        }\n    },\n\n    \"$=\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const left = context.evaluate(call.args[0]);\n            const right = context.evaluate(call.args[1]);\n            if (typeof left === \"string\" && typeof right === \"string\") {\n                return left.endsWith(right);\n            }\n            return false;\n        }\n    }\n};\n\nexport const StringOperators: OperatorDescriptorMap = operators;\nexport type StringOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CallExpr } from \"../Expr\";\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\n\nconst operators = {\n    typeof: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return typeof context.evaluate(call.args[0]);\n        }\n    }\n};\n\nexport const TypeOperators: OperatorDescriptorMap = operators;\nexport type TypeOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Value } from \"../Env\";\nimport { CallExpr, NumberLiteralExpr } from \"../Expr\";\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\n\nimport * as THREE from \"three\";\n\ntype MakeVectorCallExpr = CallExpr & {\n    _value?: THREE.Vector2 | THREE.Vector3 | THREE.Vector4;\n};\n\nfunction isVector(\n    context: ExprEvaluatorContext,\n    call: CallExpr,\n    type: \"vector2\" | \"vector3\" | \"vector4\"\n): Value {\n    let ctor: new () => object;\n    switch (type) {\n        case \"vector2\":\n            ctor = THREE.Vector2;\n            break;\n        case \"vector3\":\n            ctor = THREE.Vector3;\n            break;\n        case \"vector4\":\n            ctor = THREE.Vector4;\n            break;\n    }\n    for (const childExpr of call.args) {\n        const value = context.evaluate(childExpr);\n        if (value instanceof ctor) {\n            return value;\n        }\n    }\n    throw new Error(`expected a \"${type}\"`);\n}\n\nfunction toVector(\n    context: ExprEvaluatorContext,\n    call: CallExpr,\n    type: \"vector2\" | \"vector3\" | \"vector4\"\n): Value {\n    let VectorCtor: any;\n    let components: number;\n\n    switch (type) {\n        case \"vector2\":\n            VectorCtor = THREE.Vector2;\n            components = 2;\n            break;\n        case \"vector3\":\n            VectorCtor = THREE.Vector3;\n            components = 3;\n            break;\n        case \"vector4\":\n            VectorCtor = THREE.Vector4;\n            components = 4;\n            break;\n    }\n\n    for (const childExpr of call.args) {\n        const value = context.evaluate(childExpr);\n        if (value instanceof VectorCtor) {\n            return value;\n        } else if (\n            Array.isArray(value) &&\n            value.length === components &&\n            value.every(v => typeof v === \"number\")\n        ) {\n            return new VectorCtor().fromArray(value);\n        }\n    }\n    throw new Error(`expected a \"${type}\"`);\n}\n\nconst operators = {\n    \"make-vector\": {\n        call: (context: ExprEvaluatorContext, call: MakeVectorCallExpr) => {\n            if (call._value !== undefined) {\n                return call._value;\n            }\n\n            if (call.args.length < 2) {\n                throw new Error(\"not enough arguments\");\n            } else if (call.args.length > 4) {\n                throw new Error(\"too many arguments\");\n            }\n\n            const components = call.args.map(arg => context.evaluate(arg)) as number[];\n\n            components.forEach((element, index) => {\n                if (typeof element !== \"number\") {\n                    throw new Error(\n                        `expected vector component at index ${index} to have type \"number\"`\n                    );\n                }\n            });\n\n            let result: THREE.Vector2 | THREE.Vector3 | THREE.Vector4 | undefined;\n\n            switch (components.length) {\n                case 2:\n                    result = new THREE.Vector2().fromArray(components);\n                    break;\n                case 3:\n                    result = new THREE.Vector3().fromArray(components);\n                    break;\n                case 4:\n                    result = new THREE.Vector4().fromArray(components);\n                    break;\n                default:\n                    throw new Error(\"too many arguments\");\n            }\n\n            if (call.args.every(arg => arg instanceof NumberLiteralExpr)) {\n                call._value = result;\n            }\n\n            return result;\n        }\n    },\n    vector2: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => isVector(context, call, \"vector2\")\n    },\n    vector3: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => isVector(context, call, \"vector3\")\n    },\n    vector4: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => isVector(context, call, \"vector4\")\n    },\n    \"to-vector2\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => toVector(context, call, \"vector2\")\n    },\n    \"to-vector3\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => toVector(context, call, \"vector3\")\n    },\n    \"to-vector4\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => toVector(context, call, \"vector4\")\n    }\n};\n\nexport const VectorOperators: OperatorDescriptorMap = operators;\nexport type VectorOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    BooleanLiteralExpr,\n    CallExpr,\n    CaseExpr,\n    Expr,\n    ExprScope,\n    ExprVisitor,\n    HasAttributeExpr,\n    InterpolateExpr,\n    LiteralExpr,\n    MatchExpr,\n    MatchLabel,\n    NullLiteralExpr,\n    NumberLiteralExpr,\n    ObjectLiteralExpr,\n    StepExpr,\n    StringLiteralExpr,\n    VarExpr\n} from \"./Expr\";\n\nimport { Env } from \"./Env\";\n\nexport interface InstantiationContext {\n    /**\n     * The {@link Env} used to lookup for names.\n     */\n    env: Env;\n\n    /**\n     * The names to preserve during the instantiation.\n     */\n    preserve?: Set<string>;\n}\n\nconst emptyEnv = new Env();\n\n/**\n * @hidden\n */\nexport class ExprInstantiator implements ExprVisitor<Expr, InstantiationContext> {\n    visitNullLiteralExpr(expr: NullLiteralExpr, _context: InstantiationContext): Expr {\n        return expr;\n    }\n\n    visitBooleanLiteralExpr(expr: BooleanLiteralExpr, _context: InstantiationContext): Expr {\n        return expr;\n    }\n\n    visitNumberLiteralExpr(expr: NumberLiteralExpr, _context: InstantiationContext): Expr {\n        return expr;\n    }\n\n    visitStringLiteralExpr(expr: StringLiteralExpr, _context: InstantiationContext): Expr {\n        return expr;\n    }\n\n    visitObjectLiteralExpr(expr: ObjectLiteralExpr, _context: InstantiationContext): Expr {\n        return expr;\n    }\n\n    visitVarExpr(expr: VarExpr, context: InstantiationContext): Expr {\n        if (context.preserve && context.preserve.has(expr.name)) {\n            return expr;\n        }\n        const value = context.env.lookup(expr.name);\n        return LiteralExpr.fromValue(value !== undefined ? value : null);\n    }\n\n    visitHasAttributeExpr(expr: HasAttributeExpr, context: InstantiationContext): Expr {\n        if (context.preserve && context.preserve.has(expr.name)) {\n            return expr;\n        }\n        const value = context.env.lookup(expr.name) !== undefined;\n        return LiteralExpr.fromValue(value);\n    }\n\n    visitCallExpr(expr: CallExpr, context: InstantiationContext): Expr {\n        const args = expr.args.map(arg => arg.accept(this, context));\n        if (args.some((a, i) => a !== expr.args[i])) {\n            return new CallExpr(expr.op, args);\n        }\n        return expr;\n    }\n\n    visitMatchExpr(match: MatchExpr, context: InstantiationContext): Expr {\n        const value = match.value.accept(this, context);\n\n        if (value instanceof LiteralExpr) {\n            const r = value.value;\n            for (const [label, body] of match.branches) {\n                if (Array.isArray(label) && (label as any[]).includes(r)) {\n                    return body.accept(this, context);\n                } else if (label === r) {\n                    return body.accept(this, context);\n                }\n            }\n            return match.fallback.accept(this, context);\n        }\n\n        let changed = match.value !== value;\n\n        const branches: Array<[MatchLabel, Expr]> = match.branches.map(([label, branch]) => {\n            const newBranch = branch.accept(this, context);\n            if (newBranch !== branch) {\n                changed = true;\n            }\n            return [label, newBranch];\n        });\n\n        const fallback = match.fallback.accept(this, context);\n\n        if (fallback !== match.fallback) {\n            changed = true;\n        }\n\n        return changed ? new MatchExpr(value, branches, fallback) : match;\n    }\n\n    visitCaseExpr(expr: CaseExpr, context: InstantiationContext): Expr {\n        const branches: Array<[Expr, Expr]> = [];\n\n        let changed = false;\n\n        for (const [condition, branch] of expr.branches) {\n            const newCondition = condition.accept(this, context);\n            const deps = newCondition.dependencies();\n            if (!condition.isDynamic() && deps.properties.size === 0) {\n                if (Boolean(newCondition.evaluate(emptyEnv, ExprScope.Condition))) {\n                    return branch.accept(this, context);\n                }\n            } else {\n                if (newCondition !== condition) {\n                    changed = true;\n                }\n                branches.push([newCondition, branch]);\n            }\n        }\n\n        if (branches.length === 0) {\n            // all the conditions of this CaseExpr evaluated\n            // to false, so the resulting of instantiating this CaseExpr\n            // is the same as instantiating its fallback expression.\n            return expr.fallback.accept(this, context);\n        }\n\n        if (branches.length !== expr.branches.length) {\n            // the number of branches changed, this means that\n            // some of the branches had constant expressions that\n            // evaluate to false. In this case the resulting\n            // `CaseExpr` has less branches.\n            changed = true;\n        }\n\n        // Instantiate the body of all the branches of this CaseExpr\n        // that have dynamic conditions.\n        branches.forEach(branch => {\n            const instantiatedBranch = branch[1].accept(this, context);\n\n            if (instantiatedBranch !== branch[1]) {\n                changed = true;\n            }\n\n            branch[1] = instantiatedBranch;\n        });\n\n        const fallback = expr.fallback.accept(this, context);\n\n        if (fallback !== expr.fallback) {\n            changed = true;\n        }\n\n        if (!changed) {\n            // nothing changed, return the old expression.\n            return expr;\n        }\n\n        return new CaseExpr(branches, fallback);\n    }\n\n    visitStepExpr(expr: StepExpr, context: InstantiationContext): Expr {\n        const input = expr.input.accept(this, context);\n        const defaultValue = expr.defaultValue.accept(this, context);\n        const stops: Array<[number, Expr]> = expr.stops.map(([key, value]) => [\n            key,\n            value.accept(this, context)\n        ]);\n        return new StepExpr(input, defaultValue, stops);\n    }\n\n    visitInterpolateExpr(expr: InterpolateExpr, context: InstantiationContext): Expr {\n        const input = expr.input.accept(this, context);\n        const stops: Array<[number, Expr]> = expr.stops.map(([key, value]) => [\n            key,\n            value.accept(this, context)\n        ]);\n        return new InterpolateExpr(expr.mode, input, stops);\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    CallExpr,\n    EqualityOp,\n    Expr,\n    HasAttributeExpr,\n    LiteralExpr,\n    NumberLiteralExpr,\n    RelationalOp,\n    StringLiteralExpr,\n    VarExpr\n} from \"./Expr\";\n\n/**\n * Character value\n */\nenum Character {\n    Tab = 9,\n    Lf = 10,\n    Cr = 13,\n    Space = 32,\n    LParen = 40,\n    RParen = 41,\n    Comma = 44,\n    Dot = 46,\n    LBracket = 91,\n    Backslash = 92,\n    RBracket = 93,\n    _0 = 48,\n    _9 = 57,\n    _ = 95,\n    A = 64,\n    Z = 90,\n    a = 97,\n    z = 122,\n    DoubleQuote = 34,\n    SingleQuote = 39,\n    Exclaim = 33,\n    Equal = 61,\n    Caret = 94,\n    Tilde = 126,\n    Dollar = 36,\n    Less = 60,\n    Greater = 62,\n    Bar = 124,\n    Amp = 38\n}\n\n/**\n * Check if a codepoint is a whitespace character.\n */\nfunction isSpace(codepoint: number): boolean {\n    switch (codepoint) {\n        case Character.Tab:\n        case Character.Lf:\n        case Character.Cr:\n        case Character.Space:\n            return true;\n        default:\n            return false;\n    } // switch\n}\n\n/**\n * Check if codepoint is a digit character.\n */\nfunction isNumber(codepoint: number): boolean {\n    return codepoint >= Character._0 && codepoint <= Character._9;\n}\n\n/**\n * Check if codepoint is a letter character.\n */\nfunction isLetter(codepoint: number): boolean {\n    return (\n        (codepoint >= Character.a && codepoint <= Character.z) ||\n        (codepoint >= Character.A && codepoint <= Character.Z)\n    );\n}\n\n/**\n * Check if codepoint is either a digit or a letter character.\n */\nfunction isLetterOrNumber(codepoint: number): boolean {\n    return isLetter(codepoint) || isNumber(codepoint);\n}\n\n/**\n * Check if codepoint is an identification character: underscore, dollar sign, dot or bracket.\n */\nfunction isIdentChar(codepoint: number): boolean {\n    return (\n        isLetterOrNumber(codepoint) ||\n        codepoint === Character._ ||\n        codepoint === Character.Dollar ||\n        codepoint === Character.Dot ||\n        codepoint === Character.LBracket ||\n        codepoint === Character.RBracket\n    );\n}\n\n/**\n * Tokens used in theme grammar.\n */\nenum Token {\n    Eof = 0,\n    Error,\n    Identifier,\n    Number,\n    String,\n    Comma,\n    LParen,\n    RParen,\n    LBracket,\n    RBracket,\n    Exclaim,\n    TildeEqual,\n    CaretEqual,\n    DollarEqual,\n    EqualEqual,\n    ExclaimEqual,\n    Less,\n    Greater,\n    LessEqual,\n    GreaterEqual,\n    BarBar,\n    AmpAmp\n}\n\n/**\n * Maps a token to its string name.\n */\nfunction tokenSpell(token: Token): string {\n    switch (token) {\n        case Token.Eof:\n            return \"eof\";\n        case Token.Error:\n            return \"error\";\n        case Token.Identifier:\n            return \"identifier\";\n        case Token.Number:\n            return \"number\";\n        case Token.String:\n            return \"string\";\n        case Token.Comma:\n            return \",\";\n        case Token.LParen:\n            return \"(\";\n        case Token.RParen:\n            return \")\";\n        case Token.LBracket:\n            return \"[\";\n        case Token.RBracket:\n            return \"]\";\n        case Token.Exclaim:\n            return \"!\";\n        case Token.TildeEqual:\n            return \"~=\";\n        case Token.CaretEqual:\n            return \"^=\";\n        case Token.DollarEqual:\n            return \"$=\";\n        case Token.EqualEqual:\n            return \"==\";\n        case Token.ExclaimEqual:\n            return \"!=\";\n        case Token.Less:\n            return \"<\";\n        case Token.Greater:\n            return \">\";\n        case Token.LessEqual:\n            return \"<=\";\n        case Token.GreaterEqual:\n            return \">=\";\n        case Token.BarBar:\n            return \"||\";\n        case Token.AmpAmp:\n            return \"&&\";\n        default:\n            throw new Error(`invalid token ${token}`);\n    }\n}\n\n/**\n * Lexer class implementation.\n */\nclass Lexer {\n    private m_token: Token = Token.Error;\n    private m_index = 0;\n    private m_char: number = Character.Lf;\n    private m_text?: string;\n\n    constructor(readonly code: string) {}\n\n    /**\n     * Single lexer token.\n     */\n    token(): Token {\n        return this.m_token;\n    }\n\n    /**\n     * Parsed text.\n     */\n    text(): string {\n        return this.m_text || \"\";\n    }\n\n    /**\n     * Go to the next token.\n     */\n    next(): Token {\n        this.m_token = this.yylex();\n        if (this.m_token === Token.Error) {\n            throw new Error(`unexpected character ${this.m_char}`);\n        }\n        return this.m_token;\n    }\n\n    private yyinp(): void {\n        this.m_char = this.code.codePointAt(this.m_index++) || 0;\n    }\n\n    private yylex(): Token {\n        this.m_text = undefined;\n        while (isSpace(this.m_char)) {\n            this.yyinp();\n        }\n        if (this.m_char === 0) {\n            return Token.Eof;\n        }\n        const ch = this.m_char;\n        this.yyinp();\n        switch (ch) {\n            case Character.LParen:\n                return Token.LParen;\n            case Character.RParen:\n                return Token.RParen;\n            case Character.LBracket:\n                return Token.LBracket;\n            case Character.RBracket:\n                return Token.RBracket;\n            case Character.Comma:\n                return Token.Comma;\n            case Character.SingleQuote:\n            case Character.DoubleQuote: {\n                const start = this.m_index - 1;\n                while (this.m_char && this.m_char !== ch) {\n                    // ### TODO handle escape sequences\n                    this.yyinp();\n                }\n                if (this.m_char !== ch) {\n                    throw new Error(\"Unfinished string literal\");\n                }\n                this.yyinp();\n                this.m_text = this.code.substring(start, this.m_index - 2);\n                return Token.String;\n            }\n            case Character.Exclaim:\n                if (this.m_char === Character.Equal) {\n                    this.yyinp();\n                    return Token.ExclaimEqual;\n                }\n                return Token.Exclaim;\n            case Character.Caret:\n                if (this.m_char === Character.Equal) {\n                    this.yyinp();\n                    return Token.CaretEqual;\n                }\n                return Token.Error;\n            case Character.Tilde:\n                if (this.m_char === Character.Equal) {\n                    this.yyinp();\n                    return Token.TildeEqual;\n                }\n                return Token.Error;\n            case Character.Equal:\n                if (this.m_char === Character.Equal) {\n                    this.yyinp();\n                    return Token.EqualEqual;\n                }\n                return Token.Error;\n            case Character.Less:\n                if (this.m_char === Character.Equal) {\n                    this.yyinp();\n                    return Token.LessEqual;\n                }\n                return Token.Less;\n            case Character.Greater:\n                if (this.m_char === Character.Equal) {\n                    this.yyinp();\n                    return Token.GreaterEqual;\n                }\n                return Token.Greater;\n            case Character.Bar:\n                if (this.m_char === Character.Bar) {\n                    this.yyinp();\n                    return Token.BarBar;\n                }\n                return Token.Error;\n            case Character.Amp:\n                if (this.m_char === Character.Amp) {\n                    this.yyinp();\n                    return Token.AmpAmp;\n                }\n                return Token.Error;\n            default: {\n                const start = this.m_index - 2;\n                if (\n                    isLetter(ch) ||\n                    ch === Character._ ||\n                    (ch === Character.Dollar && isIdentChar(this.m_char))\n                ) {\n                    while (isIdentChar(this.m_char)) {\n                        this.yyinp();\n                    }\n                    this.m_text = this.code.substring(start, this.m_index - 1);\n                    return Token.Identifier;\n                } else if (isNumber(ch)) {\n                    while (isNumber(this.m_char)) {\n                        this.yyinp();\n                    }\n                    if (this.m_char === Character.Dot) {\n                        this.yyinp();\n                        while (isNumber(this.m_char)) {\n                            this.yyinp();\n                        }\n                    }\n                    this.m_text = this.code.substring(start, this.m_index - 1);\n                    return Token.Number;\n                } else if (ch === Character.Dollar) {\n                    if (this.m_char === Character.Equal) {\n                        this.yyinp();\n                        return Token.DollarEqual;\n                    }\n                    return Token.Error;\n                }\n            }\n        }\n        return Token.Error;\n    }\n}\n\nfunction getEqualityOp(token: Token): EqualityOp | undefined {\n    switch (token) {\n        case Token.TildeEqual:\n            return \"~=\";\n        case Token.CaretEqual:\n            return \"^=\";\n        case Token.DollarEqual:\n            return \"$=\";\n        case Token.EqualEqual:\n            return \"==\";\n        case Token.ExclaimEqual:\n            return \"!=\";\n        default:\n            return undefined;\n    } // switch\n}\n\nfunction getRelationalOp(token: Token): RelationalOp | undefined {\n    switch (token) {\n        case Token.Less:\n            return \"<\";\n        case Token.Greater:\n            return \">\";\n        case Token.LessEqual:\n            return \"<=\";\n        case Token.GreaterEqual:\n            return \">=\";\n        default:\n            return undefined;\n    } // switch\n}\n\nexport class ExprParser {\n    private readonly lex: Lexer;\n\n    constructor(code: string) {\n        this.lex = new Lexer(code);\n        this.lex.next();\n    }\n\n    parse(): Expr | never {\n        return this.parseLogicalOr();\n    }\n\n    private yyexpect(token: Token): void | never {\n        if (this.lex.token() !== token) {\n            throw new Error(\n                `Syntax error: Expected token '${tokenSpell(token)}' but ` +\n                    `found '${tokenSpell(this.lex.token())}'`\n            );\n        }\n        this.lex.next();\n    }\n\n    private parsePrimary(): Expr | never {\n        switch (this.lex.token()) {\n            case Token.Identifier: {\n                const text = this.lex.text();\n                switch (text) {\n                    case \"has\":\n                        this.lex.next(); // skip has keyword\n                        this.yyexpect(Token.LParen);\n                        const hasAttribute = this.lex.text();\n                        this.yyexpect(Token.Identifier);\n                        this.yyexpect(Token.RParen);\n                        return new HasAttributeExpr(hasAttribute);\n                    case \"length\":\n                        this.lex.next(); // skip length keyword\n                        this.yyexpect(Token.LParen);\n                        const value = this.parseLogicalOr();\n                        this.yyexpect(Token.RParen);\n                        return new CallExpr(\"length\", [value]);\n                    default:\n                        const expr = new VarExpr(text);\n                        this.lex.next();\n                        return expr;\n                }\n            }\n\n            case Token.LParen: {\n                this.lex.next();\n                const expr = this.parseLogicalOr();\n                this.yyexpect(Token.RParen);\n                return expr;\n            }\n\n            default:\n                return this.parseLiteral();\n        } // switch\n    }\n\n    private parseLiteral(): NumberLiteralExpr | StringLiteralExpr | never {\n        switch (this.lex.token()) {\n            case Token.Number: {\n                const expr = new NumberLiteralExpr(parseFloat(this.lex.text()));\n                this.lex.next();\n                return expr;\n            }\n            case Token.String: {\n                const expr = new StringLiteralExpr(this.lex.text());\n                this.lex.next();\n                return expr;\n            }\n            default:\n                throw new Error(\"Syntax error\");\n        } // switch\n    }\n\n    private parseUnary(): Expr | never {\n        if (this.lex.token() === Token.Exclaim) {\n            this.lex.next();\n            return new CallExpr(\"!\", [this.parseUnary()]);\n        }\n        return this.parsePrimary();\n    }\n\n    private parseRelational(): Expr | never {\n        let expr = this.parseUnary();\n        while (true) {\n            if (this.lex.token() === Token.Identifier && this.lex.text() === \"in\") {\n                this.lex.next();\n                this.yyexpect(Token.LBracket);\n                const elements = [this.parseLiteral()];\n                while (this.lex.token() === Token.Comma) {\n                    this.lex.next();\n                    elements.push(this.parseLiteral());\n                }\n                this.yyexpect(Token.RBracket);\n                expr = new CallExpr(\"in\", [\n                    expr,\n                    LiteralExpr.fromValue(elements.map(({ value }) => value))\n                ]);\n            } else {\n                const op = getRelationalOp(this.lex.token());\n                if (op === undefined) {\n                    break;\n                }\n                this.lex.next();\n                const right = this.parseUnary();\n                expr = new CallExpr(op, [expr, right]);\n            }\n        }\n        return expr;\n    }\n\n    private parseEquality(): Expr | never {\n        let expr = this.parseRelational();\n        while (true) {\n            let op: string | undefined = getEqualityOp(this.lex.token());\n\n            if (op === undefined) {\n                break;\n            }\n\n            if (op === \"~=\") {\n                op = \"in\";\n            }\n\n            this.lex.next();\n            const right = this.parseRelational();\n            expr = new CallExpr(op, [expr, right]);\n        }\n        return expr;\n    }\n\n    private parseLogicalAnd(): Expr | never {\n        const expr = this.parseEquality();\n\n        if (this.lex.token() !== Token.AmpAmp) {\n            return expr;\n        }\n\n        const expressions: Expr[] = [expr];\n\n        do {\n            this.lex.next();\n            expressions.push(this.parseEquality());\n        } while (this.lex.token() === Token.AmpAmp);\n\n        return new CallExpr(\"all\", expressions);\n    }\n\n    private parseLogicalOr(): Expr | never {\n        const expr = this.parseLogicalAnd();\n\n        if (this.lex.token() !== Token.BarBar) {\n            return expr;\n        }\n\n        const expressions: Expr[] = [expr];\n\n        do {\n            this.lex.next();\n            expressions.push(this.parseLogicalAnd());\n        } while (this.lex.token() === Token.BarBar);\n\n        return new CallExpr(\"any\", expressions);\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Common communication protocol for [[WorkerService]].\n */\nexport namespace WorkerServiceProtocol {\n    /**\n     * Service id of worker manager ([[WorkerServiceManager]]) used to create/destroy service\n     * instances in workers.\n     */\n    export const WORKER_SERVICE_MANAGER_SERVICE_ID = \"worker-service-manager\";\n\n    /**\n     * Define possible names of messages exchanged with services within `WebWorker`.\n     */\n    export enum ServiceMessageName {\n        Initialized = \"initialized\",\n        Request = \"request\",\n        Response = \"response\"\n    }\n\n    /**\n     * Interface for `ServiceMessage` which describes metadata for a service messages.\n     */\n    export interface ServiceMessage {\n        service: string;\n        type: ServiceMessageName;\n    }\n\n    /**\n     * This message is sent by the worker to the main thread. No data is sent. Receiving this\n     * message confirms that the worker has started successfully.\n     */\n    export interface InitializedMessage extends ServiceMessage {\n        type: ServiceMessageName.Initialized;\n    }\n\n    /**\n     * Type guard to check if an object is a signal message from worker.\n     */\n    export function isInitializedMessage(message: any): message is InitializedMessage {\n        return (\n            message &&\n            typeof message.service === \"string\" &&\n            typeof message.type === \"string\" &&\n            message.type === ServiceMessageName.Initialized\n        );\n    }\n\n    /**\n     * Define possible names of requests called on services within `WebWorker`.\n     */\n    export enum Requests {\n        CreateService = \"create-service\",\n        DestroyService = \"destroy-service\"\n    }\n\n    /**\n     * This is an internal general interface used in communication with workers.\n     * Check [[ConcurrentWorkerSet]]'s invokeRequest function for exemplary usage.\n     */\n    export interface ServiceRequest {\n        type: string;\n    }\n\n    /**\n     * This message is sent by the main thread to [[WorkerServiceManager]] to dynamically create a\n     * new service.\n     *\n     * May throw `UnknownServiceError` if service of given type is not registered in\n     * [[WorkerServiceManager]], see [[isUnknownServiceError]].\n     */\n    export interface CreateServiceRequest extends ServiceRequest {\n        type: Requests.CreateService;\n\n        /**\n         * Type of service to be created.\n         *\n         * @see [[WorkerServiceManager.register]]\n         */\n        targetServiceType: string;\n\n        /**\n         * The newly created service instance will be available under this id.\n         */\n        targetServiceId: string;\n    }\n\n    /**\n     * Test if `error` thrown by [[CreateServiceRequest]] was caused by unknown type of service.\n     */\n    export function isUnknownServiceError(error: Error): boolean {\n        return /unknown targetServiceType requested: /.test(error.message);\n    }\n\n    /**\n     * This message is sent by the main thread to [[WorkerServiceManager]] to dynamically destroy a\n     * service.\n     */\n    export interface DestroyServiceRequest extends ServiceRequest {\n        type: Requests.DestroyService;\n\n        /**\n         * Id of service to be destroyed.\n         */\n        targetServiceId: string;\n    }\n\n    /**\n     * Possible service management messages (`CreateService` or `DestroyService`) sent to WebWorker.\n     */\n    export type WorkerServiceManagerRequest = CreateServiceRequest | DestroyServiceRequest;\n\n    /**\n     * This message is a part of the Request-Response scheme implemented to be used in communication\n     * between workers and the decoder.\n     */\n    export interface RequestMessage extends ServiceMessage {\n        type: ServiceMessageName.Request;\n        messageId: number;\n        request: any;\n    }\n\n    /**\n     * Type guard to check if an object is a request message sent to a worker.\n     */\n    export function isRequestMessage(message: any): message is RequestMessage {\n        return (\n            message &&\n            typeof message.service === \"string\" &&\n            typeof message.type === \"string\" &&\n            message.type === ServiceMessageName.Request\n        );\n    }\n\n    /**\n     * This message is a part of the Request-Response scheme implemented to be used in communication\n     * between workers and the decoder.\n     */\n    export interface ResponseMessage extends ServiceMessage {\n        type: ServiceMessageName.Response;\n        messageId: number;\n        errorMessage?: string;\n        errorStack?: string;\n        response?: object;\n    }\n\n    /**\n     * Type guard to check if an object is a request message sent to a worker.\n     */\n    export function isResponseMessage(message: any): message is ResponseMessage {\n        return (\n            message &&\n            typeof message.service === \"string\" &&\n            typeof message.type === \"string\" &&\n            message.type === ServiceMessageName.Response\n        );\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeoJson } from \"../lib/GeoJsonDataType\";\nimport { WorkerServiceProtocol } from \"./WorkerServiceProtocol\";\n\n/**\n * Communication protocol with [[ITiler]].\n */\nexport namespace WorkerTilerProtocol {\n    /**\n     * Define possible names of requests called on tiler services within `WebWorker`.\n     */\n    export enum Requests {\n        RegisterIndex = \"register-index\",\n        UpdateIndex = \"update-index\",\n        TileRequest = \"tile-request\"\n    }\n\n    /**\n     * This object is sent to the tiler to register a new tile index in the worker.\n     */\n    export interface RegisterIndexRequest extends WorkerServiceProtocol.ServiceRequest {\n        type: Requests.RegisterIndex;\n        id: string;\n        input: string | GeoJson;\n    }\n\n    /**\n     * Type guard to check if an object is an index registration request sent to a worker.\n     */\n    export function isRegisterIndexRequest(message: any): message is RegisterIndexRequest {\n        return (\n            message && typeof message.type === \"string\" && message.type === Requests.RegisterIndex\n        );\n    }\n\n    /**\n     * This object is sent to the tiler to register a new tile index in the worker.\n     */\n    export interface UpdateIndexRequest extends WorkerServiceProtocol.ServiceRequest {\n        type: Requests.UpdateIndex;\n        id: string;\n        input: string | GeoJson;\n    }\n\n    /**\n     * Type guard to check if an object is an update request for the index registration.\n     */\n    export function isUpdateIndexRequest(message: any): message is UpdateIndexRequest {\n        return message && typeof message.type === \"string\" && message.type === Requests.UpdateIndex;\n    }\n\n    /**\n     * This object is sent to the tiler asking to retrieve a specific tile. The expected response\n     * type is an object containing a tiled payload.\n     */\n    export interface TileRequest extends WorkerServiceProtocol.ServiceRequest {\n        type: Requests.TileRequest;\n        index: string;\n        tileKey: number;\n    }\n\n    /**\n     * Type guard to check if an object is a tile request sent to a worker.\n     */\n    export function isTileRequest(message: any): message is TileRequest {\n        return message && typeof message.type === \"string\" && message.type === Requests.TileRequest;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Definitions, StyleSet } from \"./Theme\";\nimport { WorkerServiceProtocol } from \"./WorkerServiceProtocol\";\n\n/**\n * Interface for `OptionsMap` which describes a general structure of key-value pairs.\n */\nexport interface OptionsMap {\n    [name: string]: any;\n}\n\n/**\n * Allows to cancel and prioritize requests inside the requestQueue.\n *\n * @remarks\n * Useful to optimize the order of decoding tiles during animations and camera movements.\n *\n * `RequestController` is not extending [[AbortController]], because this is not supported in ES5.\n */\nexport class RequestController implements AbortController {\n    /**\n     * Creates an instance of `RequestController`.\n     *\n     * @param {number} priority\n     * @param {AbortController} abortController Optional [[AbortController]] used internally, since\n     *      [[AbortController]]s should not be subclassed.\n     */\n    constructor(\n        public priority: number = 0,\n        public abortController: AbortController = new AbortController()\n    ) {}\n\n    get signal(): AbortSignal {\n        return this.abortController.signal;\n    }\n\n    /**\n     * Invoking this method will set this object's AbortSignal's aborted flag and\n     * signal to any observers that the associated activity is to be aborted.\n     */\n    abort(): void {\n        this.abortController.abort();\n    }\n}\n\n/**\n * Communication protocol with [[ITileDecoder]].\n */\nexport namespace WorkerDecoderProtocol {\n    /**\n     * Define possible names of messages exchanged with decoder services within `WebWorker`.\n     */\n    export enum DecoderMessageName {\n        Configuration = \"configuration\"\n    }\n\n    /**\n     * Interface for `DecodedTileMessage` which describes metadata for a decoded tile.\n     */\n    export interface DecoderMessage {\n        service: string;\n        type: DecoderMessageName;\n    }\n\n    /**\n     * Interface for a ConfigurationMessage that is sent from the datasource to the decoder. The\n     * message used to configure the [[ITileDecoder]].\n     */\n    export interface ConfigurationMessage extends DecoderMessage {\n        type: DecoderMessageName.Configuration;\n        styleSet?: StyleSet;\n        definitions?: Definitions;\n        options?: OptionsMap;\n        languages?: string[];\n    }\n\n    /**\n     * Type guard to check if an object is an instance of `ConfigurationMessage`.\n     */\n    export function isConfigurationMessage(message: any): message is ConfigurationMessage {\n        return (\n            message &&\n            typeof message.service === \"string\" &&\n            typeof message.type === \"string\" &&\n            message.type === DecoderMessageName.Configuration\n        );\n    }\n\n    /**\n     * Define possible names of requests called on decoder services within `WebWorker`.\n     */\n    export enum Requests {\n        DecodeTileRequest = \"decode-tile-request\",\n        TileInfoRequest = \"tile-info-request\"\n    }\n\n    /**\n     * This object is sent to the decoder asking to decode a specific tile. The expected response\n     * type is a [[DecodedTile]].\n     */\n    export interface DecodeTileRequest extends WorkerServiceProtocol.ServiceRequest {\n        type: Requests.DecodeTileRequest;\n        tileKey: number;\n        data: ArrayBufferLike;\n        projection: string;\n    }\n\n    /**\n     * Type guard to check if an object is a decoded tile object sent to a worker.\n     */\n    export function isDecodeTileRequest(message: any): message is DecodeTileRequest {\n        return (\n            message &&\n            typeof message.type === \"string\" &&\n            message.type === Requests.DecodeTileRequest\n        );\n    }\n\n    /**\n     * This object is sent to the decoder asking for a tile info of a specific tile. The expected\n     * response type is a [[DecodedTile]].\n     */\n    export interface TileInfoRequest extends WorkerServiceProtocol.ServiceRequest {\n        type: Requests.TileInfoRequest;\n        tileKey: number;\n        data: ArrayBufferLike;\n        projection: string;\n    }\n\n    /**\n     * Type guard to check if an object is an info tile object sent to a worker.\n     */\n    export function isTileInfoRequest(message: any): message is TileInfoRequest {\n        return (\n            message && typeof message.type === \"string\" && message.type === Requests.TileInfoRequest\n        );\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Env, Expr, MapEnv, Value } from \"./Expr\";\nimport { getPropertyValue } from \"./PropertyValue\";\n\nexport interface AttrEvaluationContext {\n    /**\n     * Expression evaluation environment containing variable bindings.\n     */\n    env: MapEnv;\n\n    /**\n     * Optional, cache of expression results.\n     *\n     * @see [[Expr.evaluate]]\n     */\n    cachedExprResults?: Map<Expr, Value>;\n}\n\n/**\n * Evaluate feature attr _without_ default value.\n *\n * @returns actual value or `undefined`\n */\nexport function evaluateTechniqueAttr<T = Value>(\n    context: Env | AttrEvaluationContext,\n    attrValue: T | Expr | undefined\n): T | undefined;\n\n/**\n * Evaluate feature attr _with_ default value.\n *\n * @returns actual value or `defaultValue`\n */\nexport function evaluateTechniqueAttr<T extends Value>(\n    context: Env | AttrEvaluationContext,\n    attrValue: T | Expr | undefined,\n    defaultValue: T\n): T;\n\nexport function evaluateTechniqueAttr<T = Value>(\n    context: Env | AttrEvaluationContext,\n    attrValue: Value | undefined,\n    defaultValue?: T\n): T | undefined {\n    if (attrValue === undefined) {\n        return defaultValue;\n    }\n\n    const result = Env.isEnv(context)\n        ? getPropertyValue(attrValue, context)\n        : getPropertyValue(attrValue, context.env, context.cachedExprResults);\n\n    return result ?? defaultValue;\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { isJsonExpr } from \"./Expr\";\nimport { StyleDeclaration, Theme } from \"./Theme\";\n\n/**\n * The ThemeVisitor visits every style in the theme in a depth-first fashion.\n */\nexport class ThemeVisitor {\n    constructor(readonly theme: Theme) {}\n    /**\n     * Applies a function to every style in the theme.\n     *\n     * @param visitFunc - Function to be called with `style` as an argument. Function should return\n     *                  `true` to cancel visitation.\n     * @returns `true` if function has finished prematurely.\n     */\n    visitStyles(visitFunc: (style: StyleDeclaration) => boolean): boolean {\n        const visit = (style: StyleDeclaration): boolean => {\n            if (isJsonExpr(style)) {\n                return false;\n            }\n            if (visitFunc(style)) {\n                return true;\n            }\n            return false;\n        };\n        if (this.theme.styles !== undefined) {\n            for (const styleSetName in this.theme.styles) {\n                if (this.theme.styles[styleSetName] !== undefined) {\n                    for (const style of this.theme.styles[styleSetName]) {\n                        if (visit(style)) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\nimport { enforceBlending } from \"./Utils\";\n\nconst vertexShader: string = `\nuniform float size;\n\nvoid main() {\n    vec3 transformed = vec3(position);\n    vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);\n\n    gl_Position = projectionMatrix * mvPosition;\n    gl_PointSize = size;\n}\n`;\n\nconst fragmentShader: string = `\nuniform vec3 diffuse;\nuniform float opacity;\n\nvoid main() {\n    float alpha = opacity;\n\n    float radius = 0.5;\n    vec2 coords = gl_PointCoord.xy - vec2(0.5);\n    float len = length(coords);\n    float falloff = fwidth(len);\n    float threshold = 1.0 - smoothstep(radius - falloff, radius, len);\n    alpha *= threshold;\n\n    gl_FragColor = vec4(diffuse, alpha);\n}`;\n\n/**\n * Parameters used when constructing a new {@link HighPrecisionPointMaterial}.\n */\nexport interface CirclePointsMaterialParameters extends THREE.ShaderMaterialParameters {\n    /**\n     * Point size.\n     */\n    size?: number;\n\n    /**\n     * Point color.\n     */\n    color?: THREE.Color;\n}\n\n/**\n * Material designed to render circle points. Note that it is always transparent since the circle\n * shape is created with an alpha channel to benefit an antialising that a mere `discard` could\n * not bring.\n */\nexport class CirclePointsMaterial extends THREE.ShaderMaterial {\n    static readonly DEFAULT_CIRCLE_SIZE = 1;\n\n    private m_color: THREE.Color;\n    private m_opacity: number;\n\n    /**\n     * Constructs a new `CirclePointsMaterial`.\n     *\n     * @param parameters - The constructor's parameters.\n     */\n    constructor(parameters: CirclePointsMaterialParameters = {}) {\n        const { size, color, opacity, ...shaderParams } = parameters;\n        shaderParams.name = \"CirclePointsMaterial\";\n        shaderParams.vertexShader = vertexShader;\n        shaderParams.fragmentShader = fragmentShader;\n        shaderParams.uniforms = {\n            size: new THREE.Uniform(CirclePointsMaterial.DEFAULT_CIRCLE_SIZE),\n            diffuse: new THREE.Uniform(new THREE.Color()),\n            opacity: new THREE.Uniform(1.0)\n        };\n        shaderParams.depthTest = false;\n        shaderParams.extensions = {\n            ...shaderParams.extensions,\n            derivatives: true\n        };\n\n        super(shaderParams);\n        // Blending needs to always be enabled to support smooth edges\n        enforceBlending(this);\n\n        this.type = \"CirclePointsMaterial\";\n        this.m_color = this.uniforms.diffuse.value;\n        this.m_opacity = this.uniforms.opacity.value;\n\n        if (size !== undefined) {\n            this.size = size;\n        }\n        if (color !== undefined) {\n            this.color = color;\n        }\n        if (opacity !== undefined) {\n            this.opacity = opacity;\n        }\n    }\n\n    /**\n     * Gets the circle screen size.\n     */\n    get size(): number {\n        return this.uniforms.size.value;\n    }\n\n    /**\n     * Sets the circle screen size.\n     */\n    set size(size: number) {\n        this.uniforms.size.value = size;\n    }\n\n    /**\n     * Get circle opacity.\n     */\n    get opacity(): number {\n        return this.m_opacity;\n    }\n\n    /**\n     * Set circle opacity.\n     */\n    set opacity(opacity: number) {\n        this.m_opacity = opacity;\n\n        // Base constructor may set opacity before uniform being created.\n        if (this.uniforms && this.uniforms.opacity) {\n            this.uniforms.opacity.value = opacity;\n        }\n    }\n\n    /**\n     * Gets the diffuse.\n     */\n    get color(): THREE.Color {\n        return this.m_color;\n    }\n\n    /**\n     * Sets the diffuse.\n     */\n    set color(color: THREE.Color) {\n        this.m_color.set(color);\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { HiddenThreeJSMaterialProperties } from \"./MapMeshMaterials\";\n\n/**\n * Parameters used when constructing a new implementor of {@link DisplacementFeature}.\n */\nexport interface DisplacementFeatureParameters {\n    /**\n     * Texture used for vertex displacement along their normals.\n     */\n    displacementMap?: THREE.Texture;\n}\n\n/**\n * Interface to be implemented by materials that use displacement maps to overlay geometry\n * on elevation data.\n */\nexport interface DisplacementFeature extends HiddenThreeJSMaterialProperties {\n    displacementMap: THREE.Texture | null;\n}\n\n/**\n * Determines whether a given material supports displacement maps for elevation overlay.\n * @param material - The material to check.\n * @returns Whether the given material supports displacement maps for elevation overlay.\n */\nexport function hasDisplacementFeature(material: any): material is DisplacementFeature {\n    return \"displacementMap\" in material;\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { DisplacementFeature, DisplacementFeatureParameters } from \"./DisplacementFeature\";\nimport {\n    ExtrusionFeature,\n    ExtrusionFeatureParameters,\n    FadingFeature,\n    FadingFeatureParameters\n} from \"./MapMeshMaterials\";\nimport { ExtrusionFeatureDefs } from \"./MapMeshMaterialsDefs\";\nimport { enforceBlending, setShaderDefine, setShaderMaterialDefine } from \"./Utils\";\n\nconst vertexSource: string = `\n#define EDGE_DEPTH_OFFSET 0.0001\n\nattribute vec4 color;\n\n// SHADER_NAME may be defined by THREE.JS own shaders in which case these attributes & uniforms are\n// already defined\n#ifndef SHADER_NAME\nattribute vec3 position;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat3 normalMatrix;\n#endif\n\nuniform vec3 edgeColor;\nuniform float edgeColorMix;\n\n#ifdef USE_DISPLACEMENTMAP\nattribute vec3 normal;\nattribute vec2 uv;\nuniform sampler2D displacementMap;\n#endif\n\nvarying vec3 vColor;\n\n#ifdef USE_EXTRUSION\n#include <extrusion_pars_vertex>\n#endif\n\n#ifdef USE_FADING\n#include <fading_pars_vertex>\n#endif\n\nvoid main() {\n\n    #ifdef USE_COLOR\n    vColor = mix(edgeColor.rgb, color.rgb, edgeColorMix);\n    #else\n    vColor = edgeColor.rgb;\n    #endif\n\n    vec3 transformed = vec3( position );\n\n    #ifdef USE_EXTRUSION\n    #include <extrusion_vertex>\n    #endif\n\n    #ifdef USE_DISPLACEMENTMAP\n    transformed += normalize( normal ) * texture2D( displacementMap, uv ).x;\n    #endif\n\n    vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\n    gl_Position = projectionMatrix * mvPosition;\n    // After projection gl_Position contains clip space coordinates of each vertex\n    // before perspective division (1 / w), thus only vertexes with -w < z < w should\n    // be displayed and offset. We offset only those edges which z coordinate in NDC\n    // space is between: -inf < z < 1\n    float depthOffset = step(-1.0, -gl_Position.z / gl_Position.w) * EDGE_DEPTH_OFFSET;\n    gl_Position.z -= depthOffset;\n\n    #ifdef USE_FADING\n    #include <fading_vertex>\n    #endif\n}`;\n\nconst fragmentSource: string = `\nprecision highp float;\nprecision highp int;\n\nvarying vec3 vColor;\n\n#ifdef USE_EXTRUSION\n#include <extrusion_pars_fragment>\n#endif\n\n#ifdef USE_FADING\n#include <fading_pars_fragment>\n#endif\n\nvoid main() {\n    float alphaValue = 1.0;\n    gl_FragColor = vec4(vColor, alphaValue);\n\n    #ifdef USE_EXTRUSION\n    #include <extrusion_fragment>\n    #endif\n\n    #ifdef USE_FADING\n    #include <fading_fragment>\n    #endif\n}`;\n\n/**\n * Parameters used when constructing a new {@link EdgeMaterial}.\n */\nexport interface EdgeMaterialParameters\n    extends FadingFeatureParameters,\n        DisplacementFeatureParameters,\n        ExtrusionFeatureParameters {\n    /**\n     * Edge color.\n     */\n    color?: number | string;\n    /**\n     * Color mix value. Mixes between vertexColors and edgeColor.\n     */\n    colorMix?: number;\n}\n\n/**\n * Material designed to render the edges of extruded buildings using GL_LINES. It supports solid\n * colors, vertex colors, color mixing and distance fading.\n */\nexport class EdgeMaterial extends THREE.RawShaderMaterial\n    implements FadingFeature, ExtrusionFeature, DisplacementFeature {\n    static DEFAULT_COLOR: number = 0x000000;\n    static DEFAULT_COLOR_MIX: number = 0.0;\n\n    /**\n     * Constructs a new `EdgeMaterial`.\n     *\n     * @param params - `EdgeMaterial` parameters.\n     */\n    constructor(params?: EdgeMaterialParameters) {\n        const defines: { [key: string]: any } = {};\n        const hasDisplacementMap = params !== undefined && params.displacementMap !== undefined;\n        const hasExtrusion =\n            params !== undefined &&\n            params.extrusionRatio !== undefined &&\n            params.extrusionRatio >= ExtrusionFeatureDefs.DEFAULT_RATIO_MIN &&\n            params.extrusionRatio < ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;\n        if (hasDisplacementMap) {\n            setShaderDefine(defines, \"USE_DISPLACEMENTMAP\", true);\n        }\n        if (hasExtrusion) {\n            setShaderDefine(defines, \"USE_EXTRUSION\", true);\n        }\n\n        const shaderParams = {\n            name: \"EdgeMaterial\",\n            vertexShader: vertexSource,\n            fragmentShader: fragmentSource,\n            uniforms: {\n                edgeColor: new THREE.Uniform(new THREE.Color(EdgeMaterial.DEFAULT_COLOR)),\n                edgeColorMix: new THREE.Uniform(EdgeMaterial.DEFAULT_COLOR_MIX),\n                fadeNear: new THREE.Uniform(FadingFeature.DEFAULT_FADE_NEAR),\n                fadeFar: new THREE.Uniform(FadingFeature.DEFAULT_FADE_FAR),\n                extrusionRatio: new THREE.Uniform(ExtrusionFeatureDefs.DEFAULT_RATIO_MAX),\n                displacementMap: new THREE.Uniform(\n                    hasDisplacementMap ? params!.displacementMap : new THREE.Texture()\n                )\n            },\n            depthWrite: false,\n            defines\n        };\n        super(shaderParams);\n        enforceBlending(this);\n\n        FadingFeature.patchGlobalShaderChunks();\n        ExtrusionFeature.patchGlobalShaderChunks();\n\n        // Apply initial parameter values.\n        if (params !== undefined) {\n            if (params.color !== undefined) {\n                // Color may be set directly on object (omitting class setter), because we already\n                // know that is does no require any special handling nor material update\n                // (see: set color()).\n                this.color.set(params.color as any);\n            }\n            if (params.colorMix !== undefined) {\n                this.colorMix = params.colorMix;\n            }\n            if (params.fadeNear !== undefined) {\n                this.fadeNear = params.fadeNear;\n            }\n            if (params.fadeFar !== undefined) {\n                this.fadeFar = params.fadeFar;\n            }\n            if (params.displacementMap !== undefined) {\n                this.displacementMap = params.displacementMap;\n            }\n            if (params.extrusionRatio !== undefined) {\n                this.extrusionRatio = params.extrusionRatio;\n            }\n        }\n    }\n\n    /**\n     * Edge color.\n     */\n    get color(): THREE.Color {\n        return this.uniforms.edgeColor.value as THREE.Color;\n    }\n    set color(value: THREE.Color) {\n        this.uniforms.edgeColor.value.copy(value);\n    }\n\n    /**\n     * Color mix value. Mixes between vertexColors and edgeColor.\n     */\n    get colorMix(): number {\n        return this.uniforms.edgeColorMix.value as number;\n    }\n    set colorMix(value: number) {\n        if (this.uniforms.edgeColorMix.value === value) {\n            return;\n        }\n        this.uniforms.edgeColorMix.value = value;\n        setShaderMaterialDefine(this, \"USE_COLOR\", value > 0.0);\n    }\n\n    get fadeNear(): number {\n        return this.uniforms.fadeNear.value as number;\n    }\n    set fadeNear(value: number) {\n        this.uniforms.fadeNear.value = value;\n    }\n\n    get fadeFar(): number {\n        return this.uniforms.fadeFar.value as number;\n    }\n    set fadeFar(value: number) {\n        if (this.uniforms.fadeFar.value === value) {\n            return;\n        }\n        this.uniforms.fadeFar.value = value;\n        setShaderMaterialDefine(this, \"USE_FADING\", value > 0.0);\n    }\n\n    get extrusionRatio(): number {\n        return this.uniforms.extrusionRatio.value as number;\n    }\n    set extrusionRatio(value: number) {\n        if (this.uniforms.extrusionRatio.value === value) {\n            return;\n        }\n        this.uniforms.extrusionRatio.value = value;\n        // NOTE: We could also disable shader extrusion chunks when it hits\n        // ExtrusionFeatureDefs.DEFAULT_RATIO_MAX value, but this would cause shader re-compile.\n        const useExtrusion = value >= ExtrusionFeatureDefs.DEFAULT_RATIO_MIN;\n        setShaderMaterialDefine(this, \"USE_EXTRUSION\", useExtrusion);\n    }\n\n    get displacementMap(): THREE.Texture | null {\n        return this.uniforms.displacementMap.value;\n    }\n\n    set displacementMap(map: THREE.Texture | null) {\n        if (this.uniforms.displacementMap.value === map) {\n            return;\n        }\n        this.uniforms.displacementMap.value = map;\n        const useDisplacementMap = map !== null;\n        if (useDisplacementMap) {\n            this.uniforms.displacementMap.value.needsUpdate = true;\n        }\n        setShaderMaterialDefine(this, \"USE_DISPLACEMENTMAP\", useDisplacementMap);\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ExtrusionFeatureDefs } from \"../MapMeshMaterialsDefs\";\n\nconst MIN_BUILDING_HEIGHT_SQUARED =\n    ExtrusionFeatureDefs.MIN_BUILDING_HEIGHT * ExtrusionFeatureDefs.MIN_BUILDING_HEIGHT;\n\nexport default {\n    extrusion_pars_vertex: `\n// Add define so we can check for it in the outline effect (see Outline.ts).\n#define HAS_EXTRUSION_PARS_VERTEX\n// Extrusion axis (xyz: vector, w: factor).\nattribute vec4 extrusionAxis;\nuniform float extrusionRatio;\n#ifdef FLAT_SHADED\nvarying vec4 vExtrusionAxis;\n#endif\n#ifdef ZFIGHTING_WORKAROUND\nvarying float vExtrusionRatio;\n#endif\n`,\n    extrusion_vertex: `\n#define HAS_EXTRUSION_VERTEX\n#ifdef ZFIGHTING_WORKAROUND\n// Cancel extrusionRatio (meaning, force to 1) if extrusionAxisLen < MIN_BUILDING_HEIGHT.\nconst float MIN_BUILDING_HEIGHT_SQUARED = ${MIN_BUILDING_HEIGHT_SQUARED};\nfloat extrusionAxisLenSquared = dot(extrusionAxis.xyz, extrusionAxis.xyz);\nvExtrusionRatio = (extrusionAxisLenSquared < MIN_BUILDING_HEIGHT_SQUARED) ? 1.0 : extrusionRatio;\n#else\nfloat vExtrusionRatio = extrusionRatio;\n#endif\ntransformed = transformed + extrusionAxis.xyz * (vExtrusionRatio - 1.0);\n#ifdef FLAT_SHADED\nvExtrusionAxis = vec4(normalMatrix * extrusionAxis.xyz, extrusionAxis.w);\n#endif\n`,\n    // Modified version of THREE <normal_fragment_begin> shader chunk which, for flat shaded\n    // geometries, computes the normal either with the extrusion axis or fragment derivatives based\n    // on the extrusion factor (1.0 = ceiling, 0.0 = footprint).\n    extrusion_normal_fragment_begin: `\n#ifdef FLAT_SHADED\n    // Flattened this divergent path to prevent undefined behaviour in the following derivatives\n    // functions. For more info:\n    // http://www.aclockworkberry.com/shader-derivative-functions/#Derivatives_and_branches\n\n    // Workaround for Adreno/Nexus5 not able able to do dFdx( vViewPosition ) ...\n    vec3 fdx = vec3(dFdx(vViewPosition.x), dFdx(vViewPosition.y), dFdx(vViewPosition.z));\n    vec3 fdy = vec3(dFdy(vViewPosition.x), dFdy(vViewPosition.y), dFdy(vViewPosition.z));\n    vec3 normal = cross( fdx, fdy );\n    if (vExtrusionAxis.w > 0.999999) {\n        normal = vExtrusionAxis.xyz;\n    }\n    normal = normalize(normal);\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * (float(gl_FrontFacing) * 2.0 - 1.0);\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * (float(gl_FrontFacing) * 2.0 - 1.0);\n\t\t\tbitangent = bitangent * (float(gl_FrontFacing) * 2.0 - 1.0);\n\t\t#endif\n\t#endif\n#endif\n// non perturbed normal for clearcoat among others\nvec3 geometryNormal = normal;\n`,\n    extrusion_pars_fragment: `\n#ifdef ZFIGHTING_WORKAROUND\nvarying float vExtrusionRatio;\n#else\nuniform float extrusionRatio;\n#endif\nvarying vec4 vExtrusionAxis;\n`,\n    extrusion_fragment: `\n#ifndef ZFIGHTING_WORKAROUND\nfloat vExtrusionRatio = extrusionRatio;\n#endif\ngl_FragColor.a *= smoothstep( 0.0, 0.25, vExtrusionRatio );\n`\n};\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * The shader chunks have their lines \"#ifdef USE_FADING\" commented out, because currently the\n * mesh materials use individually created shader strings based on the materials settings.\n * @see [[FadingMeshBasicMaterial]]\n **/\n\nexport default {\n    fading_pars_vertex: `\nvarying float fadingDepth;\n`,\n\n    fading_vertex: `\nfadingDepth = -mvPosition.z;\n`,\n\n    fading_pars_fragment: `\nvarying float fadingDepth;\nuniform float fadeNear;\nuniform float fadeFar;\n`,\n\n    fading_fragment: `\n\n// lerp with \"hard\" edges\n//float fadingFactor = 1.0 - clamp((fadingDepth - fadeNear) / (fadeFar - fadeNear), 0.0, 1.0);\n\n// smooth transitions\nfloat fadingFactor = smoothstep( fadeNear, fadeFar, fadingDepth );\n\ngl_FragColor.a *= 1.0 - fadingFactor;\n\n// debugging color:\n// gl_FragColor = vec4(1., fadingFactor, fadingFactor, 1.0);\n`\n};\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * This shader chunk replaces the default lighting in the standard material, the problem with this\n * is that the final pixel color is the addition of the material color and the light, this means\n * that the final map's rendered color is vastly different from that configured by the designers.\n * This chunk removes the extra highlight by providing just two colors, the material color when not\n * in shadow and a reduced color value when in shadow (currently 50% of the material's color).\n */\nexport const simpleLightingShadowChunk = `\n    struct PhysicalMaterial {\n        vec3\tdiffuseColor;\n        float\tspecularRoughness;\n        vec3\tspecularColor;\n    };\n\n    #define DEFAULT_SPECULAR_COEFFICIENT 0.04\n\n    void RE_Direct_Physical( const in IncidentLight directLight,\n        const in GeometricContext geometry,\n        const in PhysicalMaterial material,\n        inout ReflectedLight reflectedLight ) {\n        // directLight.color is the light color * shadow, internally three.js uses a step function, so\n        // this value is either the light color or black. in order to lighten up the shadows, we\n        // take add 50% of the color to grey (to give us either pure white or grey) and multiply this to\n        // the material's diffuse color.\n        #if defined(USE_SHADOWMAP)\n            reflectedLight.directDiffuse = (0.5 * directLight.color +\n                vec3(0.5,0.5,0.5)) * material.diffuseColor;\n        #else\n            reflectedLight.directDiffuse = material.diffuseColor;\n        #endif\n    }\n\n    void RE_IndirectDiffuse_Physical( const in vec3 irradiance,\n        const in GeometricContext geometry,\n        const in PhysicalMaterial material,\n        inout ReflectedLight reflectedLight ) {\n            // Disable influence of indirect light (it is handled in the RE_Direct_Physical function)\n    }\n\n    void RE_IndirectSpecular_Physical( const in vec3 radiance,\n        const in vec3 irradiance,\n        const in vec3 clearcoatRadiance,\n        const in GeometricContext geometry,\n        const in PhysicalMaterial material,\n        inout ReflectedLight reflectedLight) {\n            // Disable specular reflection of light.\n    }\n\n    #define RE_Direct               RE_Direct_Physical\n    #define RE_IndirectDiffuse      RE_IndirectDiffuse_Physical\n    #define RE_IndirectSpecular     RE_IndirectSpecular_Physical\n`;\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport * as THREE from \"three\";\nimport AtmosphereShaderChunks from \"./ShaderChunks/AtmosphereChunks\";\nimport { setShaderDefine } from \"./Utils\";\n\nconst EQUATORIAL_RADIUS: number = 6378137.0;\n\n/**\n * `GroundAtmosphereShader`.\n *\n * Describes shading of atmosphere as seen from outer space.\n */\nexport const GroundAtmosphereShader: THREE.Shader = {\n    uniforms: {\n        u_eyePositionWorld: new THREE.Uniform(new THREE.Vector3()),\n        u_lightDirectionWorld: new THREE.Uniform(new THREE.Vector3(0, 1, 0)),\n        u_modelViewProjection: new THREE.Uniform(new THREE.Matrix4()),\n        // Environment settings:\n        // atmosphere inner and outer radius, camera height, light mode\n        u_atmosphereEnv: new THREE.Uniform(\n            new THREE.Vector4(\n                // Maximum inner radius\n                EQUATORIAL_RADIUS * 1.001,\n                // Maximum outer radius\n                EQUATORIAL_RADIUS * 1.025,\n                // Camera height\n                0,\n                // Toggles the light modes:\n                // 0 - light always directly overhead,\n                // 1 - lighting uses light direction: uniform u_lightDirectionWorld\n                1\n            )\n        ),\n        u_hsvCorrection: new THREE.Uniform(new THREE.Vector3(0, 0, 0)),\n\n        topColor: new THREE.Uniform(new THREE.Color(0x0077ff)),\n        bottomColor: new THREE.Uniform(new THREE.Color(0xffffff)),\n        offset: new THREE.Uniform(33.0),\n        exponent: new THREE.Uniform(0.6),\n        fogColor: new THREE.Uniform(new THREE.Color(0x0077ff)), // scene.fog.color\n        fogNear: new THREE.Uniform(new THREE.Color(0x0077ff)), // scene.fog.near\n        fogFar: new THREE.Uniform(new THREE.Color(0xffffff)) // scene.fog.far\n    },\n\n    vertexShader: `\n\n    #define IMPROVE_INTERSECT_PRECISION 1\n    #define IMPROVE_DOT_PRECISION 1\n\n    precision highp float;\n    precision highp int;\n\n    attribute vec4 position;\n\n    // Base mandatory uniforms\n    uniform mat4 u_modelViewProjection;\n    uniform vec3 u_eyePositionWorld;\n    uniform vec3 u_lightDirectionWorld;\n\n    uniform vec4 u_atmosphereEnv; // Atmosphere inner and outer radius, camera height, light mode\n    uniform vec3 u_hsvCorrection;\n\n    const float Pi = 3.141592653589793;\n    const float Kr = 0.0025;\n    const float Km = 0.0015;\n    const float Kr4PI = Kr * 4.0 * Pi;\n    const float Km4PI = Km * 4.0 * Pi;\n    const float ESun = 25.0; // should be 15.0\n    const float KmESun = Km * ESun;\n    const float KrESun = Kr * ESun;\n    const vec3 InvWavelength = vec3(\n        1.0 / pow(0.650, 4.0), // Red\n        1.0 / pow(0.570, 4.0), // Green\n        1.0 / pow(0.475, 4.0)); // Blue\n\n    const int nSamples = 2;\n    const float fSamples = 2.0;\n\n    varying vec3 v_rayleighColor;\n    varying vec3 v_mieColor;\n    varying vec3 v_vertToCamera;\n    varying vec3 v_vertToOrigin;\n\n    ${AtmosphereShaderChunks.atmosphere_common_utils}\n    ${AtmosphereShaderChunks.atmosphere_vertex_utils}\n\n    //\n    // Computes rayleight and mia atmosphere factors for ground.\n    //\n    // Code based on GPU Gems article.\n    //\n    // Author: Sean O'Neil\n    //\n    // Copyright (c) 2004 Sean O'Neil\n    //\n    // https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-16-accurate-atmospheric-scattering\n    //\n    // Further modifications by HERE.\n    //\n    AtmosphereColor computeGroundAtmosphere(vec3 v3Pos, vec3 vLightDir, bool dynamicLighting)\n    {\n        // Retrieve environment variables\n        float fInnerRadius = u_atmosphereEnv.x;\n        float fOuterRadius = u_atmosphereEnv.y;\n        float fCameraHeight = u_atmosphereEnv.z;\n\n        // All that may be moved to const or define(s) at further optimizations:\n        float fScale = 1.0 / (fOuterRadius - fInnerRadius);\n        float fScaleOverScaleDepth = fScale / RayleighScaleDepth;\n        float fCameraHeight2 = fCameraHeight * fCameraHeight;\n        float fOuterRadius2 = fOuterRadius * fOuterRadius;\n\n        // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\n        vec3 v3Ray = v3Pos - u_eyePositionWorld;\n        float fFar = length(v3Ray);\n        v3Ray /= fFar;\n\n#if !defined(IMPROVE_DOT_PRECISION)\n        vec3 v3Dir = normalize(v3Pos);\n#endif\n\n#ifdef CAMERA_IN_SPACE\n\n        // Calculate first point of camera ray and sphere intersection.\n        float fNear = getNearSphereIntersect(u_eyePositionWorld, v3Ray, fCameraHeight2, fOuterRadius2);\n        // Make far relative to first atmosphere intersection, setting it to\n        // the length of ray passed through atmosphere\n        fFar -= fNear;\n\n        // Compute the ray's starting position within the atmosphere, then\n        // calculate its scattering offset\n        vec3 v3Start = u_eyePositionWorld + v3Ray * fNear;\n        float fDepth = exp((fInnerRadius - fOuterRadius) / RayleighScaleDepth);\n\n#else // CAMERA_IN_ATMOSPHERE\n\n        // The ray starts already in atmosphere\n        vec3 v3Start = u_eyePositionWorld;\n        // Virtually fNear is just at eye position, so ray passing through atmosphere does not shorten\n        // fFar -= 0.0;\n        float fDepth = exp((fInnerRadius - fCameraHeight) / RayleighScaleDepth);\n#endif\n\n#if defined(IMPROVE_DOT_PRECISION)\n        float fCameraAngle = dot(-v3Ray, v3Pos) / length(v3Pos);\n#else\n        float fCameraAngle = dot(-v3Ray, v3Dir);\n#endif\n        float fCameraScale = scale(fCameraAngle);\n\n        // When we want the atmosphere to be uniform over the globe so it is set to 1.0.\n#if defined(IMPROVE_DOT_PRECISION)\n        // The light angle for given light source may be calculated as:\n        // angle = dot(vLightDir, v3Dir) / length(v3Dir);\n        // where v3Dir holds normalized vertex position, but for precision issues we v3Pos (un-normalized)\n        float fLightAngle = conditionalBranchFree(dynamicLighting, dot(vLightDir, v3Pos) / length(v3Pos), 1.0);\n#else\n        float fLightAngle = conditionalBranchFree(dynamicLighting, dot(vLightDir, v3Dir), 1.0);\n#endif\n        float fLightScale = scale(fLightAngle);\n\n        float fCameraOffset = fDepth * fCameraScale;\n        float fTemp = (fLightScale + fCameraScale);\n\n        // Initialize the scattering loop variables\n        float fSampleLength = fFar / fSamples;\n        float fScaledLength = fSampleLength * fScale;\n        vec3 v3SampleRay = v3Ray * fSampleLength;\n        vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\n\n        // Now loop through the sample rays\n        vec3 v3BaseColor = vec3(0.0);\n        vec3 v3Attenuate = vec3(0.0);\n        for(int i = 0; i < nSamples; i++)\n        {\n            float fHeight = length(v3SamplePoint);\n            float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\n            float fScatter = fDepth * fTemp - fCameraOffset;\n            // Compute color factors\n            v3Attenuate = exp(-fScatter * (InvWavelength * Kr4PI + Km4PI));\n            v3BaseColor += v3Attenuate * (fDepth * fScaledLength);\n            // Move to the next point\n            v3SamplePoint += v3SampleRay;\n        }\n\n        AtmosphereColor color;\n        color.mie = v3BaseColor * (InvWavelength * KrESun + KmESun);\n        // Calculate the attenuation factor for the ground\n        color.rayleigh = v3Attenuate;\n\n        return color;\n    }\n\n    void main(void)\n    {\n        float fLightMode = u_atmosphereEnv.w;\n        bool bDynamicLight = fLightMode != 0.0;\n\n        vec3 vLightDir = conditionalBranchFree(bDynamicLight,\n            u_lightDirectionWorld,\n            u_eyePositionWorld);\n        vLightDir = normalize(vLightDir);\n\n        AtmosphereColor atmColor = computeGroundAtmosphere(position.xyz, vLightDir, bDynamicLight);\n        v_mieColor = atmColor.mie;\n        v_rayleighColor = atmColor.rayleigh;\n        v_vertToCamera = u_eyePositionWorld - position.xyz;\n        v_vertToOrigin = normalize(position.xyz);\n\n        gl_Position = u_modelViewProjection * position;\n    }\n    `,\n\n    fragmentShader: `\n\n    // Exposure correction gives more subtle gradients on the ground.\n    #define CORRECT_EXPOSURE 1\n    #define FADE_DEPTH 1\n    #define NIGHT_LOCAL 1\n\n    precision highp float;\n    precision highp int;\n\n    #ifdef CORRECT_COLOR\n    uniform vec3 u_hsvCorrection; // Hue, saturation, brightness\n    #endif\n\n    uniform vec4 u_atmosphereEnv; // Atmosphere inner and outer radius, camera height, light mode\n    uniform vec3 u_eyePositionWorld;\n    uniform vec3 u_lightDirectionWorld;\n\n    const float g = -0.95;\n    const float g2 = g * g;\n\n    varying vec3 v_rayleighColor;\n    varying vec3 v_mieColor;\n    varying vec3 v_vertToCamera;\n    varying vec3 v_vertToOrigin;\n\n    ${AtmosphereShaderChunks.atmosphere_common_utils}\n    ${AtmosphereShaderChunks.atmosphere_fragment_utils}\n\n    void main(void)\n    {\n        float fInnerRadius = u_atmosphereEnv.x;\n        float fOuterRadius = u_atmosphereEnv.y;\n        float fCameraHeight = u_atmosphereEnv.z;\n        float fLightMode = u_atmosphereEnv.w;\n        bool bDynamicLight = fLightMode != 0.0;\n\n        vec3 vLightDir = conditionalBranchFree(bDynamicLight,\n            u_lightDirectionWorld,\n            u_eyePositionWorld);\n        vLightDir = normalize(vLightDir);\n\n        // GPU gems mix of ground solution, with custom alpha settings\n        vec3 cRgb = v_mieColor + 0.25 * v_rayleighColor;\n\n        // Not needed for HDR frame buffer\n    #if !defined(HDR_FRAME_BUFFER) && defined(CORRECT_EXPOSURE)\n        // Interesting results with exposure factor: 2.0, 3.5, 4.0\n        cRgb = correctExposure(cRgb, 3.0);\n    #endif\n\n    #ifdef CORRECT_COLOR\n        cRgb = correctColor(cRgb, u_hsvCorrection);\n    #endif\n\n        // Base atmosphere opacity\n        float fAtmosphereAlpha = 1.0;\n\n        // Factor based on the distance of camera atmosphere and ground, results are:\n        // 0.0 = camera on the ground surface,\n        // 1.0 = at the outer edge of the atmosphere.\n        float fDepthFactor = clamp((fCameraHeight - fInnerRadius) /\n            (fOuterRadius - fInnerRadius), 0.0, 1.0);\n    #ifdef FADE_DEPTH\n        // Fade alpha based on the distance of camera between atmosphere layers\n        #ifdef FADE_DEPTH_LINEAR\n            fAtmosphereAlpha *= fDepthFactor;\n        #else\n            fAtmosphereAlpha *= pow(fDepthFactor, 1.5);\n        #endif\n    #endif\n\n#if defined(FADE_NIGHT) || defined(DARKEN_NIGHT)\n        // Adjust factor based on time of day, results are:\n        // 0.0 = night,\n        // 1.0 = day.\n    #ifdef NIGHT_GLOBAL\n        // Global night fade based on camera and light orientation\n        float fNightFactor = conditionalBranchFree(bDynamicLight,\n            clamp(dot(normalize(u_eyePositionWorld), vLightDir), 0.0, 1.0),\n             1.0);\n        fNightFactor = pow(fNightFactor, 0.5);\n    #else // NIGHT_LOCAL\n        float fNightFactor = conditionalBranchFree(bDynamicLight,\n            clamp(dot(v_vertToOrigin, vLightDir) / length(v_vertToOrigin), 0.0, 1.0),\n            1.0);\n        fNightFactor = pow(fNightFactor, 0.8);\n    #endif\n#endif\n\n    #ifdef FADE_NIGHT\n        // Adjust alpha for night side of the globe\n        fAtmosphereAlpha *= fNightFactor;\n    #endif\n\n    #ifdef DARKEN_NIGHT\n        // Change the brightness depending on night / day side.\n        // NOTE: Darkening should be rather applied in HSV space, without loss on saturation,\n        // but it is much more GPU consuming.\n        const float minBrightness = 0.5;\n        float fDarkenFactor = clamp(fNightFactor, minBrightness, 1.0);\n        cRgb *= fDarkenFactor;\n    #endif\n\n    #ifdef EXPOSURE_DEPTH\n        // Control exposure depending from ground distance\n        float exposureBoost = 3.0 - fDepthFactor;\n        cRgb = correctExposure(cRgb, exposureBoost);\n    #endif\n\n        // Experimental fading out of focus point - similar to fresnel effect in top view.\n        // This fade is handy to better expose cartographic/map features in screen center.\n        float fFocusFactor = 1.0 - clamp(dot(normalize(v_vertToCamera), v_vertToOrigin), 0.0, 1.0) + 0.1;\n        fFocusFactor = pow(fFocusFactor, 2.5);\n        fAtmosphereAlpha *= fFocusFactor;\n\n        // Integrate all features\n        gl_FragColor = vec4(cRgb, fAtmosphereAlpha);\n    }\n    `\n};\n\nexport class GroundAtmosphereMaterial extends THREE.RawShaderMaterial {\n    constructor(params?: any) {\n        const defines: { [key: string]: any } = {};\n        defines.CAMERA_IN_SPACE = \"\";\n\n        const shaderParams = {\n            name: \"GroundAtmosphereMaterial\",\n            vertexShader: GroundAtmosphereShader.vertexShader,\n            fragmentShader: GroundAtmosphereShader.fragmentShader,\n            uniforms: GroundAtmosphereShader.uniforms,\n            transparent: true,\n            depthTest: false,\n            depthWrite: false,\n            side: THREE.FrontSide,\n            blending: THREE.NormalBlending,\n            fog: false\n        };\n        super(shaderParams);\n    }\n\n    setDynamicLighting(enableLighting: boolean) {\n        this.uniforms.u_atmosphereEnv.value.w = enableLighting ? 1.0 : 0.0;\n    }\n\n    /**\n     * Set maximum outer radius of atmosphere.\n     *\n     * @default [[EarthConstants.EQUATORIAL_RADIUS]] * 1.025\n     */\n    set outerRadius(radius: number) {\n        this.uniforms.u_atmosphereEnv.value.y = radius;\n    }\n\n    get outerRadius(): number {\n        return this.uniforms.u_atmosphereEnv.value.y;\n    }\n\n    /**\n     * Set maximum inner radius of atmosphere.\n     *\n     * @default [[EarthConstants.EQUATORIAL_RADIUS]] * 1.001.\n     */\n    set innerRadius(radius: number) {\n        this.uniforms.u_atmosphereEnv.value.x = radius;\n    }\n\n    get innerRadius(): number {\n        return this.uniforms.u_atmosphereEnv.value.x;\n    }\n\n    /**\n     * Updates the uniform data of a material used to render an atmosphere.\n     *\n     * This includes only uniforms that may change frame by frame, other uniforms are\n     * accessed with convenient material setters and getters.\n     *\n     * @param shaderMaterial - Material which uniforms will be updated.\n     * @param matrixWorldInverse - Inverse of world matrix used to position the atmosphere dome.\n     * @param lightDirection - The light directional vector in world space.\n     * @param camera - Camera used in rendering.\n     */\n    updateUniforms(\n        shaderMaterial: THREE.ShaderMaterial,\n        object: THREE.Object3D,\n        camera: THREE.Camera,\n        lightDirection: THREE.Vector3\n    ): void {\n        const cameraInfo = this.getCameraInfo(object, camera);\n\n        if (shaderMaterial !== undefined && shaderMaterial.isMaterial) {\n            if (\n                shaderMaterial.uniforms &&\n                shaderMaterial.uniforms.u_atmosphereEnv &&\n                shaderMaterial.uniforms.u_hsvCorrection &&\n                shaderMaterial.uniforms.u_eyePositionWorld &&\n                shaderMaterial.uniforms.u_modelViewProjection &&\n                shaderMaterial.uniforms.u_lightDirectionWorld\n            ) {\n                const eyePos = cameraInfo.eyePos;\n                const mvp = cameraInfo.modelViewProjection;\n                const cameraHeight = cameraInfo.eyeHeight;\n\n                shaderMaterial.uniforms.u_eyePositionWorld.value.copy(eyePos);\n                shaderMaterial.uniforms.u_modelViewProjection.value.copy(mvp);\n\n                shaderMaterial.uniforms.u_atmosphereEnv.value.z = cameraHeight;\n                shaderMaterial.uniforms.u_lightDirectionWorld.value = lightDirection.clone();\n\n                const cameraInSpace = cameraHeight > this.outerRadius;\n                const needsUpdate0 = setShaderDefine(\n                    shaderMaterial.defines,\n                    \"CAMERA_IN_SPACE\",\n                    cameraInSpace\n                );\n                const needsUpdate1 = setShaderDefine(\n                    shaderMaterial.defines,\n                    \"CAMERA_IN_ATMOSPHERE\",\n                    !cameraInSpace\n                );\n                shaderMaterial.needsUpdate = needsUpdate0 || needsUpdate1;\n            } else {\n                throw Error(\"Atmosphere material has missing uniforms\");\n            }\n        } else {\n            throw Error(\"Wrong object used, only Material objects are supported\");\n        }\n    }\n\n    /*\n     * Calculate camera position used in vertex shader of atmosphere materials.\n     *\n     * @param object -\n     * @param camera - Camera used to get the eye position.\n     */\n    private getCameraInfo(\n        object: THREE.Object3D,\n        camera: THREE.Camera,\n        reverse: boolean = false\n    ): { modelViewProjection: THREE.Matrix4; eyePos: THREE.Vector3; eyeHeight: number } {\n        if (reverse) {\n            const modelMatrix = new THREE.Matrix4().identity();\n            const viewMatrix = new THREE.Matrix4().getInverse(object.matrixWorld).transpose();\n            const projectionMatrix = camera.projectionMatrix;\n\n            const mvpMatrix = new THREE.Matrix4();\n            // MVP = Projection * View * Model\n            mvpMatrix.multiplyMatrices(viewMatrix, modelMatrix);\n            mvpMatrix.multiplyMatrices(projectionMatrix, mvpMatrix);\n\n            const eyePos = new THREE.Vector3();\n            object.getWorldPosition(eyePos);\n            const objectPos = new THREE.Vector3();\n            camera.getWorldPosition(objectPos);\n            const eyeHeight = objectPos.distanceTo(eyePos);\n\n            return {\n                modelViewProjection: mvpMatrix,\n                eyePos,\n                eyeHeight\n            };\n        } else {\n            const modelMatrix = object.matrixWorld;\n            const viewMatrix = camera.matrixWorldInverse;\n            const projectionMatrix = camera.projectionMatrix;\n\n            const mvpMatrix = new THREE.Matrix4();\n            // MVP = Projection * View * Model\n            mvpMatrix.multiplyMatrices(viewMatrix, modelMatrix);\n            mvpMatrix.multiplyMatrices(projectionMatrix, mvpMatrix);\n\n            const eyePos = new THREE.Vector3();\n            camera.getWorldPosition(eyePos);\n            const objectPos = new THREE.Vector3();\n            object.getWorldPosition(objectPos);\n            const eyeHeight = objectPos.distanceTo(eyePos);\n            // Normally we would return simply camera position, but since camera is not moving in\n            // the globe view only the world, we need to calculate eye relative to object position.\n            eyePos.sub(objectPos);\n            return {\n                modelViewProjection: mvpMatrix,\n                eyePos,\n                eyeHeight\n            };\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\nimport linesShaderChunk from \"./ShaderChunks/LinesChunks\";\n\nconst vertexSource: string = `\n#ifdef USE_COLOR\nattribute vec4 color;\nvarying vec3 vColor;\n#endif\n\n// uniforms to implement double-precision\nuniform mat4 u_mvp;             // combined modelView and projection matrix\nuniform vec3 u_eyepos;          // eye position major\nuniform vec3 u_eyepos_lowpart;  // eye position minor ((double) eyepos - (float) eyepos)\n\n// vertex attributes\nattribute vec3 position;        // high part\nattribute vec3 positionLow;     // low part\n\n#include <high_precision_vert_func>\n\nvoid main() {\n    #ifdef USE_COLOR\n    vColor = color.rgb;\n    #endif\n\n    vec3 pos = subtractDblEyePos(position);\n    gl_Position = u_mvp * vec4(pos, 1.0);\n}`;\n\nconst fragmentSource: string = `\nprecision highp float;\nprecision highp int;\n\nuniform vec3 diffuse;\nuniform float opacity;\n\n#ifdef USE_COLOR\nvarying vec3 color;\n#endif\n\nvoid main() {\n    #ifdef USE_COLOR\n    gl_FragColor = vec4( diffuse * vColor, opacity );\n    #else\n    gl_FragColor = vec4( diffuse, opacity );\n    #endif\n}`;\n\n/**\n * Parameters used when constructing a new {@link SolidLineMaterial}.\n */\nexport interface HighPrecisionLineMaterialParameters {\n    /**\n     * Line color.\n     */\n    color?: number | string | THREE.Color;\n    /**\n     * Line opacity.\n     */\n    opacity?: number;\n}\n\n/**\n * Material designed to render high precision lines (ideal for position-sensible data).\n */\nexport class HighPrecisionLineMaterial extends THREE.RawShaderMaterial {\n    static DEFAULT_COLOR: number = 0x000050;\n    static DEFAULT_OPACITY: number = 1.0;\n\n    isHighPrecisionLineMaterial: boolean;\n\n    /**\n     * Constructs a new `HighPrecisionLineMaterial`.\n     *\n     * @param params - `HighPrecisionLineMaterial` parameters.\n     */\n    constructor(params?: HighPrecisionLineMaterialParameters) {\n        Object.assign(THREE.ShaderChunk, linesShaderChunk);\n\n        const shaderParams = {\n            name: \"HighPrecisionLineMaterial\",\n            vertexShader: vertexSource,\n            fragmentShader: fragmentSource,\n            uniforms: {\n                diffuse: new THREE.Uniform(\n                    new THREE.Color(HighPrecisionLineMaterial.DEFAULT_COLOR)\n                ),\n                opacity: new THREE.Uniform(HighPrecisionLineMaterial.DEFAULT_OPACITY),\n                u_mvp: new THREE.Uniform(new THREE.Matrix4()),\n                u_eyepos: new THREE.Uniform(new THREE.Vector3()),\n                u_eyepos_lowpart: new THREE.Uniform(new THREE.Vector3())\n            }\n        };\n        Object.assign(shaderParams, params);\n        super(shaderParams);\n\n        this.type = \"HighPrecisionLineMaterial\";\n        this.isHighPrecisionLineMaterial = true;\n\n        // Apply initial parameter values.\n        if (params !== undefined) {\n            if (params.color !== undefined) {\n                this.color.set(params.color as any);\n            }\n            if (params.opacity !== undefined) {\n                this.opacity = params.opacity;\n            }\n        }\n\n        this.updateTransparencyFeature();\n    }\n\n    /**\n     * Line color.\n     */\n    get color(): THREE.Color {\n        return this.uniforms.diffuse.value as THREE.Color;\n    }\n    set color(value: THREE.Color) {\n        this.uniforms.diffuse.value.copy(value);\n    }\n\n    private updateTransparencyFeature() {\n        this.transparent = this.opacity < 1.0 ? true : false;\n    }\n}\n\nexport function isHighPrecisionLineMaterial(\n    material: object | undefined\n): material is HighPrecisionLineMaterial {\n    return (\n        material !== undefined &&\n        (material as HighPrecisionLineMaterial).isHighPrecisionLineMaterial === true\n    );\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\nimport linesShaderChunk from \"./ShaderChunks/LinesChunks\";\n\nconst vertexSource: string = `\n#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif\n\nuniform float size;\n\n// uniforms to implement double-precision\nuniform mat4 u_mvp;             // combined modelView and projection matrix\nuniform vec3 u_eyepos;          // eye position major\nuniform vec3 u_eyepos_lowpart;  // eye position minor ((double) eyepos - (float) eyepos)\n\n// vertex attributes\nattribute vec3 positionLow;     // low part\n\n#include <high_precision_vert_func>\n\nvoid main() {\n    #ifdef USE_COLOR\n    vColor = color.rgb;\n    #endif\n\n    vec3 pos = subtractDblEyePos(position);\n    gl_Position = u_mvp * vec4(pos, 1.0);\n\n    // ignore sizeAttenuation for now!\n    gl_PointSize = size;\n}`;\n\n/**\n * Parameters used when constructing a new {@link HighPrecisionPointMaterial}.\n */\nexport interface HighPrecisionPointMaterialParameters extends THREE.PointsMaterialParameters {\n    /**\n     * Point color.\n     */\n    color?: number | string | THREE.Color;\n    /**\n     * Point opacity.\n     */\n    opacity?: number;\n    /**\n     * Point scale.\n     */\n    scale?: number;\n    /**\n     * UV transformation matrix.\n     */\n    uvTransform?: THREE.Matrix3;\n}\n\n/**\n * Material designed to render high precision points (ideal for position-sensible data).\n */\nexport class HighPrecisionPointMaterial extends THREE.PointsMaterial {\n    static DEFAULT_COLOR: number = 0x000050;\n    static DEFAULT_OPACITY: number = 1.0;\n    static DEFAULT_SIZE: number = 1.0;\n    static DEFAULT_SCALE: number = 1.0;\n\n    isHighPrecisionPointMaterial: boolean;\n    uniforms: { [uniform: string]: THREE.IUniform };\n    vertexShader?: string;\n    fragmentShader?: string;\n\n    /**\n     * Constructs a new `HighPrecisionPointMaterial`.\n     *\n     * @param params - `HighPrecisionPointMaterial` parameters.\n     */\n    constructor(params?: HighPrecisionPointMaterialParameters) {\n        Object.assign(THREE.ShaderChunk, linesShaderChunk);\n\n        const shaderParams = params;\n        super(shaderParams);\n\n        this.type = \"HighPrecisionPointMaterial\";\n        this.vertexShader = vertexSource;\n        this.fragmentShader = THREE.ShaderChunk.points_frag;\n        this.fog = false;\n\n        this.uniforms = {\n            diffuse: new THREE.Uniform(new THREE.Color(HighPrecisionPointMaterial.DEFAULT_COLOR)),\n            opacity: new THREE.Uniform(HighPrecisionPointMaterial.DEFAULT_OPACITY),\n            size: new THREE.Uniform(HighPrecisionPointMaterial.DEFAULT_SIZE),\n            scale: new THREE.Uniform(HighPrecisionPointMaterial.DEFAULT_SCALE),\n            map: new THREE.Uniform(new THREE.Texture()),\n            uvTransform: new THREE.Uniform(new THREE.Matrix3()),\n            u_mvp: new THREE.Uniform(new THREE.Matrix4()),\n            u_eyepos: new THREE.Uniform(new THREE.Vector3()),\n            u_eyepos_lowpart: new THREE.Uniform(new THREE.Vector3())\n        };\n\n        this.isHighPrecisionPointMaterial = true;\n\n        // Apply initial parameter values.\n        if (params !== undefined) {\n            if (params.color !== undefined) {\n                this.color.set(params.color as any);\n            }\n            if (params.opacity !== undefined) {\n                this.opacity = params.opacity;\n            }\n            if (params.size !== undefined) {\n                this.size = params.size;\n            }\n            if (params.scale !== undefined) {\n                this.scale = params.scale;\n            }\n            if (params.uvTransform !== undefined) {\n                this.uvTransform = params.uvTransform;\n            }\n            if (params.map !== undefined) {\n                this.map = params.map;\n            }\n        }\n    }\n\n    /**\n     *  Point scale.\n     */\n    get scale(): number {\n        return this.uniforms.scale.value;\n    }\n\n    set scale(value: number) {\n        this.uniforms.scale.value = value;\n    }\n\n    /**\n     * UV transformation matrix.\n     */\n    get uvTransform(): THREE.Matrix3 {\n        return this.uniforms.uvTransform.value;\n    }\n    set uvTransform(value: THREE.Matrix3) {\n        this.uniforms.uvTransform.value = value;\n    }\n}\n\nexport function isHighPrecisionPointMaterial(\n    material: object | undefined\n): material is HighPrecisionPointMaterial {\n    return (\n        material !== undefined &&\n        (material as HighPrecisionPointMaterial).isHighPrecisionPointMaterial === true\n    );\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nconst vertexSource: string = `\nattribute vec4 position;\nattribute vec4 color;\nattribute vec2 uv;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nvarying vec4 vColor;\nvarying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    vColor = color;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xyz, 1.0);\n}`;\n\nconst fragmentSource: string = `\nprecision highp float;\nprecision highp int;\n\nuniform sampler2D map;\n\nvarying vec4 vColor;\nvarying vec2 vUv;\n\nvoid main() {\n\n    vec4 color = texture2D(map, vUv.xy);\n    color *= vColor;\n    if (color.a < 0.05) {\n        discard;\n    }\n    gl_FragColor = color;\n}`;\n\n/**\n * Parameters used when constructing a new {@link IconMaterial}.\n */\nexport interface IconMaterialParameters {\n    /**\n     * Texture map.\n     */\n    map: THREE.Texture;\n}\n\n/**\n * 2D material for icons, similar to [[TextMaterial]]. Uses component in texture coordinates to\n * apply opacity.\n */\nexport class IconMaterial extends THREE.RawShaderMaterial {\n    /**\n     * Constructs a new `IconMaterial`.\n     *\n     * @param params - `IconMaterial` parameters.\n     */\n    constructor(params: IconMaterialParameters) {\n        // tslint:disable-next-line: deprecation\n        const shaderParams: THREE.ShaderMaterialParameters = {\n            name: \"IconMaterial\",\n            vertexShader: vertexSource,\n            fragmentShader: fragmentSource,\n            uniforms: {\n                map: new THREE.Uniform(params.map)\n            },\n            depthTest: true,\n            depthWrite: false,\n            transparent: true,\n\n            vertexColors: true,\n            premultipliedAlpha: true,\n            blending: THREE.NormalBlending\n        };\n        super(shaderParams);\n    }\n\n    /**\n     * Icon texture map/atlas.\n     */\n    get map(): THREE.Texture {\n        return this.uniforms.map.value;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\n/**\n * The shader used in the [[UnrealBloomPass]] for the bloom/glow effect.\n */\nexport const LuminosityHighPassShader: THREE.Shader = {\n    uniforms: {\n        tDiffuse: { value: null },\n        luminosityThreshold: { value: 1.0 },\n        smoothWidth: { value: 1.0 },\n        defaultColor: { value: new THREE.Color(0x000000) },\n        defaultOpacity: { value: 0.0 }\n    },\n    vertexShader: `\n    varying vec2 vUv;\n    void main() {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }`,\n    fragmentShader: `\n    uniform sampler2D tDiffuse;\n    uniform vec3 defaultColor;\n    uniform float defaultOpacity;\n    uniform float luminosityThreshold;\n    uniform float smoothWidth;\n    varying vec2 vUv;\n    void main() {\n        vec4 texel = texture2D( tDiffuse, vUv );\n        vec3 luma = vec3( 0.299, 0.587, 0.114 );\n        float v = dot( texel.xyz, luma );\n        vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\n        float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\n        gl_FragColor = mix( outputColor, texel, alpha );\n    }`\n};\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport * as THREE from \"three\";\n\nimport { CopyShader } from \"./CopyMaterial\";\n\n/**\n * The material to use for the quad of the {@link @here/harp-mapview#MSAARenderPass}\n * in the composing.\n */\nexport class MSAAMaterial extends THREE.ShaderMaterial {\n    /**\n     * The constructor of `MSAAMaterial`.\n     *\n     * @param uniforms - The [[CopyShader]]'s uniforms.\n     */\n    constructor(uniforms: { [uniformName: string]: THREE.IUniform }) {\n        super({\n            uniforms,\n            vertexShader: CopyShader.vertexShader,\n            fragmentShader: CopyShader.fragmentShader,\n            premultipliedAlpha: true,\n            transparent: true,\n            blending: THREE.AdditiveBlending,\n            depthTest: false,\n            depthWrite: false\n        });\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport * as THREE from \"three\";\n\n/**\n * `SepiaShader`.\n */\nexport const SepiaShader: THREE.Shader = {\n    uniforms: {\n        tDiffuse: { value: null },\n        amount: { value: 1.0 }\n    },\n    vertexShader: `\n        varying vec2 vUv;\n        void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }`,\n    fragmentShader: `\n        uniform float amount;\n        uniform sampler2D tDiffuse;\n        varying vec2 vUv;\n        void main() {\n            vec4 color = texture2D( tDiffuse, vUv );\n            vec3 c = color.rgb;\n            color.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );\n            color.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );\n            color.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );\n            gl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );\n        }`\n};\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport * as THREE from \"three\";\nimport AtmosphereShaderChunks from \"./ShaderChunks/AtmosphereChunks\";\nimport { setShaderDefine } from \"./Utils\";\n\nconst EQUATORIAL_RADIUS: number = 6378137.0;\n\n/**\n * `SkyAtmosphereShader`.\n *\n * Describes shading of atmosphere as seen from outer space.\n */\nexport const SkyAtmosphereShader: THREE.Shader = {\n    uniforms: {\n        u_eyePositionWorld: new THREE.Uniform(new THREE.Vector3()),\n        u_lightDirectionWorld: new THREE.Uniform(new THREE.Vector3(0, 1, 0)),\n        u_modelViewProjection: new THREE.Uniform(new THREE.Matrix4()),\n        // Environment settings:\n        // atmosphere inner and outer radius, camera height, light mode\n        u_atmosphereEnv: new THREE.Uniform(\n            new THREE.Vector4(\n                // Maximum inner radius\n                EQUATORIAL_RADIUS,\n                // Maximum outer radius\n                EQUATORIAL_RADIUS * 1.025,\n                // Camera height\n                0,\n                // Toggles the light modes:\n                // 0 - light always directly overhead,\n                // 1 - lighting uses light direction: uniform u_lightDirectionWorld\n                1\n            )\n        ),\n        u_hsvCorrection: new THREE.Uniform(new THREE.Vector3(0, 0, 0)),\n\n        topColor: new THREE.Uniform(new THREE.Color(0x0077ff)),\n        bottomColor: new THREE.Uniform(new THREE.Color(0xffffff)),\n        offset: new THREE.Uniform(33.0),\n        exponent: new THREE.Uniform(0.6),\n        fogColor: new THREE.Uniform(new THREE.Color(0x0077ff)), // scene.fog.color\n        fogNear: new THREE.Uniform(new THREE.Color(0x0077ff)), // scene.fog.near\n        fogFar: new THREE.Uniform(new THREE.Color(0xffffff)) // scene.fog.far\n    },\n\n    vertexShader: `\n    precision highp float;\n    precision highp int;\n\n    attribute vec4 position;\n\n    uniform mat4 u_modelViewProjection;\n    uniform vec3 u_eyePositionWorld;\n    uniform vec3 u_lightDirectionWorld;\n\n    uniform vec4 u_atmosphereEnv; // Atmosphere inner and outer radius, camera height, light mode\n    uniform vec3 u_hsvCorrection;\n\n    const float Pi = 3.141592653589793;\n    const float Kr = 0.0025;\n    const float Kr4PI = Kr * 4.0 * Pi;\n    const float Km = 0.0015;\n    const float Km4PI = Km * 4.0 * Pi;\n    const float ESun = 15.0; // should be 15.0\n    const float KmESun = Km * ESun;\n    const float KrESun = Kr * ESun;\n    const vec3 InvWavelength = vec3(\n        5.60204474633241,  // Red = 1.0 / Math.pow(0.650, 4.0)\n        9.473284437923038, // Green = 1.0 / Math.pow(0.570, 4.0)\n        19.643802610477206); // Blue = 1.0 / Math.pow(0.475, 4.0)\n\n    const int nSamples = 2;\n    const float fSamples = 2.0;\n\n    varying vec3 v_rayleighColor;\n    varying vec3 v_mieColor;\n    varying vec3 v_vertToCamera;\n\n    ${AtmosphereShaderChunks.atmosphere_common_utils}\n    ${AtmosphereShaderChunks.atmosphere_vertex_utils}\n\n    //\n    // Computes rayleight and mia atmosphere factors for sky.\n    //\n    // Code based on GPU Gems article.\n    //\n    // Author: Sean O'Neil\n    //\n    // Copyright (c) 2004 Sean O'Neil\n    //\n    // https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-16-accurate-atmospheric-scattering\n    //\n    // Further modifications by HERE\n    //\n    AtmosphereColor computeSkyAtmosphere(vec3 v3Pos, vec3 vLightDir, bool dynamicLighting)\n    {\n        // Unpack attributes\n        float fInnerRadius = u_atmosphereEnv.x;\n        float fOuterRadius = u_atmosphereEnv.y;\n        float fCameraHeight = u_atmosphereEnv.z;\n\n        // All that may be const or define(s) at further optimization:\n        float fScale = 1.0 / (fOuterRadius - fInnerRadius);\n        float fScaleOverScaleDepth = (fScale / RayleighScaleDepth);\n        float fCameraHeight2 = fCameraHeight * fCameraHeight;\n        float fOuterRadius2 = fOuterRadius * fOuterRadius;\n\n        // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\n        vec3 v3Ray = v3Pos - u_eyePositionWorld;\n        float fFar = length(v3Ray);\n        v3Ray /= fFar;\n\n    #ifdef CAMERA_IN_SPACE\n\n        // Calculate the closest intersection of the ray with the outer\n        // atmosphere, this is the first point of the ray passing through the atmosphere dome.\n        float fNear = getNearSphereIntersect(u_eyePositionWorld, v3Ray, fCameraHeight2, fOuterRadius2);\n        // Make far relative to first atmosphere intersection\n        fFar -= fNear;\n\n        // Compute the ray's starting position within the atmosphere, then\n        // calculate its scattering offset\n        vec3 v3Start = u_eyePositionWorld + v3Ray * fNear;\n\n        float fStartAngle = dot(v3Ray, v3Start) / fOuterRadius;\n        float fStartDepth = exp(-1.0 / RayleighScaleDepth );\n        float fStartOffset = fStartDepth * scale(fStartAngle);\n\n    #else // CAMERA_IN_ATMOSPHERE\n\n        // The ray starts already in atmosphere\n        vec3 v3Start = u_eyePositionWorld;\n        float height = length(v3Start);\n        float depth = exp(fScaleOverScaleDepth * (fInnerRadius - fCameraHeight));\n        float fStartAngle = dot(v3Ray, v3Start) / height;\n        float fStartOffset = depth * scale(fStartAngle);\n\n    #endif\n\n        // Initialize the scattering loop variables\n        float fSampleLength = fFar / fSamples;\n        float fScaledLength = fSampleLength * fScale;\n        vec3 v3SampleRay = v3Ray * fSampleLength;\n        vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\n\n        // Now loop through the sample rays\n        vec3 v3BaseColor = vec3(0.0);\n        vec3 v3Attenuate = vec3(0.0);\n        for(int i=0; i < nSamples; i++)\n        {\n            float height = length(v3SamplePoint);\n            float depth = exp(fScaleOverScaleDepth * (fInnerRadius - height));\n            float fLightAngle = dot(vLightDir, v3SamplePoint) / height;\n            float fCameraAngle = dot(v3Ray, v3SamplePoint) / height;\n            float fScatter = (fStartOffset + depth * (scale(fLightAngle) - scale(fCameraAngle)));\n            v3Attenuate = exp(-fScatter * (InvWavelength * Kr4PI + Km4PI));\n            v3BaseColor += v3Attenuate * (depth * fScaledLength);\n            v3SamplePoint += v3SampleRay;\n        }\n\n        // Scale the Mie and Rayleigh colors and set up output of the function\n        AtmosphereColor color;\n        color.mie = v3BaseColor * KmESun;\n        color.rayleigh = v3BaseColor * (InvWavelength * KrESun);\n        return color;\n    }\n\n    void main(void)\n    {\n        float fLightMode = u_atmosphereEnv.w;\n        bool bDynamicLight = fLightMode != 0.0;\n\n        vec3 vLightDir = conditionalBranchFree(bDynamicLight,\n            u_lightDirectionWorld,\n            u_eyePositionWorld);\n        vLightDir = normalize(vLightDir);\n\n        AtmosphereColor atmColor = computeSkyAtmosphere(position.xyz, vLightDir, bDynamicLight);\n        v_mieColor = atmColor.mie;\n        v_rayleighColor = atmColor.rayleigh;\n        v_vertToCamera = u_eyePositionWorld - position.xyz;\n\n        gl_Position = u_modelViewProjection * position;\n    }\n    `,\n\n    fragmentShader: `\n    // Because of harsh light distribution the exposure correction is always enabled for the sky.\n    #define CORRECT_EXPOSURE 1\n\n    precision highp float;\n    precision highp int;\n\n    #ifdef CORRECT_COLOR\n    uniform vec3 u_hsvCorrection; // Hue, saturation, brightness\n    #endif\n\n    uniform vec4 u_atmosphereEnv; // Atmosphere inner and outer radius, camera height, light mode\n    uniform vec3 u_eyePositionWorld;\n    uniform vec3 u_lightDirectionWorld;\n\n    const float g = -0.95;\n    const float g2 = g * g;\n\n    varying vec3 v_rayleighColor;\n    varying vec3 v_mieColor;\n    varying vec3 v_vertToCamera;\n\n    ${AtmosphereShaderChunks.atmosphere_common_utils}\n    ${AtmosphereShaderChunks.atmosphere_fragment_utils}\n\n    void main(void)\n    {\n        float fInnerRadius = u_atmosphereEnv.x;\n        float fOuterRadius = u_atmosphereEnv.y;\n        float fCameraHeight = u_atmosphereEnv.z;\n        float fLightMode = u_atmosphereEnv.w;\n        bool bDynamicLight = fLightMode != 0.0;\n\n        vec3 vLightDir = conditionalBranchFree(bDynamicLight,\n            u_lightDirectionWorld,\n            u_eyePositionWorld);\n        vLightDir = normalize(vLightDir);\n\n        // NOTE:\n        // For better precision normalization may be added on fragment (for mobile devices)\n        // while in vertex shader may be left un-normalized\n        // dot(vLightDir, normalize(v_vertToCamera)) / length(v_vertToCamera);\n        float fCosAngle = dot(vLightDir, v_vertToCamera) / length(v_vertToCamera);\n        float fRayleighPhase = 0.75 * (1.0 + fCosAngle * fCosAngle);\n        float fMiePhase = 1.5 * ((1.0 - g2) / (2.0 + g2)) * (1.0 + fCosAngle * fCosAngle) / pow(1.0 + g2 - 2.0 * g * fCosAngle, 1.5);\n\n        vec3 cRgb = fRayleighPhase * v_rayleighColor + fMiePhase * v_mieColor;\n\n        // Sky produces very harsh lighting effect so exposure correction is always enabled.\n    #if !defined(HDR_FRAME_BUFFER) && defined(CORRECT_EXPOSURE)\n        // Exposure factor may be exposed to uniform variable.\n        cRgb = correctExposure(cRgb, 2.0);\n    #endif\n\n    #ifdef CORRECT_COLOR\n        cRgb = correctColor(cRgb, u_hsvCorrection);\n    #endif\n\n        // Alter alpha based on how close the viewer is to the ground (1.0 = on ground, 0.0 = at edge of atmosphere)\n        float fAtmosphereAlpha = clamp((fOuterRadius - fCameraHeight) /\n            (fOuterRadius - fInnerRadius), 0.0, 1.0);\n\n        // Alter alpha based on time of day (0.0 = night , 1.0 = day)\n        float fNightAlpha = conditionalBranchFree(bDynamicLight,\n            clamp(dot(normalize(u_eyePositionWorld), vLightDir), 0.0, 1.0),\n            1.0);\n        fAtmosphereAlpha *= pow(fNightAlpha, 0.5);\n\n        gl_FragColor = vec4(cRgb, mix(cRgb.b, 1.0, fAtmosphereAlpha));\n    }\n    `\n};\n\nexport class SkyAtmosphereMaterial extends THREE.RawShaderMaterial {\n    constructor(params?: any) {\n        // Import shader chunks\n        const defines: { [key: string]: any } = {};\n        defines.CAMERA_IN_SPACE = \"\";\n\n        const shaderParams = {\n            name: \"SkyAtmosphereMaterial\",\n            vertexShader: SkyAtmosphereShader.vertexShader,\n            fragmentShader: SkyAtmosphereShader.fragmentShader,\n            uniforms: SkyAtmosphereShader.uniforms,\n            transparent: true,\n            depthTest: true,\n            depthWrite: false,\n            side: THREE.BackSide,\n            blending: THREE.NormalBlending,\n            fog: false\n        };\n        super(shaderParams);\n    }\n\n    setDynamicLighting(enableLighting: boolean) {\n        this.uniforms.u_atmosphereEnv.value.w = enableLighting ? 1.0 : 0.0;\n    }\n\n    /**\n     * Set maximum outer radius of atmosphere.\n     *\n     * @default [[EarthConstants.EQUATORIAL_RADIUS]] * 1.025\n     */\n    set outerRadius(radius: number) {\n        this.uniforms.u_atmosphereEnv.value.y = radius;\n    }\n\n    get outerRadius(): number {\n        return this.uniforms.u_atmosphereEnv.value.y;\n    }\n\n    /**\n     * Set maximum inner radius of atmosphere.\n     *\n     * @default [[EarthConstants.EQUATORIAL_RADIUS]].\n     */\n    set innerRadius(radius: number) {\n        this.uniforms.u_atmosphereEnv.value.x = radius;\n    }\n\n    get innerRadius(): number {\n        return this.uniforms.u_atmosphereEnv.value.x;\n    }\n\n    /**\n     * Updates the uniform data of a material used to render an atmosphere.\n     *\n     * This includes only uniforms that may change frame by frame, other uniforms are\n     * accessed with convenient material setters and getters.\n     *\n     * @param shaderMaterial - Material which uniforms will be updated.\n     * @param matrixWorldInverse - Inverse of world matrix used to position the atmosphere dome.\n     * @param lightDirection - The light directional vector in world space.\n     * @param camera - Camera used in rendering.\n     */\n    updateUniforms(\n        shaderMaterial: THREE.ShaderMaterial,\n        object: THREE.Object3D,\n        camera: THREE.Camera,\n        lightDirection: THREE.Vector3\n    ): void {\n        const cameraInfo = this.getCameraInfo(object, camera);\n\n        if (shaderMaterial !== undefined && shaderMaterial.isMaterial) {\n            if (\n                shaderMaterial.uniforms &&\n                shaderMaterial.uniforms.u_atmosphereEnv &&\n                shaderMaterial.uniforms.u_hsvCorrection &&\n                shaderMaterial.uniforms.u_eyePositionWorld &&\n                shaderMaterial.uniforms.u_modelViewProjection &&\n                shaderMaterial.uniforms.u_lightDirectionWorld\n            ) {\n                const eyePos = cameraInfo.eyePos;\n                const mvp = cameraInfo.modelViewProjection;\n                const cameraHeight = cameraInfo.eyeHeight;\n\n                shaderMaterial.uniforms.u_eyePositionWorld.value.copy(eyePos);\n                shaderMaterial.uniforms.u_modelViewProjection.value.copy(mvp);\n\n                shaderMaterial.uniforms.u_atmosphereEnv.value.z = cameraHeight;\n                shaderMaterial.uniforms.u_lightDirectionWorld.value = lightDirection.clone();\n\n                const cameraInSpace = cameraHeight > this.outerRadius;\n                const needsUpdate0 = setShaderDefine(\n                    shaderMaterial.defines,\n                    \"CAMERA_IN_SPACE\",\n                    cameraInSpace\n                );\n                const needsUpdate1 = setShaderDefine(\n                    shaderMaterial.defines,\n                    \"CAMERA_IN_ATMOSPHERE\",\n                    !cameraInSpace\n                );\n                shaderMaterial.needsUpdate = needsUpdate0 || needsUpdate1;\n            } else {\n                throw Error(\"Atmosphere material has missing uniforms\");\n            }\n        } else {\n            throw Error(\"Wrong object used, only Material objects are supported\");\n        }\n    }\n\n    /*\n     * Calculate camera position used in vertex shader of atmosphere materials.\n     *\n     * @param object -\n     * @param camera - Camera used to get the eye position.\n     */\n    private getCameraInfo(\n        object: THREE.Object3D,\n        camera: THREE.Camera,\n        reverse: boolean = false\n    ): { modelViewProjection: THREE.Matrix4; eyePos: THREE.Vector3; eyeHeight: number } {\n        if (reverse) {\n            const modelMatrix = new THREE.Matrix4().identity();\n            const viewMatrix = new THREE.Matrix4().getInverse(object.matrixWorld).transpose();\n            const projectionMatrix = camera.projectionMatrix;\n\n            const mvpMatrix = new THREE.Matrix4();\n            // MVP = Projection * View * Model\n            mvpMatrix.multiplyMatrices(viewMatrix, modelMatrix);\n            mvpMatrix.multiplyMatrices(projectionMatrix, mvpMatrix);\n\n            const eyePos = new THREE.Vector3();\n            object.getWorldPosition(eyePos);\n            const objectPos = new THREE.Vector3();\n            camera.getWorldPosition(objectPos);\n            const eyeHeight = objectPos.distanceTo(eyePos);\n            return {\n                modelViewProjection: mvpMatrix,\n                eyePos,\n                eyeHeight\n            };\n        } else {\n            const modelMatrix = object.matrixWorld;\n            const viewMatrix = camera.matrixWorldInverse;\n            const projectionMatrix = camera.projectionMatrix;\n\n            const mvpMatrix = new THREE.Matrix4();\n            // MVP = Projection * View * Model\n            mvpMatrix.multiplyMatrices(viewMatrix, modelMatrix);\n            mvpMatrix.multiplyMatrices(projectionMatrix, mvpMatrix);\n\n            const eyePos = new THREE.Vector3();\n            camera.getWorldPosition(eyePos);\n            const objectPos = new THREE.Vector3();\n            object.getWorldPosition(objectPos);\n            const eyeHeight = objectPos.distanceTo(eyePos);\n            // Normally we would return simply camera position, but since camera is not moving in\n            // the globe view only the world, we need to calculate eye relative to object position.\n            eyePos.sub(objectPos);\n            return {\n                modelViewProjection: mvpMatrix,\n                eyePos,\n                eyeHeight\n            };\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { LineCaps, LineDashes } from \"@here/harp-datasource-protocol\";\nimport * as THREE from \"three\";\nimport { DisplacementFeature, DisplacementFeatureParameters } from \"./DisplacementFeature\";\nimport { FadingFeature, FadingFeatureParameters } from \"./MapMeshMaterials\";\nimport linesShaderChunk, { LineCapsModes } from \"./ShaderChunks/LinesChunks\";\nimport {\n    enforceBlending,\n    getShaderMaterialDefine,\n    setShaderDefine,\n    setShaderMaterialDefine\n} from \"./Utils\";\n\nconst LineCapsDefinesMapping: { [key in LineCaps]: number } = {\n    None: LineCapsModes.CAPS_NONE,\n    Square: LineCapsModes.CAPS_SQUARE,\n    Round: LineCapsModes.CAPS_ROUND,\n    TriangleIn: LineCapsModes.CAPS_TRIANGLE_IN,\n    TriangleOut: LineCapsModes.CAPS_TRIANGLE_OUT\n};\n\nconst DefinesLineCapsMapping: { [key: number]: LineCaps } = Object.keys(\n    LineCapsDefinesMapping\n).reduce((r, lineCapsName) => {\n    const defineKey = lineCapsName as keyof typeof LineCapsDefinesMapping;\n    const defineValue: number = LineCapsDefinesMapping[defineKey];\n    r[defineValue] = defineKey;\n    return r;\n}, ({} as any) as { [key: number]: LineCaps });\n\nexport enum LineDashesModes {\n    DASHES_SQUARE = 0,\n    DASHES_ROUND,\n    DASHES_DIAMOND\n}\n\nconst LineDashesDefinesMapping: { [key in LineDashes]: number } = {\n    Square: LineDashesModes.DASHES_SQUARE,\n    Round: LineDashesModes.DASHES_ROUND,\n    Diamond: LineDashesModes.DASHES_DIAMOND\n};\n\nconst DefinesLineDashesMapping: { [key: number]: LineDashes } = Object.keys(\n    LineDashesDefinesMapping\n).reduce((r, lineDashesName) => {\n    const defineKey = lineDashesName as keyof typeof LineDashesDefinesMapping;\n    const defineValue: number = LineDashesDefinesMapping[defineKey];\n    r[defineValue] = defineKey;\n    return r;\n}, ({} as any) as { [key: number]: LineDashes });\n\n/**\n * The vLength contains the actual line length, it's needed for the creation of line caps by\n * detecting line ends. `vLength == vExtrusionCoord.x + lineWidth * 2`\n */\n/**\n * The vExtrusionStrength relies on the edges of the lines. Represents how far the current point was\n * extruded on the edges because of the current angle. Needed for preventing line caps artifacts on\n * sharp line edges. For example, on sharp edges, some vertices can be extruded much further than\n * the full line length.\n */\n\nconst tmpColor = new THREE.Color();\nconst vertexSource: string = `\n#define SEGMENT_OFFSET 0.1\n\nattribute vec3 extrusionCoord;\nattribute vec3 position;\nattribute vec4 bitangent;\nattribute vec3 tangent;\nattribute vec2 uv;\nattribute vec3 normal;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float extrusionWidth;\nuniform float outlineWidth;\nuniform float offset;\nuniform vec2 drawRange;\n\n#ifdef USE_DISPLACEMENTMAP\nuniform sampler2D displacementMap;\n#endif\n\n#ifdef USE_TILE_CLIP\nvarying vec3 vPosition;\n#endif\nvarying vec3 vRange;\nvarying vec4 vCoords;\n#ifdef USE_COLOR\nattribute vec3 color;\nvarying vec3 vColor;\n#endif\n\n#ifdef USE_FADING\n#include <fading_pars_vertex>\n#endif\n\n#include <fog_pars_vertex>\n\n#include <extrude_line_vert_func>\n\nvoid main() {\n    // Calculate the segment.\n    vec2 segment = abs(extrusionCoord.xy) - SEGMENT_OFFSET;\n    float segmentPos = sign(extrusionCoord.x) / 2.0 + 0.5;\n\n    // Calculate the vertex position inside the line (segment) and extrusion direction and factor.\n    float linePos = mix(segment.x, segment.y, segmentPos);\n    vec2 extrusionDir = sign(extrusionCoord.xy);\n    // Precompute to avoid computing multiple times\n    float tanHalfAngle = tan(bitangent.w / 2.0);\n    float extrusionFactor = extrusionDir.y * tanHalfAngle;\n\n    // Calculate the extruded vertex position (and scale the extrusion direction).\n    vec3 pos = extrudeLine(\n        position, linePos, extrusionWidth + outlineWidth, bitangent, tangent, tanHalfAngle,\n        extrusionDir);\n\n    // Store the normalized extrusion coordinates in vCoords (with their ranges in vRange).\n    vRange = vec3(extrusionCoord.z, extrusionWidth, extrusionFactor);\n    vCoords = vec4(extrusionDir / vRange.xy, segment / vRange.x);\n\n    // Adjust the segment to fit the drawRange.\n    float capDist = (extrusionWidth + outlineWidth) / extrusionCoord.z;\n    if ((vCoords.w + capDist) < drawRange.x || (vCoords.z - capDist) > drawRange.y) {\n        vCoords.zw += 1.0;\n    }\n    if (vCoords.z < drawRange.x) {\n        vCoords.zw += vec2(drawRange.x - vCoords.z, 0.0);\n    }\n    if (vCoords.w > drawRange.y) {\n        vCoords.zw -= vec2(0.0, vCoords.w - drawRange.y);\n    }\n\n    // Transform position.\n    #ifdef USE_DISPLACEMENTMAP\n    pos += normalize( normal ) * texture2D( displacementMap, uv ).x;\n    #endif\n\n    // Shift the line based on the offset, where the bitangent is the cross product of the average\n    // of the two direction vectors (the previous and next segment directions) and the normal of\n    // the line (facing into the sky). The w component is the angle between the two segments.\n    // Note, we need to take the angle into consideration, so we use trigonometry to calculate how\n    // much we need to extend the offset. Note, orthough this looks complicated we are doing this\n    // in the vertex shader, so it should not cause a performance issue.\n    pos += bitangent.xyz * offset * sqrt(1.0 + pow(abs(tanHalfAngle), 2.0));\n\n    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);\n    gl_Position = projectionMatrix * mvPosition;\n\n    // Pass extruded position to fragment shader.\n    #ifdef USE_TILE_CLIP\n    vPosition = pos;\n    #endif\n\n    #ifdef USE_COLOR\n    // Pass vertex color to fragment shader.\n    vColor = color;\n    #endif\n\n    #ifdef USE_FADING\n    #include <fading_vertex>\n    #endif\n\n    #include <fog_vertex>\n}`;\n\nconst fragmentSource: string = `\nprecision highp float;\nprecision highp int;\n\nuniform vec3 diffuse;\nuniform vec3 outlineColor;\nuniform float opacity;\nuniform float extrusionWidth;\nuniform float outlineWidth;\nuniform vec2 tileSize;\nuniform vec2 drawRange;\n\n#ifdef USE_DASHED_LINE\nuniform float dashSize;\nuniform float gapSize;\nuniform vec3 dashColor;\n\n#define DASHES_SQUARE ${LineDashesModes.DASHES_SQUARE}\n#define DASHES_ROUND ${LineDashesModes.DASHES_ROUND}\n#define DASHES_DIAMOND ${LineDashesModes.DASHES_DIAMOND}\n#endif\n\n#ifdef USE_TILE_CLIP\nvarying vec3 vPosition;\n#endif\n\nvarying vec3 vRange;\nvarying vec4 vCoords;\n#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif\n\n#include <round_edges_and_add_caps>\n#include <tile_clip_func>\n\n#ifdef USE_FADING\n#include <fading_pars_fragment>\n#endif\n\n#include <fog_pars_fragment>\n\nvoid main() {\n    float alpha = opacity;\n    vec3 outputDiffuse = diffuse;\n\n    #ifdef USE_TILE_CLIP\n    tileClip(vPosition.xy, tileSize);\n    #endif\n\n    // Calculate distance to center (0.0: lineCenter, 1.0: lineEdge).\n    float distToCenter = roundEdgesAndAddCaps(vCoords, vRange);\n    // Calculate distance to edge (-1.0: lineCenter, 0.0: lineEdge).\n    float distToEdge = distToCenter - (extrusionWidth + outlineWidth) / extrusionWidth;\n\n    // Decrease the line opacity by the distToEdge, making the transition steeper when the slope\n    // of distToChange increases (i.e. the line is further away).\n    float width = fwidth(distToEdge);\n    alpha *= (1.0 - smoothstep(-width, width, distToEdge));\n\n    #ifdef USE_DASHED_LINE\n    // Compute the distance to the dash origin (0.0: dashOrigin, 1.0: dashEnd, (d+g)/d: gapEnd).\n    float d = dashSize / vRange.x;\n    float g = gapSize / vRange.x;\n    float distToDashOrigin = mod(vCoords.x, d + g) / d;\n\n    // Compute distance to dash edge (0.5: dashCenter, 0.0: dashEdge) and compute the\n    // dashBlendFactor similarly on how we did it for the line opacity.\n    float distToDashEdge = 0.5 - distance(distToDashOrigin, (d + g) / d * 0.5);\n    #if DASHES_MODE == DASHES_ROUND\n    distToDashEdge = 0.5 - distance(vec2(distToCenter * 0.5, distToDashEdge), vec2(0.0, 0.5));\n    #elif DASHES_MODE == DASHES_DIAMOND\n    distToDashEdge -= distToCenter * 0.5;\n    #endif\n    float dashWidth = fwidth(distToDashEdge);\n    float dashBlendFactor = 1.0 - smoothstep(-dashWidth, dashWidth, distToDashEdge);\n\n    #ifdef USE_DASH_COLOR\n    outputDiffuse = mix(diffuse, dashColor, dashBlendFactor);\n    #endif\n    #endif\n\n    #ifdef USE_OUTLINE\n    // Calculate distance to outline (0.0: lineEdge, outlineWidth/lineWidth: outlineEdge) and\n    // compute the outlineBlendFactor (used to mix line and outline colors).\n    float distToOutline = distToCenter - 1.0;\n    float outlineWidth = fwidth(distToOutline);\n    float outlineBlendFactor = smoothstep(-outlineWidth, outlineWidth, distToOutline);\n\n    // Mix the colors using the different computed factors.\n    #if defined(USE_DASHED_LINE) && !defined(USE_DASH_COLOR)\n    float colorBlendFactor = smoothstep(-1.0, 1.0, dashBlendFactor - outlineBlendFactor);\n    outputDiffuse = mix(\n      mix(\n        mix(outlineColor, diffuse, colorBlendFactor),\n        outputDiffuse,\n        dashBlendFactor\n      ),\n      outlineColor,\n      outlineBlendFactor\n    );\n    #else\n    outputDiffuse = mix(outputDiffuse, outlineColor, outlineBlendFactor);\n    #endif\n    #endif\n\n    #if defined(USE_DASHED_LINE) && !defined(USE_DASH_COLOR)\n    // Multiply the alpha by the dashBlendFactor.\n    #if defined(USE_OUTLINE)\n    alpha *= clamp(dashBlendFactor + outlineBlendFactor, 0.0, 1.0);\n    #else\n    alpha *= 1.0 - dashBlendFactor;\n    #endif\n    #endif\n\n    #ifdef USE_COLOR\n    gl_FragColor = vec4( outputDiffuse * vColor, alpha );\n    #else\n    gl_FragColor = vec4( outputDiffuse, alpha );\n    #endif\n\n    #include <fog_fragment>\n\n    #ifdef USE_FADING\n    #include <fading_fragment>\n    #endif\n}`;\n\n/**\n * Parameters used when constructing a new {@link SolidLineMaterial}.\n */\nexport interface SolidLineMaterialParameters\n    extends FadingFeatureParameters,\n        DisplacementFeatureParameters {\n    /**\n     * Line color.\n     */\n    color?: number | string;\n\n    /**\n     * Line outline color.\n     */\n    outlineColor?: number | string;\n\n    /**\n     * Enables/Disable depth test.\n     */\n    depthTest?: boolean;\n\n    /**\n     * Enables/Disable depth write.\n     */\n    depthWrite?: boolean;\n\n    /**\n     * `SolidLineMaterial` extends the ThreeJS `RawShaderMaterial` that does not update fog at\n     * runtime, so instead of recompiling everything we pass it in the constructor.\n     */\n    fog?: boolean;\n\n    /**\n     * Line width.\n     */\n    lineWidth?: number;\n\n    /**\n     * Outline width.\n     */\n    outlineWidth?: number;\n\n    /**\n     * Line opacity.\n     */\n    opacity?: number;\n\n    /**\n     * Describes line caps type (`\"None\"`, `\"Round\"`, `\"Square\"`, `\"TriangleOut\"`, `\"TriangleIn\"`).\n     * Default is `\"Round\"`.\n     */\n    caps?: LineCaps;\n\n    /**\n     * Describes the starting drawing position for the line (in the range [0...1]).\n     * Default is `0.0`.\n     */\n    drawRangeStart?: number;\n\n    /**\n     * Describes the ending drawing position for the line (in the range [0...1]).\n     * Default is `1.0`.\n     */\n    drawRangeEnd?: number;\n\n    /**\n     * Describes line dash type (`\"Round\"`, `\"Square\"`, `\"Diamond\"`).\n     * Default is `\"Square\"`.\n     */\n    dashes?: LineDashes;\n\n    /**\n     * Line dashes color.\n     */\n    dashColor?: number | string;\n\n    /**\n     * Size of the dashed segments.\n     */\n    dashSize?: number;\n\n    /**\n     * Size of the gaps between dashed segments.\n     */\n    gapSize?: number;\n\n    /**\n     * How much to offset in world units.\n     */\n    offset?: number;\n}\n\n/**\n * Material designed to render solid variable-width lines.\n */\nexport class SolidLineMaterial extends THREE.RawShaderMaterial\n    implements DisplacementFeature, FadingFeature {\n    static DEFAULT_COLOR: number = 0xff0000;\n    static DEFAULT_WIDTH: number = 1.0;\n    static DEFAULT_OUTLINE_WIDTH: number = 0.0;\n    static DEFAULT_OPACITY: number = 1.0;\n    static DEFAULT_DRAW_RANGE_START: number = 0.0;\n    static DEFAULT_DRAW_RANGE_END: number = 1.0;\n    static DEFAULT_DASH_SIZE: number = 1.0;\n    static DEFAULT_GAP_SIZE: number = 1.0;\n    static DEFAULT_OFFSET: number = 0.0;\n\n    /**\n     * @hidden\n     * Material properties overrides.\n     */\n    private m_fog: boolean;\n    private m_opacity: number;\n\n    /**\n     * Constructs a new `SolidLineMaterial`.\n     *\n     * @param params - `SolidLineMaterial` parameters.\n     */\n    constructor(params?: SolidLineMaterialParameters) {\n        Object.assign(THREE.ShaderChunk, linesShaderChunk);\n\n        FadingFeature.patchGlobalShaderChunks();\n\n        // Setup default defines.\n        const defines: { [key: string]: any } = {\n            CAPS_MODE: LineCapsModes.CAPS_ROUND,\n            DASHES_MODE: LineDashesModes.DASHES_SQUARE\n        };\n\n        // Prepare defines based on params passed in, before super class c-tor, this ensures\n        // proper set for shader compilation, without need to re-compile.\n        let fogParam = true;\n        let opacityParam = 1.0;\n        let displacementMap;\n        if (params !== undefined) {\n            fogParam = params.fog === true;\n            if (fogParam) {\n                setShaderDefine(defines, \"USE_FOG\", true);\n            }\n            opacityParam = params.opacity !== undefined ? params.opacity : opacityParam;\n            displacementMap = params.displacementMap;\n            if (displacementMap !== undefined) {\n                setShaderDefine(defines, \"USE_DISPLACEMENTMAP\", true);\n            }\n            const hasOutline = params.outlineWidth !== undefined && params.outlineWidth > 0;\n            if (hasOutline) {\n                setShaderDefine(defines, \"USE_OUTLINE\", true);\n            }\n        }\n\n        const shaderParams: THREE.ShaderMaterialParameters = {\n            name: \"SolidLineMaterial\",\n            vertexShader: vertexSource,\n            fragmentShader: fragmentSource,\n            uniforms: THREE.UniformsUtils.merge([\n                {\n                    diffuse: new THREE.Uniform(new THREE.Color(SolidLineMaterial.DEFAULT_COLOR)),\n                    dashColor: new THREE.Uniform(new THREE.Color(SolidLineMaterial.DEFAULT_COLOR)),\n                    outlineColor: new THREE.Uniform(\n                        new THREE.Color(SolidLineMaterial.DEFAULT_COLOR)\n                    ),\n                    extrusionWidth: new THREE.Uniform(SolidLineMaterial.DEFAULT_WIDTH),\n                    outlineWidth: new THREE.Uniform(SolidLineMaterial.DEFAULT_OUTLINE_WIDTH),\n                    offset: new THREE.Uniform(SolidLineMaterial.DEFAULT_OFFSET),\n                    opacity: new THREE.Uniform(SolidLineMaterial.DEFAULT_OPACITY),\n                    tileSize: new THREE.Uniform(new THREE.Vector2()),\n                    fadeNear: new THREE.Uniform(FadingFeature.DEFAULT_FADE_NEAR),\n                    fadeFar: new THREE.Uniform(FadingFeature.DEFAULT_FADE_FAR),\n                    displacementMap: new THREE.Uniform(\n                        displacementMap !== undefined ? displacementMap : new THREE.Texture()\n                    ),\n                    drawRange: new THREE.Uniform(\n                        new THREE.Vector2(\n                            SolidLineMaterial.DEFAULT_DRAW_RANGE_START,\n                            SolidLineMaterial.DEFAULT_DRAW_RANGE_END\n                        )\n                    ),\n                    dashSize: new THREE.Uniform(SolidLineMaterial.DEFAULT_DASH_SIZE),\n                    gapSize: new THREE.Uniform(SolidLineMaterial.DEFAULT_GAP_SIZE)\n                },\n                // We need the fog uniforms available when we use `fog` setter as the internal\n                // recompilation cannot add or remove uniforms.\n                THREE.UniformsLib.fog\n            ]),\n            defines,\n            // No need to pass overridden `fog` and `opacity` params they will be set\n            // after super c-tor call.\n            fog: fogParam,\n            opacity: opacityParam\n        };\n        super(shaderParams);\n        // Required to satisfy compiler error if fields has no initializer or are not definitely\n        // assigned in the constructor, this also mimics ShaderMaterial set of defaults\n        // for overridden props.\n        this.m_fog = fogParam;\n        this.m_opacity = opacityParam;\n\n        enforceBlending(this);\n        this.extensions.derivatives = true;\n\n        // Apply initial parameter values.\n        if (params !== undefined) {\n            if (params.color !== undefined) {\n                tmpColor.set(params.color as any);\n                this.color = tmpColor;\n            }\n            if (params.outlineColor !== undefined) {\n                tmpColor.set(params.outlineColor as any);\n                this.outlineColor = tmpColor;\n            }\n            if (params.lineWidth !== undefined) {\n                this.lineWidth = params.lineWidth;\n            }\n            if (params.outlineWidth !== undefined) {\n                this.outlineWidth = params.outlineWidth;\n            }\n            if (params.opacity !== undefined) {\n                this.opacity = params.opacity;\n            }\n            if (params.depthTest !== undefined) {\n                this.depthTest = params.depthTest;\n            }\n            if (params.depthWrite !== undefined) {\n                this.depthWrite = params.depthWrite;\n            }\n            if (params.fadeNear !== undefined) {\n                this.fadeNear = params.fadeNear;\n            }\n            if (params.fadeFar !== undefined) {\n                this.fadeFar = params.fadeFar;\n            }\n            if (params.displacementMap !== undefined) {\n                this.displacementMap = params.displacementMap;\n            }\n            if (params.caps !== undefined) {\n                this.caps = params.caps;\n            }\n            if (params.drawRangeStart !== undefined) {\n                this.drawRangeStart = params.drawRangeStart;\n            }\n            if (params.drawRangeEnd !== undefined) {\n                this.drawRangeEnd = params.drawRangeEnd;\n            }\n            if (params.dashes !== undefined) {\n                this.dashes = params.dashes;\n            }\n            if (params.dashColor !== undefined) {\n                tmpColor.set(params.dashColor as any);\n                this.dashColor = tmpColor;\n            }\n            if (params.dashSize !== undefined) {\n                this.dashSize = params.dashSize;\n            }\n            if (params.gapSize !== undefined) {\n                this.gapSize = params.gapSize;\n            }\n            if (params.fog !== undefined) {\n                this.fog = params.fog;\n            }\n            this.offset = params.offset ?? 0;\n        }\n        // ShaderMaterial overrides requires invalidation cause super c-tor may set this\n        // properties before related `defines` and `uniforms` were created.\n        this.invalidateFog();\n        this.invalidateOpacity();\n    }\n\n    /**\n     * Overrides THREE.Material.fog flag to add support for custom shader.\n     *\n     * @param enable - Whether we want to enable the fog.\n     */\n    set fog(enable: boolean) {\n        this.m_fog = enable;\n        // Function may be called from THREE.js cause we override setter,\n        // in this case defines are not yet initialized and require late invalidation in\n        // SolidLineMaterial c-tor.\n        if (this.defines !== undefined) {\n            setShaderMaterialDefine(this, \"USE_FOG\", enable);\n        }\n    }\n\n    /**\n     * Checks if fog is enabled.\n     */\n    get fog(): boolean {\n        return this.m_fog && getShaderMaterialDefine(this, \"USE_FOG\") === true;\n    }\n\n    /**\n     * Sets the offset used to shift the line in world space perpendicular to the direction.\n     */\n    set offset(offset: number) {\n        this.uniforms.offset.value = offset;\n    }\n\n    /**\n     * @return The offset to shift the line in world space perpendicular to the direction.\n     */\n    get offset(): number {\n        return this.uniforms.offset.value as number;\n    }\n\n    /**\n     * The method to call to recompile a material to enable/disable outline effect\n     *\n     * @param enable - Whether we want to use outline.\n     */\n    set outline(enable: boolean) {\n        setShaderMaterialDefine(this, \"USE_OUTLINE\", enable);\n    }\n\n    /**\n     * Checks if outline is enabled.\n     */\n    get outline(): boolean {\n        return getShaderMaterialDefine(this, \"USE_OUTLINE\") === true;\n    }\n\n    /**\n     * Line opacity.\n     */\n    get opacity(): number {\n        return this.m_opacity;\n    }\n    set opacity(value: number) {\n        this.m_opacity = value;\n        // Setting opacity before uniform being created requires late invalidation,\n        // call to invalidateOpacity() is done at the end of c-tor.\n        if (this.uniforms !== undefined) {\n            this.uniforms.opacity.value = value;\n        }\n    }\n\n    /**\n     * Line color.\n     */\n    get color(): THREE.Color {\n        return this.uniforms.diffuse.value as THREE.Color;\n    }\n    set color(value: THREE.Color) {\n        this.uniforms.diffuse.value.copy(value);\n    }\n\n    /**\n     * Outline color.\n     *\n     * @note The width of outline ([[outlineWidth]]) need to be also set to enable outlining.\n     */\n    get outlineColor(): THREE.Color {\n        return this.uniforms.outlineColor.value as THREE.Color;\n    }\n    set outlineColor(value: THREE.Color) {\n        this.uniforms.outlineColor.value.copy(value);\n    }\n\n    /**\n     * Dash color.\n     *\n     * @note The property [[gapSize]] need to be set to enable dashed line.\n     */\n    get dashColor(): THREE.Color {\n        return this.uniforms.dashColor.value as THREE.Color;\n    }\n    set dashColor(value: THREE.Color) {\n        this.uniforms.dashColor.value.copy(value);\n        setShaderMaterialDefine(this, \"USE_DASH_COLOR\", true);\n    }\n\n    /**\n     * Line width.\n     */\n    get lineWidth(): number {\n        return (this.uniforms.extrusionWidth.value as number) * 2;\n    }\n    set lineWidth(value: number) {\n        this.uniforms.extrusionWidth.value = value / 2;\n    }\n\n    /**\n     * Outline width.\n     */\n    get outlineWidth(): number {\n        return this.uniforms.outlineWidth.value as number;\n    }\n    set outlineWidth(value: number) {\n        this.uniforms.outlineWidth.value = value;\n        this.outline = value > 0.0;\n    }\n\n    /**\n     * Size of the dashed segments.\n     *\n     * @note Ths [[gapSize]] need to be also set to enable dashed line.\n     * @see gapSize.\n     */\n    get dashSize(): number {\n        return this.uniforms.dashSize.value as number;\n    }\n    set dashSize(value: number) {\n        this.uniforms.dashSize.value = value;\n    }\n\n    /**\n     * Size of the gaps between dashed segments.\n     *\n     * @note You may also need to set [[dashSize]].\n     * @see dashSize.\n     */\n    get gapSize(): number {\n        return this.uniforms.gapSize.value as number;\n    }\n    set gapSize(value: number) {\n        this.uniforms.gapSize.value = value;\n        setShaderMaterialDefine(this, \"USE_DASHED_LINE\", value > 0.0);\n    }\n\n    /**\n     * Caps mode.\n     */\n    get caps(): LineCaps {\n        let result: LineCaps = \"Round\";\n        const capsMode = getShaderMaterialDefine(this, \"CAPS_MODE\");\n        // Sanity check if material define is numerical and has direct mapping to LineCaps type.\n        if (typeof capsMode === \"number\" && DefinesLineCapsMapping.hasOwnProperty(capsMode)) {\n            result = DefinesLineCapsMapping[capsMode];\n        }\n        return result;\n    }\n    set caps(value: LineCaps) {\n        // Line caps mode may be set directly from theme, thus we need to check value\n        // for correctness and provide string to define mapping in fragment shader.\n        if (LineCapsDefinesMapping.hasOwnProperty(value)) {\n            setShaderMaterialDefine(this, \"CAPS_MODE\", LineCapsDefinesMapping[value]);\n        }\n    }\n\n    /**\n     * Dashes mode.\n     */\n    get dashes(): LineDashes {\n        let result: LineDashes = \"Square\";\n        const dashesMode = getShaderMaterialDefine(this, \"DASHES_MODE\");\n        // Sanity check if material define is numerical and has direct mapping to LineDashes type.\n        if (typeof dashesMode === \"number\" && DefinesLineDashesMapping.hasOwnProperty(dashesMode)) {\n            result = DefinesLineDashesMapping[dashesMode];\n        }\n        return result;\n    }\n    set dashes(value: LineDashes) {\n        // Line dashes mode may be set directly from theme, thus we need to check value\n        // for correctness and provide string to define mapping in fragment shader.\n        if (LineDashesDefinesMapping.hasOwnProperty(value)) {\n            setShaderMaterialDefine(this, \"DASHES_MODE\", LineDashesDefinesMapping[value]);\n        }\n    }\n\n    get fadeNear(): number {\n        return this.uniforms.fadeNear.value as number;\n    }\n    set fadeNear(value: number) {\n        this.uniforms.fadeNear.value = value;\n    }\n\n    get fadeFar(): number {\n        return this.uniforms.fadeFar.value as number;\n    }\n    set fadeFar(value: number) {\n        this.uniforms.fadeFar.value = value;\n        setShaderMaterialDefine(this, \"USE_FADING\", value > 0.0);\n    }\n\n    get displacementMap(): THREE.Texture | null {\n        return this.uniforms.displacementMap.value;\n    }\n    set displacementMap(map: THREE.Texture | null) {\n        if (this.uniforms.displacementMap.value === map) {\n            return;\n        }\n        this.uniforms.displacementMap.value = map;\n        const useDisplacementMap = map !== null;\n        if (useDisplacementMap) {\n            this.uniforms.displacementMap.value.needsUpdate = true;\n        }\n        setShaderMaterialDefine(this, \"USE_DISPLACEMENTMAP\", useDisplacementMap);\n    }\n\n    get drawRangeStart(): number {\n        return this.uniforms.drawRange.value.x as number;\n    }\n    set drawRangeStart(value: number) {\n        this.uniforms.drawRange.value.x = value;\n    }\n\n    get drawRangeEnd(): number {\n        return this.uniforms.drawRange.value.y as number;\n    }\n    set drawRangeEnd(value: number) {\n        this.uniforms.drawRange.value.y = value;\n    }\n\n    set clipTileSize(tileSize: THREE.Vector2) {\n        this.uniforms.tileSize.value.copy(tileSize);\n        const useTileClip = tileSize.x > 0 && tileSize.y > 0;\n        setShaderMaterialDefine(this, \"USE_TILE_CLIP\", useTileClip);\n    }\n    get clipTileSize(): THREE.Vector2 {\n        return this.uniforms.tileSize.value as THREE.Vector2;\n    }\n\n    private invalidateFog() {\n        if (this.m_fog !== getShaderMaterialDefine(this, \"USE_FOG\")) {\n            setShaderMaterialDefine(this, \"USE_FOG\", this.m_fog);\n        }\n    }\n\n    private invalidateOpacity() {\n        if (this.m_opacity !== this.uniforms.opacity.value) {\n            this.uniforms.opacity.value = this.m_opacity;\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport * as THREE from \"three\";\n\n/**\n * `VignetteShader`.\n */\nexport const VignetteShader: THREE.Shader = {\n    uniforms: {\n        tDiffuse: { value: null },\n        offset: { value: 1.0 },\n        darkness: { value: 1.0 }\n    },\n    vertexShader: `\n        varying vec2 vUv;\n        void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }`,\n    fragmentShader: `\n        uniform float offset;\n        uniform float darkness;\n        uniform sampler2D tDiffuse;\n        varying vec2 vUv;\n        void main() {\n            vec4 texel = texture2D( tDiffuse, vUv );\n            vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );\n            gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );\n        }`\n};\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { MemoryUsage } from \"../TextCanvas\";\nimport { GlyphData } from \"./GlyphData\";\nimport { GlyphTextureCache } from \"./GlyphTextureCache\";\nimport { FontStyle, FontVariant, TextRenderStyle } from \"./TextStyle\";\n\nconst ASSETS_PATH = \"_Assets/\";\nconst BOLD_ASSETS_PATH = \"_BoldAssets/\";\nconst ITALIC_ASSETS_PATH = \"_ItalicAssets/\";\nconst BOLD_ITALIC_ASSETS_PATH = \"_BoldItalicAssets/\";\nconst REPLACEMENT_PATH = \"_Assets/Extra/\";\n\ninterface SrcGlyphData {\n    id: number;\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    xoffset: number;\n    yoffset: number;\n    xadvance: number;\n    page: number;\n    chnl: number;\n}\n\n/**\n * Metrics defining the placement and rendering of all glyphs in a given [[Font]].\n */\nexport interface FontMetrics {\n    size: number;\n    distanceRange: number;\n    base: number;\n    lineHeight: number;\n    lineGap: number;\n    capHeight: number;\n    xHeight: number;\n}\n\n/**\n * Description of all assets, charset and metrics that define a font inside a [[FontCatalog]].\n */\nexport interface Font {\n    name: string;\n    metrics: FontMetrics;\n    charset: string;\n    bold?: string;\n    italic?: string;\n    boldItalic?: string;\n}\n\n/**\n * Description of a continuous range of Unicode code points (as well as information on which fonts\n * supports it).\n */\nexport interface UnicodeBlock {\n    name: string;\n    min: number;\n    max: number;\n    fonts: string[];\n}\n\n/**\n * Collection of font assets used to render glyphs when using a [[TextCanvas]].\n *\n * @summary A `FontCatalog` works as a stack of SDF bitmap fonts (using the BMFont format) designed\n * to cover the widest Unicode code point range possible. In order to manage all these assets\n * elegantly, the assets inside the `FontCatalog` are stored on a per-Unicode-Block basis, and\n * assets for a block are only loaded once a glyph belonging to that block is requested.\n *\n * Bitmap information coming from all different fonts is then stored in a unified WebGL GPU Texture\n * resource, which can be sampled to render all currently loaded glyphs.\n *\n */\nexport class FontCatalog {\n    /**\n     * Loads a `FontCatalog`.\n     *\n     * @param url - Asset url.\n     * @param maxCodePointCount - Maximum number of unique code points bitmaps this `FontCatalog`'s\n     * internal texture can store simultaneously.\n     *\n     * @returns `FontCatalog` Promise.\n     */\n    static async load(path: string, maxCodePointCount: number): Promise<FontCatalog> {\n        const url = new URL(path, window.location.href);\n        const fontCatalog = await FontCatalog.loadJSON(url.href);\n\n        const replacementDirUrl = new URL(`${fontCatalog.name}${REPLACEMENT_PATH}`, url);\n        const replacementJson = await FontCatalog.loadJSON(\n            replacementDirUrl.href + \"Specials.json\"\n        );\n        const replacementTexture = await FontCatalog.loadTexture(\n            replacementDirUrl.href + \"Specials.png\"\n        );\n        replacementTexture.wrapS = THREE.ClampToEdgeWrapping;\n        replacementTexture.wrapT = THREE.ClampToEdgeWrapping;\n        replacementTexture.minFilter = THREE.NearestFilter;\n        replacementTexture.needsUpdate = true;\n\n        const replacementFont = fontCatalog.fonts.find((font: Font) => font.name === \"Extra\");\n        const replacementGlyph = new GlyphData(\n            65533,\n            \"Specials\",\n            replacementJson.chars[0].width,\n            replacementJson.chars[0].height,\n            replacementJson.chars[0].xadvance,\n            replacementJson.chars[0].xoffset,\n            replacementJson.chars[0].yoffset,\n            0.0,\n            0.0,\n            1.0,\n            1.0,\n            replacementTexture,\n            replacementFont!\n        );\n\n        const fontCatalogInfo = new FontCatalog(\n            url.href.substr(0, url.href.lastIndexOf(\"/\")),\n            fontCatalog.name,\n            fontCatalog.type,\n            fontCatalog.size,\n            fontCatalog.maxWidth,\n            fontCatalog.maxHeight,\n            fontCatalog.distanceRange,\n            fontCatalog.fonts,\n            fontCatalog.supportedBlocks,\n            maxCodePointCount,\n            replacementGlyph\n        );\n        return fontCatalogInfo;\n    }\n\n    static async loadTexture(url: string): Promise<THREE.Texture> {\n        return new Promise(resolve => {\n            new THREE.TextureLoader().load(url, resolve);\n        }) as Promise<THREE.Texture>;\n    }\n\n    static async loadJSON(url: string): Promise<any> {\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(`${url} Status Text:  ${response.statusText}`);\n        }\n        const rawJSON = await response.text();\n        return JSON.parse(rawJSON);\n    }\n\n    private m_glyphTextureCache: GlyphTextureCache;\n\n    private m_loadingJson: Map<string, Promise<any>>;\n    private m_loadingPages: Map<string, Promise<THREE.Texture>>;\n    private m_loadingGlyphs: Map<string, Promise<GlyphData>>;\n    private m_loadedJson: Map<string, any>;\n    private m_loadedPages: Map<string, THREE.Texture>;\n    private m_loadedGlyphs: Map<string, Map<number, GlyphData>>;\n\n    /**\n     * @hidden\n     * Creates a new FontCatalog.\n     *\n     * @param url - FontCatalog's URL.\n     * @param name - FontCatalog's name.\n     * @param type - FontCatalog's type (sdf or msdf).\n     * @param size - FontCatalog's glyph size (pixels).\n     * @param maxWidth - FontCatalog's maximum glyph width (pixels).\n     * @param maxHeight - FontCatalog's maximum glyph height (pixels).\n     * @param distanceRange - Distance range used to generate the SDF bitmaps.\n     * @param fonts - Array of supported fonts.\n     * @param unicodeBlocks - Array of supported Unicode blocks.\n     * @param maxCodePointCount - Maximum number of unique code points bitmaps this `FontCatalog`'s\n     * internal texture can store simultaneously.\n     * @param m_replacementGlyph - [[GlyphData]] to be used whenever a Unicode code point is not\n     * supported by this `FontCatalog`.\n     *\n     * @returns New FontCatalog.\n     */\n    private constructor(\n        readonly url: string,\n        readonly name: string,\n        readonly type: string,\n        readonly size: number,\n        readonly maxWidth: number,\n        readonly maxHeight: number,\n        readonly distanceRange: number,\n        readonly fonts: Font[],\n        readonly unicodeBlocks: UnicodeBlock[],\n        readonly maxCodePointCount: number,\n        private m_replacementGlyph: GlyphData\n    ) {\n        this.m_glyphTextureCache = new GlyphTextureCache(\n            maxCodePointCount,\n            this.maxWidth + 1,\n            this.maxHeight + 1\n        );\n\n        this.m_loadingJson = new Map<string, Promise<any>>();\n        this.m_loadingPages = new Map<string, Promise<THREE.Texture>>();\n        this.m_loadingGlyphs = new Map<string, Promise<GlyphData>>();\n        this.m_loadedJson = new Map<string, any>();\n        this.m_loadedPages = new Map<string, THREE.Texture>();\n        this.m_loadedGlyphs = new Map<string, Map<number, GlyphData>>();\n    }\n\n    /**\n     * Release all allocated resources.\n     */\n    dispose() {\n        this.fonts.length = 0;\n        this.unicodeBlocks.length = 0;\n        this.m_glyphTextureCache.dispose();\n        this.m_loadingJson.clear();\n        this.m_loadingPages.clear();\n        this.m_loadingGlyphs.clear();\n        this.m_loadedJson.clear();\n        this.m_loadedPages.clear();\n        this.m_loadedGlyphs.clear();\n    }\n\n    /**\n     * Removes all loaded (and loading) assets.\n     */\n    clear() {\n        this.m_glyphTextureCache.clear();\n        this.m_loadingJson.clear();\n        this.m_loadingPages.clear();\n        this.m_loadingGlyphs.clear();\n        this.m_loadedJson.clear();\n        this.m_loadedPages.clear();\n        this.m_loadedGlyphs.clear();\n    }\n\n    /**\n     * Updates the internal WebGLRenderTarget.\n     * The update will copy the newly introduced glyphs since the previous update.\n     *\n     * @param renderer - WebGLRenderer.\n     */\n    update(renderer: THREE.WebGLRenderer): void {\n        this.m_glyphTextureCache.update(renderer);\n    }\n\n    /**\n     * Internal WebGL Texture.\n     */\n    get texture(): THREE.Texture {\n        return this.m_glyphTextureCache.texture;\n    }\n\n    /**\n     * Internal WebGL Texture size.\n     */\n    get textureSize(): THREE.Vector2 {\n        return this.m_glyphTextureCache.textureSize;\n    }\n\n    /**\n     * Current internal loading state.\n     */\n    get isLoading(): boolean {\n        return (\n            this.m_loadingJson.size > 0 ||\n            this.m_loadingPages.size > 0 ||\n            this.m_loadingGlyphs.size > 0\n        );\n    }\n\n    /**\n     * Loads the description file for a specific [[UnicodeBlock]]. This speeds up consequent calls\n     * to `FontCatalog`.loadCharset() that require glyphs from this block to be loaded.\n     *\n     * @param block - Requested [[UnicodeBlock]].\n     * @param font - [[Font]] to retrieve this Unicode block from.\n     * @param fontStyle - [[FontStyle]] assets to load.\n     * @param loadPages - If `true`, all pages in this Unicode block will also be loaded.\n     *\n     * @returns Loaded Unicode Block json.\n     */\n    async loadBlock(\n        block: UnicodeBlock,\n        font: Font,\n        fontStyle: FontStyle,\n        loadPages?: boolean\n    ): Promise<any> {\n        const assetsPath = this.getAssetsPath(fontStyle, font);\n        const jsonPath = `${assetsPath}/${block.name.replace(/ /g, \"_\")}.json`;\n        let json = this.m_loadedJson.get(jsonPath);\n        if (json === undefined) {\n            let jsonPromise = this.m_loadingJson.get(jsonPath);\n            if (jsonPromise === undefined) {\n                try {\n                    jsonPromise = FontCatalog.loadJSON(jsonPath);\n                    this.m_loadingJson.set(jsonPath, jsonPromise);\n                    json = await jsonPromise;\n                    this.m_loadingJson.delete(jsonPath);\n                    this.m_loadedJson.set(jsonPath, json);\n                } catch (e) {\n                    // tslint:disable-next-line:no-console\n                    console.error(e);\n                    this.m_loadingJson.delete(jsonPath);\n                }\n            } else {\n                json = await jsonPromise;\n            }\n        }\n\n        const pagePromises: Array<Promise<THREE.Texture>> = [];\n        if (loadPages === true) {\n            for (const page of json.pages) {\n                pagePromises.push(this.loadPage(`${assetsPath}/${page}`));\n            }\n        }\n        await Promise.all(pagePromises);\n\n        return json;\n    }\n\n    /**\n     * Releases the description file for a specific [[UnicodeBlock]] (and all downloaded pages).\n     * Safe to call when no assets for this block have been loaded.\n     *\n     * @param block - Requested [[UnicodeBlock]].\n     * @param font - [[Font]] to remove this Unicode block from.\n     * @param fontStyle - [[FontStyle]] assets to remove.\n     */\n    removeBlock(block: UnicodeBlock, font: Font, fontStyle: FontStyle): void {\n        const assetsPath = this.getAssetsPath(fontStyle, font);\n        const jsonPath = `${assetsPath}/${block.name.replace(/ /g, \"_\")}.json`;\n        const json = this.m_loadedJson.get(jsonPath);\n        if (json !== undefined) {\n            for (const page of json.pages) {\n                const pagePath = `${assetsPath}/${page}`;\n                this.m_loadingPages.delete(pagePath);\n                this.m_loadedPages.delete(pagePath);\n            }\n            this.m_loadingJson.delete(jsonPath);\n            this.m_loadedJson.delete(jsonPath);\n        }\n    }\n\n    /**\n     * Loads all the required glyphs needed to render the input text. Character repetition will not\n     * be considered, and only styled assets (with applied font selection, style and variants) will\n     * be loaded.\n     *\n     * @param input - Input text.\n     * @param style - Specific [[TextRenderStyle]] for which glyphs will be loaded.\n     *\n     * @returns Promise containing an array of all loaded [[GlyphData]] for the input text.\n     */\n    async loadCharset(input: string, style: TextRenderStyle): Promise<GlyphData[]> {\n        const fontName = style.fontName;\n        const fontStyle = style.fontStyle;\n        const shouldTransform =\n            style.fontVariant === FontVariant.AllCaps ||\n            style.fontVariant === FontVariant.SmallCaps;\n\n        const charset = (shouldTransform ? input.toUpperCase() : input).replace(\n            /[\\s\\S](?=([\\s\\S]+))/g,\n            (c, s) => {\n                return s.indexOf(c) + 1 ? \"\" : c;\n            }\n        );\n        const glyphPromises: Array<Promise<GlyphData>> = [];\n        for (const char of charset) {\n            const codePoint = char.codePointAt(0)!;\n            const font = this.getFont(codePoint, fontName);\n            const fontHash = `${font.name}_${fontStyle}`;\n            const glyphHash = `${fontHash}_${codePoint}`;\n\n            let fontGlyphMap = this.m_loadedGlyphs.get(fontHash);\n            if (fontGlyphMap === undefined) {\n                fontGlyphMap = new Map();\n                this.m_loadedGlyphs.set(fontHash, fontGlyphMap);\n            }\n\n            const glyph = fontGlyphMap.get(codePoint);\n            if (glyph === undefined) {\n                let glyphPromise = this.m_loadingGlyphs.get(glyphHash);\n                if (glyphPromise === undefined) {\n                    if (font.charset.indexOf(String.fromCodePoint(codePoint)) === -1) {\n                        const replacementGlyph = this.createReplacementGlyph(codePoint, char, font);\n                        fontGlyphMap!.set(codePoint, replacementGlyph);\n                        this.m_glyphTextureCache.add(glyphHash, replacementGlyph);\n                        continue;\n                    }\n\n                    let charUnicodeBlock: UnicodeBlock | undefined;\n                    for (const block of this.unicodeBlocks) {\n                        if (codePoint >= block.min && codePoint <= block.max) {\n                            charUnicodeBlock = block;\n                            break;\n                        }\n                    }\n\n                    glyphPromise = this.loadAssets(codePoint, fontStyle, charUnicodeBlock!, font);\n                    this.m_loadingGlyphs.set(glyphHash, glyphPromise);\n                    glyphPromise.then((loadedGlyph: GlyphData) => {\n                        this.m_loadingGlyphs.delete(glyphHash);\n                        fontGlyphMap!.set(codePoint, loadedGlyph);\n                        this.m_glyphTextureCache.add(glyphHash, loadedGlyph);\n                    });\n                }\n                glyphPromises.push(glyphPromise);\n            } else if (!this.m_glyphTextureCache.has(glyphHash)) {\n                glyphPromises.push(Promise.resolve(glyph));\n                this.m_glyphTextureCache.add(glyphHash, glyph);\n            }\n        }\n\n        return Promise.all(glyphPromises);\n    }\n\n    /**\n     * Retrieves the loaded [[GlyphData]] for a specific character.\n     * Returns `undefined` if the assets for this glyph haven't been loaded yet.\n     *\n     * @param codePoint - Character's Unicode code point.\n     * @param font - [[Font]] to get this glyph from.\n     * @param fontStyle - Specific [[FontStyle]] to get glyphs for.\n     *\n     * @returns [[GlyphData]] for this code point.\n     */\n    getGlyph(codePoint: number, font: Font, fontStyle: FontStyle): GlyphData | undefined {\n        const fontGlyphMap = this.m_loadedGlyphs.get(`${font.name}_${fontStyle}`);\n        if (fontGlyphMap === undefined) {\n            return undefined;\n        }\n        return fontGlyphMap.get(codePoint);\n    }\n\n    /**\n     * Retrieves the loaded [[GlyphData]] for the specified text.\n     * Returns `undefined` if the assets for these glyphs haven't been loaded yet.\n     *\n     * @param input - Input text.\n     * @param style - Specific [[TextRenderStyle]] to get glyphs for.\n     * @param letterCaseArray - Array containing the original letter case for the requested glyphs.\n     *\n     * @returns Array containing [[GlyphData]] for each character of the input text.\n     */\n    getGlyphs(\n        input: string,\n        style: TextRenderStyle,\n        letterCaseArray?: boolean[]\n    ): GlyphData[] | undefined {\n        const result = [];\n        const fontName = style.fontName;\n        const fontStyle = style.fontStyle;\n        const fontVariant = style.fontVariant;\n        const shouldTransform =\n            fontVariant === FontVariant.AllCaps || fontVariant === FontVariant.SmallCaps;\n        for (const character of input) {\n            const transformedCharacter = shouldTransform ? character.toUpperCase() : character;\n            for (const char of transformedCharacter) {\n                const codePoint = char.codePointAt(0)!;\n                const font = this.getFont(codePoint, fontName);\n                const glyphData = this.getGlyph(codePoint, font, fontStyle);\n                if (glyphData !== undefined) {\n                    result.push(glyphData);\n                    if (letterCaseArray !== undefined) {\n                        letterCaseArray.push(char !== character);\n                    }\n                } else {\n                    return undefined;\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Gets the best matched font for a specific character.\n     *\n     * @param codePoint - Character's Unicode code point.\n     * @param fontName - Font name suggestion.\n     *\n     * @returns Best matched font.\n     */\n    getFont(codePoint: number, fontName?: string): Font {\n        let selectedFontName: string = this.fonts[0].name;\n        for (const block of this.unicodeBlocks) {\n            if (codePoint >= block.min && codePoint <= block.max) {\n                selectedFontName =\n                    fontName !== undefined &&\n                    block.fonts.find(element => {\n                        return element === fontName;\n                    }) !== undefined\n                        ? fontName\n                        : block.fonts[0];\n                break;\n            }\n        }\n\n        return this.fonts.find(element => {\n            return element.name === selectedFontName;\n        })!;\n    }\n\n    /**\n     * Update the info with the memory footprint caused by objects owned by the `FontCatalog`.\n     *\n     * @param info - The info object to increment with the values from this `FontCatalog`.\n     */\n    updateMemoryUsage(info: MemoryUsage) {\n        let numBytes = 0;\n\n        for (const block of this.unicodeBlocks) {\n            numBytes += (block.max - block.min) * 2;\n        }\n\n        // Always stored in RGBA internally.\n        let textureBytes =\n            this.m_glyphTextureCache.textureSize.x * this.m_glyphTextureCache.textureSize.y * 4;\n\n        for (const page in this.m_loadedPages.entries) {\n            if (this.m_loadedPages.get(page) !== undefined) {\n                const loadedPage = this.m_loadedPages.get(page);\n                if (loadedPage !== undefined) {\n                    textureBytes += loadedPage.image.width * loadedPage.image.height * 4;\n                }\n            }\n        }\n\n        info.heapSize += numBytes + textureBytes;\n        info.gpuSize += textureBytes;\n    }\n\n    private createReplacementGlyph(codePoint: number, char: string, font: Font): GlyphData {\n        const replacementGlyph = this.m_replacementGlyph.clone();\n        (replacementGlyph as any).codePoint = codePoint;\n        (replacementGlyph as any).character = char;\n        (replacementGlyph as any).font = font;\n        return replacementGlyph;\n    }\n\n    private async loadAssets(\n        codePoint: number,\n        fontStyle: FontStyle,\n        block: UnicodeBlock,\n        font: Font\n    ): Promise<GlyphData> {\n        const json = await this.loadBlock(block, font, fontStyle);\n        if (json === undefined) {\n            return this.m_replacementGlyph;\n        }\n\n        const sourceGlyphData = (json.chars as SrcGlyphData[]).find(char => char.id === codePoint);\n        const assetsPath = this.getAssetsPath(fontStyle, font);\n        const texturePath = `${assetsPath}/${json.pages[sourceGlyphData!.page]}`;\n        const texture = await this.loadPage(texturePath);\n\n        const glyphData = new GlyphData(\n            sourceGlyphData!.id,\n            block.name,\n            sourceGlyphData!.width,\n            sourceGlyphData!.height,\n            sourceGlyphData!.xadvance,\n            sourceGlyphData!.xoffset,\n            sourceGlyphData!.yoffset,\n            sourceGlyphData!.x / texture!.image.width,\n            1.0 - (sourceGlyphData!.y + sourceGlyphData!.height) / texture!.image.height,\n            (sourceGlyphData!.x + sourceGlyphData!.width) / texture!.image.width,\n            1.0 - sourceGlyphData!.y / texture!.image.height,\n            texture!,\n            font\n        );\n\n        return glyphData;\n    }\n\n    private async loadPage(pagePath: string): Promise<THREE.Texture> {\n        let page = this.m_loadedPages.get(pagePath);\n        if (page === undefined) {\n            let pagePromise = this.m_loadingPages.get(pagePath);\n            if (pagePromise === undefined) {\n                pagePromise = FontCatalog.loadTexture(pagePath);\n                this.m_loadingPages.set(pagePath, pagePromise);\n                page = await pagePromise;\n                page.wrapS = THREE.ClampToEdgeWrapping;\n                page.wrapT = THREE.ClampToEdgeWrapping;\n                page.minFilter = THREE.NearestFilter;\n                page.needsUpdate = true;\n                if (this.m_loadingPages.delete(pagePath)) {\n                    this.m_loadedPages.set(pagePath, page);\n                }\n                this.m_loadingPages.delete(pagePath);\n            } else {\n                page = await pagePromise;\n            }\n        }\n        return page;\n    }\n\n    private getAssetsPath(fontStyle: FontStyle, font: Font) {\n        let fontStylePath = ASSETS_PATH;\n        switch (fontStyle) {\n            case FontStyle.Bold:\n                if (font.bold !== undefined) {\n                    fontStylePath = BOLD_ASSETS_PATH;\n                }\n                break;\n            case FontStyle.Italic:\n                if (font.italic !== undefined) {\n                    fontStylePath = ITALIC_ASSETS_PATH;\n                }\n                break;\n            case FontStyle.BoldItalic:\n                if (font.boldItalic !== undefined) {\n                    fontStylePath = BOLD_ITALIC_ASSETS_PATH;\n                } else if (font.italic !== undefined) {\n                    fontStylePath = ITALIC_ASSETS_PATH;\n                } else if (font.bold !== undefined) {\n                    fontStylePath = BOLD_ASSETS_PATH;\n                }\n                break;\n        }\n        return `${this.url}/${this.name}${fontStylePath}${font.name!}`;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { LRUCache } from \"@here/harp-lrucache\";\nimport * as THREE from \"three\";\n\nimport { Font, FontMetrics } from \"./FontCatalog\";\nimport { GlyphData } from \"./GlyphData\";\nimport { GlyphClearMaterial, GlyphCopyMaterial } from \"./TextMaterials\";\n\n/**\n * Maximum number of texture atlas pages we can copy from in a single go. This amount is determined\n * by the maximum number of texture units available on a pixel shader for all devices:\n * https://webglstats.com/webgl/parameter/MAX_TEXTURE_IMAGE_UNITS\n */\nconst MAX_NUM_COPY_PAGES = 8;\n\n/**\n * Maximum texture size supported. This amount is determined by the maximum texture size supported\n * for all devices:\n * https://webglstats.com/webgl/parameter/MAX_TEXTURE_SIZE\n */\nconst MAX_TEXTURE_SIZE = 4096;\n\n/**\n * @hidden\n * Information stored for every entry in a [[GlyphTextureCache]].\n */\nexport interface GlyphCacheEntry {\n    glyphData: GlyphData;\n    location: THREE.Vector2;\n}\n\n/**\n * @hidden\n * Unified glyph SDF bitmap storage for all fonts in a [[FontCatalog]].\n * Implemented as an abstraction layer on top of an LRUCache and WebGLRenderTarget.\n */\nexport class GlyphTextureCache {\n    private m_cacheWidth: number;\n    private m_cacheHeight: number;\n    private m_textureSize: THREE.Vector2;\n    private m_entryCache: LRUCache<string, GlyphCacheEntry>;\n\n    private m_scene: THREE.Scene;\n    private m_camera: THREE.OrthographicCamera;\n    private m_rt: THREE.WebGLRenderTarget;\n\n    private m_copyTextureSet: Set<THREE.Texture>;\n    private m_copyTransform: THREE.Matrix3;\n    private m_copyPositions: THREE.Vector2[];\n    private m_copyMaterial: GlyphCopyMaterial;\n    private m_copyVertexBuffer: THREE.InterleavedBuffer;\n    private m_copyPositionAttribute: THREE.InterleavedBufferAttribute;\n    private m_copyUVAttribute: THREE.InterleavedBufferAttribute;\n    private m_copyGeometry: THREE.BufferGeometry;\n    private m_copyMesh: THREE.Mesh;\n    private m_copyGeometryDrawCount: number;\n\n    private m_clearMaterial: GlyphClearMaterial;\n    private m_clearPositionAttribute: THREE.BufferAttribute;\n    private m_clearGeometry: THREE.BufferGeometry;\n    private m_clearMesh: THREE.Mesh;\n    private m_clearGeometryDrawCount: number;\n\n    /**\n     * Creates a `GlyphTextureCache` object.\n     *\n     * @param capacity - Cache's maximum glyph capacity.\n     * @param entryWidth - Maximum entry width.\n     * @param entryHeight - Maximum entry height.\n     *\n     * @returns New `GlyphTextureCache`.\n     */\n    constructor(\n        readonly capacity: number,\n        readonly entryWidth: number,\n        readonly entryHeight: number\n    ) {\n        const nRows = Math.floor(Math.sqrt(capacity));\n        this.m_cacheHeight = nRows * nRows < capacity ? nRows + 1 : nRows;\n        this.m_cacheWidth = nRows * this.m_cacheHeight < capacity ? nRows + 1 : nRows;\n\n        this.m_textureSize = new THREE.Vector2(\n            this.m_cacheWidth * entryWidth,\n            this.m_cacheHeight * entryHeight\n        );\n        if (this.m_textureSize.y > MAX_TEXTURE_SIZE || this.m_textureSize.x > MAX_TEXTURE_SIZE) {\n            // tslint:disable-next-line:no-console\n            console.warn(\n                \"GlyphTextureCache texture size (\" +\n                    this.m_textureSize.x +\n                    \", \" +\n                    this.m_textureSize.y +\n                    \") exceeds WebGL's widely supported MAX_TEXTURE_SIZE (\" +\n                    MAX_TEXTURE_SIZE +\n                    \").\\n\" +\n                    \"This could result in rendering errors on some devices.\\n\" +\n                    \"Please consider reducing its capacity or input assets size.\"\n            );\n        }\n\n        this.m_entryCache = new LRUCache<string, GlyphCacheEntry>(capacity);\n        this.initCacheEntries();\n\n        this.m_scene = new THREE.Scene();\n        this.m_camera = new THREE.OrthographicCamera(\n            0,\n            this.m_textureSize.x,\n            this.m_textureSize.y,\n            0\n        );\n        this.m_camera.position.z = 1;\n        this.m_camera.updateMatrixWorld(false);\n        this.m_rt = new THREE.WebGLRenderTarget(this.m_textureSize.x, this.m_textureSize.y, {\n            wrapS: THREE.ClampToEdgeWrapping,\n            wrapT: THREE.ClampToEdgeWrapping,\n            depthBuffer: false,\n            stencilBuffer: false\n        });\n\n        this.m_copyTextureSet = new Set<THREE.Texture>();\n        this.m_copyTransform = new THREE.Matrix3();\n        this.m_copyPositions = [];\n        this.m_copyPositions.push(\n            new THREE.Vector2(),\n            new THREE.Vector2(),\n            new THREE.Vector2(),\n            new THREE.Vector2()\n        );\n\n        this.m_copyMaterial = new GlyphCopyMaterial();\n        this.m_copyVertexBuffer = new THREE.InterleavedBuffer(new Float32Array(capacity * 20), 5);\n        this.m_copyVertexBuffer.setUsage(THREE.DynamicDrawUsage);\n\n        this.m_copyPositionAttribute = new THREE.InterleavedBufferAttribute(\n            this.m_copyVertexBuffer,\n            3,\n            0\n        );\n        this.m_copyUVAttribute = new THREE.InterleavedBufferAttribute(\n            this.m_copyVertexBuffer,\n            2,\n            3\n        );\n        this.m_copyGeometry = new THREE.BufferGeometry();\n        this.m_copyGeometry.setAttribute(\"position\", this.m_copyPositionAttribute);\n        this.m_copyGeometry.setAttribute(\"uv\", this.m_copyUVAttribute);\n\n        const copyIndexBuffer = new THREE.BufferAttribute(new Uint32Array(capacity * 6), 1);\n        copyIndexBuffer.setUsage(THREE.DynamicDrawUsage);\n        this.m_copyGeometry.setIndex(copyIndexBuffer);\n        this.m_copyMesh = new THREE.Mesh(this.m_copyGeometry, this.m_copyMaterial);\n        this.m_copyMesh.frustumCulled = false;\n        this.m_copyGeometryDrawCount = 0;\n\n        this.m_clearMaterial = new GlyphClearMaterial();\n        this.m_clearPositionAttribute = new THREE.BufferAttribute(\n            new Float32Array(capacity * 8),\n            2\n        );\n        this.m_clearPositionAttribute.setUsage(THREE.DynamicDrawUsage);\n        this.m_clearGeometry = new THREE.BufferGeometry();\n        this.m_clearGeometry.setAttribute(\"position\", this.m_clearPositionAttribute);\n        const clearIndexBuffer = new THREE.BufferAttribute(new Uint32Array(capacity * 6), 1);\n        clearIndexBuffer.setUsage(THREE.DynamicDrawUsage);\n\n        this.m_clearGeometry.setIndex(clearIndexBuffer);\n        this.m_clearMesh = new THREE.Mesh(this.m_clearGeometry, this.m_clearMaterial);\n        this.m_clearMesh.frustumCulled = false;\n        this.m_clearGeometryDrawCount = 0;\n\n        this.m_scene.add(this.m_clearMesh, this.m_copyMesh);\n    }\n\n    /**\n     * Release all allocated resources.\n     */\n    dispose(): void {\n        this.m_entryCache.clear();\n        this.m_scene.remove(this.m_clearMesh, this.m_copyMesh);\n        this.m_rt.dispose();\n        this.m_clearMaterial.dispose();\n        this.m_copyMaterial.dispose();\n        this.m_copyTextureSet.clear();\n        this.m_clearGeometry.dispose();\n        this.m_copyGeometry.dispose();\n    }\n\n    /**\n     * Internal WebGL Texture.\n     */\n    get texture(): THREE.Texture {\n        return this.m_rt.texture;\n    }\n\n    /**\n     * Internal WebGL Texture size.\n     */\n    get textureSize(): THREE.Vector2 {\n        return this.m_textureSize;\n    }\n\n    /**\n     * Add a new entry to the GlyphTextureCache. If the limit of entries is hit, the least requested\n     * entry will be replaced.\n     *\n     * @param hash - Entry's hash.\n     * @param glyph - Entry's glyph data.\n     */\n    add(hash: string, glyph: GlyphData): void {\n        const entry = this.m_entryCache.get(hash);\n        if (entry !== undefined) {\n            return;\n        }\n\n        const oldestEntry = this.m_entryCache.oldest;\n        if (oldestEntry === null) {\n            throw new Error(\"GlyphTextureCache is uninitialized!\");\n        }\n        this.clearCacheEntry(oldestEntry.value);\n        this.copyGlyphToCache(hash, glyph, oldestEntry.value.location);\n    }\n\n    /**\n     * Checks if an entry is in the cache.\n     *\n     * @param hash - Entry's hash.\n     *\n     * @returns Test result.\n     */\n    has(hash: string): boolean {\n        return this.m_entryCache.has(hash);\n    }\n\n    /**\n     * Retrieves an entry from the cache.\n     *\n     * @param hash - Entry's hash.\n     *\n     * @returns Retrieval result.\n     */\n    get(hash: string): GlyphCacheEntry | undefined {\n        return this.m_entryCache.get(hash);\n    }\n\n    /**\n     * Clears the internal LRUCache.\n     */\n    clear(): void {\n        this.m_copyGeometryDrawCount = 0;\n        this.m_clearGeometryDrawCount = 0;\n        this.m_entryCache.clear();\n        this.m_copyTextureSet.clear();\n        this.initCacheEntries();\n    }\n\n    /**\n     * Updates the internal WebGLRenderTarget.\n     * The update will copy the newly introduced glyphs since the previous update.\n     *\n     * @param renderer - WebGLRenderer.\n     */\n    update(renderer: THREE.WebGLRenderer): void {\n        let oldRenderTarget: THREE.RenderTarget | null = null;\n\n        const willClearGeometry = this.m_clearGeometryDrawCount > 0;\n        const willCopyGeometry = this.m_copyGeometryDrawCount > 0;\n\n        if (willClearGeometry || willCopyGeometry) {\n            oldRenderTarget = renderer.getRenderTarget();\n            renderer.setRenderTarget(this.m_rt);\n        }\n\n        if (willClearGeometry) {\n            if (this.m_clearGeometry.index === null) {\n                throw new Error(\"GlyphTextureCache clear geometry index is uninitialized!\");\n            }\n            this.m_clearPositionAttribute.needsUpdate = true;\n            this.m_clearPositionAttribute.updateRange.offset = 0;\n            this.m_clearPositionAttribute.updateRange.count = this.m_clearGeometryDrawCount * 8;\n            this.m_clearGeometry.index.needsUpdate = true;\n            this.m_clearGeometry.index.updateRange.offset = 0;\n            this.m_clearGeometry.index.updateRange.count = this.m_clearGeometryDrawCount * 6;\n            this.m_clearGeometry.setDrawRange(0, this.m_clearGeometryDrawCount * 6);\n\n            this.m_clearMesh.visible = true;\n            this.m_copyMesh.visible = false;\n\n            renderer.render(this.m_scene, this.m_camera);\n            this.m_clearGeometryDrawCount = 0;\n            this.m_clearMesh.visible = false;\n        }\n\n        if (willCopyGeometry) {\n            if (this.m_copyGeometry.index === null) {\n                throw new Error(\"GlyphTextureCache copy geometry index is uninitialized!\");\n            }\n            this.m_copyVertexBuffer.needsUpdate = true;\n            this.m_copyVertexBuffer.updateRange.offset = 0;\n            this.m_copyVertexBuffer.updateRange.count = this.m_copyGeometryDrawCount * 20;\n            this.m_copyGeometry.index.needsUpdate = true;\n            this.m_copyGeometry.index.updateRange.offset = 0;\n            this.m_copyGeometry.index.updateRange.count = this.m_copyGeometryDrawCount * 6;\n            this.m_copyGeometry.setDrawRange(0, this.m_copyGeometryDrawCount * 6);\n\n            this.m_copyMesh.visible = true;\n            const srcPages = Array.from(this.m_copyTextureSet);\n            const nCopies = Math.ceil(this.m_copyTextureSet.size / MAX_NUM_COPY_PAGES);\n            for (let copyIndex = 0; copyIndex < nCopies; copyIndex++) {\n                const pageOffset = copyIndex * MAX_NUM_COPY_PAGES;\n                this.m_copyMaterial.uniforms.pageOffset.value = pageOffset;\n                for (let i = 0; i < MAX_NUM_COPY_PAGES; i++) {\n                    const pageIndex = pageOffset + i;\n                    if (pageIndex < this.m_copyTextureSet.size) {\n                        this.m_copyMaterial.uniforms[\"page\" + i].value = srcPages[pageIndex];\n                    }\n                }\n\n                renderer.render(this.m_scene, this.m_camera);\n            }\n            this.m_copyTextureSet.clear();\n            this.m_copyGeometryDrawCount = 0;\n        }\n        if (willClearGeometry || willCopyGeometry) {\n            renderer.setRenderTarget(oldRenderTarget);\n        }\n    }\n\n    private initCacheEntries() {\n        const dummyMetrics: FontMetrics = {\n            size: 0,\n            distanceRange: 0,\n            base: 0,\n            lineHeight: 0,\n            lineGap: 0,\n            capHeight: 0,\n            xHeight: 0\n        };\n        const dummyFont: Font = {\n            name: \"\",\n            metrics: dummyMetrics,\n            charset: \"\"\n        };\n\n        const dummyGlyphData = new GlyphData(\n            0,\n            \"\",\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            THREE.Texture.DEFAULT_IMAGE,\n            dummyFont\n        );\n\n        for (let i = 0; i < this.m_cacheHeight; i++) {\n            for (let j = 0; j < this.m_cacheWidth; j++) {\n                const dummyEntry: GlyphCacheEntry = {\n                    glyphData: dummyGlyphData,\n                    location: new THREE.Vector2(j, i)\n                };\n                this.m_entryCache.set(`Dummy_${i * this.m_cacheHeight + j}`, dummyEntry);\n            }\n        }\n    }\n\n    private copyGlyphToCache(hash: string, glyph: GlyphData, cacheLocation: THREE.Vector2) {\n        this.m_copyTextureSet.add(glyph.texture);\n        let copyTextureIndex = 0;\n        for (const value of this.m_copyTextureSet.values()) {\n            if (value === glyph.texture) {\n                break;\n            }\n            copyTextureIndex++;\n        }\n        glyph.copyIndex = copyTextureIndex;\n\n        this.m_copyTransform.set(\n            1.0,\n            0.0,\n            cacheLocation.x * this.entryWidth - glyph.offsetX,\n            0.0,\n            1.0,\n            cacheLocation.y * this.entryHeight - glyph.positions[0].y,\n            0.0,\n            0.0,\n            0.0\n        );\n        for (let i = 0; i < 4; ++i) {\n            this.m_copyPositions[i].set(glyph.positions[i].x, glyph.positions[i].y);\n            this.m_copyPositions[i].applyMatrix3(this.m_copyTransform);\n        }\n\n        if (this.m_copyGeometryDrawCount >= this.capacity) {\n            return;\n        }\n        const baseVertex = this.m_copyGeometryDrawCount * 4;\n        const baseIndex = this.m_copyGeometryDrawCount * 6;\n\n        for (let i = 0; i < 4; ++i) {\n            this.m_copyPositionAttribute.setXYZ(\n                baseVertex + i,\n                this.m_copyPositions[i].x,\n                this.m_copyPositions[i].y,\n                glyph.copyIndex\n            );\n            this.m_copyUVAttribute.setXY(\n                baseVertex + i,\n                glyph.sourceTextureCoordinates[i].x,\n                glyph.sourceTextureCoordinates[i].y\n            );\n        }\n\n        if (this.m_copyGeometry.index === null) {\n            throw new Error(\"GlyphTextureCache copy geometry index is uninitialized!\");\n        }\n        this.m_copyGeometry.index.setX(baseIndex, baseVertex);\n        this.m_copyGeometry.index.setX(baseIndex + 1, baseVertex + 1);\n        this.m_copyGeometry.index.setX(baseIndex + 2, baseVertex + 2);\n        this.m_copyGeometry.index.setX(baseIndex + 3, baseVertex + 2);\n        this.m_copyGeometry.index.setX(baseIndex + 4, baseVertex + 1);\n        this.m_copyGeometry.index.setX(baseIndex + 5, baseVertex + 3);\n\n        ++this.m_copyGeometryDrawCount;\n\n        const u0 = this.m_copyPositions[0].x / this.m_textureSize.x;\n        const v0 = this.m_copyPositions[0].y / this.m_textureSize.y;\n        const u1 = this.m_copyPositions[3].x / this.m_textureSize.x;\n        const v1 = this.m_copyPositions[3].y / this.m_textureSize.y;\n        glyph.dynamicTextureCoordinates[0].set(u0, v0);\n        glyph.dynamicTextureCoordinates[1].set(u1, v0);\n        glyph.dynamicTextureCoordinates[2].set(u0, v1);\n        glyph.dynamicTextureCoordinates[3].set(u1, v1);\n\n        glyph.isInCache = true;\n        this.m_entryCache.set(hash, {\n            glyphData: glyph,\n            location: cacheLocation\n        });\n    }\n\n    private clearCacheEntry(entry: GlyphCacheEntry) {\n        entry.glyphData.isInCache = false;\n        this.m_copyPositions[0].set(\n            entry.location.x * this.entryWidth,\n            entry.location.y * this.entryHeight\n        );\n        this.m_copyPositions[1].set(\n            (entry.location.x + 1) * this.entryWidth,\n            entry.location.y * this.entryHeight\n        );\n        this.m_copyPositions[2].set(\n            entry.location.x * this.entryWidth,\n            (entry.location.y + 1) * this.entryHeight\n        );\n        this.m_copyPositions[3].set(\n            (entry.location.x + 1) * this.entryWidth,\n            (entry.location.y + 1) * this.entryHeight\n        );\n\n        if (this.m_clearGeometryDrawCount >= this.capacity) {\n            return;\n        }\n        const baseVertex = this.m_clearGeometryDrawCount * 4;\n        const baseIndex = this.m_clearGeometryDrawCount * 6;\n\n        for (let i = 0; i < 4; ++i) {\n            this.m_clearPositionAttribute.setXY(\n                baseVertex + i,\n                this.m_copyPositions[i].x,\n                this.m_copyPositions[i].y\n            );\n        }\n\n        if (this.m_clearGeometry.index === null) {\n            throw new Error(\"GlyphTextureCache clear geometry index is uninitialized!\");\n        }\n        this.m_clearGeometry.index.setX(baseIndex, baseVertex);\n        this.m_clearGeometry.index.setX(baseIndex + 1, baseVertex + 1);\n        this.m_clearGeometry.index.setX(baseIndex + 2, baseVertex + 2);\n        this.m_clearGeometry.index.setX(baseIndex + 3, baseVertex + 2);\n        this.m_clearGeometry.index.setX(baseIndex + 4, baseVertex + 1);\n        this.m_clearGeometry.index.setX(baseIndex + 5, baseVertex + 3);\n\n        ++this.m_clearGeometryDrawCount;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { assert } from \"@here/harp-utils\";\n\n/** @hidden */\nexport class Entry<Key, Value> {\n    constructor(\n        public key: Key,\n        public value: Value,\n        public size: number,\n        public newer: Entry<Key, Value> | null,\n        public older: Entry<Key, Value> | null\n    ) {}\n}\n\n/**\n * Fixed size cache that evicts its entries in least-recently-used order when it overflows.\n * Modeled after standard JavaScript `Map` otherwise.\n */\nexport class LRUCache<Key, Value> {\n    /**\n     * Optional callback that is called on every item that is evicted from the cache.\n     *\n     * **Note**: This callback is not called when an item is explicitly deleted from the map via\n     * [[delete]] or [[clear]].\n     */\n    evictionCallback?: (key: Key, value: Value) => void;\n\n    /**\n     * Optional callback that is called on every item that should be evicted from the cache to\n     * determine if it can be removed, or should be locked in the cache.\n     *\n     * It returns `true` if the item can be removed from cache, `false` otherwise. Locking items in\n     * the cache should be a temporary measure, since if the cache is filled with non-evictable\n     * items only, it may grow beyond its capacity.\n     *\n     * **Note**: This callback is not called when an item is explicitly deleted from the map via\n     * [[delete]] or [[clear]].\n     */\n    canEvict?: (key: Key, value: Value) => boolean;\n    private m_capacity: number;\n    private m_size = 0;\n\n    /**\n     * The internal map object that keeps the key-value pairs and their order.\n     */\n    private m_map = new Map<Key, Entry<Key, Value>>();\n\n    /**\n     * The newest entry, i.e. the most recently used item.\n     */\n    private m_newest: Entry<Key, Value> | null = null;\n\n    /**\n     * The oldest entry, i.e. the least recently used item.\n     */\n    private m_oldest: Entry<Key, Value> | null = null;\n\n    /**\n     * A function determining the size per element.\n     */\n    private m_sizeFunction: (v: Value) => number;\n\n    /**\n     * Creates a new instance of `LRUCache`.\n     *\n     * The optional [[sizeFunction]] can be used to fine tune the memory consumption of all cached\n     * elements, thus [[cacheCapacity]] means then memory used (in MBs). Otherwise, if\n     * [[sizeFunction]] is not specified, the [[cacheCapacity]] accounts for the maximum\n     * number of elements stored.\n     *\n     * @param cacheCapacity - Number used to configure the maximum cache size, may express\n     * number of entries or memory consumed in megabytes depending on [[sizeFunction]].\n     * @param sizeFunction - A function determining the size per element.\n     */\n    constructor(cacheCapacity: number, sizeFunction: (v: Value) => number = () => 1) {\n        this.m_capacity = cacheCapacity;\n        this.m_sizeFunction = sizeFunction;\n    }\n\n    /**\n     * Iterates over all items from the most recently used item to the least recently used one.\n     *\n     * **Note**: Results are undefined if the entire cache is modified during iteration. You may\n     * although modify the current element in [[callbackfn]] function.\n     *\n     * @param callbackfn - The callback to call for each item.\n     * @param thisArg - Optional this argument for the callback.\n     */\n    forEach(\n        callbackfn: (value: Value, key: Key, map: LRUCache<Key, Value>) => void,\n        thisArg?: any\n    ): void {\n        let entry = this.m_newest;\n        while (entry !== null) {\n            const older = entry.older;\n            callbackfn.call(thisArg, entry.value, entry.key, this);\n            entry = older;\n        }\n    }\n\n    /**\n     * The size of the cache, i.e. the sum of all the sizes of all the objects in the cache.\n     *\n     * @returns The size of the cache.\n     */\n    get size(): number {\n        return this.m_size;\n    }\n\n    /**\n     * Returns the maximum capacity of the cache, i.e. the maximum number of elements this cache\n     * can contain or the total amount of memory that may be consumed by cache if element size\n     * function was specified in cache c-tor.\n     *\n     * @returns The capacity of the cache.\n     */\n    get capacity(): number {\n        return this.m_capacity;\n    }\n\n    /**\n     * @deprecated - DO NOT USE. Will be removed in future versions.\n     *\n     * Returns the internal map object that keeps the key-value pairs and their order.\n     *\n     * @returns The internal map object.\n     */\n    get map(): Map<Key, Entry<Key, Value>> {\n        // ### TODO - remove me. Cache must not expose its internal object,\n        // modifications to it are fatal for the internal state machine.\n        return this.m_map;\n    }\n\n    /**\n     * Returns the newest entry in the cache.\n     *\n     * @returns Newest entry in the cache.\n     */\n    get newest(): Entry<Key, Value> | null {\n        return this.m_newest;\n    }\n\n    /**\n     * Returns the oldest entry in the cache.\n     *\n     * Note: Does not promote the oldest item as most recently used item.\n     *\n     * @returns Oldest entry in the cache.\n     */\n    get oldest(): Entry<Key, Value> | null {\n        return this.m_oldest;\n    }\n\n    /**\n     * Resets the capacity of this cache. If `newCapacity` is smaller than the current cache size,\n     * all items will be evicted until the cache shrinks to `newCapacity`.\n     *\n     * @param newCapacity - The new capacity of this cache.\n     */\n    setCapacity(newCapacity: number): void {\n        this.m_capacity = newCapacity;\n        this.evict();\n    }\n\n    /**\n     * Resets the cache capacity and function used to measure the element size.\n     *\n     * @param newCapacity - The new capacity masured in units returned from [[sizeMeasure]] funtion.\n     * @param sizeMeasure - Function that defines the size of element, if you want to measure\n     * number of elements only always return 1 from this function (default), you may also\n     * specify own function that measures entries by memory consumed, nubmer of sub-elements, etc.\n     */\n    setCapacityAndMeasure(newCapacity: number, sizeMeasure: (v: Value) => number = () => 1) {\n        this.m_capacity = newCapacity;\n        this.m_sizeFunction = sizeMeasure;\n        this.shrinkToCapacity();\n    }\n\n    /**\n     * Updates the size of all elements in this cache. If their aggregated size is larger than the\n     * capacity, items will be evicted until the cache shrinks to fit the capacity.\n     */\n    shrinkToCapacity(): void {\n        let size = 0;\n        const sizeFunction = this.m_sizeFunction;\n\n        let entry = this.m_newest;\n        while (entry !== null) {\n            const entrySize = sizeFunction(entry.value);\n            entry.size = entrySize;\n            size += entrySize;\n            entry = entry.older;\n        }\n\n        this.m_size = size;\n        this.evict();\n    }\n\n    /**\n     * Inserts or updates a key/value pair in the cache.\n     *\n     * If the key already existed in the cache, it will be updated and promoted to the most recently\n     * used item.\n     *\n     * If the key didn't exist in the cache, it will be inserted as most recently used item. An\n     * eviction of the least recently used item takes place if the cache exceeded its capacity.\n     *\n     * @param key - The key for the key-value pair to insert or update.\n     * @param value - The value for the key-value pair to insert or update.\n     */\n    set(key: Key, value: Value) {\n        const valueSize = this.m_sizeFunction(value);\n        let entry = this.m_map.get(key);\n        if (entry !== undefined) {\n            this.m_size = this.m_size - entry.size + valueSize;\n            entry.value = value;\n            entry.size = valueSize;\n            this.promoteEntry(entry);\n            this.evict();\n        } else {\n            if (valueSize > this.m_capacity) {\n                return; // single item too big to cache\n            }\n\n            entry = new Entry<Key, Value>(key, value, valueSize, null, null);\n            if (this.m_map.size === 0) {\n                this.m_newest = this.m_oldest = entry;\n            } else {\n                assert(this.m_newest !== null);\n                const newest: Entry<Key, Value> = this.m_newest!;\n                entry.older = this.m_newest;\n                newest.newer = entry;\n                this.m_newest = entry;\n            }\n            this.m_map.set(key, entry);\n            this.m_size += valueSize;\n            this.evict();\n        }\n    }\n\n    /**\n     * Looks up key in the cache and returns the associated value.\n     *\n     * @param key - The key to look up.\n     * @returns The associated value, or `undefined` if the key-value pair is not in the cache.\n     */\n    get(key: Key): Value | undefined {\n        const entry = this.m_map.get(key);\n        if (entry === undefined) {\n            return undefined;\n        }\n\n        this.promoteEntry(entry);\n        return entry.value;\n    }\n\n    /**\n     * Test if a key/value pair is in the cache.\n     *\n     * @param key - The key to look up.\n     * @returns `true` if the key-value pair is in the cache, `false` otherwise.\n     */\n    has(key: Key): boolean {\n        return this.m_map.has(key);\n    }\n\n    /**\n     * Clears the cache and removes all stored key-value pairs.\n     *\n     * Does not call the eviction callback. Use [[evictAll]] to clear the cache and call the\n     * eviction callback.\n     */\n    clear(): void {\n        this.m_newest = this.m_oldest = null;\n        this.m_size = 0;\n        this.m_map.clear();\n    }\n\n    /**\n     * Evicts all items from the cache, calling the eviction callback on each item.\n     *\n     * Use [[clear]] to remove all items without calling the eviction callback.\n     */\n    evictAll(): void {\n        const cb = this.evictionCallback;\n        if (cb !== undefined) {\n            this.forEach((value, key) => cb(key, value));\n        }\n        this.clear();\n    }\n\n    /**\n     * Evict selected elements from the cache using [[selector]] function.\n     *\n     * @param selector - The function for selecting elements for eviction.\n     * @param thisArg - Optional _this_ object reference.\n     */\n    evictSelected(selector: (value: Value, key: Key) => boolean, thisArg?: any) {\n        const cb = this.evictionCallback;\n        let entry = this.m_newest;\n        while (entry !== null) {\n            const entryOlder = entry.older;\n            if (selector.call(thisArg, entry.value, entry.key)) {\n                if (cb !== undefined) {\n                    cb(entry.key, entry.value);\n                }\n                this.deleteEntry(entry);\n                this.m_map.delete(entry.key);\n            }\n            entry = entryOlder;\n        }\n    }\n\n    /**\n     * Explicitly removes a key-value pair from the cache.\n     *\n     * **Note**: This is an explicit removal, thus, the eviction callback will not be called.\n     *\n     * @param key - The key of the key-value pair to delete.\n     * @returns `true` if the key-value pair existed and was deleted, `false` otherwise.\n     */\n    delete(key: Key): boolean {\n        const entry = this.m_map.get(key);\n        if (entry === undefined) {\n            return false;\n        }\n        this.deleteEntry(entry);\n        return this.m_map.delete(key);\n    }\n\n    protected evict() {\n        while (this.m_oldest !== null && this.m_size > this.m_capacity) {\n            const evicted = this.evictOldest();\n            if (evicted === undefined) {\n                return;\n            }\n        }\n    }\n\n    protected evictOldest(): Entry<Key, Value> | undefined {\n        assert(this.m_oldest !== null);\n        const oldest = this.m_oldest!;\n        assert(oldest.older === null);\n        let itemToRemove = oldest;\n\n        if (this.canEvict !== undefined) {\n            while (!this.canEvict(itemToRemove.key, itemToRemove.value)) {\n                if (itemToRemove.newer === null) {\n                    return undefined;\n                }\n                itemToRemove = itemToRemove.newer;\n            }\n        }\n\n        if (itemToRemove === oldest) {\n            this.m_oldest = itemToRemove.newer;\n            if (itemToRemove.newer !== null) {\n                assert(itemToRemove.newer.older === itemToRemove);\n                itemToRemove.newer.older = null;\n            }\n        } else {\n            if (itemToRemove.newer !== null) {\n                assert(itemToRemove.newer.older === itemToRemove);\n                itemToRemove.newer.older = itemToRemove.older;\n                if (itemToRemove.older !== null) {\n                    itemToRemove.older.newer = itemToRemove.newer;\n                }\n            } else {\n                return undefined;\n            }\n        }\n\n        const isOk = this.m_map.delete(itemToRemove.key);\n        assert(isOk === true);\n        if (isOk && this.evictionCallback !== undefined) {\n            this.evictionCallback(itemToRemove.key, itemToRemove.value);\n        }\n        this.m_size -= itemToRemove.size;\n        return itemToRemove;\n    }\n\n    private deleteEntry(entry: Entry<Key, Value>): void {\n        if (entry === this.m_newest) {\n            this.m_newest = entry.older;\n        } else if (entry.newer) {\n            entry.newer.older = entry.older;\n        } else {\n            assert(false);\n        }\n\n        if (entry === this.m_oldest) {\n            this.m_oldest = entry.newer;\n        } else if (entry.older) {\n            entry.older.newer = entry.newer;\n        } else {\n            assert(false);\n        }\n\n        this.m_size -= entry.size;\n    }\n\n    private promoteEntry(entry: Entry<Key, Value>): void {\n        if (entry === this.m_newest) {\n            return;\n        } // already newest, nothing to do\n\n        // re-link newer and older items\n        if (entry.newer) {\n            assert(entry.newer.older === entry);\n            entry.newer.older = entry.older;\n        }\n        if (entry.older) {\n            assert(entry.older.newer === entry);\n            entry.older.newer = entry.newer;\n        }\n        if (entry === this.m_oldest) {\n            this.m_oldest = entry.newer;\n        }\n        // re-link ourselves\n        entry.newer = null;\n        entry.older = this.m_newest;\n\n        // finally, set ourselves as the newest entry\n        assert(this.m_newest !== null);\n        const newest = this.m_newest!;\n        assert(newest.newer === null);\n        newest.newer = entry;\n        this.m_newest = entry;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { FontCatalog } from \"./rendering/FontCatalog\";\nimport { GlyphData } from \"./rendering/GlyphData\";\nimport { TextBufferObject } from \"./rendering/TextBufferObject\";\nimport { QUAD_VERTEX_MEMORY_FOOTPRINT, TextGeometry } from \"./rendering/TextGeometry\";\nimport { SdfTextMaterial } from \"./rendering/TextMaterials\";\nimport { FontVariant, TextLayoutStyle, TextRenderStyle } from \"./rendering/TextStyle\";\nimport { LineTypesetter } from \"./typesetting/LineTypesetter\";\nimport { PathTypesetter, PathTypesettingParameters } from \"./typesetting/PathTypesetter\";\nimport { TypesettingParameters } from \"./typesetting/Typesetter\";\nimport { createSdfTextMaterial } from \"./utils/MaterialUtils\";\n\nconst tempTextPosition = new THREE.Vector3();\nconst tempTextBounds = {\n    array: [new THREE.Box2()],\n    offset: 0\n};\nlet tempVertexBuffer = new Float32Array();\n\ninterface TextPlacementParameters {\n    input: string | GlyphData[];\n    layer: TextCanvasLayer;\n    textPath?: THREE.Path | THREE.CurvePath<THREE.Vector2>;\n    textPathOverflow?: boolean;\n    bounds?: THREE.Box2;\n    individualBounds?: THREE.Box2[];\n    computeTextBuffer?: boolean;\n    letterCaseArray?: boolean[];\n}\n\n/**\n * Optional parameters passed on [[TextCanvas]].`measureText` function call.\n */\nexport interface MeasurementParameters {\n    /**\n     * Path where text should be placed on. Overrides the original position parameter.\n     */\n    path?: THREE.Path | THREE.CurvePath<THREE.Vector2>;\n\n    /**\n     * If `true`, text on a path will be placed even when its size its bigger than the path's size.\n     */\n    pathOverflow?: boolean;\n\n    /**\n     * Output per-character bounds.\n     */\n    outputCharacterBounds?: THREE.Box2[];\n\n    /**\n     * Array containing info on whether the glyphs are upper or lower case. Needed to support\n     * `SmallCaps`.\n     */\n    letterCaseArray?: boolean[];\n}\n\n/**\n * Optional parameters passed on [[TextCanvas]].`addText` function call.\n */\nexport interface AdditionParameters {\n    /**\n     * Path where text should be placed on. Overrides the original position parameter.\n     */\n    path?: THREE.Path | THREE.CurvePath<THREE.Vector2>;\n\n    /**\n     * If `true`, text on a path will be placed even when its size its bigger than the path's size.\n     */\n    pathOverflow?: boolean;\n\n    /**\n     * Layer where text will be added.\n     */\n    layer?: number;\n\n    /**\n     * If `true`, the input position parameter will be updated to contain the position of the last\n     * glyph added.\n     */\n    updatePosition?: boolean;\n\n    /**\n     * Object containing additional data intended to be retrieved during picking.\n     */\n    pickingData?: any;\n\n    /**\n     * Array containing info on whether the glyphs are upper or lower case. Needed to support\n     * `SmallCaps`.\n     */\n    letterCaseArray?: boolean[];\n}\n\n/**\n * Optional parameters passed on [[TextCanvas]].`createTextBufferObject` function call.\n */\nexport interface TextBufferCreationParameters {\n    /**\n     * Path where text should be placed on. Overrides the original position parameter.\n     */\n    path?: THREE.Path | THREE.CurvePath<THREE.Vector2>;\n\n    /**\n     * If `true`, text on a path will be placed even when its size its bigger than the path's size.\n     */\n    pathOverflow?: boolean;\n\n    /**\n     * Output text bounding-box.\n     */\n    outputBounds?: boolean;\n\n    /**\n     * Output per-character bounds.\n     */\n    outputCharacterBounds?: boolean;\n\n    /**\n     * Array containing info on whether the glyphs are upper or lower case. Needed to support\n     * `SmallCaps`.\n     */\n    letterCaseArray?: boolean[];\n\n    /**\n     * If `true`, both the [[TextRenderStyle]] and [[TextLayoutStyle]] used to generate the\n     * [[TextBufferObject]] will be stored in it.\n     */\n    storeStyles?: boolean;\n}\n\n/**\n * Optional parameters passed on [[TextCanvas]].`addTextBufferObject` function call.\n */\nexport interface TextBufferAdditionParameters {\n    layer?: number;\n    position?: THREE.Vector3;\n    scale?: number;\n    rotation?: number;\n    color?: THREE.Color;\n    opacity?: number;\n    backgroundColor?: THREE.Color;\n    backgroundOpacity?: number;\n    pickingData?: any;\n}\n\n/**\n * Default's [[TextCanvas]] layer identifier.\n */\nexport const DEFAULT_TEXT_CANVAS_LAYER = 0;\n\n/**\n * [[TextCanvas]] rendering layer.\n */\nexport interface TextCanvasLayer {\n    id: number;\n    storage: TextGeometry;\n}\n\n/**\n * [[TextCanvas]] construction parameters.\n */\nexport interface TextCanvasParameters {\n    /**\n     * WebGLRenderer internally used by this `TextCanvas`.\n     */\n    renderer: THREE.WebGLRenderer;\n\n    /**\n     * Initial [[FontCatalog]].\n     */\n    fontCatalog: FontCatalog;\n\n    /**\n     * Minimum amount of glyphs each [[TextCanvas]] layer can store.\n     */\n    minGlyphCount: number;\n\n    /**\n     * Maximum amount of glyphs each [[TextCanvas]] layer can store.\n     */\n    maxGlyphCount: number;\n\n    /**\n     * Material used to render text.\n     */\n    material?: THREE.Material;\n\n    /**\n     * Material used to render text background.\n     */\n    backgroundMaterial?: THREE.Material;\n}\n\n/**\n * Describes estimated usage of memory on heap and GPU.\n */\nexport interface MemoryUsage {\n    heapSize: number;\n    gpuSize: number;\n}\n\n/**\n * three.js text rendering engine which can manage and render high-quality, transformable, stylable\n * and properly layout SDF and MSDF text.\n */\nexport class TextCanvas {\n    private static defaultTextRenderStyle: TextRenderStyle = new TextRenderStyle();\n    private static defaultTextLayoutStyle: TextLayoutStyle = new TextLayoutStyle();\n    /**\n     * Minimum amount of glyphs each [[TextCanvas]] layer can store.\n     */\n    readonly minGlyphCount: number;\n\n    /**\n     * Maximum amount of glyphs each [[TextCanvas]] layer can store.\n     */\n    readonly maxGlyphCount: number;\n\n    private m_renderer: THREE.WebGLRenderer;\n    private m_fontCatalog: FontCatalog;\n\n    private m_currentTextRenderStyle: TextRenderStyle;\n    private m_currentTextLayoutStyle: TextLayoutStyle;\n\n    private m_material: SdfTextMaterial | THREE.Material;\n    private m_bgMaterial: SdfTextMaterial | THREE.Material;\n    private m_ownsMaterial: boolean;\n    private m_ownsBgMaterial: boolean;\n\n    private m_defaultLayer: TextCanvasLayer;\n    private m_layers: TextCanvasLayer[];\n\n    private m_lineTypesetter: LineTypesetter;\n    private m_pathTypesetter: PathTypesetter;\n\n    /**\n     * Constructs a new `TextCanvas`.\n     *\n     * @param params - `TextCanvas` construction parameters.\n     *\n     * @returns New `TextCanvas`.\n     */\n    constructor(params: TextCanvasParameters) {\n        this.m_renderer = params.renderer;\n        this.m_fontCatalog = params.fontCatalog;\n        this.minGlyphCount = params.minGlyphCount;\n        this.maxGlyphCount = params.maxGlyphCount;\n\n        if (params.material === undefined) {\n            this.m_ownsMaterial = true;\n            this.m_material = createSdfTextMaterial({ fontCatalog: params.fontCatalog });\n        } else {\n            this.m_ownsMaterial = false;\n            this.m_material = params.material;\n        }\n        if (params.backgroundMaterial === undefined) {\n            this.m_ownsBgMaterial = true;\n            this.m_bgMaterial = createSdfTextMaterial({\n                fontCatalog: params.fontCatalog,\n                isBackground: true\n            });\n        } else {\n            this.m_ownsBgMaterial = false;\n            this.m_bgMaterial = params.backgroundMaterial;\n        }\n\n        this.m_defaultLayer = {\n            id: DEFAULT_TEXT_CANVAS_LAYER,\n            storage: new TextGeometry(\n                new THREE.Scene(),\n                this.m_material,\n                this.m_bgMaterial,\n                this.minGlyphCount,\n                this.maxGlyphCount\n            )\n        };\n        this.m_layers = [this.m_defaultLayer];\n\n        this.m_currentTextRenderStyle = new TextRenderStyle().copy(\n            TextCanvas.defaultTextRenderStyle\n        );\n        this.m_currentTextLayoutStyle = new TextLayoutStyle().copy(\n            TextCanvas.defaultTextLayoutStyle\n        );\n\n        this.m_lineTypesetter = new LineTypesetter();\n        this.m_pathTypesetter = new PathTypesetter();\n    }\n\n    /**\n     * Currently active [[FontCatalog]].\n     */\n    get fontCatalog(): FontCatalog {\n        return this.m_fontCatalog;\n    }\n    set fontCatalog(value: FontCatalog) {\n        this.m_fontCatalog = value;\n\n        const material = this.m_material as THREE.RawShaderMaterial;\n        material.uniforms.sdfTexture.value = this.m_fontCatalog.texture;\n        material.uniforms.sdfParams.value = new THREE.Vector4(\n            this.m_fontCatalog.textureSize.x,\n            this.m_fontCatalog.textureSize.y,\n            this.m_fontCatalog.size,\n            this.m_fontCatalog.distanceRange\n        );\n        material.defines.MSDF = this.m_fontCatalog.type === \"msdf\" ? 1.0 : 0.0;\n\n        const bgMaterial = this.m_bgMaterial as THREE.RawShaderMaterial;\n        bgMaterial.uniforms.sdfTexture.value = this.m_fontCatalog.texture;\n        bgMaterial.uniforms.sdfParams.value = new THREE.Vector4(\n            this.m_fontCatalog.textureSize.x,\n            this.m_fontCatalog.textureSize.y,\n            this.m_fontCatalog.size,\n            this.m_fontCatalog.distanceRange\n        );\n        bgMaterial.defines.MSDF = this.m_fontCatalog.type === \"msdf\" ? 1.0 : 0.0;\n    }\n\n    /**\n     * Currently active text rendering material.\n     */\n    get material(): THREE.Material {\n        return this.m_material;\n    }\n    set material(value: THREE.Material) {\n        if (this.m_ownsMaterial) {\n            this.m_material.dispose();\n            this.m_ownsMaterial = false;\n        }\n\n        this.m_material = value;\n        for (const layer of this.m_layers) {\n            layer.storage.mesh.material = this.m_material;\n        }\n    }\n\n    /**\n     * Currently active text background rendering material.\n     */\n    get backgroundMaterial(): THREE.Material {\n        return this.m_bgMaterial;\n    }\n    set backgroundMaterial(value: THREE.Material) {\n        if (this.m_ownsBgMaterial) {\n            this.m_bgMaterial.dispose();\n            this.m_ownsBgMaterial = false;\n        }\n\n        this.m_bgMaterial = value;\n        for (const layer of this.m_layers) {\n            layer.storage.backgroundMesh.material = this.m_bgMaterial;\n        }\n    }\n\n    /**\n     * Currently active text rendering style.\n     */\n    get textRenderStyle(): TextRenderStyle {\n        return this.m_currentTextRenderStyle;\n    }\n    set textRenderStyle(style: TextRenderStyle) {\n        this.m_currentTextRenderStyle.copy(style);\n    }\n\n    /**\n     * Currently active text layout style.\n     */\n    get textLayoutStyle(): TextLayoutStyle {\n        return this.m_currentTextLayoutStyle;\n    }\n    set textLayoutStyle(style: TextLayoutStyle) {\n        this.m_currentTextLayoutStyle.copy(style);\n    }\n\n    /**\n     * Clears all the placed glyphs in this `TextCanvas` (as well as resetting the current style).\n     */\n    clear() {\n        for (const layer of this.m_layers) {\n            layer.storage.clear();\n        }\n        this.m_currentTextRenderStyle.copy(TextCanvas.defaultTextRenderStyle);\n        this.m_currentTextLayoutStyle.copy(TextCanvas.defaultTextLayoutStyle);\n    }\n\n    /**\n     * Renders the content of this `TextCanvas`.\n     *\n     * @param camera - Orthographic camera.\n     * @param target - Optional render target.\n     * @param clear - Optional render target clear operation.\n     */\n    render(camera: THREE.OrthographicCamera, target?: THREE.WebGLRenderTarget, clear?: boolean) {\n        this.m_fontCatalog.update(this.m_renderer);\n        let oldTarget: THREE.RenderTarget | null = null;\n        if (target !== undefined) {\n            oldTarget = this.m_renderer.getRenderTarget();\n            this.m_renderer.setRenderTarget(target);\n        }\n        if (clear === true) {\n            this.m_renderer.clear(true);\n        }\n        for (const layer of this.m_layers) {\n            layer.storage.update();\n            this.m_renderer.render(layer.storage.scene, camera);\n        }\n        if (target !== undefined) {\n            this.m_renderer.setRenderTarget(oldTarget);\n        }\n    }\n\n    /**\n     * Creates a new `TextCanvas` rendering layer and returns. If there was already a layer for the\n     * input `layerId`, it just returns this one instead.\n     *\n     * @param layerId - Desired layer identifier.\n     *\n     * @returns Created [[TextCanvasLayer]].\n     */\n    addLayer(layerId: number): TextCanvasLayer {\n        let result = this.getLayer(layerId);\n        if (result === undefined) {\n            result = {\n                id: layerId,\n                storage: new TextGeometry(\n                    new THREE.Scene(),\n                    this.m_material,\n                    this.m_bgMaterial,\n                    this.minGlyphCount,\n                    this.maxGlyphCount\n                )\n            };\n\n            this.m_layers.push(result);\n            this.m_layers.sort((a: TextCanvasLayer, b: TextCanvasLayer) => {\n                return a.id - b.id;\n            });\n        }\n        return result;\n    }\n\n    /**\n     * Retrieves a specific `TextCanvas` rendering layer.\n     *\n     * @param layerId - Desired layer identifier.\n     *\n     * @returns Selected [[TextCanvasLayer]].\n     */\n    getLayer(layerId: number): TextCanvasLayer | undefined {\n        return this.m_layers.find(layer => layer.id === layerId);\n    }\n\n    /**\n     * Retrieves all `TextCanvas` rendering layers.\n     *\n     * @returns Array of [[TextCanvasLayer]]s.\n     */\n    getAllLayers(): TextCanvasLayer[] {\n        return this.m_layers;\n    }\n\n    /**\n     * Returns the computed bounding box for the input text. The current [[TextRenderStyle]] and\n     * [[TextLayoutStyle]] will influence the results of this function.\n     *\n     * @param text - Input text. Provide an array of [[GlyphData]] for better performance.\n     * @param outputBounds - Output text bounding box.\n     * @param params - Optional measurement parameters.\n     *\n     * @returns Result of the measurement. If `false`, some error occurred during execution and the\n     * input text couldn't be properly measured.\n     */\n    measureText(\n        text: string | GlyphData[],\n        outputBounds: THREE.Box2,\n        params?: MeasurementParameters\n    ): boolean {\n        tempTextPosition.set(0, 0, 0);\n\n        let path;\n        let pathOverflow;\n        let upperCaseArray;\n        let outputCharacterBounds;\n        if (params !== undefined) {\n            path = params.path;\n            pathOverflow = params.pathOverflow;\n            outputCharacterBounds = params.outputCharacterBounds;\n            if (params.path !== undefined) {\n                const pathOrigin = params.path.getPoint(0);\n                if (pathOrigin === null) {\n                    return false;\n                }\n                tempTextPosition.set(pathOrigin.x, pathOrigin.y, 0.0);\n            }\n            if (params.letterCaseArray) {\n                upperCaseArray = params.letterCaseArray;\n            }\n        }\n\n        return this.placeText({\n            input: text,\n            layer: this.m_defaultLayer,\n            textPath: path,\n            textPathOverflow: pathOverflow,\n            bounds: outputBounds,\n            individualBounds: outputCharacterBounds,\n            letterCaseArray: upperCaseArray\n        });\n    }\n\n    /**\n     * Adds the input text to this `TextCanvas` in the specified screen position. The current\n     * [[TextRenderStyle]] and [[TextLayoutStyle]] will influence the results of this function.\n     *\n     * @param text - Input text. Provide an array of [[GlyphData]] for better performance.\n     * @param position - Screen position.\n     * @param params - Optional addition parameters.\n     *\n     * @returns Result of the addition. If `false`, some error occurred during execution and the\n     * input text couldn't be properly added.\n     */\n    addText(\n        text: string | GlyphData[],\n        position: THREE.Vector3,\n        params?: AdditionParameters\n    ): boolean {\n        tempTextPosition.copy(position);\n\n        let path;\n        let pathOverflow;\n        let upperCaseArray;\n        let targetLayer = this.m_defaultLayer;\n        if (params !== undefined) {\n            path = params.path;\n            pathOverflow = params.pathOverflow;\n            if (params.layer !== undefined) {\n                let tempLayer = this.getLayer(params.layer);\n                if (tempLayer === undefined) {\n                    tempLayer = this.addLayer(params.layer);\n                }\n                targetLayer = tempLayer;\n            }\n            if (params.path !== undefined) {\n                tempTextPosition.set(0, 0, tempTextPosition.z);\n            }\n            if (params.letterCaseArray) {\n                upperCaseArray = params.letterCaseArray;\n            }\n        }\n        const prevDrawCount = targetLayer.storage.drawCount;\n\n        const result = this.placeText({\n            input: text,\n            textPath: path,\n            textPathOverflow: pathOverflow,\n            layer: targetLayer,\n            letterCaseArray: upperCaseArray\n        });\n        if (result && params !== undefined) {\n            if (params.updatePosition === true) {\n                position.copy(tempTextPosition);\n            }\n            if (params.pickingData !== undefined) {\n                targetLayer.storage.addPickingData(\n                    prevDrawCount,\n                    targetLayer.storage.drawCount,\n                    params.pickingData\n                );\n            }\n        } else if (!result) {\n            (targetLayer.storage as any).m_drawCount = prevDrawCount;\n        }\n        return result;\n    }\n\n    /**\n     * Creates a new [[TextBufferObject]]. The computed text vertex buffer is equivalent to the\n     * result of performing the `addText` function for the input text in the screen origin.\n     *\n     * @param text - Input text. Provide an array of [[GlyphData]] for better performance.\n     * @param params - Optional creation parameters.\n     *\n     * @returns New [[TextBufferObject]] (or `undefined` if requested text glyphs couldn't be\n     * retrieved from the current [[FontCatalog]]).\n     */\n    createTextBufferObject(\n        text: string | GlyphData[],\n        params?: TextBufferCreationParameters\n    ): TextBufferObject | undefined {\n        tempTextPosition.set(0, 0, 0);\n\n        let glyphArray;\n        let upperCaseArray: boolean[] | undefined;\n        const smallCapsEnabled =\n            this.m_currentTextRenderStyle.fontVariant === FontVariant.SmallCaps;\n        if (typeof text !== \"string\") {\n            glyphArray = text;\n            if (params !== undefined && params.letterCaseArray) {\n                upperCaseArray = params.letterCaseArray;\n            }\n        } else {\n            upperCaseArray = [];\n            glyphArray = this.m_fontCatalog.getGlyphs(\n                text,\n                this.m_currentTextRenderStyle,\n                smallCapsEnabled ? upperCaseArray : undefined\n            );\n            if (glyphArray === undefined) {\n                return undefined;\n            }\n        }\n\n        let path;\n        let pathOverflow;\n        let textBounds;\n        let characterBounds;\n        let renderStyle;\n        let layoutStyle;\n        if (params !== undefined) {\n            path = params.path;\n            pathOverflow = params.pathOverflow;\n            if (params.outputBounds === true) {\n                textBounds = new THREE.Box2();\n            }\n            if (params.outputCharacterBounds === true) {\n                characterBounds = [];\n            }\n            if (params.storeStyles === true) {\n                renderStyle = this.m_currentTextRenderStyle.clone();\n                layoutStyle = this.m_currentTextLayoutStyle.clone();\n            }\n        }\n\n        this.placeText({\n            input: text,\n            layer: this.m_defaultLayer,\n            computeTextBuffer: true,\n            textPath: path,\n            textPathOverflow: pathOverflow,\n            bounds: textBounds,\n            individualBounds: characterBounds,\n            letterCaseArray: upperCaseArray\n        });\n\n        return new TextBufferObject(\n            glyphArray,\n            new Float32Array(tempVertexBuffer),\n            textBounds,\n            characterBounds,\n            renderStyle,\n            layoutStyle\n        );\n    }\n\n    /**\n     * Adds a previously created [[TextBufferObject]] to the `TextCanvas`. Additional parameters can\n     * be provided to override the attributes stored in the buffer.\n     *\n     * @param textBufferObject - [[TextBufferObject]] to add.\n     * @param params - Optional addition parameters.\n     *\n     * @returns Result of the addition. If `false`, some error occurred during execution and the\n     * input text couldn't be properly added.\n     */\n    addTextBufferObject(\n        textBufferObject: TextBufferObject,\n        params?: TextBufferAdditionParameters\n    ): boolean {\n        let targetLayer = this.m_defaultLayer;\n        let position;\n        let scale;\n        let rotation;\n        let color;\n        let opacity;\n        let bgColor;\n        let bgOpacity;\n\n        if (params !== undefined) {\n            if (params.layer !== undefined) {\n                let tempLayer = this.getLayer(params.layer);\n                if (tempLayer === undefined) {\n                    tempLayer = this.addLayer(params.layer);\n                }\n                targetLayer = tempLayer;\n            }\n            position = params.position?.clone();\n            scale = params.scale;\n            rotation = params.rotation;\n            color = params.color;\n            opacity = params.opacity;\n            bgColor = params.backgroundColor;\n            bgOpacity = params.backgroundOpacity;\n        }\n        const prevDrawCount = targetLayer.storage.drawCount;\n\n        const result = targetLayer.storage.addTextBufferObject(\n            textBufferObject,\n            position,\n            scale,\n            rotation,\n            color,\n            opacity,\n            bgColor,\n            bgOpacity\n        );\n        if (result && params !== undefined) {\n            if (params.pickingData !== undefined) {\n                targetLayer.storage.addPickingData(\n                    prevDrawCount,\n                    targetLayer.storage.drawCount,\n                    params.pickingData\n                );\n            }\n        } else if (!result) {\n            (targetLayer.storage as any).m_drawCount = prevDrawCount;\n        }\n        return result;\n    }\n\n    /**\n     * Executes the `pickCallback` for all previously stored picking data for text covering the\n     * specified screen position.\n     *\n     * @param screenPosition - Screen coordinate of picking position.\n     * @param pickCallback - Callback to be called for every picked element.\n     */\n    pickText(position: THREE.Vector2, callback: (pickData: any | undefined) => void): void {\n        for (const layer of this.m_layers) {\n            layer.storage.pick(position, callback);\n        }\n    }\n\n    /**\n     * Update the info with the memory footprint caused by objects owned by the `TextCanvas`.\n     *\n     * @param info - The info object to increment with the values from this `TextCanvas`.\n     */\n    getMemoryUsage(info: MemoryUsage) {\n        this.m_fontCatalog.updateMemoryUsage(info);\n\n        for (const layer of this.m_layers) {\n            layer.storage.updateMemoryUsage(info);\n        }\n    }\n\n    // Places all glyphs for input text. Depending on parameters, it can store the resulting glyphs\n    // in the current [[TextGeometry]] (or into a separate buffer) or compute the bounding box for\n    // the input (as a whole or on a per-character basis).\n    private placeText(params: TextPlacementParameters): boolean {\n        if (params.input.length === 0 || this.m_currentTextLayoutStyle.maxLines! === 0) {\n            if (params.bounds !== undefined) {\n                params.bounds.min.set(0, 0);\n                params.bounds.max.set(0, 0);\n            }\n            if (params.individualBounds !== undefined) {\n                params.individualBounds.length = 0;\n            }\n            return true;\n        }\n\n        let glyphArray;\n        let smallCapsTransformations: boolean[] | undefined;\n        const smallCapsEnabled =\n            this.m_currentTextRenderStyle.fontVariant === FontVariant.SmallCaps;\n        if (typeof params.input !== \"string\") {\n            glyphArray = params.input;\n            if (params.letterCaseArray) {\n                smallCapsTransformations = params.letterCaseArray;\n            }\n        } else {\n            smallCapsTransformations = [];\n            glyphArray = this.m_fontCatalog.getGlyphs(\n                params.input,\n                this.m_currentTextRenderStyle,\n                smallCapsEnabled ? smallCapsTransformations : undefined\n            );\n            if (glyphArray === undefined) {\n                return false;\n            }\n        }\n\n        let glyphBounds;\n        if (params.individualBounds !== undefined) {\n            tempTextBounds.array = params.individualBounds;\n            tempTextBounds.offset = 0;\n            glyphBounds = tempTextBounds;\n        }\n        if (params.bounds !== undefined) {\n            params.bounds.min.set(Infinity, Infinity);\n            params.bounds.max.set(-Infinity, -Infinity);\n        }\n        if (params.computeTextBuffer === true) {\n            tempVertexBuffer = new Float32Array(glyphArray.length * QUAD_VERTEX_MEMORY_FOOTPRINT);\n        }\n\n        const isPath = params.textPath !== undefined;\n        const typesettingParams: TypesettingParameters | PathTypesettingParameters = {\n            glyphs: glyphArray,\n            fontCatalog: this.m_fontCatalog,\n            textRenderStyle: this.m_currentTextRenderStyle,\n            textLayoutStyle: this.m_currentTextLayoutStyle,\n            position: tempTextPosition,\n            geometry: params.layer.storage,\n            smallCapsArray: smallCapsEnabled ? smallCapsTransformations : undefined,\n            globalBounds: params.bounds,\n            individualBounds: glyphBounds,\n            vertexBuffer: params.computeTextBuffer === true ? tempVertexBuffer : undefined\n        };\n\n        let result = true;\n        if (isPath) {\n            Object.assign(typesettingParams as PathTypesettingParameters, {\n                path: params.textPath,\n                pathOverflow: params.textPathOverflow === true\n            });\n            result = this.m_pathTypesetter.arrangeGlyphs(\n                typesettingParams as PathTypesettingParameters\n            );\n        } else {\n            result = this.m_lineTypesetter.arrangeGlyphs(typesettingParams);\n        }\n        if (glyphBounds !== undefined) {\n            glyphBounds.array.length = glyphBounds.offset;\n        }\n\n        return result;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { QUAD_VERTEX_MEMORY_FOOTPRINT } from \"../rendering/TextGeometry\";\nimport { FontStyle, FontVariant, WrappingMode } from \"../rendering/TextStyle\";\nimport { TypesettingUtils } from \"../utils/TypesettingUtils\";\nimport { UnicodeUtils } from \"../utils/UnicodeUtils\";\nimport { Typesetter, TypesettingParameters } from \"./Typesetter\";\n\n/**\n * [[Typesetter]] implementation that handles multi-line complex layout text.\n */\nexport class LineTypesetter implements Typesetter {\n    private m_tempTransform: THREE.Matrix3;\n    private m_tempCorners: THREE.Vector3[];\n    private m_tempLineDirection: UnicodeUtils.Direction;\n    private m_tempRunDirection: UnicodeUtils.Direction;\n    private m_tempPixelSize: number;\n    private m_tempPixelBgSize: number;\n    private m_tempScale: number;\n    private m_tempSmallCaps: boolean;\n\n    private m_currentParams?: TypesettingParameters;\n\n    /**\n     * Creates a `LineTypesetter` object.\n     *\n     * @returns New `LineTypesetter`.\n     */\n    constructor() {\n        this.m_tempTransform = new THREE.Matrix3();\n        this.m_tempCorners = [\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3()\n        ];\n        this.m_tempLineDirection = UnicodeUtils.Direction.LTR;\n        this.m_tempRunDirection = UnicodeUtils.Direction.LTR;\n        this.m_tempPixelSize = 1.0;\n        this.m_tempPixelBgSize = 1.0;\n        this.m_tempScale = 1.0;\n        this.m_tempSmallCaps = false;\n    }\n\n    /**\n     * Arranges the specified glyphs using this `LineTypesetter`. Text will be placed into multiple\n     * bidirectional lines, that will be generated taking into account [[textLayoutStyle]] features,\n     * such as:\n     * - Maximum line width.\n     * - Word and character wrapping.\n     * - Maximum number of lines.\n     * - Vertical and horizontal alignment.\n     * - Leading (spacing between lines).\n     *\n     * @param params - Typesetting parameters.\n     *\n     * @returns If `false`, some error occurred during execution and the output should be dismissed.\n     */\n    arrangeGlyphs(params: TypesettingParameters): boolean {\n        // Initializes common typesetting parameters (used across all functions in this class).\n        this.m_currentParams = params;\n        this.m_tempLineDirection = TypesettingUtils.getDirection(this.m_currentParams.glyphs, 0);\n        this.m_tempRunDirection = this.m_tempLineDirection;\n        this.m_tempPixelSize = TypesettingUtils.getPixelSize(\n            this.m_currentParams.textRenderStyle.fontSize.size,\n            this.m_currentParams.textRenderStyle.fontSize.unit,\n            this.m_currentParams.fontCatalog.size\n        );\n        this.m_tempScale = this.m_tempPixelSize / this.m_currentParams.fontCatalog.size;\n        this.m_tempPixelBgSize = Math.min(\n            TypesettingUtils.getPixelSize(\n                this.m_currentParams.textRenderStyle.fontSize.backgroundSize,\n                this.m_currentParams.textRenderStyle.fontSize.unit,\n                this.m_currentParams.fontCatalog.size\n            ),\n            this.m_currentParams!.fontCatalog.distanceRange * this.m_tempScale\n        );\n        this.m_tempSmallCaps = this.m_currentParams!.smallCapsArray !== undefined;\n\n        this.m_currentParams.position.y +=\n            this.m_currentParams.textLayoutStyle.verticalAlignment *\n            this.m_currentParams.glyphs[0].font.metrics.capHeight *\n            this.m_tempScale;\n\n        const isOnlyMeasured =\n            this.m_currentParams.globalBounds !== undefined &&\n            this.m_currentParams.vertexBuffer === undefined;\n\n        // Compute line origin and height.\n        const origin = this.m_currentParams.position.x;\n        const lineHeight =\n            this.m_currentParams.glyphs[0].font.metrics.lineHeight +\n            this.m_currentParams.textLayoutStyle.leading;\n\n        // Initialize line-breaking and wrapping variables.\n        let lineStartIdx = 0;\n        let glyphWrapIdx = 0;\n        let wordWrapIdx = 0;\n        let lineStartX = 0;\n        let lineCurrX = 0;\n        let glyphWrapX = 0;\n        let wordWrapX = 0;\n\n        let lineCount = 0;\n        let isBidirectionalLine = false;\n        for (let i = 0; i < this.m_currentParams.glyphs.length; ++i) {\n            if (lineCount > this.m_currentParams.textLayoutStyle.maxLines - 1) {\n                break;\n            }\n            const glyphData = this.m_currentParams.glyphs[i];\n            if (!glyphData.isInCache && !isOnlyMeasured) {\n                return false;\n            }\n\n            const isNewLine = UnicodeUtils.isNewLine(glyphData.codePoint);\n            const isWhiteSpace = UnicodeUtils.isWhiteSpace(glyphData.codePoint);\n\n            // Check if this line should be treated as bidirectional.\n            if (!isBidirectionalLine && glyphData.direction === -this.m_tempLineDirection) {\n                isBidirectionalLine = true;\n            }\n            // Advance the line's current X offset (only for printable characters).\n            if (UnicodeUtils.isPrintable(glyphData.codePoint)) {\n                lineCurrX +=\n                    (glyphData.advanceX + this.m_currentParams.textLayoutStyle.tracking) *\n                    this.m_tempScale *\n                    (this.m_tempSmallCaps\n                        ? TypesettingUtils.getSmallCapsScale(\n                              this.m_currentParams.glyphs,\n                              this.m_currentParams.smallCapsArray!,\n                              i,\n                              this.m_currentParams.textRenderStyle.fontVariant\n                          )\n                        : 1.0);\n            }\n            // If this is the first character in a line, update the line's X offset values (needed\n            // to properly center and wrap).\n            if (i === lineStartIdx) {\n                lineStartX = lineCurrX;\n                glyphWrapX = lineCurrX;\n                wordWrapX = lineCurrX;\n            }\n\n            // Check if should break the current line.\n            if (\n                isNewLine ||\n                (this.m_currentParams.textLayoutStyle.wrappingMode === WrappingMode.Character &&\n                    lineCurrX > this.m_currentParams.textLayoutStyle.lineWidth) ||\n                (this.m_currentParams.textLayoutStyle.wrappingMode === WrappingMode.Word &&\n                    lineCurrX > this.m_currentParams.textLayoutStyle.lineWidth &&\n                    wordWrapX !== lineStartX)\n            ) {\n                // Perform wrapping.\n                if (this.m_currentParams.textLayoutStyle.wrappingMode !== WrappingMode.None) {\n                    let wrapPointIdx = glyphWrapIdx;\n                    let wrapPointX = glyphWrapX;\n                    // Only wrap words when more than a single word fits into the current line.\n                    if (\n                        this.m_currentParams.textLayoutStyle.wrappingMode === WrappingMode.Word &&\n                        wordWrapX !== lineStartX\n                    ) {\n                        wrapPointIdx = wordWrapIdx;\n                        wrapPointX = wordWrapX;\n                    }\n\n                    lineCurrX = wrapPointX;\n                    i = Math.min(\n                        isNewLine ? (lineStartIdx === i ? wrapPointIdx : i) : wrapPointIdx,\n                        this.m_currentParams.glyphs.length - 1\n                    );\n                }\n\n                // Calculate the correct starting position for the line base on alignment, and place\n                // all glyphs in it.\n                const lineAlignment =\n                    this.m_tempLineDirection === UnicodeUtils.Direction.RTL && isBidirectionalLine\n                        ? 1.0 + this.m_currentParams.textLayoutStyle.horizontalAlignment\n                        : this.m_currentParams.textLayoutStyle.horizontalAlignment;\n                this.m_currentParams.position.x =\n                    this.m_currentParams.position.x + lineCurrX * lineAlignment;\n                if (\n                    !this.placeLine(lineStartIdx, i, this.m_tempLineDirection, isBidirectionalLine)\n                ) {\n                    return false;\n                }\n\n                // Update the line position.\n                this.m_currentParams.position.y -= lineHeight * this.m_tempScale;\n                this.m_currentParams.position.x = origin;\n\n                // Find the beginning of a new line (removing trailing white spaces).\n                while (\n                    i !== lineStartIdx &&\n                    i + 1 < this.m_currentParams.glyphs.length &&\n                    UnicodeUtils.isWhiteSpace(this.m_currentParams.glyphs[i + 1].codePoint)\n                ) {\n                    ++i;\n                }\n                lineStartIdx = i + 1;\n                if (lineStartIdx === this.m_currentParams.glyphs.length) {\n                    break;\n                }\n\n                // Only reset the line's direction when a new line character is found (to keep\n                // correct bidirectional behaviour when a bidirectional run is placed between\n                // multiple lines).\n                if (isNewLine) {\n                    this.m_tempLineDirection = TypesettingUtils.getDirection(\n                        this.m_currentParams.glyphs,\n                        lineStartIdx\n                    );\n                    this.m_tempRunDirection = this.m_tempLineDirection;\n                }\n\n                // Reset the line placement parameters.\n                lineStartX = 0;\n                lineCurrX = 0;\n                glyphWrapIdx = lineStartIdx;\n                glyphWrapX = 0;\n                wordWrapIdx = lineStartIdx;\n                wordWrapX = 0;\n                isBidirectionalLine = false;\n                lineCount++;\n            }\n            // If not, should if we should record any new wrapping points.\n            else if (\n                this.m_currentParams.textLayoutStyle.wrappingMode !== WrappingMode.None &&\n                !isWhiteSpace\n            ) {\n                // Update the per-glyph wrapping point.\n                glyphWrapIdx = i;\n                glyphWrapX = lineCurrX;\n\n                // Update the word wrapping point (only if mode is correctly set and we are\n                // currently placed at the end of a word).\n                if (\n                    this.m_currentParams.textLayoutStyle.wrappingMode === WrappingMode.Word &&\n                    i + 1 < this.m_currentParams.glyphs.length &&\n                    (UnicodeUtils.isWhiteSpace(this.m_currentParams.glyphs[i + 1].codePoint) ||\n                        UnicodeUtils.isNewLine(this.m_currentParams.glyphs[i + 1].codePoint))\n                ) {\n                    wordWrapIdx = i;\n                    wordWrapX = lineCurrX;\n                }\n            }\n        }\n\n        // If we still haven't placed all characters, place a final line.\n        if (\n            lineCount <= this.m_currentParams.textLayoutStyle.maxLines - 1 &&\n            lineStartIdx <= this.m_currentParams.glyphs.length - 1\n        ) {\n            const offset =\n                this.m_tempLineDirection === UnicodeUtils.Direction.RTL && isBidirectionalLine\n                    ? 1.0 + this.m_currentParams.textLayoutStyle.horizontalAlignment\n                    : this.m_currentParams.textLayoutStyle.horizontalAlignment;\n            this.m_currentParams.position.setX(\n                this.m_currentParams.position.x + lineCurrX * offset\n            );\n            if (\n                !this.placeLine(\n                    lineStartIdx,\n                    this.m_currentParams.glyphs.length - 1,\n                    this.m_tempLineDirection,\n                    isBidirectionalLine\n                )\n            ) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    // Place characters alongside a line. Text direction is taken into account, and text is broken\n    // into directional runs.\n    private placeLine(\n        startIdx: number,\n        endIdx: number,\n        direction: UnicodeUtils.Direction,\n        isBidirectional: boolean\n    ): boolean {\n        // If the line is not bidirectional, place it as a single directional run.\n        if (!isBidirectional) {\n            return this.placeRun(startIdx, endIdx, direction);\n        }\n\n        // Gather common typesetting parameters.\n        const glyphDataArray = this.m_currentParams!.glyphs;\n        const smallCapsArray = this.m_currentParams!.smallCapsArray;\n        const textRenderStyle = this.m_currentParams!.textRenderStyle;\n        const textLayoutStyle = this.m_currentParams!.textLayoutStyle;\n        const position = this.m_currentParams!.position;\n\n        // Initialize line placement parameters.\n        const isRTL = direction === UnicodeUtils.Direction.RTL;\n        const origin = position.x;\n        let offset = 0;\n        let runStart = startIdx;\n\n        for (let i = startIdx; i <= endIdx; ++i) {\n            const glyphData = glyphDataArray[i];\n\n            // If the current glyph changes the line direction, place the current run.\n            if (glyphData.direction === -this.m_tempRunDirection) {\n                if (isRTL) {\n                    position.x = origin + offset;\n                }\n                if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {\n                    return false;\n                }\n                if (!isRTL) {\n                    position.x = origin + offset;\n                }\n\n                runStart = i;\n                this.m_tempRunDirection *= -1.0;\n            }\n            // If the current glyph has neutral direction (i.e. white space) and we're in the middle\n            // of a run with direction opposite to the line's main direction, check for the closest\n            // strong direction in the run.\n            else if (\n                glyphData.direction === UnicodeUtils.Direction.Neutral &&\n                this.m_tempRunDirection === -direction\n            ) {\n                let neutralIdx = i;\n                while (\n                    neutralIdx + 1 < glyphDataArray.length &&\n                    Math.abs(glyphDataArray[neutralIdx].direction) !== 1\n                ) {\n                    ++neutralIdx;\n                }\n\n                // If the closest strong direction in the run is not the current run's direction,\n                // place the current run.\n                if (glyphDataArray[neutralIdx].direction !== this.m_tempRunDirection) {\n                    if (isRTL) {\n                        position.x = origin + offset;\n                    }\n                    if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {\n                        return false;\n                    }\n                    if (!isRTL) {\n                        position.x = origin + offset;\n                    }\n\n                    runStart = i;\n                    this.m_tempRunDirection *= -1.0;\n                }\n            }\n\n            // Advance the offset position in the line.\n            offset +=\n                (glyphData.advanceX + textLayoutStyle.tracking) *\n                this.m_tempScale *\n                (this.m_tempSmallCaps\n                    ? TypesettingUtils.getSmallCapsScale(\n                          glyphDataArray,\n                          smallCapsArray!,\n                          i,\n                          textRenderStyle.fontVariant\n                      )\n                    : 1.0) *\n                direction;\n        }\n\n        // If we still haven't placed all characters in the line, place a final run.\n        if (runStart <= endIdx) {\n            if (isRTL) {\n                position.x = origin + offset;\n            }\n            if (!this.placeRun(runStart, endIdx, this.m_tempRunDirection)) {\n                return false;\n            }\n            if (!isRTL) {\n                position.x = origin + offset;\n            }\n        }\n\n        return true;\n    }\n\n    // Place a directional run of index inside a line.\n    private placeRun(startIdx: number, endIdx: number, direction: UnicodeUtils.Direction): boolean {\n        // Gather common typesetting parameters.\n        const glyphDataArray = this.m_currentParams!.glyphs;\n        const smallCapsArray = this.m_currentParams!.smallCapsArray;\n        const fontCatalog = this.m_currentParams!.fontCatalog;\n        const textRenderStyle = this.m_currentParams!.textRenderStyle;\n        const textLayoutStyle = this.m_currentParams!.textLayoutStyle;\n        const position = this.m_currentParams!.position;\n        const geometry = this.m_currentParams!.geometry;\n        const globalBounds = this.m_currentParams!.globalBounds;\n        const individualBounds = this.m_currentParams!.individualBounds;\n        const vertexBuffer = this.m_currentParams!.vertexBuffer;\n\n        // Move through the glyph array following the run's direction (as the order of the glyphs in\n        // memory might not match the order on glyphs on scree).\n        const start = direction === UnicodeUtils.Direction.LTR ? startIdx : endIdx;\n        const end = direction === UnicodeUtils.Direction.LTR ? endIdx : startIdx;\n        for (\n            let i = start;\n            direction === UnicodeUtils.Direction.RTL ? i >= end : i <= end;\n            i += direction\n        ) {\n            // Only process printable characters.\n            const glyphData = glyphDataArray[i];\n            if (!UnicodeUtils.isPrintable(glyphData.codePoint)) {\n                continue;\n            }\n\n            // When placing a RTL run, we need to check for weak runs (numerical runs of characters\n            // that don't change the overall run direction, but should always be displayed as LTR\n            // text).\n            if (\n                startIdx !== endIdx &&\n                i !== 0 &&\n                direction === UnicodeUtils.Direction.RTL &&\n                glyphData.direction === UnicodeUtils.Direction.Weak\n            ) {\n                let weakRunStart = i;\n                let weakGlyph = glyphDataArray[weakRunStart - 1];\n                while (\n                    weakRunStart !== startIdx &&\n                    (weakGlyph.direction === UnicodeUtils.Direction.Weak ||\n                        (weakGlyph.direction === UnicodeUtils.Direction.Neutral &&\n                            !UnicodeUtils.isWhiteSpace(weakGlyph.codePoint)))\n                ) {\n                    --weakRunStart;\n                    weakGlyph = glyphDataArray[weakRunStart - 1];\n                }\n\n                this.placeRun(Math.max(weakRunStart, startIdx), i, UnicodeUtils.Direction.LTR);\n\n                i = weakRunStart;\n                continue;\n            }\n\n            // Compute various rendering parameters for this glyph.\n            const glyphFont = glyphData.font;\n            const glyphFontMetrics = glyphFont.metrics;\n            const fontStyle = textRenderStyle.fontStyle;\n\n            const isBoldEmulated =\n                (fontStyle === FontStyle.Bold && glyphFont.bold === undefined) ||\n                (fontStyle === FontStyle.BoldItalic &&\n                    glyphFont.bold === undefined &&\n                    glyphFont.boldItalic === undefined);\n            const isItalicEmulated =\n                (fontStyle === FontStyle.Italic && glyphFont.italic === undefined) ||\n                (fontStyle === FontStyle.BoldItalic &&\n                    glyphFont.italic === undefined &&\n                    glyphFont.boldItalic === undefined);\n\n            const isSmallCaps = this.m_tempSmallCaps\n                ? smallCapsArray![i] && textRenderStyle.fontVariant === FontVariant.SmallCaps\n                : false;\n            const smallCapsScale = isSmallCaps\n                ? glyphFontMetrics.xHeight / glyphFontMetrics.capHeight\n                : 1.0;\n            const glyphScale = this.m_tempScale * smallCapsScale;\n\n            const emulationWeight =\n                ((isBoldEmulated ? 0.02 : 0.0) + (isSmallCaps ? 0.01 : 0.0)) *\n                (fontCatalog.size / fontCatalog.distanceRange);\n            const bgWeight =\n                (0.5 * this.m_tempPixelBgSize!) /\n                (fontCatalog.distanceRange * Math.max(glyphScale, 1.0));\n            const isMirrored =\n                UnicodeUtils.isRtlMirrored(glyphData.codePoint) &&\n                direction === UnicodeUtils.Direction.RTL;\n            const verticalOffset =\n                glyphFontMetrics.lineHeight -\n                glyphFontMetrics.base -\n                glyphFontMetrics.distanceRange * 0.5;\n\n            // Compute the glyphs transformation matrix and apply to all corners of a glyph.\n            TypesettingUtils.computeGlyphTransform(\n                this.m_tempTransform,\n                position,\n                glyphScale,\n                textLayoutStyle.canvasRotation,\n                textRenderStyle.rotation\n            );\n            for (let j = 0; j < 4; ++j) {\n                const glyphVertexPosition = glyphData.positions[j];\n                const horizontalOffset =\n                    isItalicEmulated && j > 1\n                        ? TypesettingUtils.OBLIQUE_OFFSET * glyphFontMetrics.size\n                        : 0.0;\n                this.m_tempCorners[j].set(\n                    glyphVertexPosition.x + horizontalOffset,\n                    glyphVertexPosition.y - verticalOffset,\n                    glyphVertexPosition.z\n                );\n                this.m_tempCorners[j].applyMatrix3(this.m_tempTransform);\n            }\n\n            // Depending on the typesetting options, add the computed glyph to the TextGeometry or\n            // update the text bounds.\n            if (globalBounds === undefined && vertexBuffer === undefined) {\n                if (\n                    !geometry.add(\n                        glyphData,\n                        this.m_tempCorners,\n                        emulationWeight,\n                        emulationWeight + bgWeight,\n                        isMirrored,\n                        textRenderStyle\n                    )\n                ) {\n                    return false;\n                }\n            } else {\n                if (globalBounds !== undefined) {\n                    TypesettingUtils.updateBounds(\n                        this.m_tempCorners,\n                        globalBounds,\n                        individualBounds\n                    );\n                }\n                if (vertexBuffer !== undefined) {\n                    geometry.addToBuffer(\n                        vertexBuffer,\n                        i * QUAD_VERTEX_MEMORY_FOOTPRINT,\n                        glyphData,\n                        this.m_tempCorners,\n                        emulationWeight,\n                        emulationWeight + bgWeight,\n                        isMirrored,\n                        textRenderStyle\n                    );\n                }\n            }\n\n            // Advance the current position and proceed to next glyph in the run.\n            position.set(\n                position.x +\n                    (glyphData.advanceX + textLayoutStyle.tracking) *\n                        glyphScale *\n                        Math.cos(textLayoutStyle.lineRotation),\n                position.y +\n                    (glyphData.advanceX + textLayoutStyle.tracking) *\n                        glyphScale *\n                        Math.sin(textLayoutStyle.lineRotation),\n                position.z\n            );\n        }\n\n        return true;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { QUAD_VERTEX_MEMORY_FOOTPRINT } from \"../rendering/TextGeometry\";\nimport { FontStyle, FontVariant } from \"../rendering/TextStyle\";\nimport { TypesettingUtils } from \"../utils/TypesettingUtils\";\nimport { UnicodeUtils } from \"../utils/UnicodeUtils\";\nimport { Typesetter, TypesettingParameters } from \"./Typesetter\";\n\n/**\n * @hidden\n * Parameters passed when placing glyphs using [[PathTypesetter]]'s `arrangeGlyphs` function.\n */\nexport interface PathTypesettingParameters extends TypesettingParameters {\n    /**\n     * Path to be followed when arranging glyphs.\n     */\n    path: THREE.Path | THREE.CurvePath<THREE.Vector2>;\n\n    /**\n     * If `true`, text on a path will be placed even when its size its bigger than the path's size.\n     */\n    pathOverflow: boolean;\n}\n\n/**\n * [[Typesetter]] implementation that arranges glyphs alongside a specified path.\n */\nexport class PathTypesetter implements Typesetter {\n    private m_tempTransform: THREE.Matrix3;\n    private m_tempCorners: THREE.Vector3[];\n    private m_tempLineDirection: UnicodeUtils.Direction;\n    private m_tempRunDirection: UnicodeUtils.Direction;\n    private m_tempPixelSize: number;\n    private m_tempPixelBgSize: number;\n    private m_tempScale: number;\n    private m_tempSmallCaps: boolean;\n\n    private m_tempPathPosition: THREE.Vector3;\n    private m_tempPathLength: number;\n    private m_tempPathOffset: number;\n\n    private m_currentParams?: PathTypesettingParameters;\n\n    /**\n     * Creates a `PathTypesetter` object.\n     *\n     * @returns New `PathTypesetter`.\n     */\n    constructor() {\n        this.m_tempTransform = new THREE.Matrix3();\n        this.m_tempCorners = [\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3()\n        ];\n        this.m_tempLineDirection = UnicodeUtils.Direction.LTR;\n        this.m_tempRunDirection = UnicodeUtils.Direction.LTR;\n        this.m_tempPixelSize = 1.0;\n        this.m_tempPixelBgSize = 1.0;\n        this.m_tempScale = 1.0;\n        this.m_tempSmallCaps = false;\n\n        this.m_tempPathPosition = new THREE.Vector3();\n        this.m_tempPathLength = 0.0;\n        this.m_tempPathOffset = 0.0;\n    }\n\n    /**\n     * Arranges the specified glyphs using this `PathTypesetter`. Text will be placed into a single\n     * bidirectional line that follows the specified path. Characters will be orientated and placed\n     * alongside this path following [[TextLayout]]'s [[VerticalAlignment]] and\n     * [[HorizontalAlignment]].\n     *\n     * @param params - Typesetting parameters.\n     *\n     * @returns If `false`, some error occurred during execution and the output should be dismissed.\n     */\n    arrangeGlyphs(params: PathTypesettingParameters): boolean {\n        // Initializes common typesetting parameters (used across all functions in this class).\n        this.m_currentParams = params;\n        this.m_tempLineDirection = TypesettingUtils.getDirection(this.m_currentParams.glyphs, 0);\n        this.m_tempRunDirection = this.m_tempLineDirection;\n        this.m_tempPixelSize = TypesettingUtils.getPixelSize(\n            this.m_currentParams.textRenderStyle.fontSize.size,\n            this.m_currentParams.textRenderStyle.fontSize.unit,\n            this.m_currentParams.fontCatalog.size\n        );\n        this.m_tempScale = this.m_tempPixelSize / this.m_currentParams.fontCatalog.size;\n        this.m_tempPixelBgSize = Math.min(\n            TypesettingUtils.getPixelSize(\n                this.m_currentParams.textRenderStyle.fontSize.backgroundSize,\n                this.m_currentParams.textRenderStyle.fontSize.unit,\n                this.m_currentParams.fontCatalog.size\n            ),\n            this.m_currentParams!.fontCatalog.distanceRange * this.m_tempScale\n        );\n        this.m_tempSmallCaps = this.m_currentParams!.smallCapsArray !== undefined;\n\n        this.m_tempPathLength = this.m_currentParams.path.getLength();\n        this.m_tempPathOffset = 0.0;\n\n        const isOnlyMeasured =\n            this.m_currentParams.globalBounds !== undefined &&\n            this.m_currentParams.vertexBuffer === undefined;\n\n        // To be able to properly set the horizontal alignment on a path, we need to first retrieve\n        // how much of the path the input text covers, so we can calculate the correct initial\n        // offset.\n        let isBidirectional = false;\n        let pathWidth = 0.0;\n        for (let i = 0; i < this.m_currentParams.glyphs.length; ++i) {\n            const glyphData = this.m_currentParams.glyphs[i];\n            if (!glyphData.isInCache && !isOnlyMeasured) {\n                return false;\n            }\n\n            if (!UnicodeUtils.isPrintable(glyphData.codePoint)) {\n                continue;\n            }\n            if (!isBidirectional && glyphData.direction === -this.m_tempLineDirection) {\n                isBidirectional = true;\n            }\n\n            pathWidth +=\n                (glyphData.advanceX + this.m_currentParams.textLayoutStyle.tracking) *\n                this.m_tempScale *\n                (this.m_tempSmallCaps\n                    ? TypesettingUtils.getSmallCapsScale(\n                          this.m_currentParams.glyphs,\n                          this.m_currentParams.smallCapsArray!,\n                          i,\n                          this.m_currentParams.textRenderStyle.fontVariant\n                      )\n                    : 1.0);\n        }\n        this.m_tempPathOffset = Math.min(\n            Math.max(\n                -this.m_currentParams.textLayoutStyle.horizontalAlignment +\n                    (this.m_currentParams.textLayoutStyle.horizontalAlignment * pathWidth) /\n                        this.m_tempPathLength,\n                0\n            ),\n            1\n        );\n\n        // Place the input text as a single path line.\n        return this.placeLine(this.m_tempLineDirection, isBidirectional);\n    }\n\n    // Place characters alongside a path line. Text direction is taken into account, and text is\n    // broken into directional runs.\n    private placeLine(direction: UnicodeUtils.Direction, isBidirectional: boolean): boolean {\n        // If the line is not bidirectional, place it as a single directional run.\n        if (!isBidirectional) {\n            return this.placeRun(0, this.m_currentParams!.glyphs.length - 1, direction);\n        }\n\n        // Gather common typesetting parameters.\n        const glyphDataArray = this.m_currentParams!.glyphs;\n\n        // Initialize line placement parameters.\n        let runStart = 0;\n        for (let i = runStart; i < glyphDataArray.length; ++i) {\n            const glyphData = glyphDataArray[i];\n\n            // If the current glyph changes the line direction, place the current run.\n            if (glyphData.direction === -this.m_tempRunDirection) {\n                if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {\n                    return false;\n                }\n\n                runStart = i;\n                this.m_tempRunDirection *= -1.0;\n            }\n            // If the current glyph has neutral direction (i.e. white space) and we're in the middle\n            // of a run with direction opposite to the line's main direction, check for the closest\n            // strong direction in the run.\n            else if (\n                glyphData.direction === UnicodeUtils.Direction.Neutral &&\n                this.m_tempRunDirection === -direction\n            ) {\n                let neutralIdx = i;\n                while (\n                    neutralIdx + 1 < glyphDataArray.length &&\n                    Math.abs(glyphDataArray[neutralIdx].direction) !== 1\n                ) {\n                    ++neutralIdx;\n                }\n\n                // If the closest strong direction in the run is not the current run's direction,\n                // place the current run.\n                if (glyphDataArray[neutralIdx].direction !== this.m_tempRunDirection) {\n                    if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {\n                        return false;\n                    }\n\n                    runStart = i;\n                    this.m_tempRunDirection *= -1.0;\n                }\n            }\n        }\n\n        // If we still haven't placed all characters in the line, place a final run.\n        if (runStart < glyphDataArray.length) {\n            if (!this.placeRun(runStart, glyphDataArray.length - 1, this.m_tempRunDirection)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    // Place a directional run of index inside a path line.\n    private placeRun(startIdx: number, endIdx: number, direction: UnicodeUtils.Direction): boolean {\n        // Gather common typesetting parameters.\n        const glyphDataArray = this.m_currentParams!.glyphs;\n        const smallCapsArray = this.m_currentParams!.smallCapsArray;\n        const fontCatalog = this.m_currentParams!.fontCatalog;\n        const textRenderStyle = this.m_currentParams!.textRenderStyle;\n        const textLayoutStyle = this.m_currentParams!.textLayoutStyle;\n        const position = this.m_currentParams!.position;\n        const geometry = this.m_currentParams!.geometry;\n        const globalBounds = this.m_currentParams!.globalBounds;\n        const individualBounds = this.m_currentParams!.individualBounds;\n        const vertexBuffer = this.m_currentParams!.vertexBuffer;\n        const path = this.m_currentParams!.path;\n\n        const defaultGlyphRotation = textRenderStyle.rotation;\n        const normalDisplacement =\n            textLayoutStyle.verticalAlignment *\n            glyphDataArray[0].font.metrics.capHeight *\n            this.m_tempScale;\n\n        // Move through the glyph array following the run's direction (as the order of the glyphs in\n        // memory might not match the order on glyphs on scree).\n        const start = direction === UnicodeUtils.Direction.LTR ? startIdx : endIdx;\n        const end = direction === UnicodeUtils.Direction.LTR ? endIdx : startIdx;\n        for (\n            let i = start;\n            direction === UnicodeUtils.Direction.RTL ? i >= end : i <= end;\n            i += direction\n        ) {\n            // Only process printable characters.\n            const glyphData = glyphDataArray[i];\n            if (!UnicodeUtils.isPrintable(glyphData.codePoint)) {\n                continue;\n            }\n\n            // When placing a RTL run, we need to check for weak runs (numerical runs of characters\n            // that don't change the overall run direction, but should always be displayed as LTR\n            // text).\n            if (\n                startIdx !== endIdx &&\n                i !== 0 &&\n                direction === UnicodeUtils.Direction.RTL &&\n                glyphData.direction === UnicodeUtils.Direction.Weak\n            ) {\n                let weakRunStart = i;\n                let weakGlyph = glyphDataArray[weakRunStart - 1];\n                while (\n                    weakRunStart !== startIdx &&\n                    (weakGlyph.direction === UnicodeUtils.Direction.Weak ||\n                        (weakGlyph.direction === UnicodeUtils.Direction.Neutral &&\n                            !UnicodeUtils.isWhiteSpace(weakGlyph.codePoint)))\n                ) {\n                    --weakRunStart;\n                    weakGlyph = glyphDataArray[weakRunStart - 1];\n                }\n\n                this.placeRun(Math.max(weakRunStart, startIdx), i, UnicodeUtils.Direction.LTR);\n\n                i = weakRunStart;\n                continue;\n            }\n\n            // Compute various rendering parameters for this glyph.\n            const glyphFont = glyphData.font;\n            const glyphFontMetrics = glyphFont.metrics;\n            const fontStyle = textRenderStyle.fontStyle;\n\n            const isBoldEmulated =\n                (fontStyle === FontStyle.Bold && glyphFont.bold === undefined) ||\n                (fontStyle === FontStyle.BoldItalic &&\n                    glyphFont.bold === undefined &&\n                    glyphFont.boldItalic === undefined);\n            const isItalicEmulated =\n                (fontStyle === FontStyle.Italic && glyphFont.italic === undefined) ||\n                (fontStyle === FontStyle.BoldItalic &&\n                    glyphFont.italic === undefined &&\n                    glyphFont.boldItalic === undefined);\n\n            const isSmallCaps = this.m_tempSmallCaps\n                ? smallCapsArray![i] && textRenderStyle.fontVariant === FontVariant.SmallCaps\n                : false;\n            const smallCapsScale = isSmallCaps\n                ? glyphFontMetrics.xHeight / glyphFontMetrics.capHeight\n                : 1.0;\n            const glyphScale = this.m_tempScale * smallCapsScale;\n\n            const emulationWeight =\n                ((isBoldEmulated ? 0.02 : 0.0) + (isSmallCaps ? 0.01 : 0.0)) *\n                (fontCatalog.size / fontCatalog.distanceRange);\n            const bgWeight =\n                (0.5 * this.m_tempPixelBgSize!) /\n                (fontCatalog.distanceRange * Math.max(glyphScale, 1.0));\n            const isMirrored =\n                UnicodeUtils.isRtlMirrored(glyphData.codePoint) &&\n                direction === UnicodeUtils.Direction.RTL;\n\n            const verticalOffset =\n                glyphFontMetrics.lineHeight -\n                glyphFontMetrics.base -\n                glyphFontMetrics.distanceRange * 0.5;\n\n            // Update the current interpolated path position and angle.\n            const textPoint = path.getPoint(this.m_tempPathOffset);\n            if (textPoint === null) {\n                return this.m_currentParams!.pathOverflow;\n            }\n            const tangent = path.getTangent(this.m_tempPathOffset);\n            const normal = new THREE.Vector2(-tangent.y, tangent.x).multiplyScalar(\n                normalDisplacement\n            );\n            const angle = Math.atan2(tangent.y, tangent.x);\n            this.m_tempPathPosition.set(normal.x + textPoint.x, normal.y + textPoint.y, position.z);\n            textRenderStyle.rotation = defaultGlyphRotation + angle;\n\n            // Compute the glyphs transformation matrix and apply to all corners of a glyph.\n            TypesettingUtils.computeGlyphTransform(\n                this.m_tempTransform,\n                this.m_tempPathPosition,\n                glyphScale,\n                0.0,\n                textRenderStyle.rotation\n            );\n            for (let j = 0; j < 4; ++j) {\n                const glyphVertexPosition = glyphData.positions[j];\n                const horizontalOffset =\n                    isItalicEmulated && j > 1\n                        ? TypesettingUtils.OBLIQUE_OFFSET * glyphFontMetrics.size\n                        : 0.0;\n                this.m_tempCorners[j].set(\n                    glyphVertexPosition.x + horizontalOffset,\n                    glyphVertexPosition.y - verticalOffset,\n                    glyphVertexPosition.z\n                );\n                this.m_tempCorners[j].applyMatrix3(this.m_tempTransform);\n\n                this.m_tempCorners[j].x -= position.x;\n                this.m_tempCorners[j].y -= position.y;\n            }\n\n            // Depending on the typesetting options, add the computed glyph to the TextGeometry or\n            // update the text bounds.\n            if (globalBounds === undefined && vertexBuffer === undefined) {\n                if (\n                    !geometry.add(\n                        glyphData,\n                        this.m_tempCorners,\n                        emulationWeight,\n                        emulationWeight + bgWeight,\n                        isMirrored,\n                        textRenderStyle\n                    )\n                ) {\n                    return false;\n                }\n            } else {\n                if (globalBounds !== undefined) {\n                    TypesettingUtils.updateBounds(\n                        this.m_tempCorners,\n                        globalBounds,\n                        individualBounds\n                    );\n                }\n                if (vertexBuffer !== undefined) {\n                    geometry.addToBuffer(\n                        vertexBuffer,\n                        i * QUAD_VERTEX_MEMORY_FOOTPRINT,\n                        glyphData,\n                        this.m_tempCorners,\n                        emulationWeight,\n                        emulationWeight + bgWeight,\n                        isMirrored,\n                        textRenderStyle\n                    );\n                }\n            }\n\n            // Restore the original glyph rotation.\n            textRenderStyle.rotation = defaultGlyphRotation;\n\n            // Advance the current position and proceed to next glyph in the run.\n            this.m_tempPathOffset +=\n                ((glyphData.advanceX + textLayoutStyle.tracking) * glyphScale) /\n                this.m_tempPathLength;\n        }\n\n        return true;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nenum ContextualForm {\n    Initial,\n    Medial,\n    Final\n}\n\nenum CombinedForm {\n    Isolated,\n    Connected\n}\n\n/**\n * Converter between arabic isolated forms (in Unicode Block 'Arabic') and their contextual forms\n * (in Unicode Block 'Arabic Presentation Forms-B').\n */\nexport class ContextualArabicConverter {\n    private static m_instance: ContextualArabicConverter;\n    static get instance(): ContextualArabicConverter {\n        if (this.m_instance === undefined) {\n            this.m_instance = new ContextualArabicConverter();\n        }\n        return this.m_instance;\n    }\n\n    private m_singleCharactersMap: Map<number, ReadonlyArray<number | undefined>> = new Map();\n    private m_combinedCharactersMap: Map<\n        number,\n        Map<number, ReadonlyArray<number | undefined>>\n    > = new Map();\n    private m_neutralCharacters: number[];\n\n    private constructor() {\n        // Single characters.\n        this.m_singleCharactersMap.set(0x0621, [undefined, undefined, undefined]); // HAMZA\n        this.m_singleCharactersMap.set(0x0622, [undefined, undefined, 0xfe82]); // ALEF_MADDA\n        this.m_singleCharactersMap.set(0x0623, [undefined, undefined, 0xfe84]); // ALEF_HAMZA_ABOVE\n        this.m_singleCharactersMap.set(0x0624, [undefined, undefined, 0xfe86]); // WAW_HAMZA\n        this.m_singleCharactersMap.set(0x0625, [undefined, undefined, 0xfe88]); // ALEF_HAMZA_BELOW\n        this.m_singleCharactersMap.set(0x0626, [0xfe8b, 0xfe8c, 0xfe8a]); // YEH_HAMZA\n        this.m_singleCharactersMap.set(0x0627, [undefined, undefined, 0xfe8e]); // ALEF\n        this.m_singleCharactersMap.set(0x0628, [0xfe91, 0xfe92, 0xfe90]); // BEH\n        this.m_singleCharactersMap.set(0x0629, [undefined, undefined, 0xfe94]); // TEH_MARBUTA\n        this.m_singleCharactersMap.set(0x062a, [0xfe97, 0xfe98, 0xfe96]); // TEH\n        this.m_singleCharactersMap.set(0x062b, [0xfe9b, 0xfe9c, 0xfe9a]); // THEH\n        this.m_singleCharactersMap.set(0x062c, [0xfe9f, 0xfea0, 0xfe9e]); // JEEM\n        this.m_singleCharactersMap.set(0x062d, [0xfea3, 0xfea4, 0xfea2]); // HAH\n        this.m_singleCharactersMap.set(0x062e, [0xfea7, 0xfea8, 0xfea6]); // KHAH\n        this.m_singleCharactersMap.set(0x062f, [undefined, undefined, 0xfeaa]); // DAL\n        this.m_singleCharactersMap.set(0x0630, [undefined, undefined, 0xfeac]); // THAL\n        this.m_singleCharactersMap.set(0x0631, [undefined, undefined, 0xfeae]); // REH\n        this.m_singleCharactersMap.set(0x0632, [undefined, undefined, 0xfeb0]); // ZAIN\n        this.m_singleCharactersMap.set(0x0633, [0xfeb3, 0xfeb4, 0xfeb2]); // SEEN\n        this.m_singleCharactersMap.set(0x0634, [0xfeb7, 0xfeb8, 0xfeb6]); // SHEEN\n        this.m_singleCharactersMap.set(0x0635, [0xfebb, 0xfebc, 0xfeba]); // SAD\n        this.m_singleCharactersMap.set(0x0636, [0xfebf, 0xfec0, 0xfebe]); // DAD\n        this.m_singleCharactersMap.set(0x0637, [0xfec3, 0xfec4, 0xfec2]); // TAH\n        this.m_singleCharactersMap.set(0x0638, [0xfec7, 0xfec8, 0xfec6]); // ZAH\n        this.m_singleCharactersMap.set(0x0639, [0xfecb, 0xfecc, 0xfeca]); // AIN\n        this.m_singleCharactersMap.set(0x063a, [0xfecf, 0xfed0, 0xfece]); // GHAIN\n        this.m_singleCharactersMap.set(0x0640, [0x0640, 0x0640, 0x0640]); // TATWEEL\n        this.m_singleCharactersMap.set(0x0641, [0xfed3, 0xfed4, 0xfed2]); // FEH\n        this.m_singleCharactersMap.set(0x0642, [0xfed7, 0xfed8, 0xfed6]); // QAF\n        this.m_singleCharactersMap.set(0x0643, [0xfedb, 0xfedc, 0xfeda]); // KAF\n        this.m_singleCharactersMap.set(0x0644, [0xfedf, 0xfee0, 0xfede]); // LAM\n        this.m_singleCharactersMap.set(0x0645, [0xfee3, 0xfee4, 0xfee2]); // MEEM\n        this.m_singleCharactersMap.set(0x0646, [0xfee7, 0xfee8, 0xfee6]); // NOON\n        this.m_singleCharactersMap.set(0x0647, [0xfeeb, 0xfeec, 0xfeea]); // HEH\n        this.m_singleCharactersMap.set(0x0648, [undefined, undefined, 0xfeee]); // WAW\n        this.m_singleCharactersMap.set(0x0649, [undefined, undefined, 0xfef0]); // ALEF_MAKSURA\n        this.m_singleCharactersMap.set(0x064a, [0xfef3, 0xfef4, 0xfef2]); // YEH\n        this.m_singleCharactersMap.set(0x067e, [0xfb58, 0xfb59, 0xfb57]); // PEH\n        this.m_singleCharactersMap.set(0x06cc, [0xfbfe, 0xfbff, 0xfbfd]); // Farsi Yeh\n        this.m_singleCharactersMap.set(0x0686, [0xfb7c, 0xfb7d, 0xfb7b]); // Tcheh\n        this.m_singleCharactersMap.set(0x06a9, [0xfb90, 0xfb91, 0xfb8f]); // Keheh\n        this.m_singleCharactersMap.set(0x06af, [0xfb94, 0xfb95, 0xfb93]); // Gaf\n        this.m_singleCharactersMap.set(0x0698, [undefined, undefined, 0xfb8b]); // Jeh\n\n        // Combined characters.\n        this.m_combinedCharactersMap.set(0x0644, new Map());\n        // LAM_ALEF_MADDA\n        this.m_combinedCharactersMap.get(0x0644)!.set(0x0622, [0xfef5, 0xfef6]);\n        // LAM_ALEF_HAMZA_ABOVE\n        this.m_combinedCharactersMap.get(0x0644)!.set(0x0623, [0xfef7, 0xfef8]);\n        // LAM_ALEF_HAMZA_BELOW\n        this.m_combinedCharactersMap.get(0x0644)!.set(0x0625, [0xfef9, 0xfefa]);\n        // LAM_ALEF\n        this.m_combinedCharactersMap.get(0x0644)!.set(0x0627, [0xfefb, 0xfefc]);\n\n        // Neutral characters.\n        this.m_neutralCharacters = [\n            0x0610, // ARABIC SIGN SALLALLAHOU ALAYHE WASSALLAM\n            0x0612, // ARABIC SIGN ALAYHE ASSALLAM\n            0x0613, // ARABIC SIGN RADI ALLAHOU ANHU\n            0x0614, // ARABIC SIGN TAKHALLUS\n            0x0615, // ARABIC SMALL HIGH TAH\n            0x064b, // ARABIC FATHATAN\n            0x064c, // ARABIC DAMMATAN\n            0x064d, // ARABIC KASRATAN\n            0x064e, // ARABIC FATHA\n            0x064f, // ARABIC DAMMA\n            0x0650, // ARABIC KASRA\n            0x0651, // ARABIC SHADDA\n            0x0652, // ARABIC SUKUN\n            0x0653, // ARABIC MADDAH ABOVE\n            0x0654, // ARABIC HAMZA ABOVE\n            0x0655, // ARABIC HAMZA BELOW\n            0x0656, // ARABIC SUBSCRIPT ALEF\n            0x0657, // ARABIC INVERTED DAMMA\n            0x0658, // ARABIC MARK NOON GHUNNA\n            0x0670, // ARABIC LETTER SUPERSCRIPT ALEF\n            0x06d6, // ARABIC SMALL HIGH LIGATURE SAD WITH LAM WITH ALEF MAKSURA\n            0x06d7, // ARABIC SMALL HIGH LIGATURE QAF WITH LAM WITH ALEF MAKSURA\n            0x06d8, // ARABIC SMALL HIGH MEEM INITIAL FORM\n            0x06d9, // ARABIC SMALL HIGH LAM ALEF\n            0x06da, // ARABIC SMALL HIGH JEEM\n            0x06db, // ARABIC SMALL HIGH THREE DOTS\n            0x06dc, // ARABIC SMALL HIGH SEEN\n            0x06df, // ARABIC SMALL HIGH ROUNDED ZERO\n            0x06e0, // ARABIC SMALL HIGH UPRIGHT RECTANGULAR ZERO\n            0x06e1, // ARABIC SMALL HIGH DOTLESS HEAD OF KHAH\n            0x06e2, // ARABIC SMALL HIGH MEEM ISOLATED FORM\n            0x06e3, // ARABIC SMALL LOW SEEN\n            0x06e4, // ARABIC SMALL HIGH MADDA\n            0x06e7, // ARABIC SMALL HIGH YEH\n            0x06e8, // ARABIC SMALL HIGH NOON\n            0x06ea, // ARABIC EMPTY CENTRE LOW STOP\n            0x06eb, // ARABIC EMPTY CENTRE HIGH STOP\n            0x06ec, // ARABIC ROUNDED HIGH STOP WITH FILLED CENTRE\n            0x06ed // ARABIC SMALL LOW MEEM\n        ];\n    }\n\n    /**\n     * Converts isolated arabic characters into their contextual form.\n     *\n     * @param input - String with isolated arabic characters.\n     */\n    convert(input: string): string {\n        let output = \"\";\n        for (let i = 0; i < input.length; ++i) {\n            const currentCodePoint = input.charCodeAt(i);\n\n            // Only process arabic characters in the map.\n            if (this.isArabicCharacter(currentCodePoint)) {\n                // Find the first previous non-neutral character.\n                let prevIndex = i - 1;\n                for (; prevIndex >= 0; --prevIndex) {\n                    if (!this.isNeutral(input.charCodeAt(prevIndex))) {\n                        break;\n                    }\n                }\n\n                // Check if the previous character has ligatures with following characters.\n                let prevCodePoint = prevIndex >= 0 ? input.charCodeAt(prevIndex) : undefined;\n                if (prevCodePoint !== undefined) {\n                    const prevMap = this.getCharacterMap(prevCodePoint);\n                    if (\n                        prevMap === undefined ||\n                        (prevMap[ContextualForm.Initial] === undefined &&\n                            prevMap[ContextualForm.Medial] === undefined)\n                    ) {\n                        prevCodePoint = undefined;\n                    }\n                }\n\n                // Find the first next non-neutral character.\n                let nextIndex = i + 1;\n                for (; nextIndex < input.length; ++nextIndex) {\n                    if (!this.isNeutral(input.charCodeAt(nextIndex))) {\n                        break;\n                    }\n                }\n\n                // Check if the next character has ligatures with previous characters.\n                let nextCodePoint =\n                    nextIndex < input.length ? input.charCodeAt(nextIndex) : undefined;\n                if (nextCodePoint !== undefined) {\n                    const nextMap = this.getCharacterMap(nextCodePoint);\n                    if (\n                        nextMap === undefined ||\n                        (nextMap[ContextualForm.Medial] === undefined &&\n                            nextMap[ContextualForm.Final] === undefined)\n                    ) {\n                        nextCodePoint = undefined;\n                    }\n                }\n\n                // Check for Lam Alef combinated forms.\n                if (\n                    currentCodePoint === 0x0644 &&\n                    nextCodePoint !== undefined &&\n                    (nextCodePoint === 0x0622 ||\n                        nextCodePoint === 0x0623 ||\n                        nextCodePoint === 0x0625 ||\n                        nextCodePoint === 0x0627)\n                ) {\n                    const combinedMap = this.getCombinedCharacterMap(\n                        currentCodePoint,\n                        nextCodePoint\n                    )!;\n                    if (prevCodePoint !== undefined) {\n                        output += String.fromCharCode(combinedMap[CombinedForm.Connected]!);\n                    } else {\n                        output += String.fromCharCode(combinedMap[CombinedForm.Isolated]!);\n                    }\n\n                    // Skip the next character and continue.\n                    ++i;\n                    continue;\n                }\n\n                // Check for single character contextual forms.\n                const map = this.getCharacterMap(currentCodePoint)!;\n                // Intermediate.\n                if (\n                    prevCodePoint !== undefined &&\n                    nextCodePoint !== undefined &&\n                    map[ContextualForm.Medial] !== undefined\n                ) {\n                    output += String.fromCharCode(map[ContextualForm.Medial]!);\n                }\n                // Final.\n                else if (prevCodePoint !== undefined && map[ContextualForm.Final] !== undefined) {\n                    output += String.fromCharCode(map[ContextualForm.Final]!);\n                }\n                // Initial.\n                else if (nextCodePoint !== undefined && map[ContextualForm.Initial] !== undefined) {\n                    output += String.fromCharCode(map[ContextualForm.Initial]!);\n                }\n                // Isolated.\n                else {\n                    output += String.fromCharCode(currentCodePoint);\n                }\n            } else {\n                output += String.fromCharCode(currentCodePoint);\n            }\n        }\n\n        return output;\n    }\n\n    private isArabicCharacter(codePoint: number): boolean {\n        return this.m_singleCharactersMap.has(codePoint);\n    }\n\n    private getCharacterMap(codePoint: number): ReadonlyArray<number | undefined> | undefined {\n        return this.m_singleCharactersMap.get(codePoint);\n    }\n\n    private getCombinedCharacterMap(\n        codePoint: number,\n        nextCodePoint: number\n    ): ReadonlyArray<number | undefined> | undefined {\n        const map = this.m_combinedCharactersMap.get(codePoint);\n        if (map !== undefined) {\n            return map.get(nextCodePoint);\n        }\n        return undefined;\n    }\n\n    private isNeutral(codePoint: number): boolean {\n        for (const character of this.m_neutralCharacters) {\n            if (character === codePoint) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { PriorityListGroup } from \"@here/harp-utils\";\nimport { TextElement } from \"./TextElement\";\n\n/**\n * Group of {@link TextElement} sharing same priority.\n */\nexport class TextElementGroup extends PriorityListGroup<TextElement> {}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GroupedPriorityList } from \"@here/harp-utils\";\nimport { TextElement } from \"./TextElement\";\n\n/**\n * List of {@link TextElement} groups sorted by priority.\n */\nexport class TextElementGroupPriorityList extends GroupedPriorityList<TextElement> {}\n","/*\n * Copyright (C) 2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    IndexedTechniqueParams,\n    LineMarkerTechnique,\n    PoiTechnique,\n    TextTechnique\n} from \"@here/harp-datasource-protocol\";\nimport { TextLayoutStyle, TextRenderStyle } from \"@here/harp-text-canvas\";\nimport { Tile } from \"../Tile\";\n\nexport class TileTextStyleCache {\n    private textRenderStyles: TextRenderStyle[] = [];\n    private textLayoutStyles: TextLayoutStyle[] = [];\n    private tile: Tile;\n\n    constructor(tile: Tile) {\n        this.tile = tile;\n    }\n\n    clear() {\n        this.textRenderStyles.length = 0;\n        this.textLayoutStyles.length = 0;\n    }\n\n    getRenderStyle(\n        technique: (TextTechnique | PoiTechnique | LineMarkerTechnique) & IndexedTechniqueParams\n    ): TextRenderStyle {\n        let style = this.textRenderStyles[technique._index];\n        if (style === undefined) {\n            style = this.textRenderStyles[\n                technique._index\n            ] = this.tile.mapView.textElementsRenderer.styleCache.createRenderStyle(\n                this.tile,\n                technique\n            );\n        }\n        return style;\n    }\n\n    getLayoutStyle(\n        technique: (TextTechnique | PoiTechnique | LineMarkerTechnique) & IndexedTechniqueParams\n    ): TextLayoutStyle {\n        let style = this.textLayoutStyles[technique._index];\n        if (style === undefined) {\n            style = this.textLayoutStyles[\n                technique._index\n            ] = this.tile.mapView.textElementsRenderer.styleCache.createLayoutStyle(\n                this.tile,\n                technique\n            );\n        }\n        return style;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport * as THREE from \"three\";\n\nimport {\n    IBloomEffect,\n    IOutlineEffect,\n    ISepiaEffect,\n    IVignetteEffect\n} from \"@here/harp-datasource-protocol\";\nimport { SepiaShader, VignetteShader } from \"@here/harp-materials\";\nimport { IPassManager } from \"./IPassManager\";\nimport { LowResRenderPass } from \"./LowResRenderPass\";\nimport { MSAARenderPass, MSAASampling } from \"./MSAARenderPass\";\nimport { OutlineEffect } from \"./Outline\";\nimport { RenderPass, ShaderPass } from \"./Pass\";\nimport { BloomPass } from \"./UnrealBloomPass\";\n\nconst DEFAULT_DYNAMIC_MSAA_SAMPLING_LEVEL = MSAASampling.Level_1;\nconst DEFAULT_STATIC_MSAA_SAMPLING_LEVEL = MSAASampling.Level_4;\n\n/**\n * Interface for the antialias settings passed when instantiating\n * a {@link MapView}, and transferred to\n * the {@link MapRenderingManager} instance.\n *\n * @remarks\n * These parameters can be changed at runtime as opposed to\n * the native WebGL antialiasing.\n */\nexport interface IMapAntialiasSettings {\n    /**\n     * Whether the MSAA is enabled or not.\n     *\n     * @default `false`\n     */\n    msaaEnabled: boolean;\n\n    /**\n     * The sampling level to use for MSAA during continuous rendering.\n     *\n     * @default `MSAASampling.Level_1`\n     */\n    dynamicMsaaSamplingLevel?: MSAASampling;\n\n    /**\n     * The sampling level to use for MSAA when the rendering stops.\n     *\n     * @default `MSAASampling.Level_4`\n     */\n    staticMsaaSamplingLevel?: MSAASampling;\n}\n\n/**\n * The `MapRenderingManager` class manages the map rendering (as opposed to text) by dispatching the\n * {@link MapRenderingManager.render} call to a set of internal {@link Pass} instances.\n *\n * @remarks It provides an API to modify some of the rendering\n * processes like the antialiasing behaviour at runtime.\n */\nexport interface IMapRenderingManager extends IPassManager {\n    /**\n     * Bloom effect parameters.\n     */\n    bloom: IBloomEffect;\n\n    /**\n     * Outline effect parameters.\n     */\n    outline: IOutlineEffect;\n\n    /**\n     * Vignette effect parameters.\n     */\n    vignette: IVignetteEffect;\n\n    /**\n     * Sepia effect parameters.\n     */\n    sepia: ISepiaEffect;\n\n    /**\n     * Set a `pixelRatio` for dynamic rendering (i.e. during animations). If a value is specified,\n     * the `LowResRenderPass` will be employed to used to render the scene into a lower resolution\n     * render target, which will then be rendered to the screen.\n     */\n    lowResPixelRatio?: number;\n\n    /**\n     * The level of MSAA sampling while the user interacts. It should be a low level so that the\n     * MSAA does not impact the framerate.\n     */\n    dynamicMsaaSamplingLevel: MSAASampling;\n\n    /**\n     * Enable or disable the MSAA. If disabled, `MapRenderingManager` will use the renderer provided\n     * in the {@link MapRenderingManager.render} method to render the scene.\n     */\n    msaaEnabled: boolean;\n\n    /**\n     * The higher level of MSAA sampling for a last frame to render, when the camera is static. It\n     * can be a high level, providing high quality renders requiring few tens of seconds, since no\n     * frame is expected to immediately follow in the requestAnimationFrame. It is still limited by\n     * zooming, since zooming is not requestAnimationFrame-based and can lead to stuttering if the\n     * render time is too long, except on desktop Mac, where mouse interaction already implements\n     * some damping. Higher levels of sampling may lead to noticeable color banding, visible in\n     * areas with a slight color gradient, like large areas or the sky background.\n     */\n    staticMsaaSamplingLevel: MSAASampling;\n\n    /**\n     * The method to call to render the map. This method depends on an `isStaticFrame` boolean that\n     * notifies the pass manager to switch to a higher level render quality for the last frame.\n     *\n     * @param renderer - The ThreeJS WebGLRenderer instance to render the map with.\n     * @param isStaticFrame - Whether the frame to render is static or dynamic. Selects level of\n     * antialiasing.\n     * @param time - Optional time argument provided by the requestAnimationFrame, to pass to\n     * sub-passes.\n     */\n    render(\n        renderer: THREE.WebGLRenderer,\n        scene: THREE.Scene,\n        camera: THREE.PerspectiveCamera | THREE.OrthographicCamera,\n        isStaticFrame: boolean,\n        time?: number\n    ): void;\n\n    /**\n     * Updating the outline rebuilds the outline materials of every outlined mesh.\n     *\n     * @param options - outline options from the {@link @here/harp-datasource-protocol#Theme}.\n     */\n    updateOutline(options: {\n        thickness: number;\n        color: string;\n        ghostExtrudedPolygons: boolean;\n    }): void;\n}\n\n/**\n * The implementation of {@link IMapRenderingManager} to\n * instantiate in {@link MapView} and manage the map\n * rendering.\n */\nexport class MapRenderingManager implements IMapRenderingManager {\n    bloom = {\n        enabled: false,\n        strength: 1.5,\n        radius: 0.4,\n        threshold: 0.85\n    };\n    outline = {\n        enabled: false,\n        thickness: 0.005,\n        color: \"#000000\",\n        ghostExtrudedPolygons: false,\n        needsUpdate: false\n    };\n    vignette = {\n        enabled: false,\n        offset: 1.0,\n        darkness: 1.0\n    };\n    sepia = {\n        enabled: false,\n        amount: 0.5\n    };\n\n    private m_width: number = 1;\n    private m_height: number = 1;\n\n    private m_outlineEffect?: OutlineEffect;\n    private m_msaaPass: MSAARenderPass;\n    private m_renderPass: RenderPass = new RenderPass();\n    private m_target1: THREE.WebGLRenderTarget = new THREE.WebGLRenderTarget(1, 1);\n    private m_target2: THREE.WebGLRenderTarget = new THREE.WebGLRenderTarget(1, 1);\n    private m_bloomPass?: BloomPass;\n    private m_sepiaPass: ShaderPass = new ShaderPass(SepiaShader);\n    private m_vignettePass: ShaderPass = new ShaderPass(VignetteShader);\n    private m_readBuffer: THREE.WebGLRenderTarget;\n    private m_dynamicMsaaSamplingLevel: MSAASampling;\n    private m_staticMsaaSamplingLevel: MSAASampling;\n    private m_lowResPass: LowResRenderPass;\n\n    /**\n     * The constructor of `MapRenderingManager`.\n     *\n     * @param width - Width of the frame buffer.\n     * @param height - Height of the frame buffer.\n     * @param lowResPixelRatio - The `pixelRatio` determines the resolution of the internal\n     *  `WebGLRenderTarget`. Values between 0.5 and `window.devicePixelRatio` can be tried to give\n     * good results. A value of `undefined` disables the low res render pass. The value should not\n     * be larger than`window.devicePixelRatio`.\n     * @param antialiasSetting - The object defining the demeanor of MSAA.\n     */\n    constructor(\n        width: number,\n        height: number,\n        lowResPixelRatio: number | undefined,\n        antialiasSettings: IMapAntialiasSettings | undefined = { msaaEnabled: false }\n    ) {\n        this.m_readBuffer = new THREE.WebGLRenderTarget(width, height);\n        this.m_msaaPass = new MSAARenderPass();\n        this.m_msaaPass.enabled =\n            antialiasSettings !== undefined ? antialiasSettings.msaaEnabled === true : false;\n        this.m_dynamicMsaaSamplingLevel =\n            antialiasSettings.dynamicMsaaSamplingLevel === undefined\n                ? DEFAULT_DYNAMIC_MSAA_SAMPLING_LEVEL\n                : antialiasSettings.dynamicMsaaSamplingLevel;\n        this.m_staticMsaaSamplingLevel =\n            antialiasSettings.staticMsaaSamplingLevel === undefined\n                ? DEFAULT_STATIC_MSAA_SAMPLING_LEVEL\n                : antialiasSettings.staticMsaaSamplingLevel;\n        this.m_lowResPass = new LowResRenderPass(lowResPixelRatio);\n        this.m_lowResPass.enabled = lowResPixelRatio !== undefined;\n    }\n\n    updateOutline(options: { thickness: number; color: string; ghostExtrudedPolygons: boolean }) {\n        this.outline.color = options.color;\n        this.outline.thickness = options.thickness;\n        this.outline.ghostExtrudedPolygons = options.ghostExtrudedPolygons;\n        this.outline.needsUpdate = true;\n    }\n\n    /**\n     * The method to call to render the map with the `MapRenderingManager` instance. It contains the\n     * chain of sub-passes that can transfer the write and read buffers, and other sheer rendering\n     * conditions as disabling AA when a high DPI device is in use.\n     *\n     * @param renderer - The ThreeJS WebGLRenderer instance to render the map with.\n     * @param scene - The ThreeJS Scene instance containing the map objects to render.\n     * @param camera - The ThreeJS Camera instance to render the scene through.\n     * @param isStaticFrame - Whether the frame to render is static or dynamic. Selects level of\n     * antialiasing.\n     */\n    render(\n        renderer: THREE.WebGLRenderer,\n        scene: THREE.Scene,\n        camera: THREE.PerspectiveCamera | THREE.OrthographicCamera,\n        isStaticFrame: boolean\n    ) {\n        const target = null;\n        if (!isStaticFrame && this.m_lowResPass.pixelRatio !== undefined) {\n            // Not designed to be combined with our own MSAA\n            this.m_lowResPass.renderToScreen = true;\n            this.m_lowResPass.render(renderer, scene, camera, target, this.m_readBuffer);\n            return;\n        }\n\n        const usePostEffects =\n            this.bloom.enabled ||\n            this.outline.enabled ||\n            this.vignette.enabled ||\n            this.sepia.enabled;\n\n        let activeTarget: null | THREE.WebGLRenderTarget = null;\n\n        // 1. If the bloom is enabled, clear the depth.\n        if (this.bloom.enabled || this.vignette.enabled || this.sepia.enabled) {\n            renderer.setRenderTarget(this.m_target1);\n            renderer.clearDepth();\n        }\n\n        // 2. Render the map.\n\n        if (this.m_msaaPass.enabled) {\n            // Use a higher MSAA sampling level for static rendering.\n            this.m_msaaPass.samplingLevel = isStaticFrame\n                ? this.m_staticMsaaSamplingLevel\n                : this.m_dynamicMsaaSamplingLevel;\n            // MSAA is the only effect for the moment.\n            this.m_msaaPass.renderToScreen = !usePostEffects;\n            // Render to the specified target with the MSAA pass.\n            this.m_msaaPass.render(renderer, scene, camera, target, this.m_readBuffer);\n        } else {\n            if (this.bloom.enabled || this.vignette.enabled || this.sepia.enabled) {\n                activeTarget = this.m_target1;\n                this.m_renderPass.render(renderer, scene, camera, this.m_target1, null!);\n            } else if (!this.outline.enabled || (this.outline.enabled && !this.bloom.enabled)) {\n                renderer.render(scene, camera);\n            }\n        }\n\n        // 3. Apply effects\n        if (this.outline.enabled) {\n            if (this.m_outlineEffect === undefined) {\n                this.m_outlineEffect = new OutlineEffect(renderer);\n            }\n            if (this.outline.needsUpdate) {\n                this.m_outlineEffect.color = this.outline.color;\n                this.m_outlineEffect.thickness = this.outline.thickness;\n                this.m_outlineEffect.ghostExtrudedPolygons = this.outline.ghostExtrudedPolygons;\n                this.outline.needsUpdate = false;\n            }\n            const nextEffectEnabled =\n                this.bloom.enabled || this.vignette.enabled || this.sepia.enabled;\n            if (nextEffectEnabled) {\n                activeTarget = this.m_target1;\n            }\n            renderer.setRenderTarget(nextEffectEnabled ? activeTarget : null!);\n            this.m_outlineEffect.render(scene, camera);\n        }\n\n        if (this.bloom.enabled) {\n            if (this.m_bloomPass === undefined) {\n                this.m_bloomPass = new BloomPass(\n                    new THREE.Vector2(this.m_width, this.m_height),\n                    this.bloom.strength,\n                    this.bloom.radius,\n                    this.bloom.threshold\n                );\n            }\n            const nextEffectEnabled = this.vignette.enabled || this.sepia.enabled;\n            this.m_bloomPass.renderToScreen = !nextEffectEnabled;\n            this.m_bloomPass.radius = this.bloom.radius;\n            this.m_bloomPass.strength = this.bloom.strength;\n            this.m_bloomPass.threshold = this.bloom.threshold;\n            this.m_bloomPass.render(renderer, scene, camera, null!, activeTarget!);\n        } else if (this.m_bloomPass !== undefined) {\n            this.m_bloomPass.dispose();\n            this.m_bloomPass = undefined;\n        }\n\n        if (this.vignette.enabled) {\n            const oldTarget = activeTarget!;\n            const nextEffectEnabled = this.sepia.enabled;\n            this.m_vignettePass.uniforms.offset.value = this.vignette.offset;\n            this.m_vignettePass.uniforms.darkness.value = this.vignette.darkness;\n            this.m_vignettePass.renderToScreen = !nextEffectEnabled;\n            if (nextEffectEnabled) {\n                activeTarget = activeTarget === this.m_target1 ? this.m_target2 : this.m_target1;\n            }\n            this.m_vignettePass.render(renderer, scene, camera, activeTarget!, oldTarget);\n        }\n\n        if (this.sepia.enabled) {\n            this.m_sepiaPass.renderToScreen = true;\n            this.m_sepiaPass.uniforms.amount.value = this.sepia.amount;\n            this.m_sepiaPass.render(renderer, scene, camera, null!, activeTarget!);\n        }\n    }\n\n    /**\n     * The resize function to call on resize events to resize the render targets. It shall include\n     * the resize methods of all the sub-passes used in `MapRenderingManager`.\n     *\n     * @param width - New width to use.\n     * @param height - New height to use.\n     */\n    setSize(width: number, height: number) {\n        this.m_readBuffer.setSize(width, height);\n        this.m_msaaPass.setSize(width, height);\n        if (this.m_bloomPass !== undefined) {\n            this.m_bloomPass.setSize(width, height);\n        }\n        this.m_lowResPass.setSize(width, height);\n        this.m_target1.setSize(width, height);\n        this.m_target2.setSize(width, height);\n        this.m_width = width;\n        this.m_height = height;\n    }\n\n    /**\n     * The `lowResPixelRatio` determines the resolution of the internal `WebGLRenderTarget`. Values\n     * between 0.5 and `window.devicePixelRatio` can be tried to give  good results. A value of\n     * `undefined` disables the low res render pass. The value should not be larger than\n     * `window.devicePixelRatio`.\n     */\n    get lowResPixelRatio(): number | undefined {\n        return this.m_lowResPass.pixelRatio;\n    }\n\n    set lowResPixelRatio(pixelRatio: number | undefined) {\n        this.m_lowResPass.pixelRatio = pixelRatio;\n        this.m_lowResPass.enabled = pixelRatio !== undefined;\n    }\n\n    /**\n     * Set the level of sampling while the user interacts.\n     *\n     * @param samplingLevel - The sampling level.\n     */\n    set dynamicMsaaSamplingLevel(samplingLevel: MSAASampling) {\n        this.m_dynamicMsaaSamplingLevel = samplingLevel;\n    }\n\n    /**\n     * Return the sampling level defined during continuous rendering.\n     */\n    get dynamicMsaaSamplingLevel(): MSAASampling {\n        return this.m_dynamicMsaaSamplingLevel;\n    }\n\n    /**\n     * Enable or disable the MSAA. If disabled, `MapRenderingManager` will use the renderer provided\n     * in the {@link MapRenderingManager.render} method to render the scene.\n     *\n     * @param value - If `true`, MSAA is enabled, disabled otherwise.\n     */\n    set msaaEnabled(value: boolean) {\n        this.m_msaaPass.enabled = value;\n    }\n\n    /**\n     * Return whether the MSAA is enabled.\n     */\n    get msaaEnabled(): boolean {\n        return this.m_msaaPass.enabled;\n    }\n\n    /**\n     * Set the sampling level for rendering static frames.\n     *\n     * @param samplingLevel - The sampling level.\n     */\n    set staticMsaaSamplingLevel(samplingLevel: MSAASampling) {\n        this.m_staticMsaaSamplingLevel = samplingLevel;\n    }\n\n    /**\n     * Return the sampling level defined for rendering static frames.\n     */\n\n    get staticMsaaSamplingLevel(): MSAASampling {\n        return this.m_staticMsaaSamplingLevel;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { CopyMaterial, CopyShader } from \"@here/harp-materials\";\nimport * as THREE from \"three\";\n\nimport { Pass } from \"./Pass\";\n\n/**\n * The `LowResRenderPass` renders the scene at a lower resolution into an internal\n * `WebGLRenderTarget`, and then copies the result into the frame buffer. The size of the internal\n * buffer is determined by the current frame buffer size multiplied by `pixelRatio`.\n *\n * @note Since no anti-aliasing is applied during dynamic rendering, visual artifacts may be\n * visible.\n */\nexport class LowResRenderPass extends Pass {\n    private m_renderTarget: THREE.WebGLRenderTarget | null = null;\n    private readonly m_localCamera: THREE.OrthographicCamera = new THREE.OrthographicCamera(\n        -1,\n        1,\n        1,\n        -1,\n        0,\n        1\n    );\n    private readonly m_quadScene: THREE.Scene = new THREE.Scene();\n    private readonly m_quadUniforms: { [uniformName: string]: THREE.IUniform } =\n        CopyShader.uniforms;\n    private readonly m_quadMaterial: THREE.ShaderMaterial = new CopyMaterial(this.m_quadUniforms);\n    private readonly m_quad: THREE.Mesh = new THREE.Mesh(\n        new THREE.PlaneBufferGeometry(2, 2),\n        this.m_quadMaterial\n    );\n    private m_pixelRatio: number | undefined;\n    private m_savedWidth = 0;\n    private m_savedHeight = 0;\n\n    /**\n     * The constructor for `LowResRenderPass`. It builds an internal scene with a camera looking at\n     * a quad.\n     *\n     * @param lowResPixelRatio - The `pixelRatio` determines the resolution of the internal\n     *  `WebGLRenderTarget`. Values between 0.5 and `window.devicePixelRatio` can be tried to give\n     * good results. A value of `undefined` disables the low res render pass. The value should not\n     * be larger than`window.devicePixelRatio`.\n     */\n    constructor(public lowResPixelRatio?: number) {\n        super();\n        this.m_quad.frustumCulled = false;\n        this.m_quadScene.add(this.m_quad);\n        this.m_pixelRatio = lowResPixelRatio;\n    }\n\n    /**\n     * Releases all used resources.\n     */\n    dispose() {\n        this.m_quadMaterial.dispose();\n        this.m_quad.geometry.dispose();\n        if (this.m_renderTarget !== null) {\n            this.m_renderTarget.dispose();\n            this.m_renderTarget = null;\n        }\n    }\n\n    /**\n     * If a value is specified, a low resolution render pass is used to render the scene into a\n     * low resolution render target, before it is copied to the screen.\n     *\n     * A value of `undefined` disables the low res render pass. The value should not be larger than\n     * `window.devicePixelRatio`.\n     *\n     * @default `undefined`\n     */\n    set pixelRatio(ratio: number | undefined) {\n        this.m_pixelRatio = ratio;\n        if (this.m_renderTarget && this.pixelRatio !== undefined) {\n            this.m_renderTarget.setSize(\n                Math.floor(this.m_savedWidth * this.pixelRatio),\n                Math.floor(this.m_savedHeight * this.pixelRatio)\n            );\n        }\n    }\n\n    get pixelRatio(): number | undefined {\n        return this.m_pixelRatio;\n    }\n\n    /**\n     * The render function of `LowResRenderPass`. It renders the whole scene into an internal\n     * `WebGLRenderTarget` instance with a lower resolution, using the passed in `WebGLRenderer`.\n     * The low resolution image is then copied to the `writeBuffer`, which is `undefined` in case it\n     * is the screen.\n     *\n     * @param renderer - The ThreeJS WebGLRenderer instance to render the scene with.\n     * @param scene - The ThreeJS Scene instance to render the scene with.\n     * @param camera - The ThreeJS Camera instance to render the scene with.\n     * @param writeBuffer - A ThreeJS WebGLRenderTarget instance to render the scene to.\n     * @param readBuffer - A ThreeJS WebGLRenderTarget instance to render the scene.\n     * @override\n     */\n    render(\n        renderer: THREE.WebGLRenderer,\n        scene: THREE.Scene,\n        camera: THREE.PerspectiveCamera | THREE.OrthographicCamera,\n        writeBuffer: THREE.WebGLRenderTarget | null,\n        readBuffer: THREE.WebGLRenderTarget\n    ) {\n        if (!this.enabled || this.pixelRatio === undefined) {\n            return;\n        }\n\n        // Initiates the local render target with the read buffer's dimensions, if not available.\n        if (this.m_renderTarget === null) {\n            this.m_savedWidth = readBuffer.width;\n            this.m_savedHeight = readBuffer.height;\n            this.m_renderTarget = new THREE.WebGLRenderTarget(\n                Math.floor(this.m_savedWidth * this.pixelRatio),\n                Math.floor(this.m_savedHeight * this.pixelRatio),\n                {\n                    minFilter: THREE.LinearFilter,\n                    magFilter: THREE.LinearFilter,\n                    format: THREE.RGBAFormat,\n                    depthBuffer: true,\n                    stencilBuffer: true\n                }\n            );\n            this.m_renderTarget.texture.name = \"LowResRenderPass.sample\";\n        }\n\n        this.m_quadUniforms.tDiffuse.value = this.m_renderTarget.texture;\n        this.m_quadUniforms.opacity.value = 1.0;\n\n        const oldRenderTarget = renderer.getRenderTarget();\n        renderer.setRenderTarget(this.m_renderTarget);\n        renderer.clear();\n        // Render into the low resolution internal render target.\n        renderer.render(scene, camera);\n\n        // Render the low resolution target into the screen.\n        // NOTE: three.js doesn't like undefined as renderTarget, but works with `null`\n        renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);\n        renderer.clear();\n        renderer.render(this.m_quadScene, this.m_localCamera);\n        renderer.setRenderTarget(oldRenderTarget);\n    }\n\n    /**\n     * Resize the internal render target to match the new size specified. The size of internal\n     * buffer depends on the `pixelRatio`.\n     *\n     * @param width - New width to apply to the render target.\n     * @param height - New height to apply to the render target.\n     * @override\n     */\n    setSize(width: number, height: number) {\n        this.m_savedWidth = width;\n        this.m_savedHeight = height;\n        if (this.m_renderTarget && this.pixelRatio !== undefined) {\n            this.m_renderTarget.setSize(\n                Math.floor(width * this.pixelRatio),\n                Math.floor(height * this.pixelRatio)\n            );\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {\n    EdgeMaterial,\n    ExtrusionFeatureDefs,\n    FadingFeature,\n    MixinShaderProperties,\n    UniformsType\n} from \"@here/harp-materials\";\nimport { chainCallbacks } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { DepthPrePassProperties } from \"../DepthPrePass\";\n\nconst vertexShaderChunk = `\n#ifdef USE_EXTRUSION\n  #ifndef HAS_EXTRUSION_PARS_VERTEX\n    #include <extrusion_pars_vertex>\n  #endif\n#endif\n\n#ifdef USE_FADING\n  #include <fading_pars_vertex>\n#endif\n\nuniform float outlineThickness;\n\nvec4 calculateOutline( vec4 pos, vec3 objectNormal, vec4 skinned ) {\n    float thickness = outlineThickness;\n    const float ratio = 1.0;\n    vec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + objectNormal, 1.0 );\n    vec4 norm = normalize( pos - pos2 );\n    return pos + norm * thickness * pos.w * ratio;\n}`;\n\nconst vertexShaderChunk2 = `\n#if ! defined( LAMBERT ) && ! defined( PHONG ) && ! defined( TOON ) && ! defined( STANDARD )\n    #ifndef USE_ENVMAP\n        vec3 objectNormal = normalize( normal );\n    #endif\n#endif\n\n#ifdef FLIP_SIDED\n    objectNormal = -objectNormal;\n#endif\n\n#ifdef DECLARE_TRANSFORMED\n    vec3 transformed = vec3( position );\n#endif\n\n#ifdef USE_EXTRUSION\n #ifndef HAS_EXTRUSION_VERTEX\n  #include <extrusion_vertex>\n #endif\n#endif\n\n#ifdef USE_FADING\n  #include <fading_vertex>\n#endif\n\n#ifdef USE_EXTRUSION\n  gl_Position = calculateOutline( projectionMatrix * modelViewMatrix * vec4( transformed, 1.0 ),\n      objectNormal, vec4( transformed, 1.0 ) );\n#else\n  gl_Position = calculateOutline( gl_Position, objectNormal, vec4( transformed, 1.0 ) );\n#endif\n\n#include <fog_vertex>`;\n\nconst fragmentShader = `\n#include <common>\n#include <fog_pars_fragment>\n\n#ifdef USE_EXTRUSION\n  #include <extrusion_pars_fragment>\n#endif\n\n#ifdef USE_FADING\n  #include <fading_pars_fragment>\n#endif\n\nuniform vec3 outlineColor;\nuniform float outlineAlpha;\n\nvoid main() {\n\n    gl_FragColor = vec4( outlineColor, outlineAlpha );\n\n    #include <fog_fragment>\n\n    #ifdef USE_EXTRUSION\n      #include <extrusion_fragment>\n    #endif\n\n    #ifdef USE_FADING\n      #include <fading_fragment>\n    #endif\n}`;\n\n/**\n * Effect to render bold lines around extruded polygons.\n *\n * Implemented by rendering the mesh geometries with an outline material before rendering them\n * again with their original.\n */\nexport class OutlineEffect {\n    enabled: boolean = true;\n\n    autoClear: boolean;\n    domElement: HTMLCanvasElement;\n    shadowMap: THREE.WebGLShadowMap;\n\n    private m_defaultThickness: number = 0.02;\n    private m_defaultColor: THREE.Color = new THREE.Color(0, 0, 0);\n    private m_defaultAlpha: number = 1;\n    private m_defaultKeepAlive: boolean = false;\n    private m_ghostExtrudedPolygons: boolean = false;\n\n    private m_cache: any = {};\n    private m_removeThresholdCount: number = 60;\n    private m_originalMaterials: any = {};\n    private m_originalOnBeforeRenders: any = {};\n\n    private m_shaderIDs: { [key: string]: string } = {\n        MeshBasicMaterial: \"basic\",\n        MeshLambertMaterial: \"lambert\",\n        MeshPhongMaterial: \"phong\",\n        MeshToonMaterial: \"phong\",\n        MeshStandardMaterial: \"physical\",\n        MeshPhysicalMaterial: \"physical\"\n    };\n    private m_uniformsChunk = {\n        outlineThickness: { value: this.m_defaultThickness },\n        outlineColor: { value: this.m_defaultColor },\n        outlineAlpha: { value: this.m_defaultAlpha }\n    };\n\n    constructor(private m_renderer: THREE.WebGLRenderer) {\n        this.autoClear = m_renderer.autoClear;\n        this.domElement = m_renderer.domElement;\n        this.shadowMap = m_renderer.shadowMap;\n    }\n\n    set thickness(thickness: number) {\n        this.m_defaultThickness = thickness;\n        this.m_uniformsChunk.outlineThickness.value = thickness;\n        this.m_cache = {};\n    }\n\n    set color(color: string) {\n        this.m_defaultColor.set(color);\n        this.m_cache = {};\n    }\n\n    set ghostExtrudedPolygons(ghost: boolean) {\n        this.m_ghostExtrudedPolygons = ghost;\n    }\n\n    clear(color: boolean, depth: boolean, stencil: boolean) {\n        this.m_renderer.clear(color, depth, stencil);\n    }\n\n    getPixelRatio() {\n        return this.m_renderer.getPixelRatio();\n    }\n\n    setPixelRatio(value: number) {\n        this.m_renderer.setPixelRatio(value);\n    }\n\n    getSize(target: THREE.Vector2) {\n        return this.m_renderer.getSize(target);\n    }\n\n    setSize(width: number, height: number, updateStyle: boolean) {\n        this.m_renderer.setSize(width, height, updateStyle);\n    }\n\n    setViewport(x: number, y: number, width: number, height: number) {\n        this.m_renderer.setViewport(x, y, width, height);\n    }\n\n    setScissor(x: number, y: number, width: number, height: number) {\n        this.m_renderer.setScissor(x, y, width, height);\n    }\n\n    setScissorTest(boolean: boolean) {\n        this.m_renderer.setScissorTest(boolean);\n    }\n\n    setRenderTarget(renderTarget: THREE.WebGLRenderTarget) {\n        this.m_renderer.setRenderTarget(renderTarget);\n    }\n\n    render(scene: THREE.Scene, camera: THREE.Camera) {\n        // Re-rendering the scene with the outline effect enables to hide the\n        // extruded polygons and show only the outlines (it is a hack and should be\n        // implemented another way!).\n        if (this.m_ghostExtrudedPolygons) {\n            if (!this.enabled) {\n                this.m_renderer.render(scene, camera);\n                return;\n            }\n\n            const currentAutoClear = this.m_renderer.autoClear;\n            this.m_renderer.autoClear = this.autoClear;\n\n            this.m_renderer.render(scene, camera);\n\n            this.m_renderer.autoClear = currentAutoClear;\n        }\n\n        this.renderOutline(scene, camera);\n    }\n\n    renderOutline(scene: THREE.Scene, camera: THREE.Camera) {\n        const currentAutoClear = this.m_renderer.autoClear;\n        const currentSceneAutoUpdate = scene.autoUpdate;\n        const currentSceneBackground = scene.background;\n        const currentShadowMapEnabled = this.m_renderer.shadowMap.enabled;\n\n        scene.autoUpdate = false;\n        scene.background = null;\n        this.m_renderer.autoClear = false;\n        this.m_renderer.shadowMap.enabled = false;\n\n        scene.traverse(this.setOutlineMaterial.bind(this));\n\n        this.m_renderer.render(scene, camera);\n\n        scene.traverse(this.restoreOriginalMaterial.bind(this));\n\n        this.cleanupCache();\n\n        scene.autoUpdate = currentSceneAutoUpdate;\n        scene.background = currentSceneBackground;\n        this.m_renderer.autoClear = currentAutoClear;\n        this.m_renderer.shadowMap.enabled = currentShadowMapEnabled;\n    }\n\n    private createInvisibleMaterial() {\n        return new THREE.ShaderMaterial({ name: \"invisible\", visible: false });\n    }\n\n    private createMaterial(originalMaterial: THREE.Material) {\n        // EdgeMaterial or depth prepass material should not be used for outlines.\n        if (\n            originalMaterial instanceof EdgeMaterial ||\n            (originalMaterial as DepthPrePassProperties).isDepthPrepassMaterial === true\n        ) {\n            return this.createInvisibleMaterial();\n        }\n\n        const shaderID = this.m_shaderIDs[originalMaterial.type];\n        let originalVertexShader;\n\n        let originalUniforms: UniformsType | undefined =\n            (originalMaterial as MixinShaderProperties).shaderUniforms !== undefined\n                ? (originalMaterial as MixinShaderProperties).shaderUniforms\n                : (originalMaterial as THREE.ShaderMaterial).uniforms;\n\n        if (shaderID !== undefined) {\n            const shader = THREE.ShaderLib[shaderID];\n            originalUniforms = shader.uniforms;\n            originalVertexShader = shader.vertexShader;\n        } else if ((originalMaterial as any).isRawShaderMaterial === true) {\n            originalVertexShader = (originalMaterial as any).vertexShader;\n\n            if (\n                !/attribute\\s+vec3\\s+position\\s*;/.test(originalVertexShader) ||\n                !/attribute\\s+vec3\\s+normal\\s*;/.test(originalVertexShader)\n            ) {\n                return this.createInvisibleMaterial();\n            }\n        } else if ((originalMaterial as any).isShaderMaterial === true) {\n            originalVertexShader = (originalMaterial as any).vertexShader;\n        } else {\n            return this.createInvisibleMaterial();\n        }\n\n        const isExtrusionMaterial =\n            (originalMaterial as MixinShaderProperties).shaderUniforms !== undefined &&\n            (originalMaterial as any).shaderUniforms.extrusionRatio !== undefined;\n\n        const isFadingMaterial = FadingFeature.isDefined(originalMaterial as FadingFeature);\n\n        const uniforms: UniformsType = { ...originalUniforms, ...this.m_uniformsChunk };\n\n        const vertexShader = originalVertexShader\n            // put vertexShaderChunk right before \"void main() {...}\"\n            .replace(/void\\s+main\\s*\\(\\s*\\)/, vertexShaderChunk + \"\\nvoid main()\")\n            // put vertexShaderChunk2 the end of \"void main() {...}\"\n            // Note: here assums originalVertexShader ends with \"}\" of \"void main() {...}\"\n            .replace(/\\}\\s*$/, vertexShaderChunk2 + \"\\n}\")\n            // remove any light related lines\n            // Note: here is very sensitive to originalVertexShader\n            // TODO: consider safer way\n            .replace(/#include\\s+<[\\w_]*light[\\w_]*>/g, \"\");\n\n        const defines: any = {};\n\n        if (\n            !/vec3\\s+transformed\\s*=/.test(originalVertexShader) &&\n            !/#include\\s+<begin_vertex>/.test(originalVertexShader)\n        ) {\n            (defines as any).DECLARE_TRANSFORMED = true;\n        }\n\n        if (isExtrusionMaterial) {\n            // If the original material is setup for animated extrusion (like buildings), add the\n            // uniform describing the extrusion to the outline material.\n            uniforms.extrusionRatio = { value: ExtrusionFeatureDefs.DEFAULT_RATIO_MIN };\n            defines.USE_EXTRUSION = 1;\n        }\n\n        if (isFadingMaterial) {\n            uniforms.fadeNear = {\n                value:\n                    originalUniforms!.fadeNear !== undefined\n                        ? originalUniforms!.fadeNear.value\n                        : FadingFeature.DEFAULT_FADE_NEAR\n            };\n            uniforms.fadeFar = {\n                value:\n                    originalUniforms!.fadeFar !== undefined\n                        ? originalUniforms!.fadeFar.value\n                        : FadingFeature.DEFAULT_FADE_FAR\n            };\n            defines.USE_FADING = 1;\n        }\n\n        const outlineMaterial = new THREE.ShaderMaterial({\n            defines,\n            uniforms,\n            vertexShader,\n            fragmentShader,\n            side: THREE.BackSide,\n            //wireframe: true,\n            skinning: false,\n            morphTargets: false,\n            morphNormals: false,\n            fog: false,\n            blending: THREE.CustomBlending,\n            blendSrc: THREE.SrcAlphaFactor,\n            blendDst: THREE.OneMinusSrcAlphaFactor,\n            blendSrcAlpha: THREE.OneFactor,\n            blendDstAlpha: THREE.OneMinusSrcAlphaFactor,\n            transparent: true,\n            polygonOffset: true,\n            // Extreme values used here to reduce artifacts, especially at tile borders.\n            polygonOffsetFactor: 10.0,\n            polygonOffsetUnits: 30.0\n        });\n\n        return outlineMaterial;\n    }\n\n    private getOutlineMaterialFromCache(originalMaterial: THREE.Material) {\n        let data = this.m_cache[originalMaterial.uuid];\n\n        if (data === undefined) {\n            data = {\n                material: this.createMaterial(originalMaterial),\n                used: true,\n                keepAlive: this.m_defaultKeepAlive,\n                count: 0\n            };\n\n            this.m_cache[originalMaterial.uuid] = data;\n        }\n\n        data.used = true;\n\n        return data.material;\n    }\n\n    private getOutlineMaterial(originalMaterial: THREE.Material) {\n        const outlineMaterial = this.getOutlineMaterialFromCache(originalMaterial);\n\n        this.m_originalMaterials[outlineMaterial.uuid] = originalMaterial;\n\n        this.updateOutlineMaterial(outlineMaterial, originalMaterial);\n\n        return outlineMaterial;\n    }\n\n    private setOutlineMaterial(object: THREE.Object3D) {\n        if ((object as THREE.Mesh).material === undefined) {\n            return;\n        }\n\n        if (Array.isArray((object as THREE.Mesh).material)) {\n            for (\n                let i = 0, il = ((object as THREE.Mesh).material as THREE.Material[]).length;\n                i < il;\n                i++\n            ) {\n                ((object as THREE.Mesh).material as THREE.Material[])[i] = this.getOutlineMaterial(\n                    ((object as THREE.Mesh).material as THREE.Material[])[i]\n                );\n            }\n        } else {\n            (object as THREE.Mesh).material = this.getOutlineMaterial(\n                (object as THREE.Mesh).material as THREE.Material\n            );\n        }\n\n        this.m_originalOnBeforeRenders[object.uuid] = object.onBeforeRender;\n        object.onBeforeRender = chainCallbacks(\n            object.onBeforeRender,\n            this.onBeforeRender.bind(this)\n        );\n    }\n\n    private restoreOriginalMaterial(object: THREE.Object3D) {\n        if ((object as THREE.Mesh).material === undefined) {\n            return;\n        }\n\n        if (Array.isArray((object as THREE.Mesh).material)) {\n            for (\n                let i = 0, il = ((object as THREE.Mesh).material as THREE.Material[]).length;\n                i < il;\n                i++\n            ) {\n                ((object as THREE.Mesh).material as THREE.Material[])[i] = this.m_originalMaterials[\n                    ((object as THREE.Mesh).material as THREE.Material[])[i].uuid\n                ];\n            }\n        } else {\n            (object as THREE.Mesh).material = this.m_originalMaterials[\n                ((object as THREE.Mesh).material as THREE.Material).uuid\n            ];\n        }\n\n        object.onBeforeRender = this.m_originalOnBeforeRenders[object.uuid];\n    }\n\n    private onBeforeRender(\n        renderer: THREE.WebGLRenderer,\n        scene: THREE.Scene,\n        camera: THREE.Camera,\n        geometry: THREE.Geometry | THREE.BufferGeometry,\n        material: THREE.Material,\n        group: THREE.Group\n    ) {\n        const originalMaterial = this.m_originalMaterials[material.uuid];\n\n        // just in case\n        if (originalMaterial === undefined) {\n            return;\n        }\n\n        this.updateUniforms(material, originalMaterial);\n    }\n\n    private updateUniforms(material: THREE.Material, originalMaterial: THREE.Material) {\n        const outlineParameters = originalMaterial.userData.outlineParameters;\n\n        const outlineUniforms = (material as THREE.ShaderMaterial).uniforms;\n        outlineUniforms.outlineAlpha.value = originalMaterial.opacity;\n\n        const originalUniforms =\n            (originalMaterial as any).shaderUniforms !== undefined\n                ? (originalMaterial as any).shaderUniforms\n                : (originalMaterial as any).uniforms;\n\n        if (outlineParameters !== undefined) {\n            if (outlineParameters.thickness !== undefined) {\n                outlineUniforms.outlineThickness.value = outlineParameters.thickness;\n            }\n            if (outlineParameters.color !== undefined) {\n                outlineUniforms.outlineColor.value.fromArray(outlineParameters.color);\n            }\n            if (outlineParameters.alpha !== undefined) {\n                outlineUniforms.outlineAlpha.value = outlineParameters.alpha;\n            }\n        }\n\n        // If the original material is setup for animated extrusion (like buildings), update the\n        // uniforms in the outline material.\n        if (originalUniforms !== undefined && originalUniforms.extrusionRatio !== undefined) {\n            const value = (originalMaterial as any).shaderUniforms.extrusionRatio.value;\n            (material as any).extrusionRatio = value;\n            (material as any).uniforms.extrusionRatio.value =\n                value !== undefined ? value : ExtrusionFeatureDefs.DEFAULT_RATIO_MIN;\n        }\n\n        // Copy available fading params to the outline material.\n        if (\n            material.defines.USE_FADING !== undefined &&\n            originalUniforms.fadeNear !== undefined &&\n            originalUniforms.fadeFar !== undefined &&\n            originalUniforms.fadeFar.value >= 0.0\n        ) {\n            outlineUniforms.fadeNear.value = originalUniforms.fadeNear.value;\n            outlineUniforms.fadeFar.value = originalUniforms.fadeFar.value;\n        }\n    }\n\n    private updateOutlineMaterial(material: THREE.Material, originalMaterial: THREE.Material) {\n        if (material.name === \"invisible\") {\n            return;\n        }\n\n        const outlineParameters = originalMaterial.userData.outlineParameters;\n\n        (material as any).skinning = (originalMaterial as any).skinning;\n        (material as any).morphTargets = (originalMaterial as any).morphTargets;\n        (material as any).morphNormals = (originalMaterial as any).morphNormals;\n        material.fog = originalMaterial.fog;\n\n        if (outlineParameters !== undefined) {\n            material.visible =\n                originalMaterial.visible === false\n                    ? false\n                    : outlineParameters.visible !== undefined\n                    ? outlineParameters.visible\n                    : true;\n\n            if (outlineParameters.keepAlive !== undefined) {\n                this.m_cache[originalMaterial.uuid].keepAlive = outlineParameters.keepAlive;\n            }\n        } else {\n            material.visible = originalMaterial.visible;\n        }\n\n        if ((originalMaterial as any).wireframe === true || originalMaterial.depthTest === false) {\n            material.visible = false;\n        }\n    }\n\n    private cleanupCache() {\n        let keys;\n\n        // clear originialMaterials\n        keys = Object.keys(this.m_originalMaterials);\n\n        for (let i = 0, il = keys.length; i < il; i++) {\n            this.m_originalMaterials[keys[i]] = undefined;\n        }\n\n        // clear originalOnBeforeRenders\n        keys = Object.keys(this.m_originalOnBeforeRenders);\n\n        for (let i = 0, il = keys.length; i < il; i++) {\n            this.m_originalOnBeforeRenders[keys[i]] = undefined;\n        }\n\n        // remove unused outlineMaterial from cache\n        keys = Object.keys(this.m_cache);\n\n        for (const key of keys) {\n            if (this.m_cache[key].used === false) {\n                this.m_cache[key].count++;\n\n                if (\n                    this.m_cache[key].keepAlive === false &&\n                    this.m_cache[key].count > this.m_removeThresholdCount\n                ) {\n                    delete this.m_cache[key];\n                }\n            } else {\n                this.m_cache[key].used = false;\n                this.m_cache[key].count = 0;\n            }\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CopyShader, LuminosityHighPassShader } from \"@here/harp-materials\";\nimport * as THREE from \"three\";\nimport { Pass } from \"./Pass\";\n\nconst BlurDirectionX = new THREE.Vector2(1.0, 0.0);\nconst BlurDirectionY = new THREE.Vector2(0.0, 1.0);\n\n/**\n * The TS version of ThreeJS's UnrealBloomPass.\n */\nexport class BloomPass extends Pass {\n    strength: number;\n    radius: number;\n    threshold: number;\n    resolution: THREE.Vector2 = new THREE.Vector2(256, 256);\n    private m_renderTargetsHorizontal: THREE.WebGLRenderTarget[] = [];\n    private m_renderTargetsVertical: THREE.WebGLRenderTarget[] = [];\n    private m_nMips: number = 5;\n    private m_highPassUniforms: any;\n    private m_materialHighPassFilter: THREE.ShaderMaterial;\n    private m_separableBlurMaterials: THREE.ShaderMaterial[] = [];\n    private m_materialCopy: THREE.ShaderMaterial;\n    private m_copyUniforms: any;\n    private m_compositeMaterial: THREE.ShaderMaterial;\n\n    private m_camera: THREE.OrthographicCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n    private m_scene: THREE.Scene = new THREE.Scene();\n    private m_basic = new THREE.MeshBasicMaterial();\n    private m_quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2));\n\n    private m_bloomTintColors: THREE.Vector3[] = [\n        new THREE.Vector3(1, 1, 1),\n        new THREE.Vector3(1, 1, 1),\n        new THREE.Vector3(1, 1, 1),\n        new THREE.Vector3(1, 1, 1),\n        new THREE.Vector3(1, 1, 1)\n    ];\n\n    private m_renderTargetBright: THREE.WebGLRenderTarget;\n\n    constructor(resolution: THREE.Vector2, strength: number, radius: number, threshold: number) {\n        super();\n\n        this.strength = strength;\n        this.radius = radius;\n        this.threshold = threshold;\n        this.resolution = resolution;\n\n        this.m_quad.frustumCulled = false;\n        this.m_scene.add(this.m_quad);\n\n        const pars = {\n            minFilter: THREE.LinearFilter,\n            magFilter: THREE.LinearFilter,\n            format: THREE.RGBAFormat\n        };\n\n        let resx = Math.round(this.resolution.x / 2);\n        let resy = Math.round(this.resolution.y / 2);\n\n        this.m_renderTargetBright = new THREE.WebGLRenderTarget(resx, resy, pars);\n        this.m_renderTargetBright.texture.name = \"UnrealBloomPass.bright\";\n        this.m_renderTargetBright.texture.generateMipmaps = false;\n\n        for (let i = 0; i < this.m_nMips; i++) {\n            const renderTargetHorizonal = new THREE.WebGLRenderTarget(resx, resy, pars);\n            renderTargetHorizonal.texture.name = \"UnrealBloomPass.h\" + i;\n            renderTargetHorizonal.texture.generateMipmaps = false;\n            this.m_renderTargetsHorizontal.push(renderTargetHorizonal);\n\n            const renderTargetVertical = new THREE.WebGLRenderTarget(resx, resy, pars);\n            renderTargetVertical.texture.name = \"UnrealBloomPass.v\" + i;\n            renderTargetVertical.texture.generateMipmaps = false;\n            this.m_renderTargetsVertical.push(renderTargetVertical);\n\n            resx = Math.round(resx / 2);\n            resy = Math.round(resy / 2);\n        }\n\n        this.m_highPassUniforms = THREE.UniformsUtils.clone(LuminosityHighPassShader.uniforms);\n\n        // tslint:disable:no-string-literal\n        this.m_highPassUniforms[\"luminosityThreshold\"].value = threshold;\n        this.m_highPassUniforms[\"smoothWidth\"].value = 0.01;\n\n        this.m_materialHighPassFilter = new THREE.ShaderMaterial({\n            uniforms: this.m_highPassUniforms,\n            vertexShader: LuminosityHighPassShader.vertexShader,\n            fragmentShader: LuminosityHighPassShader.fragmentShader,\n            defines: {}\n        });\n\n        // Gaussian Blur Materials\n        const kernelSizeArray = [3, 5, 7, 9, 11];\n        resx = Math.round(this.resolution.x / 2);\n        resy = Math.round(this.resolution.y / 2);\n        for (let i = 0; i < this.m_nMips; i++) {\n            this.m_separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));\n            this.m_separableBlurMaterials[i].uniforms[\"texSize\"].value = new THREE.Vector2(\n                resx,\n                resy\n            );\n            resx = Math.round(resx / 2);\n            resy = Math.round(resy / 2);\n        }\n\n        // Composite material\n        this.m_compositeMaterial = this.getCompositeMaterial(this.m_nMips);\n        this.m_compositeMaterial.uniforms[\n            \"blurTexture1\"\n        ].value = this.m_renderTargetsVertical[0].texture;\n        this.m_compositeMaterial.uniforms[\n            \"blurTexture2\"\n        ].value = this.m_renderTargetsVertical[1].texture;\n        this.m_compositeMaterial.uniforms[\n            \"blurTexture3\"\n        ].value = this.m_renderTargetsVertical[2].texture;\n        this.m_compositeMaterial.uniforms[\n            \"blurTexture4\"\n        ].value = this.m_renderTargetsVertical[3].texture;\n        this.m_compositeMaterial.uniforms[\n            \"blurTexture5\"\n        ].value = this.m_renderTargetsVertical[4].texture;\n        this.m_compositeMaterial.uniforms[\"bloomStrength\"].value = strength;\n        this.m_compositeMaterial.uniforms[\"bloomRadius\"].value = 0.1;\n        this.m_compositeMaterial.needsUpdate = true;\n\n        const bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];\n        this.m_compositeMaterial.uniforms[\"bloomFactors\"].value = bloomFactors;\n        this.m_compositeMaterial.uniforms[\"bloomTintColors\"].value = this.m_bloomTintColors;\n\n        this.m_copyUniforms = THREE.UniformsUtils.clone(CopyShader.uniforms);\n        this.m_copyUniforms[\"opacity\"].value = 1.0;\n        // tslint:enable:no-string-literal\n\n        this.m_materialCopy = new THREE.ShaderMaterial({\n            uniforms: this.m_copyUniforms,\n            vertexShader: CopyShader.vertexShader,\n            fragmentShader: CopyShader.fragmentShader,\n            blending: THREE.AdditiveBlending,\n            depthTest: false,\n            depthWrite: false,\n            transparent: true\n        });\n    }\n    dispose() {\n        for (const rt of this.m_renderTargetsHorizontal) {\n            rt.dispose();\n        }\n        for (const rt of this.m_renderTargetsVertical) {\n            rt.dispose();\n        }\n        this.m_renderTargetBright.dispose();\n    }\n    /** @override */\n    setSize(width: number, height: number) {\n        let resx = Math.round(width / 2);\n        let resy = Math.round(height / 2);\n        this.m_renderTargetBright.setSize(resx, resy);\n        for (let i = 0; i < this.m_nMips; i++) {\n            this.m_renderTargetsHorizontal[i].setSize(resx, resy);\n            this.m_renderTargetsVertical[i].setSize(resx, resy);\n            // tslint:disable-next-line:no-string-literal\n            this.m_separableBlurMaterials[i].uniforms[\"texSize\"].value = new THREE.Vector2(\n                resx,\n                resy\n            );\n            resx = Math.round(resx / 2);\n            resy = Math.round(resy / 2);\n        }\n    }\n    /** @override */\n    render(\n        renderer: THREE.WebGLRenderer,\n        scene: THREE.Scene,\n        camera: THREE.Camera,\n        writeBuffer: THREE.WebGLRenderTarget | null,\n        readBuffer: THREE.WebGLRenderTarget\n    ) {\n        // tslint:disable:no-string-literal\n\n        // Render input to screen\n        if (this.renderToScreen) {\n            this.m_quad.material = this.m_basic;\n            this.m_basic.map = readBuffer.texture;\n            renderer.setRenderTarget(null!);\n            renderer.clear();\n            renderer.render(this.m_scene, this.m_camera);\n        }\n\n        // 1. Extract bright areas\n        this.m_highPassUniforms[\"tDiffuse\"].value = readBuffer.texture;\n        this.m_highPassUniforms[\"luminosityThreshold\"].value = this.threshold;\n        this.m_quad.material = this.m_materialHighPassFilter;\n\n        renderer.setRenderTarget(this.m_renderTargetBright);\n        renderer.clear();\n        renderer.render(this.m_scene, this.m_camera);\n\n        // 2. Blur all the mips progressively\n        let inputRenderTarget = this.m_renderTargetBright;\n\n        for (let i = 0; i < this.m_nMips; i++) {\n            this.m_quad.material = this.m_separableBlurMaterials[i];\n\n            this.m_separableBlurMaterials[i].uniforms[\"colorTexture\"].value =\n                inputRenderTarget.texture;\n            this.m_separableBlurMaterials[i].uniforms[\"direction\"].value = BlurDirectionX;\n            renderer.setRenderTarget(this.m_renderTargetsHorizontal[i]);\n            renderer.clear();\n            renderer.render(this.m_scene, this.m_camera);\n\n            this.m_separableBlurMaterials[i].uniforms[\n                \"colorTexture\"\n            ].value = this.m_renderTargetsHorizontal[i].texture;\n            this.m_separableBlurMaterials[i].uniforms[\"direction\"].value = BlurDirectionY;\n            renderer.setRenderTarget(this.m_renderTargetsVertical[i]);\n            renderer.clear();\n            renderer.render(this.m_scene, this.m_camera);\n\n            inputRenderTarget = this.m_renderTargetsVertical[i];\n        }\n\n        // Composite all the mips\n        this.m_quad.material = this.m_compositeMaterial;\n        this.m_compositeMaterial.uniforms[\"bloomStrength\"].value = this.strength;\n        this.m_compositeMaterial.uniforms[\"bloomRadius\"].value = this.radius;\n        this.m_compositeMaterial.uniforms[\"bloomTintColors\"].value = this.m_bloomTintColors;\n\n        renderer.setRenderTarget(this.m_renderTargetsHorizontal[0]);\n        renderer.clear();\n        renderer.render(this.m_scene, this.m_camera);\n\n        // Blend it additively over the input texture\n        this.m_quad.material = this.m_materialCopy;\n        this.m_copyUniforms[\"tDiffuse\"].value = this.m_renderTargetsHorizontal[0].texture;\n\n        if (this.renderToScreen) {\n            renderer.setRenderTarget(null!);\n            renderer.render(this.m_scene, this.m_camera);\n        } else {\n            renderer.setRenderTarget(readBuffer);\n            renderer.render(this.m_scene, this.m_camera);\n        }\n        // tslint:enable:no-string-literal\n    }\n\n    getSeperableBlurMaterial(kernelRadius: number): THREE.ShaderMaterial {\n        return new THREE.ShaderMaterial({\n            defines: {\n                KERNEL_RADIUS: kernelRadius,\n                SIGMA: kernelRadius\n            },\n\n            uniforms: {\n                colorTexture: { value: null },\n                texSize: { value: new THREE.Vector2(0.5, 0.5) },\n                direction: { value: new THREE.Vector2(0.5, 0.5) }\n            },\n\n            vertexShader: `varying vec2 vUv;\n            void main() {\n                vUv = uv;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n            }`,\n\n            fragmentShader: `#include <common>\n            varying vec2 vUv;\n            uniform sampler2D colorTexture;\n            uniform vec2 texSize;\n            uniform vec2 direction;\n\n            float gaussianPdf(in float x, in float sigma) {\n                return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n            }\n            void main() {\\n\\\n                vec2 invSize = 1.0 / texSize;\n                float fSigma = float(SIGMA);\n                float weightSum = gaussianPdf(0.0, fSigma);\n                vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\n                for( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n                    float x = float(i);\n                    float w = gaussianPdf(x, fSigma);\n                    vec2 uvOffset = direction * invSize * x;\n                    vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\n                    vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\n                    diffuseSum += (sample1 + sample2) * w;\n                    weightSum += 2.0 * w;\n                }\n                gl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n            }`\n        });\n    }\n\n    getCompositeMaterial(nMips: number): THREE.ShaderMaterial {\n        return new THREE.ShaderMaterial({\n            defines: {\n                NUM_MIPS: nMips\n            },\n\n            uniforms: {\n                blurTexture1: { value: null },\n                blurTexture2: { value: null },\n                blurTexture3: { value: null },\n                blurTexture4: { value: null },\n                blurTexture5: { value: null },\n                dirtTexture: { value: null },\n                bloomStrength: { value: 1.0 },\n                bloomFactors: { value: null },\n                bloomTintColors: { value: null },\n                bloomRadius: { value: 0.0 }\n            },\n\n            vertexShader: `varying vec2 vUv;\n                void main() {\n                    vUv = uv;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n                }`,\n\n            fragmentShader: `varying vec2 vUv;\n                uniform sampler2D blurTexture1;\n                uniform sampler2D blurTexture2;\n                uniform sampler2D blurTexture3;\n                uniform sampler2D blurTexture4;\n                uniform sampler2D blurTexture5;\n                uniform sampler2D dirtTexture;\n                uniform float bloomStrength;\n                uniform float bloomRadius;\n                uniform float bloomFactors[NUM_MIPS];\n                uniform vec3 bloomTintColors[NUM_MIPS];\n\n                float lerpBloomFactor(const in float factor) {\n                    float mirrorFactor = 1.2 - factor;\n                    return mix(factor, mirrorFactor, bloomRadius);\n                }\n\n                void main() {\n                    gl_FragColor = bloomStrength * (\nlerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\nlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\nlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\nlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\nlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n                }`\n        });\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Message sent by web worker that requests to resolve actual\n * URLs of it's dependencies.\n *\n * Main thread is expected.\n */\nexport interface WorkerBootstrapRequest {\n    type: \"worker-bootstrap-request\";\n\n    /// Names of dependencies, usually NPM package names.\n    dependencies: string[];\n}\n\nexport interface WorkerBootstrapResponse {\n    type: \"worker-bootstrap-response\";\n\n    /// Actual URL scripts requested in [[WorkerBootstrapRequest]].\n    resolvedDependencies: string[];\n}\n\nexport function isWorkerBootstrapRequest(message: any): message is WorkerBootstrapRequest {\n    return (\n        message &&\n        message.type === \"worker-bootstrap-request\" &&\n        Array.isArray(message.dependencies)\n    );\n}\n\nexport function isWorkerBootstrapResponse(message: any): message is WorkerBootstrapResponse {\n    return (\n        message &&\n        message.type === \"worker-bootstrap-response\" &&\n        Array.isArray(message.resolvedDependencies)\n    );\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { getOptionValue } from \"@here/harp-utils\";\nimport { MapView, MapViewEventNames } from \"../MapView\";\nimport { CopyrightInfo } from \"./CopyrightInfo\";\n\n/**\n * Helper class that maintains up-to-date {@link MapView} copyright information in DOM element.\n *\n * @example\n *\n *     // HTML snippet\n *     <div id=\"copyrightNotice\" style=\"position:absolute; right:0; bottom:0; z-index:100\"></div>\n *\n *     // JavaScript\n *     const mapView = new MapView({ ... });\n *     CopyrightElementHandler.install(\"copyrightNotice\", mapView);\n */\nexport class CopyrightElementHandler {\n    /**\n     * Install {@link CopyrightElementHandler} on DOM element and - optionally -\n     * attach to a {@link MapView} instance.\n     *\n     * @param element - HTML DOM element or a HTML DOM element id\n     * @param mapView -, optional, [[attach]] to this {@link MapView}\n     */\n    static install(element: string | HTMLElement, mapView?: MapView): CopyrightElementHandler {\n        return new CopyrightElementHandler(element, mapView);\n    }\n\n    /**\n     * Static copyright info.\n     *\n     * Use when {@link MapView}'s {@link DataSource}'s do not provide proper copyright information.\n     */\n    staticInfo: CopyrightInfo[] | undefined;\n\n    private m_defaults: Map<string, CopyrightInfo> = new Map();\n    private m_element: HTMLElement;\n    private m_mapViews: MapView[] = [];\n\n    /**\n     * Creates a new `CopyrightElementHandler` that updates the DOM element with the copyright info\n     * of the given `mapView`.\n     *\n     * Note: Generally, the static [[install]] method can be used to create and attach a new\n     * `CopyrightElementHandler` to a {@link MapView}\n     *\n     * @param element - HTML DOM element or a HTML DOM element id\n     * @param mapView - optional, [[attach]] to this {@link MapView} instance\n     */\n    constructor(element: string | HTMLElement, mapView?: MapView) {\n        if (typeof element === \"string\") {\n            const htmlElement = document.getElementById(element);\n            if (!htmlElement) {\n                throw new Error(`CopyrightElementHandler: unable to find DOM element #${element}`);\n            }\n            this.m_element = htmlElement;\n        } else {\n            this.m_element = element;\n        }\n\n        if (mapView !== undefined) {\n            this.attach(mapView);\n        }\n    }\n\n    /**\n     * Destroys this object by removing all event listeners from the attached {@link MapView}s.\n     */\n    destroy() {\n        for (const mapView of this.m_mapViews) {\n            mapView.removeEventListener(MapViewEventNames.CopyrightChanged, this.update);\n        }\n    }\n\n    /**\n     * Attaches this {@link CopyrightInfo} updates from {@link MapView} instance.\n     */\n    attach(mapView: MapView): this {\n        this.m_mapViews.push(mapView);\n\n        mapView.addEventListener(MapViewEventNames.CopyrightChanged, this.update);\n        this.update();\n\n        return this;\n    }\n\n    /**\n     * Stop following {@link CopyrightInfo} updates from {@link MapView} instance.\n     */\n    detach(mapView: MapView): this {\n        mapView.removeEventListener(MapViewEventNames.CopyrightChanged, this.update);\n\n        this.m_mapViews = this.m_mapViews.filter(item => item !== mapView);\n        this.update();\n\n        return this;\n    }\n\n    /**\n     * Set {@link CopyrightInfo} defaults to be used in case\n     * {@link DataSource} does not provide deatailed\n     * copyright information.\n     *\n     * @remarks\n     * The defaults will applied to all undefined `year`, `label` and `link` values in the copyright\n     * information retrieved from {@link MapView}.\n     */\n    setDefaults(defaults: CopyrightInfo[] | undefined): this {\n        this.m_defaults.clear();\n        if (defaults !== undefined) {\n            for (const item of defaults) {\n                this.m_defaults.set(item.id, item);\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Sets the [[staticInfo]] property.\n     *\n     * A `CopyrightElementHandler` always displays a deduplicated sum of static copyright info and\n     * copyright information obtained from attached {@link MapView}s.\n     *\n     * This information is used when {@link DataSource}\n     * instances of given {@link MapView} do not provide\n     * copyright information.\n     */\n    setStaticCopyightInfo(staticInfo: CopyrightInfo[] | undefined): this {\n        this.staticInfo = staticInfo;\n        return this;\n    }\n\n    /**\n     * Update copyright info text in controlled HTML element.\n     */\n    update = () => {\n        const mergedCopyrightInfo = this.m_mapViews\n            .map(mapView => mapView.copyrightInfo)\n            .reduce(CopyrightInfo.mergeArrays, this.staticInfo || []);\n\n        // Conditionally hiding of element with copyright information.\n        // If nothing to show we schould to avoid empty white rectangle in right bottom corner.\n        if (mergedCopyrightInfo.length === 0) {\n            this.m_element.style.display = \"none\";\n            return;\n        } else {\n            this.m_element.style.display = \"block\";\n        }\n\n        if (this.m_defaults.size !== 0) {\n            for (const sourceInfo of mergedCopyrightInfo) {\n                const defaults = this.m_defaults.get(sourceInfo.id);\n                if (defaults !== undefined) {\n                    sourceInfo.year = getOptionValue(sourceInfo.year, defaults.year);\n                    sourceInfo.label = getOptionValue(sourceInfo.label, defaults.label);\n                    sourceInfo.link = getOptionValue(sourceInfo.link, defaults.link);\n                }\n            }\n        }\n        const deduped = CopyrightInfo.mergeArrays(mergedCopyrightInfo);\n\n        this.m_element.innerHTML = CopyrightInfo.formatAsHtml(deduped);\n    };\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Box3Like, GeoBox, Projection, ProjectionType } from \"@here/harp-geoutils\";\nimport { assert } from \"@here/harp-utils\";\nimport { Vector3 } from \"three\";\nimport { SubdivisionModifier } from \"./SubdivisionModifier\";\n\nconst VERTEX_POSITION_CACHE = [new Vector3(), new Vector3()];\n\nexport enum SubdivisionMode {\n    /**\n     * Subdivide all edges\n     */\n    All,\n    /**\n     * Only subdivide horizontal and vertical edges\n     */\n    NoDiagonals\n}\n\n/**\n * The [[EdgeLengthGeometrySubdivisionModifier]] subdivides triangle mesh depending on\n * length of edges.\n */\nexport class EdgeLengthGeometrySubdivisionModifier extends SubdivisionModifier {\n    private m_projectedBox: Box3Like;\n    private m_maxLength: number;\n    private m_maxLengthX: number;\n    private m_maxLengthY: number;\n\n    /**\n     * Constructs a new [[EdgeLengthGeometrySubdivisionModifier]].\n     *\n     * @param subdivision - The subdivision factor\n     * @param geoBox - The geo bounding box of a tile\n     * @param subdivisionMode - Configures what edges to divide\n     * @param projection - The projection that defines the world space of this geometry.\n     */\n    constructor(\n        readonly subdivision: number,\n        readonly geoBox: GeoBox,\n        readonly subdivisionMode: SubdivisionMode = SubdivisionMode.All,\n        readonly projection: Projection\n    ) {\n        super();\n\n        assert(\n            projection.type === ProjectionType.Planar,\n            \"EdgeLengthGeometrySubdivisionModifier only supports planar projections\"\n        );\n\n        const northEast = projection.projectPoint(geoBox.northEast, VERTEX_POSITION_CACHE[0]);\n        const southWest = projection.projectPoint(geoBox.southWest, VERTEX_POSITION_CACHE[1]);\n        this.m_projectedBox = {\n            min: {\n                x: Math.min(northEast.x, southWest.x),\n                y: Math.min(northEast.y, southWest.y),\n                z: Math.min(northEast.z, southWest.z)\n            },\n            max: {\n                x: Math.max(northEast.x, southWest.x),\n                y: Math.max(northEast.y, southWest.y),\n                z: Math.max(northEast.z, southWest.z)\n            }\n        };\n        this.m_maxLengthX = (this.m_projectedBox.max.x - this.m_projectedBox.min.x) / subdivision;\n        this.m_maxLengthY = (this.m_projectedBox.max.y - this.m_projectedBox.min.y) / subdivision;\n\n        // Increase max length slightly to account for precision errors\n        if (this.subdivisionMode === SubdivisionMode.All) {\n            this.m_maxLengthX *= 1.1;\n            this.m_maxLengthY *= 1.1;\n        }\n        this.m_maxLength = Math.sqrt(\n            this.m_maxLengthX * this.m_maxLengthX + this.m_maxLengthY * this.m_maxLengthY\n        );\n    }\n\n    /**\n     * Return upper bound for length of diagonal edges\n     */\n    get maxLength() {\n        return this.m_maxLength;\n    }\n\n    /**\n     * Return upper bound for edge length in x direction\n     */\n    get maxLengthX() {\n        return this.m_maxLengthX;\n    }\n\n    /**\n     * Return upper bound for edge length in y direction\n     */\n    get maxLengthY() {\n        return this.m_maxLengthY;\n    }\n\n    /** @override */\n    protected shouldSplitTriangle(a: Vector3, b: Vector3, c: Vector3): number | undefined {\n        const shouldSplitAB = this.shouldSplitEdge(a, b);\n        const shouldSplitBC = this.shouldSplitEdge(b, c);\n        const shouldSplitCA = this.shouldSplitEdge(c, a);\n        const shouldSplit = shouldSplitAB || shouldSplitBC || shouldSplitCA;\n\n        if (!shouldSplit) {\n            return;\n        }\n\n        const ab = a.distanceTo(b);\n        const bc = b.distanceTo(c);\n        const ca = c.distanceTo(a);\n        const maxDistance = Math.max(\n            shouldSplitAB ? ab : 0,\n            shouldSplitBC ? bc : 0,\n            shouldSplitCA ? ca : 0\n        );\n        if (ab === maxDistance) {\n            return 0;\n        } else if (bc === maxDistance) {\n            return 1;\n        } else if (ca === maxDistance) {\n            return 2;\n        }\n\n        throw new Error(\"Could not split triangle.\");\n    }\n\n    private shouldSplitEdge(a: Vector3, b: Vector3): boolean {\n        switch (this.subdivisionMode) {\n            case SubdivisionMode.All:\n                return (\n                    (a.y === b.y && Math.abs(a.x - b.x) > this.m_maxLengthX) ||\n                    (a.x === b.x && Math.abs(a.y - b.y) > this.m_maxLengthY) ||\n                    a.distanceTo(b) > this.m_maxLength\n                );\n            case SubdivisionMode.NoDiagonals:\n                return (\n                    (a.y === b.y && Math.abs(a.x - b.x) > this.m_maxLengthX) ||\n                    (a.x === b.x && Math.abs(a.y - b.y) > this.m_maxLengthY)\n                );\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Projection, sphereProjection } from \"@here/harp-geoutils\";\nimport { Vector3 } from \"three\";\nimport { SubdivisionModifier } from \"./SubdivisionModifier\";\n\nconst VERTEX_POSITION_CACHE = [new Vector3(), new Vector3(), new Vector3()];\n\n/**\n * The [[SphericalGeometrySubdivisionModifier]] subdivides triangle mesh geometries positioned\n * on the surface of a sphere centered at `(0, 0, 0)`.\n */\nexport class SphericalGeometrySubdivisionModifier extends SubdivisionModifier {\n    /**\n     * Constructs a new [[SphericalGeometrySubdivisionModifier]].\n     *\n     * @param angle - The maximum angle in radians between two vertices and the origin.\n     * @param projection - The projection that defines the world space of this geometry.\n     */\n    constructor(readonly angle: number, readonly projection: Projection = sphereProjection) {\n        super();\n    }\n\n    /** @override */\n    protected shouldSplitTriangle(a: Vector3, b: Vector3, c: Vector3): number | undefined {\n        const aa = sphereProjection.reprojectPoint(this.projection, a, VERTEX_POSITION_CACHE[0]);\n        const bb = sphereProjection.reprojectPoint(this.projection, b, VERTEX_POSITION_CACHE[1]);\n        const cc = sphereProjection.reprojectPoint(this.projection, c, VERTEX_POSITION_CACHE[2]);\n\n        const alpha = aa.angleTo(bb);\n        const beta = bb.angleTo(cc);\n        const gamma = cc.angleTo(aa);\n\n        // find the maximum angle\n        const m = Math.max(alpha, Math.max(beta, gamma));\n\n        // split the triangle if needed.\n        if (m < this.angle) {\n            return undefined;\n        }\n\n        if (m === alpha) {\n            return 0;\n        } else if (m === beta) {\n            return 1;\n        } else if (m === gamma) {\n            return 2;\n        }\n\n        throw new Error(\"failed to split triangle\");\n    }\n}\n","/*\n * Copyright (C) 2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { DisplacementFeature, hasDisplacementFeature } from \"@here/harp-materials\";\nimport { assert } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\nimport { DisplacedBufferAttribute } from \"./DisplacedBufferAttribute\";\nimport { DisplacedBufferGeometry, DisplacementRange } from \"./DisplacedBufferGeometry\";\n\nfunction isDisplacementMaterial(material: any): material is DisplacementFeature {\n    const isDisplacementFeature = hasDisplacementFeature(material);\n    assert(isDisplacementFeature, \"Material does not support displacement maps.\");\n    return isDisplacementFeature;\n}\n\nfunction isDataTextureMap(map?: THREE.Texture | null): map is THREE.DataTexture {\n    if (!map) {\n        return false;\n    }\n    const isDataTexture = map instanceof THREE.DataTexture;\n    assert(isDataTexture, \"Material does not support displacement maps.\");\n    return isDataTexture;\n}\n\n/**\n * Mesh with geometry modified by a displacement map. Overrides raycasting behaviour to apply\n * displacement map before intersection test.\n * @internal\n */\nexport class DisplacedMesh extends THREE.Mesh {\n    private static displacedPositions?: DisplacedBufferAttribute;\n\n    private static getDisplacedPositionAttribute(\n        geometry: THREE.BufferGeometry,\n        displacementMap: THREE.DataTexture\n    ): DisplacedBufferAttribute {\n        // Reuse same buffer attribute for all meshes since it's only needed during the\n        // intersection test.\n        if (!DisplacedMesh.displacedPositions) {\n            DisplacedMesh.displacedPositions = new DisplacedBufferAttribute(\n                geometry.attributes.position,\n                geometry.attributes.normal,\n                geometry.attributes.uv,\n                displacementMap\n            );\n        } else {\n            DisplacedMesh.displacedPositions.reset(\n                geometry.attributes.position,\n                geometry.attributes.normal,\n                geometry.attributes.uv,\n                displacementMap\n            );\n        }\n        return DisplacedMesh.displacedPositions;\n    }\n\n    displacedGeometry?: DisplacedBufferGeometry;\n\n    /**\n     * Creates an instance of displaced mesh.\n     * @param geometry - Original geometry to displace.\n     * @param material - Material(s) to be used by the mesh. All must have the same\n     *                   displacement map.\n     * @param m_getDisplacementRange - Displacement values range getter.\n     * @param [m_raycastStrategy] Function that will be used to find ray intersections. If not\n     * provided, THREE.Mesh's raycast will be used.\n     */\n    constructor(\n        geometry: THREE.BufferGeometry,\n        material: THREE.Material | THREE.Material[],\n        private m_getDisplacementRange: () => DisplacementRange,\n        private m_raycastStrategy?: (\n            mesh: THREE.Mesh,\n            raycaster: THREE.Raycaster,\n            intersects: THREE.Intersection[]\n        ) => void\n    ) {\n        super(geometry, material);\n    }\n\n    // HARP-9585: Override of base class method, however tslint doesn't recognize it as such.\n    // tslint:disable-next-line: explicit-override\n    raycast(raycaster: THREE.Raycaster, intersects: THREE.Intersection[]): void {\n        // All materials in the object are expected to have the same displacement map.\n        const firstMaterial = this.firstMaterial;\n\n        // Use default raycasting implementation if there's no displacement material or if there's\n        // no displacement map or its type is not supported.\n        if (\n            !isDisplacementMaterial(firstMaterial) ||\n            !isDataTextureMap(firstMaterial.displacementMap)\n        ) {\n            super.raycast(raycaster, intersects);\n            return;\n        }\n        const displacementMap = firstMaterial.displacementMap;\n        const displacementRange = { ...this.m_getDisplacementRange() };\n\n        assert(this.geometry instanceof THREE.BufferGeometry, \"Unsupported geometry type.\");\n        const geometry = this.geometry as THREE.BufferGeometry;\n        if (this.displacedGeometry) {\n            this.displacedGeometry.reset(geometry, displacementMap, displacementRange);\n        } else {\n            this.displacedGeometry = new DisplacedBufferGeometry(\n                geometry,\n                displacementMap,\n                displacementRange,\n                DisplacedMesh.getDisplacedPositionAttribute(geometry, displacementMap)\n            );\n        }\n\n        // Replace the original geometry by the displaced one only during the intersection test.\n        this.geometry = this.displacedGeometry;\n        if (this.m_raycastStrategy) {\n            this.m_raycastStrategy(this, raycaster, intersects);\n        } else {\n            super.raycast(raycaster, intersects);\n        }\n        super.geometry = this.displacedGeometry.originalGeometry;\n    }\n\n    private get firstMaterial(): THREE.Material {\n        return Array.isArray(this.material) ? this.material[0] : this.material;\n    }\n}\n","/*\n * Copyright (C) 2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Vector3Like } from \"@here/harp-geoutils\";\nimport { assert } from \"@here/harp-utils\";\n\n// Offsets for the fields stored in cache for each vertex.\nenum Field {\n    VertexId = 0,\n    OlderIdx, // Index in cache of the immediately older vertex.\n    NewerIdx, // Index in cache of the immediately newer vertex.\n    X,\n    Y,\n    Z,\n    Count\n}\n\nconst Invalid: number = -1;\n\n/**\n * Compact vertex LRU Cache for on the fly temporary mesh transformations.\n * @internal\n */\nexport class VertexCache {\n    private m_cache: number[] = []; // Stores all fields for every cached vertex (see Field).\n    private m_vertexCount: number = 0;\n    private m_oldestIdx: number = 0;\n    private m_newestIdx: number = 0;\n\n    /**\n     * Creates a new cache with the specified maximum size.\n     * @param maxVertexCount - The maximum number of vertices the cache will store.\n     */\n    constructor(readonly maxVertexCount: number) {\n        this.m_cache.length = this.maxVertexCount * Field.Count;\n        this.clear();\n    }\n\n    /**\n     * Clears the vertex cache.\n     */\n    clear() {\n        this.m_cache.fill(Invalid);\n        this.m_vertexCount = 0;\n    }\n\n    /**\n     * Gets a vertex from cache.\n     * @param vertexId - The id of the vertex to get.\n     * @param vertex - The vertex coordinates will be set here if found.\n     * @returns whether the vertex was found on cache.\n     */\n    get(vertexId: number, vertex: Vector3Like): boolean {\n        const vertexIdx = this.find(vertexId);\n        if (vertexIdx === undefined) {\n            return false;\n        }\n        this.promoteEntry(vertexIdx);\n        this.getVertex(vertexIdx, vertex);\n        return true;\n    }\n\n    /**\n     * Sets a vertex in cache. It's assumed there's no vertex with the same id already in cache.\n     * @param vertexId - The vertex id.\n     * @param vertex - The vertex coordinates.\n     */\n    set(vertexId: number, vertex: Vector3Like) {\n        let vertexIdx = Invalid;\n        if (this.m_vertexCount < this.maxVertexCount) {\n            vertexIdx = this.m_vertexCount * Field.Count;\n            this.m_vertexCount++;\n        } else {\n            vertexIdx = this.m_oldestIdx;\n        }\n        if (this.m_vertexCount === 1) {\n            this.m_oldestIdx = this.m_newestIdx = vertexIdx;\n        } else {\n            this.promoteEntry(vertexIdx);\n        }\n        this.setVertex(vertexIdx, vertexId, vertex);\n    }\n\n    private find(vertexId: number): number | undefined {\n        const size = this.m_cache.length;\n        for (let i = 0; i < size; i += Field.Count) {\n            if (this.m_cache[i] === vertexId) {\n                return i;\n            }\n        }\n        return undefined;\n    }\n    private promoteEntry(vertexIdx: number): void {\n        if (vertexIdx === this.m_newestIdx) {\n            return;\n        } // already newest, nothing to do\n        // re-link newer and older items\n        const newerIdx = this.getNewerIdx(vertexIdx);\n        const olderIdx = this.getOlderIdx(vertexIdx);\n        if (newerIdx !== Invalid) {\n            assert(this.getOlderIdx(newerIdx) === vertexIdx);\n            this.setOlderIdx(newerIdx, olderIdx);\n        }\n        if (olderIdx !== Invalid) {\n            assert(this.getNewerIdx(olderIdx) === vertexIdx);\n            this.setNewerIdx(olderIdx, newerIdx);\n        }\n        if (vertexIdx === this.m_oldestIdx) {\n            this.m_oldestIdx = newerIdx;\n        }\n        // re-link ourselves\n        this.setNewerIdx(vertexIdx, Invalid);\n        this.setOlderIdx(vertexIdx, this.m_newestIdx);\n        // finally, set ourselves as the newest entry\n        assert(this.m_newestIdx !== Invalid);\n        assert(this.getNewerIdx(this.m_newestIdx) === Invalid);\n        this.setNewerIdx(this.m_newestIdx, vertexIdx);\n        this.m_newestIdx = vertexIdx;\n    }\n    private getOlderIdx(vertexIdx: number): number {\n        return this.m_cache[vertexIdx + Field.OlderIdx];\n    }\n    private setOlderIdx(vertexIdx: number, olderIdx: number): void {\n        this.m_cache[vertexIdx + Field.OlderIdx] = olderIdx;\n    }\n    private getNewerIdx(vertexIdx: number): number {\n        return this.m_cache[vertexIdx + Field.NewerIdx];\n    }\n    private setNewerIdx(vertexIdx: number, newerIdx: number): void {\n        this.m_cache[vertexIdx + Field.NewerIdx] = newerIdx;\n    }\n    private getVertex(vertexIdx: number, vertex: Vector3Like): void {\n        vertex.x = this.m_cache[vertexIdx + Field.X];\n        vertex.y = this.m_cache[vertexIdx + Field.Y];\n        vertex.z = this.m_cache[vertexIdx + Field.Z];\n    }\n    private setVertex(vertexIdx: number, vertexId: number, vertex: Vector3Like): void {\n        this.m_cache[vertexIdx] = vertexId;\n        this.m_cache[vertexIdx + Field.X] = vertex.x;\n        this.m_cache[vertexIdx + Field.Y] = vertex.y;\n        this.m_cache[vertexIdx + Field.Z] = vertex.z;\n    }\n}\n","/*\n * Copyright (C) 2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { OrientedBox3 } from \"@here/harp-geoutils\";\nimport { SolidLineMaterial } from \"@here/harp-materials\";\nimport { assert } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\nimport { displaceBox, DisplacedBufferGeometry, DisplacementRange } from \"./DisplacedBufferGeometry\";\n\nconst tmpSphere = new THREE.Sphere();\nconst tmpInverseMatrix = new THREE.Matrix4();\nconst tmpRay = new THREE.Ray();\nconst tmpLine1 = new THREE.Line3();\nconst tmpBox = new THREE.Box3();\nconst tmpOBB = new OrientedBox3();\nconst tmpPlane = new THREE.Plane();\nconst tmpV1 = new THREE.Vector3();\nconst tmpV2 = new THREE.Vector3();\nconst tmpV3 = new THREE.Vector3();\nconst tmpV4 = new THREE.Vector3();\n\n// Strides to access the index buffer. See [[createLineGeometry]].\n// Stride between the start vertex indices of consecutive segments, each one made of 2 triangles.\nconst SEGMENT_STRIDE = 6;\n// Stride between the start and end vertex indices of a segment. Vertices are duplicated so that\n// each copy is extruded in opposite directions in the vertex shader.\nconst VERTEX_STRIDE = 2;\n\nfunction isSolidLineMaterial(material: THREE.Material | THREE.Material[]): boolean {\n    return Array.isArray(material)\n        ? material.every(mat => mat instanceof SolidLineMaterial)\n        : material instanceof SolidLineMaterial;\n}\n\n/**\n * Computes the bounding sphere of the part of a given geometry corresponding to a feature.\n * @param geometry - The geometry containing the feature.\n * @param featureBeginIndex - The index where the feature starts in the geometry's\n *                            indices attribute.\n * @param featureEndIndex - The index where the feature end in the geometry's indices attribute.\n * @returns The feature bounding sphere.\n */\nfunction computeFeatureBoundingSphere(\n    geometry: THREE.BufferGeometry | DisplacedBufferGeometry,\n    featureBeginIndex: number,\n    featureEndIndex: number\n): THREE.Sphere {\n    let displacementRange: DisplacementRange | undefined;\n\n    if (geometry instanceof DisplacedBufferGeometry) {\n        displacementRange = geometry.displacementRange;\n        geometry = geometry.originalGeometry;\n    }\n\n    const attributes = geometry.attributes;\n    const pos = attributes.position as THREE.BufferAttribute;\n    const indices = geometry.index!.array;\n    const sphere = new THREE.Sphere();\n    const bbox = tmpBox.makeEmpty();\n    const vertex = tmpV1;\n\n    // First compute the bounding box for all line segments.\n    for (let i = featureBeginIndex; i < featureEndIndex; i += SEGMENT_STRIDE) {\n        bbox.expandByPoint(vertex.fromBufferAttribute(pos, indices[i]));\n        bbox.expandByPoint(vertex.fromBufferAttribute(pos, indices[i + VERTEX_STRIDE]));\n    }\n\n    if (displacementRange) {\n        // If geometry is displaced, expand the bounding box to cover the whole displacement range,\n        // and return the sphere bounding the box. This is a coarse estimation, but avoids having\n        // to displace all vertices.\n        // All normals in the geometry are assumed to be the same or close enough so that any of\n        // them can be used as displacement direction. For sphere projection, the surface normals\n        // within a tile are approximately the same from level 4 onwards. Here are some examples of\n        // the minimum dot product between normals in a tile (normals at tile's opposite corners):\n        // TILE: (6,9,4): 0.9806892129880023\n        // TILE: (12,17,5): 0.9946739445457075\n        // TILE: (25,34,6): 0.9986326302953471\n        // TILE: (50,68,7): 0.9996583822992287\n        // TILE: (1620,2199,12): 0.9999996706085572\n        const normal = tmpV2;\n        normal.fromBufferAttribute(geometry.attributes.normal as THREE.BufferAttribute, 0);\n        return displaceBox(bbox, displacementRange, normal).getBoundingSphere(sphere);\n    }\n\n    return bbox.getBoundingSphere(sphere);\n}\n\n/**\n * Finds the intersection of a ray with a extruded line.\n * @param ray - Intersection ray in object's local space.\n * @param line - The centerline.\n * @param vExtrusion - Line extrusion vector.\n * @param normal - Extrusion plane normal.\n * @param hWidth - Extrusion half width.\n * @returns Distance of the extruded line intersection to the ray origin.\n */\nfunction intersectExtrudedLine(\n    ray: THREE.Ray,\n    line: THREE.Line3,\n    vExtrusion: THREE.Vector3,\n    normal: THREE.Vector3,\n    hWidth: number\n): number {\n    const obb = tmpOBB;\n    line.getCenter(obb.position);\n    line.delta(obb.xAxis).normalize();\n    obb.yAxis.copy(vExtrusion);\n    obb.zAxis.copy(normal);\n    obb.extents.set(line.distance() / 2, hWidth, hWidth);\n\n    if (obb.contains(ray.origin)) {\n        return 0;\n    }\n    return obb.intersectsRay(ray) ?? Infinity;\n}\n\n/**\n * Finds the intersection of a ray with the closest end cap of a extruded line.\n * @param ray - Intersection ray in object's local space.\n * @param line - The centerline.\n * @param hWidth - Extrusion half width.\n * @returns Distance of the end cap intersection to the ray origin.\n */\nfunction intersectClosestEndCap(ray: THREE.Ray, line: THREE.Line3, hWidth: number): number {\n    const sphere = new THREE.Sphere(line.start, hWidth);\n    const startCapT = sphere.containsPoint(ray.origin)\n        ? 0\n        : ray.intersectSphere(sphere, tmpV4)\n        ? tmpV4.sub(ray.origin).length()\n        : Infinity;\n    sphere.center.copy(line.end);\n    const endCapT = sphere.containsPoint(ray.origin)\n        ? 0\n        : ray.intersectSphere(sphere, tmpV4)\n        ? tmpV4.sub(ray.origin).length()\n        : Infinity;\n    return Math.min(startCapT, endCapT);\n}\n\n/**\n * Intersects line\n * @param ray - Intersection ray in object's local space.\n * @param line - The line to intersect.\n * @param vExtrusion - Line extrusion vector.\n * @param hWidth - The line's extrusion half width.\n * @param hWidthSq - The line's extrusion half width squared.\n * @param plane - The extrusion plane.\n * @param interPlane - The intersection of the ray with the extrusion plane.\n * @param outInterLine - The ray intersetion with the extruded line.\n * @returns true if ray intersects the extruded line, false otherwise.\n */\nfunction intersectLine(\n    ray: THREE.Ray,\n    line: THREE.Line3,\n    vExtrusion: THREE.Vector3,\n    hWidth: number,\n    hWidthSq: number,\n    plane: THREE.Plane,\n    interPlane: THREE.Vector3,\n    outInterLine: THREE.Vector3\n): boolean {\n    if (interPlane.equals(ray.origin) && ray.direction.dot(plane.normal) === 0) {\n        // Corner case: ray is coplanar to extruded line, find distance to extruded line sides\n        // and end caps.\n        const extrLineT = intersectExtrudedLine(ray, line, vExtrusion, plane.normal, hWidth);\n        const endCapT = intersectClosestEndCap(ray, line, hWidth);\n\n        const minT = Math.min(extrLineT, endCapT);\n        if (minT === Infinity) {\n            return false;\n        }\n        ray.at(minT, outInterLine);\n        return true;\n    }\n\n    // The plain intersection is also a line intersection only if it's closer to the line\n    // than the extrusion half width.\n    const distSq = interPlane.distanceToSquared(line.closestPointToPoint(interPlane, true, tmpV4));\n\n    if (distSq > hWidthSq) {\n        return false;\n    }\n    outInterLine.copy(interPlane);\n    return true;\n}\n\n/**\n * Finds the intersections of a ray with a partition of a solid line mesh representing a feature.\n * @param mesh - The mesh whose intersections will be found.\n * @param raycaster - Contains the intersection ray.\n * @param localRay - Same ray as raycaster.ray but in object's local space.\n * @param halfWidth - The line's extrusion half width.\n * @param lHalfWidth - The line's extrusion half width in mesh local space.\n * @param lHalfWidthSq - The line's extrusion half width squared in mesh local space.\n * @param beginIdx - The index where the feature starts in the mesh geometry's indices attribute.\n * @param endIdx - The index where the feature end in the mesh geometry's indices attribute.\n * @param bSphere - The feature bounding sphere.\n * @param intersections - Array where all intersections found between ray and feature will\n *                        be pushed.\n */\nfunction intersectFeature(\n    mesh: THREE.Mesh,\n    raycaster: THREE.Raycaster,\n    localRay: THREE.Ray,\n    halfWidth: number,\n    lHalfWidth: number,\n    lHalfWidthSq: number,\n    beginIdx: number,\n    endIdx: number,\n    bSphere: THREE.Sphere,\n    intersections: THREE.Intersection[]\n): void {\n    const vExt = tmpV1;\n    const plane = tmpPlane;\n    const interPlane = tmpV2;\n    const line = tmpLine1;\n\n    const geometry = mesh.geometry as THREE.BufferGeometry;\n    const attributes = geometry.attributes;\n    const position = attributes.position as THREE.BufferAttribute;\n    const bitangent = attributes.bitangent;\n    const indices = geometry.index!.array;\n\n    tmpSphere.copy(bSphere);\n    tmpSphere.applyMatrix4(mesh.matrixWorld);\n    tmpSphere.radius += halfWidth;\n\n    if (!raycaster.ray.intersectsSphere(tmpSphere)) {\n        return;\n    }\n\n    for (let i = beginIdx; i < endIdx; i += SEGMENT_STRIDE) {\n        const a = indices[i];\n        const b = indices[i + VERTEX_STRIDE];\n\n        // Find the plane containing the line segment, using the segment start, end and extrusion\n        // vector.\n        line.start.fromBufferAttribute(position, a);\n        line.end.fromBufferAttribute(position, b);\n        vExt.set(bitangent.getX(a), bitangent.getY(a), bitangent.getZ(a)).normalize();\n        plane.setFromCoplanarPoints(line.start, tmpV3.copy(line.start).add(vExt), line.end);\n        if (plane.normal.manhattanLength() === 0) {\n            // Invalid plane, coplanar points are actually collinear because:\n            // a) The line segment has length 0.\n            // b) The extrusion vector has length 0.\n            // c) The extrusion and segment directions are the same.\n            // In any case it's a degenerate segment, skip it.\n            continue;\n        }\n\n        // The ray intersection if any, will be on the extrusion plane.\n        if (!localRay.intersectPlane(plane, interPlane)) {\n            continue;\n        }\n\n        const interLine = tmpV3;\n        if (\n            !intersectLine(\n                localRay,\n                line,\n                vExt,\n                lHalfWidth,\n                lHalfWidthSq,\n                plane,\n                interPlane,\n                interLine\n            )\n        ) {\n            continue;\n        }\n\n        // Move back to world space for distance calculation\n        const interLineWorld = interLine.applyMatrix4(mesh.matrixWorld);\n\n        const distance = raycaster.ray.origin.distanceTo(interLineWorld);\n\n        if (distance < raycaster.near || distance > raycaster.far) {\n            continue;\n        }\n\n        intersections.push({\n            distance,\n            point: interLineWorld.clone(),\n            index: i,\n            object: mesh\n        });\n    }\n}\n\nconst singleFeatureStart = [0];\nconst MAX_SCALE_RATIO_DIFF = 1e-2;\n\n/**\n * Finds the intersections of a ray with a group within a solid line mesh.\n * @param mesh - The mesh whose intersections will be found.\n * @param material - The material used by the group inside the mesh.\n * @param raycaster -  Contains the intersection ray.\n * @param localRay - Same ray as raycaster.ray but in object's local space.\n * @param firstFeatureIdx - Index of the first feature in the group.\n * @param groupEndIdx - Index of the last vertex in the group.\n * @param intersections -  Array where all intersections found between ray and group will be pushed.\n * @returns The next feature index after the group.\n */\nfunction intersectGroup(\n    mesh: THREE.Mesh,\n    material: THREE.Material,\n    raycaster: THREE.Raycaster,\n    localRay: THREE.Ray,\n    firstFeatureIdx: number,\n    groupEndIdx: number,\n    intersections: THREE.Intersection[]\n): number {\n    const bVolumes = mesh.userData.feature.boundingVolumes;\n    assert(mesh.geometry instanceof THREE.BufferGeometry, \"Unsupported geometry type.\");\n    const geometry = mesh.geometry as THREE.BufferGeometry;\n    assert(isSolidLineMaterial(material), \"Unsupported material type\");\n    const solidLineMaterial = material as SolidLineMaterial;\n\n    const halfWidth = (solidLineMaterial.lineWidth + solidLineMaterial.outlineWidth) / 2;\n    // Assumption: scaling is uniform or close enough to use a local width independent of direction.\n    assert(Math.abs(1 - mesh.scale.x / mesh.scale.y) < MAX_SCALE_RATIO_DIFF);\n    assert(Math.abs(1 - mesh.scale.x / mesh.scale.z) < MAX_SCALE_RATIO_DIFF);\n    assert(Math.abs(1 - mesh.scale.y / mesh.scale.z) < MAX_SCALE_RATIO_DIFF);\n    const localHalfWidth = halfWidth / ((mesh.scale.x + mesh.scale.y + mesh.scale.z) / 3);\n    const localHalfWidthSq = localHalfWidth * localHalfWidth;\n    const featureStarts = mesh.userData.feature.starts ?? singleFeatureStart;\n\n    let featureIdx = firstFeatureIdx;\n    let beginIdx = featureStarts[featureIdx];\n    const lastFeatureIdx = featureStarts.length - 1;\n\n    while (beginIdx < groupEndIdx) {\n        const bVolumeIdx = featureIdx;\n        const endIdx = featureIdx < lastFeatureIdx ? featureStarts[++featureIdx] : groupEndIdx;\n        if (bVolumeIdx >= bVolumes.length) {\n            // Geometry might be extruded on any direction. To avoid extruding all vertices, the\n            // centerline geometry is used to compute a bounding sphere whose radius is later\n            // expanded by the extrusion half width to ensure it contains the extruded geometry.\n            bVolumes.push(computeFeatureBoundingSphere(geometry, beginIdx, endIdx));\n        }\n        intersectFeature(\n            mesh,\n            raycaster,\n            localRay,\n            halfWidth,\n            localHalfWidth,\n            localHalfWidthSq,\n            beginIdx,\n            endIdx,\n            bVolumes[bVolumeIdx],\n            intersections\n        );\n        beginIdx = endIdx;\n    }\n    return featureIdx;\n}\n\n/**\n * Mesh formed by extruding a polyline in the shaders. Overrides raycasting behaviour to account for\n * extrusion, see [[SolidLineMaterial]].\n * @internal\n */\nexport class SolidLineMesh extends THREE.Mesh {\n    /**\n     * Finds the intersections of a ray with a mesh, assuming the mesh is a polyline extruded in\n     * the shaders (see [[SolidLineMaterial]]).\n     * @param mesh - The mesh whose intersections will be found.\n     * @param raycaster - Contains the intersection ray.\n     * @param intersections - Array where all intersections found between ray and mesh will\n     *                        be pushed.\n     */\n    static raycast(\n        mesh: THREE.Mesh,\n        raycaster: THREE.Raycaster,\n        intersections: THREE.Intersection[]\n    ): void {\n        assert(mesh.geometry instanceof THREE.BufferGeometry, \"Unsupported geometry type\");\n        const geometry = mesh.geometry as THREE.BufferGeometry;\n        assert(geometry.index !== null, \"Geometry does not have indices\");\n        const matrixWorld = mesh.matrixWorld;\n\n        tmpInverseMatrix.getInverse(matrixWorld);\n        const localRay = tmpRay.copy(raycaster.ray).applyMatrix4(tmpInverseMatrix);\n\n        // Test intersection of ray with each of the features within the mesh.\n        if (!mesh.userData.feature) {\n            mesh.userData.feature = {};\n        }\n        if (!mesh.userData.feature.boundingVolumes) {\n            mesh.userData.feature.boundingVolumes = [];\n        }\n        const indices = geometry.index!.array;\n\n        if (Array.isArray(mesh.material)) {\n            let nextFeatureIdx = 0;\n            for (const group of geometry.groups) {\n                const material = mesh.material[group.materialIndex!];\n                const groupEndIdx = group.start + group.count;\n                nextFeatureIdx = intersectGroup(\n                    mesh,\n                    material,\n                    raycaster,\n                    localRay,\n                    nextFeatureIdx,\n                    groupEndIdx,\n                    intersections\n                );\n            }\n        } else {\n            intersectGroup(\n                mesh,\n                mesh.material,\n                raycaster,\n                localRay,\n                0,\n                indices.length,\n                intersections\n            );\n        }\n    }\n\n    /**\n     * Creates an instance of SolidLineMesh.\n     * @param geometry - Mesh geometry.\n     * @param material - Material(s) to be used by the mesh. They must be instances of\n     * [[SolidLineMaterial]].\n     */\n    constructor(geometry: THREE.BufferGeometry, material: THREE.Material | THREE.Material[]) {\n        super(geometry, material);\n    }\n\n    // HARP-9585: Override of base class method, however tslint doesn't recognize it as such.\n    // tslint:disable-next-line: explicit-override\n    raycast(raycaster: THREE.Raycaster, intersects: THREE.Intersection[]): void {\n        SolidLineMesh.raycast(this, raycaster, intersects);\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Vector3Like } from \"@here/harp-geoutils\";\nimport * as THREE from \"three\";\n\n/**\n * This path in world coordinates is projected to screen space and blocks all other labels.\n *\n * It could be used for example:\n * - Border rejects labels.\n * - Route blocks street labels from being rendered underneath.\n *\n * Could potentially be expanded in future to have a priority, however for now, this isn't required.\n */\n\nexport class PathBlockingElement {\n    /**\n     * Note, [[screenSpaceLines]] is only used as a performance improvement and contains no\n     * useful information. They are used to contain the screen space coordinates of the\n     * points. By allocating the space here, we avoid per frame allocations, see\n     * [[TextElementsRenderer.prepopulateScreenWithBlockingElements]].\n     */\n    readonly screenSpaceLines: THREE.Line3[];\n\n    /**\n     * Constructs a path from a list of points.\n     * Pre allocates the [[screenSpaceLines]] used to render.\n     * @param points - Points in world coordinates.\n     */\n    constructor(readonly points: Vector3Like[]) {\n        this.screenSpaceLines = new Array<THREE.Line3>(points.length >= 2 ? points.length - 1 : 0);\n        for (let i = 0; i < this.screenSpaceLines.length; i++) {\n            this.screenSpaceLines[i] = new THREE.Line3(new THREE.Vector3(), new THREE.Vector3());\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { Math2D } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { MemoryUsage } from \"@here/harp-text-canvas\";\nimport { getPixelFromImage, screenToUvCoordinates } from \"./PixelPicker\";\n\n/**\n * Declares an interface for a `struct` containing a [[BoxBuffer]]'s attribute state information.\n */\nexport interface State {\n    positionAttributeCount: number;\n    colorAttributeCount: number;\n    uvAttributeCount: number;\n    indexAttributeCount: number;\n    pickInfoCount: number;\n}\n\n/**\n * Initial number of boxes in BoxBuffer.\n */\nconst START_BOX_BUFFER_SIZE = 0;\n\n/**\n * Maximum number of boxes in BoxBuffer.\n */\nconst MAX_BOX_BUFFER_SIZE = 32 * 1024;\n\n/**\n * Number of vertices per box/glyph element: 4 corners.\n */\nconst NUM_VERTICES_PER_ELEMENT = 4;\n\n/**\n * Number of indices added per box/glyph: 2 triangles, 6 indices.\n */\nconst NUM_INDICES_PER_ELEMENT = 6;\n\n/**\n * Number of values per position.\n */\nconst NUM_POSITION_VALUES_PER_VERTEX = 3;\n\n/**\n * Number of values per color.\n */\nconst NUM_COLOR_VALUES_PER_VERTEX = 4;\n\n/**\n * Number of values per UV.\n */\nconst NUM_UV_VALUES_PER_VERTEX = 4;\n\n/**\n * Number of values per index.\n */\nconst NUM_INDEX_VALUES_PER_VERTEX = 1;\n\n/**\n * Number of bytes for float in an Float32Array.\n */\nconst NUM_BYTES_PER_FLOAT = 4;\n\n/**\n * Number of bytes for integer number in an UInt32Array.\n */\nconst NUM_BYTES_PER_INT32 = 4;\n\n/**\n * SubClass of [[THREE.Mesh]] to identify meshes that have been created by [[BoxBuffer]] and\n * [[TextBuffer]]. Add the isEmpty flag to quickly test for empty meshes.\n */\nexport class BoxBufferMesh extends THREE.Mesh {\n    constructor(geometry: THREE.BufferGeometry, material: THREE.Material | THREE.Material[]) {\n        super(geometry, material);\n\n        this.type = \"BoxBufferMesh\";\n    }\n\n    /**\n     * A mesh that has no positions and indices set is defined to be empty.\n     *\n     * @returns `True` if no indices have been added to the mesh.\n     */\n    get isEmpty(): boolean {\n        if (this.geometry === undefined) {\n            return true;\n        } else {\n            const bufferGeometry = this.geometry as THREE.BufferGeometry;\n            return bufferGeometry.index === null || bufferGeometry.index.count === 0;\n        }\n    }\n}\n\n/**\n * Buffer for (untransformed) `Box2` objects. Can be used to create a single geometry for screen-\n * aligned boxes, like POIs.\n */\nexport class BoxBuffer {\n    /**\n     * {@link @here/harp-datasource-protocol#BufferAttribute} holding the `BoxBuffer` position data.\n     */\n    protected positionAttribute?: THREE.BufferAttribute;\n\n    /**\n     * {@link @here/harp-datasource-protocol#BufferAttribute} holding the `BoxBuffer` color data.\n     */\n    protected colorAttribute?: THREE.BufferAttribute;\n\n    /**\n     * {@link @here/harp-datasource-protocol#BufferAttribute} holding the `BoxBuffer` uv data.\n     */\n    protected uvAttribute?: THREE.BufferAttribute;\n\n    /**\n     * {@link @here/harp-datasource-protocol#BufferAttribute} holding the `BoxBuffer` index data.\n     */\n    protected indexAttribute?: THREE.BufferAttribute;\n    protected pickInfos: Array<any | undefined>;\n\n    /**\n     * [[BufferGeometry]] holding all the different\n     * {@link @here/harp-datasource-protocol#BufferAttribute}s.\n     */\n    protected geometry: THREE.BufferGeometry | undefined;\n\n    /**\n     * [[Mesh]] used for rendering.\n     */\n    protected internalMesh: BoxBufferMesh | undefined;\n\n    private m_size: number = 0;\n\n    /**\n     * Creates a new `BoxBuffer`.\n     *\n     * @param material - Material to be used for [[Mesh]] of this `BoxBuffer`.\n     * @param renderOrder - Optional renderOrder of this buffer.\n     * @param startElementCount - Initial number of elements this `BoxBuffer` can hold.\n     * @param maxElementCount - Maximum number of elements this `BoxBuffer` can hold.\n     */\n    constructor(\n        readonly material: THREE.Material | THREE.Material[],\n        readonly renderOrder: number = 0,\n        readonly startElementCount = START_BOX_BUFFER_SIZE,\n        readonly maxElementCount = MAX_BOX_BUFFER_SIZE\n    ) {\n        this.resizeBuffer(startElementCount);\n        this.pickInfos = new Array();\n    }\n\n    /**\n     * Duplicate this `BoxBuffer` with same material and renderOrder.\n     *\n     * @returns A clone of this `BoxBuffer`.\n     */\n    clone(): BoxBuffer {\n        return new BoxBuffer(this.material, this.renderOrder);\n    }\n\n    /**\n     * Dispose of the geometry.\n     */\n    dispose() {\n        if (this.geometry !== undefined) {\n            this.geometry.dispose();\n            this.geometry = undefined;\n        }\n        this.internalMesh = undefined;\n    }\n\n    /**\n     * Return the current number of elements the buffer can hold.\n     */\n    get size(): number {\n        return this.m_size;\n    }\n\n    /**\n     * Clear's the `BoxBuffer` attribute buffers.\n     */\n    reset() {\n        if (this.positionAttribute !== undefined) {\n            this.positionAttribute.count = 0;\n            this.colorAttribute!.count = 0;\n            this.uvAttribute!.count = 0;\n            this.indexAttribute!.count = 0;\n            this.pickInfos!.length = 0;\n        }\n    }\n\n    /**\n     * Returns `true` if this `BoxBuffer` can hold the specified amount of glyphs. If the buffer\n     * can only add the glyph by increasing the buffer size, the resize() method is called, which\n     * will then create a new geometry for the mesh.\n     *\n     * @param glyphCount - Number of glyphs to be added to the buffer.\n     * @returns `true` if the element (box or glyph) can be added to the buffer, `false` otherwise.\n     */\n    canAddElements(glyphCount = 1): boolean {\n        const indexAttribute = this.indexAttribute!;\n        if (\n            indexAttribute.count + glyphCount * NUM_INDICES_PER_ELEMENT >=\n            indexAttribute.array.length\n        ) {\n            // Too many elements for the current buffer, check if we can resize the buffer.\n            if (indexAttribute.array.length >= this.maxElementCount * NUM_INDICES_PER_ELEMENT) {\n                return false;\n            }\n\n            const newSize = Math.min(this.maxElementCount, this.size === 0 ? 256 : this.size * 2);\n            this.resize(newSize);\n        }\n        return true;\n    }\n\n    /**\n     * Returns this `BoxBuffer`'s attribute [[State]].\n     */\n    saveState(): State {\n        const state: State = {\n            positionAttributeCount: this.positionAttribute!.count,\n            colorAttributeCount: this.colorAttribute!.count,\n            uvAttributeCount: this.uvAttribute!.count,\n            indexAttributeCount: this.indexAttribute!.count,\n            pickInfoCount: this.pickInfos!.length\n        };\n        return state;\n    }\n\n    /**\n     * Store this `BoxBuffer`'s attribute [[State]] to a previously stored one.\n     *\n     * @param state - [[State]] struct describing a previous attribute state.\n     */\n    restoreState(state: State) {\n        this.positionAttribute!.count = state.positionAttributeCount;\n        this.colorAttribute!.count = state.colorAttributeCount;\n        this.uvAttribute!.count = state.uvAttributeCount;\n        this.indexAttribute!.count = state.indexAttributeCount;\n        this.pickInfos!.length = state.pickInfoCount;\n    }\n\n    /**\n     * Adds a new box to this `BoxBuffer`.\n     *\n     * @param screenBox - [[Math2D.Box]] holding screen coordinates for this box.\n     * @param uvBox - [[Math2D.UvBox]] holding uv coordinates for this box.\n     * @param color - Box's color.\n     * @param opacity - Box's opacity.\n     * @param distance - Box's distance to camera.\n     * @param pickInfo - Box's picking information.\n     */\n    addBox(\n        screenBox: Math2D.Box,\n        uvBox: Math2D.UvBox,\n        color: THREE.Color,\n        opacity: number,\n        distance: number,\n        pickInfo?: any\n    ): boolean {\n        if (!this.canAddElements()) {\n            return false;\n        }\n\n        const { s0, t0, s1, t1 } = uvBox;\n        const { x, y, w, h } = screenBox;\n\n        const r = Math.round(color.r * 255);\n        const g = Math.round(color.g * 255);\n        const b = Math.round(color.b * 255);\n        const a = Math.round(opacity * 255);\n\n        const positionAttribute = this.positionAttribute!;\n        const colorAttribute = this.colorAttribute!;\n        const uvAttribute = this.uvAttribute!;\n        const indexAttribute = this.indexAttribute!;\n\n        const baseVertex = positionAttribute.count;\n        const baseIndex = indexAttribute.count;\n\n        positionAttribute.setXYZ(baseVertex, x, y, distance);\n        positionAttribute.setXYZ(baseVertex + 1, x + w, y, distance);\n        positionAttribute.setXYZ(baseVertex + 2, x, y + h, distance);\n        positionAttribute.setXYZ(baseVertex + 3, x + w, y + h, distance);\n\n        colorAttribute.setXYZW(baseVertex, r, g, b, a);\n        colorAttribute.setXYZW(baseVertex + 1, r, g, b, a);\n        colorAttribute.setXYZW(baseVertex + 2, r, g, b, a);\n        colorAttribute.setXYZW(baseVertex + 3, r, g, b, a);\n\n        uvAttribute.setXY(baseVertex, s0, t0);\n        uvAttribute.setXY(baseVertex + 1, s1, t0);\n        uvAttribute.setXY(baseVertex + 2, s0, t1);\n        uvAttribute.setXY(baseVertex + 3, s1, t1);\n\n        indexAttribute.setX(baseIndex, baseVertex);\n        indexAttribute.setX(baseIndex + 1, baseVertex + 1);\n        indexAttribute.setX(baseIndex + 2, baseVertex + 2);\n        indexAttribute.setX(baseIndex + 3, baseVertex + 2);\n        indexAttribute.setX(baseIndex + 4, baseVertex + 1);\n        indexAttribute.setX(baseIndex + 5, baseVertex + 3);\n\n        positionAttribute.count += NUM_VERTICES_PER_ELEMENT;\n        colorAttribute.count += NUM_VERTICES_PER_ELEMENT;\n        uvAttribute.count += NUM_VERTICES_PER_ELEMENT;\n        indexAttribute.count += NUM_INDICES_PER_ELEMENT;\n\n        this.pickInfos.push(pickInfo);\n\n        return true;\n    }\n\n    /**\n     * Updates a [[BufferGeometry]] object to reflect the changes in this `TextBuffer`'s attribute\n     * data.\n     */\n    updateBufferGeometry() {\n        const positionAttribute = this.positionAttribute!;\n        const colorAttribute = this.colorAttribute!;\n        const uvAttribute = this.uvAttribute!;\n        const indexAttribute = this.indexAttribute!;\n\n        if (positionAttribute.count > 0) {\n            positionAttribute.needsUpdate = true;\n            positionAttribute.updateRange.offset = 0;\n            positionAttribute.updateRange.count =\n                positionAttribute.count * NUM_VERTICES_PER_ELEMENT;\n        }\n\n        if (colorAttribute.count > 0) {\n            colorAttribute.needsUpdate = true;\n            colorAttribute.updateRange.offset = 0;\n            colorAttribute.updateRange.count = colorAttribute.count * NUM_VERTICES_PER_ELEMENT;\n        }\n\n        if (uvAttribute.count > 0) {\n            uvAttribute.needsUpdate = true;\n            uvAttribute.updateRange.offset = 0;\n            uvAttribute.updateRange.count = uvAttribute.count * NUM_VERTICES_PER_ELEMENT;\n        }\n\n        if (indexAttribute.count > 0) {\n            indexAttribute.needsUpdate = true;\n            indexAttribute.updateRange.offset = 0;\n            indexAttribute.updateRange.count = indexAttribute.count;\n        }\n\n        if (this.geometry !== undefined) {\n            this.geometry.clearGroups();\n            this.geometry.addGroup(0, this.indexAttribute!.count);\n        }\n    }\n\n    /**\n     * Check if the buffer is empty. If it is empty, the memory usage is minimized to reduce\n     * footprint.\n     */\n    cleanUp() {\n        // If there is nothing in this buffer, resize it, it may never be used again.\n        if (this.indexAttribute!.count === 0 && this.size > START_BOX_BUFFER_SIZE) {\n            this.clearAttributes();\n        }\n    }\n\n    /**\n     * Determine if the mesh is empty.\n     */\n    get isEmpty(): boolean {\n        return this.internalMesh!.isEmpty;\n    }\n\n    /**\n     * Get the [[Mesh]] object. The geometry instance of the mesh may change if the buffers are\n     * resized. The mesh, once created, will not change, so it can always be added to the scene.\n     */\n    get mesh(): BoxBufferMesh {\n        if (this.internalMesh === undefined) {\n            this.resize();\n        }\n        return this.internalMesh!;\n    }\n\n    /**\n     * Fill the picking results for the pixel with the given screen coordinate. If multiple\n     * boxes are found, the order of the results is unspecified.\n     *\n     * @param screenPosition - Screen coordinate of picking position.\n     * @param pickCallback - Callback to be called for every picked element.\n     * @param imageData - Image data to test if the pixel is transparent\n     */\n    pickBoxes(\n        screenPosition: THREE.Vector2,\n        pickCallback: (pickData: any | undefined) => void,\n        imageData?: ImageBitmap | ImageData\n    ) {\n        const n = this.pickInfos.length;\n        const pickInfos = this.pickInfos;\n        const positions = this.positionAttribute!;\n        const screenX = screenPosition.x;\n        const screenY = screenPosition.y;\n\n        const canvas = document.createElement(\"canvas\");\n        for (let pickInfoIndex = 0; pickInfoIndex < n; pickInfoIndex++) {\n            const positionIndex = pickInfoIndex * NUM_VERTICES_PER_ELEMENT;\n\n            const minX = positions.getX(positionIndex);\n            if (screenX < minX) {\n                continue;\n            }\n\n            const maxX = positions.getX(positionIndex + 1);\n            if (screenX > maxX) {\n                continue;\n            }\n\n            const minY = positions.getY(positionIndex);\n            if (screenY < minY) {\n                continue;\n            }\n\n            const maxY = positions.getY(positionIndex + 2);\n            if (screenY > maxY) {\n                continue;\n            }\n\n            const box = new Math2D.Box(minX, minY, maxX - minX, maxY - minY);\n            if (\n                imageData !== undefined &&\n                pickInfos[pickInfoIndex].poiInfo !== undefined &&\n                pickInfos[pickInfoIndex].poiInfo.uvBox !== undefined &&\n                this.isPixelTransparent(\n                    imageData,\n                    screenX,\n                    screenY,\n                    box,\n                    pickInfos[pickInfoIndex].poiInfo.uvBox,\n                    canvas\n                )\n            ) {\n                continue;\n            }\n\n            if (pickInfos[pickInfoIndex] !== undefined) {\n                pickCallback(pickInfos[pickInfoIndex]);\n            }\n        }\n    }\n\n    /**\n     * Creates a new {@link @here/harp-datasource-protocol#Geometry} object\n     * from all the attribute data stored in this `BoxBuffer`.\n     *\n     * @remarks\n     * The [[Mesh]] object may be created if it is not initialized already.\n     *\n     * @param newSize - Optional number of elements to resize the buffer to.\n     * @param forceResize - Optional flag to force a resize even if new size is smaller than before.\n     */\n    resize(newSize?: number, forceResize?: boolean): BoxBufferMesh {\n        if (this.geometry !== undefined) {\n            this.geometry.dispose();\n        }\n\n        this.geometry = new THREE.BufferGeometry();\n\n        if (newSize !== undefined && (forceResize === true || newSize > this.size)) {\n            this.resizeBuffer(newSize);\n        }\n\n        this.geometry.setAttribute(\"position\", this.positionAttribute!);\n        this.geometry.setAttribute(\"color\", this.colorAttribute!);\n        this.geometry.setAttribute(\"uv\", this.uvAttribute!);\n        this.geometry.setIndex(this.indexAttribute!);\n        this.geometry.addGroup(0, this.indexAttribute!.count);\n\n        if (this.internalMesh === undefined) {\n            this.internalMesh = new BoxBufferMesh(this.geometry, this.material);\n            this.internalMesh.renderOrder = this.renderOrder;\n        } else {\n            this.internalMesh.geometry = this.geometry;\n        }\n        return this.internalMesh;\n    }\n\n    /**\n     * Update the info with the memory footprint caused by objects owned by the `BoxBuffer`.\n     *\n     * @param info - The info object to increment with the values from this `BoxBuffer`.\n     */\n    updateMemoryUsage(info: MemoryUsage) {\n        const numBytes =\n            this.positionAttribute!.count * NUM_POSITION_VALUES_PER_VERTEX * NUM_BYTES_PER_FLOAT +\n            this.colorAttribute!.count * NUM_COLOR_VALUES_PER_VERTEX +\n            this.uvAttribute!.count * NUM_UV_VALUES_PER_VERTEX * NUM_BYTES_PER_FLOAT +\n            this.indexAttribute!.count * NUM_BYTES_PER_INT32; // May be UInt16, so we overestimate\n\n        info.heapSize += numBytes;\n        info.gpuSize += numBytes;\n    }\n\n    /**\n     * Check if a pixel is transparent or not.\n     *\n     * @param imageData - Data containing the pixels.\n     * @param xScreenPos - X position of the pixel.\n     * @param yScreenPos - Y position of the pixel.\n     * @param box - Bounding box of the image in screen coordinates.\n     * @param uvBox - Uv box referred to the given bounding box.\n     * @param canvas - Canvas element that will be used to draw the image, in case the imageData is\n     *      an `ImageBitmap`\n     */\n    protected isPixelTransparent(\n        imageData: ImageBitmap | ImageData,\n        xScreenPos: number,\n        yScreenPos: number,\n        box: Math2D.Box,\n        uvBox: Math2D.UvBox,\n        canvas?: HTMLCanvasElement\n    ): boolean {\n        let pixelIsTransparent = false;\n\n        const { u, v } = screenToUvCoordinates(xScreenPos, yScreenPos, box, uvBox);\n\n        const imageWidth = imageData.width;\n        const x = imageWidth * u;\n        const imageHeight = imageData.height;\n        const y = imageHeight * v;\n\n        const pixel = getPixelFromImage(x, y, imageData, canvas);\n\n        if (pixel !== undefined && pixel[3] === 0) {\n            pixelIsTransparent = true;\n        }\n        return pixelIsTransparent;\n    }\n\n    /**\n     * Remove current attributes and arrays. Minimizes memory footprint.\n     */\n    protected clearAttributes() {\n        this.positionAttribute = undefined;\n        this.colorAttribute = undefined;\n        this.uvAttribute = undefined;\n        this.indexAttribute = undefined;\n        this.resize(START_BOX_BUFFER_SIZE, true);\n    }\n\n    /**\n     * Resize the attribute buffers. New value must be larger than the previous one.\n     *\n     * @param newSize - New number of elements in the buffer. Number has to be larger than the\n     *      previous size.\n     */\n    protected resizeBuffer(newSize: number) {\n        const newPositionArray = new Float32Array(\n            newSize * NUM_VERTICES_PER_ELEMENT * NUM_POSITION_VALUES_PER_VERTEX\n        );\n\n        if (this.positionAttribute !== undefined && this.positionAttribute.array.length > 0) {\n            const positionAttributeCount = this.positionAttribute.count;\n            newPositionArray.set(this.positionAttribute.array);\n            this.positionAttribute.array = newPositionArray;\n            this.positionAttribute.count = positionAttributeCount;\n        } else {\n            this.positionAttribute = new THREE.BufferAttribute(\n                newPositionArray,\n                NUM_POSITION_VALUES_PER_VERTEX\n            );\n            this.positionAttribute.count = 0;\n            this.positionAttribute.setUsage(THREE.DynamicDrawUsage);\n        }\n\n        const newColorArray = new Uint8Array(\n            newSize * NUM_VERTICES_PER_ELEMENT * NUM_COLOR_VALUES_PER_VERTEX\n        );\n\n        if (this.colorAttribute !== undefined) {\n            const colorAttributeCount = this.colorAttribute.count;\n            newColorArray.set(this.colorAttribute.array);\n            this.colorAttribute.array = newColorArray;\n            this.colorAttribute.count = colorAttributeCount;\n        } else {\n            this.colorAttribute = new THREE.BufferAttribute(\n                newColorArray,\n                NUM_COLOR_VALUES_PER_VERTEX,\n                true\n            );\n            this.colorAttribute.count = 0;\n            this.colorAttribute.setUsage(THREE.DynamicDrawUsage);\n        }\n\n        const newUvArray = new Float32Array(\n            newSize * NUM_VERTICES_PER_ELEMENT * NUM_UV_VALUES_PER_VERTEX\n        );\n\n        if (this.uvAttribute !== undefined) {\n            const uvAttributeCount = this.uvAttribute.count;\n            newUvArray.set(this.uvAttribute.array);\n            this.uvAttribute.array = newUvArray;\n            this.uvAttribute.count = uvAttributeCount;\n        } else {\n            this.uvAttribute = new THREE.BufferAttribute(newUvArray, NUM_UV_VALUES_PER_VERTEX);\n            this.uvAttribute.count = 0;\n            this.uvAttribute.setUsage(THREE.DynamicDrawUsage);\n        }\n\n        const numIndexValues = newSize * NUM_INDICES_PER_ELEMENT * NUM_INDEX_VALUES_PER_VERTEX;\n\n        const newIndexArray =\n            numIndexValues > 65535\n                ? new Uint32Array(numIndexValues)\n                : new Uint16Array(numIndexValues);\n\n        if (this.indexAttribute !== undefined) {\n            const indexAttributeCount = this.indexAttribute.count;\n            newIndexArray.set(this.indexAttribute.array);\n            this.indexAttribute.array = newIndexArray;\n            this.indexAttribute.count = indexAttributeCount;\n        } else {\n            this.indexAttribute = new THREE.BufferAttribute(\n                newIndexArray,\n                NUM_INDEX_VALUES_PER_VERTEX\n            );\n            this.indexAttribute.count = 0;\n            this.indexAttribute.setUsage(THREE.DynamicDrawUsage);\n        }\n\n        this.m_size = newSize;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Math2D, MathUtils } from \"@here/harp-utils\";\n\n/**\n * It returns an array containing the channel colors for the pixel at the given coordinates.\n *\n * @param xPos - X value of the pixel.\n * @param yPos - Y value of the pixel.\n * @param imageData - Data containing the pixels.\n * @param canvas - Canvas element that will be used to draw the image, in case the imageData is an\n * ImageBitmap\n */\nexport function getPixelFromImage(\n    xPos: number,\n    yPos: number,\n    imageData: ImageData | ImageBitmap,\n    canvas?: HTMLCanvasElement\n): Uint8ClampedArray | undefined {\n    let pickedColor;\n\n    const isImageBitmap = (imgData: ImageBitmap | ImageData) => {\n        return (imgData as ImageBitmap).close !== undefined;\n    };\n\n    if (isImageBitmap(imageData!)) {\n        if (canvas === undefined) {\n            canvas = document.createElement(\"canvas\");\n        }\n        pickedColor = getPixelFromImageBitmap(imageData as ImageBitmap, xPos, yPos, canvas);\n    } else {\n        const pixelsData = imageData as ImageData;\n        const stride = pixelsData.data.length / (pixelsData.height * pixelsData.width);\n        pickedColor = getPixelFromImageData(pixelsData, xPos, yPos, stride);\n    }\n    return pickedColor;\n}\n\n/**\n * Given the x and y position in screen coordinates inside the target box, it map them to the UV\n * coordinates.\n * @param screenX - X value in screen coordinates.\n * @param screenY - Y value in screen coordinates.\n * @param box - Bounding box in screen coordinates.\n * @param uvBox - Uv box referred to the given bounding box.\n */\nexport function screenToUvCoordinates(\n    screenX: number,\n    screenY: number,\n    box: Math2D.Box,\n    uvBox: Math2D.UvBox\n): { u: number; v: number } {\n    const minX = box.x;\n    const maxX = box.x + box.w;\n    const minY = box.y;\n    const maxY = box.y + box.h;\n    const u = MathUtils.map(screenX, minX, maxX, uvBox.s0, uvBox.s1);\n    const v = MathUtils.map(screenY, minY, maxY, uvBox.t0, uvBox.t1);\n\n    return { u, v };\n}\n\n/**\n * It returns an Uint8ClampedArray containing the color channel values for the given pixel\n * coordinates. It returns undefined if the given coordinates are out of range.\n *\n * @param image - Bitmap image in which the pixels are stored.\n * @param xPos - X value of the pixel.\n * @param yPos - Y value of the pixel.\n * @param canvas - HTML Canvas element on which the image is drawn.\n */\nexport function getPixelFromImageBitmap(\n    image: ImageBitmap,\n    xPos: number,\n    yPos: number,\n    canvas: HTMLCanvasElement\n): Uint8ClampedArray | undefined {\n    if (xPos > image.width || xPos < 0 || yPos > image.height || yPos < 0) {\n        return undefined;\n    }\n\n    let pixelData;\n\n    canvas.width = image.width;\n    canvas.height = image.height;\n\n    const context = canvas.getContext(\"2d\");\n    if (context !== null) {\n        context.drawImage(\n            image,\n            0,\n            0,\n            image.width,\n            image.height,\n            0,\n            0,\n            canvas.width,\n            canvas.height\n        );\n        pixelData = context.getImageData(xPos, yPos, 1, 1).data;\n    }\n    return pixelData;\n}\n\n/**\n * It returns an Uint8ClampedArray containing the color channel values for the given pixel\n * coordinates. It returns undefined if the given coordinates are out of range.\n *\n * @param image - Image data in which the pixels are stored.\n * @param xPos - X value of the pixel.\n * @param yPos - Y value of the pixel.\n * @param stride - The stride value of the image data.\n */\nexport function getPixelFromImageData(\n    imgData: ImageData,\n    xPos: number,\n    yPos: number,\n    stride: number\n): Uint8ClampedArray | undefined {\n    const getPixel = (imageData: ImageData, index: number, strd: number) => {\n        const i = index * strd;\n        const d = imageData.data;\n        const pixel = new Uint8ClampedArray(strd);\n        for (let s = 0; s < strd; s++) {\n            pixel[0] = d[i + s];\n        }\n        return pixel;\n    };\n    if (xPos > imgData.width || xPos < 0 || yPos > imgData.height || yPos < 0) {\n        return undefined;\n    }\n    return getPixel(imgData, yPos * imgData.width + xPos, stride);\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { IChannel } from \"@here/harp-utils\";\n\nexport class PlacementStats {\n    totalGroups: number = 0;\n    resortedGroups: number = 0;\n    total: number = 0;\n    uninitialized: number = 0;\n    tooFar: number = 0;\n    numNotVisible: number = 0;\n    numPathTooSmall: number = 0;\n    numCannotAdd: number = 0;\n    numRenderedPoiIcons: number = 0;\n    numRenderedPoiTexts: number = 0;\n    numPoiTextsInvisible: number = 0;\n    numRenderedTextElements: number = 0;\n\n    constructor(private readonly m_logger: IChannel) {}\n\n    clear() {\n        this.totalGroups = 0;\n        this.resortedGroups = 0;\n        this.total = 0;\n        this.uninitialized = 0;\n        this.tooFar = 0;\n        this.numNotVisible = 0;\n        this.numPathTooSmall = 0;\n        this.numCannotAdd = 0;\n        this.numRenderedPoiIcons = 0;\n        this.numRenderedPoiTexts = 0;\n        this.numPoiTextsInvisible = 0;\n        this.numRenderedTextElements = 0;\n    }\n    log() {\n        const numNotRendered =\n            this.uninitialized +\n            this.numPoiTextsInvisible +\n            this.tooFar +\n            this.numNotVisible +\n            this.numCannotAdd;\n        this.m_logger.debug(\"Total groups\", this.totalGroups);\n        this.m_logger.debug(\"Resorted groups\", this.resortedGroups);\n        this.m_logger.debug(\"Total labels\", this.total);\n        this.m_logger.debug(\"Rendered labels\", this.numRenderedTextElements);\n        this.m_logger.debug(\"Rejected labels\", numNotRendered);\n        this.m_logger.debug(\"Unitialized labels\", this.uninitialized);\n        this.m_logger.debug(\"Rendered poi icons\", this.numRenderedPoiIcons);\n        this.m_logger.debug(\"Rendered poi texts\", this.numRenderedPoiTexts);\n        this.m_logger.debug(\"Poi text invisible\", this.numPoiTextsInvisible);\n        this.m_logger.debug(\"Too far\", this.tooFar);\n        this.m_logger.debug(\"Not visible\", this.numNotVisible);\n        this.m_logger.debug(\"Path too small\", this.numPathTooSmall);\n        this.m_logger.debug(\"Rejected, max glyphs reached\", this.numCannotAdd);\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\n/**\n * @hidden\n */\nexport class SimpleLineCurve extends THREE.LineCurve {\n    private m_lengths?: number[];\n\n    constructor(v1: THREE.Vector2, v2: THREE.Vector2) {\n        super(v1, v2);\n    }\n\n    getLengths(): number[] {\n        if (this.m_lengths === undefined) {\n            this.m_lengths = [0, this.v2.distanceTo(this.v1)];\n        }\n        return this.m_lengths;\n    }\n}\n\n/**\n * @hidden\n */\nexport class PathParam {\n    private m_point: THREE.Vector2 | undefined;\n\n    constructor(readonly path: THREE.Path, readonly index: number, readonly t: number) {}\n\n    get curve(): THREE.Curve<THREE.Vector2> {\n        return this.path.curves[this.index];\n    }\n\n    get point(): THREE.Vector2 {\n        if (this.m_point === undefined) {\n            this.m_point = this.curve.getPoint(this.t);\n        }\n        return this.m_point;\n    }\n}\n\n/**\n * @hidden\n */\nexport class SimplePath extends THREE.Path {\n    private m_cache?: number[];\n\n    constructor() {\n        super();\n    }\n\n    getLengths(): number[] {\n        if (this.m_cache) {\n            return this.m_cache;\n        }\n        let sum = 0;\n        const lengths = new Array<number>();\n        lengths.push(0);\n\n        this.curves.forEach(curve => {\n            const lineCurve = curve as THREE.LineCurve;\n            sum += lineCurve.v1.distanceTo(lineCurve.v2);\n            lengths.push(sum);\n        });\n        this.m_cache = lengths;\n        return lengths;\n    }\n\n    getParamAt(t: number): PathParam | null {\n        const distance = t * this.getLength();\n        const curveLengths = this.getCurveLengths();\n\n        for (let index = 0; index < curveLengths.length; ++index) {\n            if (curveLengths[index] < distance) {\n                continue;\n            }\n\n            const diff = curveLengths[index] - distance;\n            const curve = this.curves[index] as THREE.LineCurve;\n            const segmentLength = curve.getLength();\n            const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n            return new PathParam(this, index, u);\n        }\n\n        return null;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nconst DEFAULT_FONT_CATALOG = \"./resources/fonts/Default_FontCatalog.json\";\n\n/**\n * Default number of labels/POIs rendered in the scene\n */\nconst DEFAULT_MAX_NUM_RENDERED_TEXT_ELEMENTS = 500;\n\n/**\n * Number of elements that are put into second queue. This second chance queue is used to render\n * TextElements that have not been on screen before. This is a quick source for elements that can\n * appear when the camera moves a bit, before new elements are placed.\n */\nconst DEFAULT_MAX_NUM_SECOND_CHANCE_ELEMENTS = 300;\n\n/**\n * Maximum distance for text labels expressed as a ratio of distance to from the camera (0) to the\n * far plane (1.0). May be synchronized with fog value ?\n */\nconst DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS = 0.99;\n\n/**\n * Minimum scaling factor that may be applied to labels when their are distant from focus point.\n */\nconst DEFAULT_LABEL_DISTANCE_SCALE_MIN = 0.7;\n\n/**\n * Maximum scaling factor that may be applied to labels due to their distance from focus point.\n */\nconst DEFAULT_LABEL_DISTANCE_SCALE_MAX = 1.5;\n\nconst MIN_GLYPH_COUNT = 1024;\n\nconst MAX_GLYPH_COUNT = 32768;\n\nexport interface TextElementsRendererOptions {\n    /**\n     * The path to the font catalog file. Default is [[DEFAULT_FONT_CATALOG]].\n     */\n    fontCatalog?: string;\n    /**\n     * Optional initial number of glyphs (characters) for labels. In situations with limited,\n     * available memory, decreasing this number may be beneficial.\n     *\n     * @default [[MIN_GLYPH_COUNT]]\n     */\n    minNumGlyphs?: number;\n    /**\n     * Optional limit of number of glyphs (characters) for labels. In situations with limited,\n     * available memory, decreasing this number may be beneficial.\n     *\n     * @default [[MAX_GLYPH_COUNT]]\n     */\n    maxNumGlyphs?: number;\n    /**\n     * Limits the number of {@link DataSource} labels visible, such as road names and POIs.\n     * On small devices, you can reduce this number to to increase performance.\n     * @default [[DEFAULT_MAX_NUM_RENDERED_TEXT_ELEMENTS]].\n     */\n    maxNumVisibleLabels?: number;\n    /**\n     * The number of {@link TextElement}s that the {@link TextElementsRenderer} tries to render even\n     * if they were not visible during placement. This property only applies to {@link TextElement}s\n     * that were culled by the frustum; useful for map movements and animations.\n     * @default [[DEFAULT_MAX_NUM_SECOND_CHANCE_ELEMENTS]].\n     */\n    numSecondChanceLabels?: number;\n    /**\n     * The maximum distance for {@link TextElement} to be rendered, expressed as a fraction of\n     * the distance between the near and far plane [0, 1.0].\n     * @default [[DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS]].\n     */\n    maxDistanceRatioForTextLabels?: number;\n    /**\n     * The maximum distance for {@link TextElement} with icons to be rendered,\n     * expressed as a fraction of the distance\n     * between the near and far plane [0, 1.0].\n     * @default [[DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS]].\n     */\n    maxDistanceRatioForPoiLabels?: number;\n    /**\n     * The minimum scaling factor that may be applied to {@link TextElement}s due to their distance.\n     * If not defined the default value specified in {@link TextElementsRenderer} will be used.\n     * @default [[DEFAULT_LABEL_DISTANCE_SCALE_MIN]].\n     */\n    labelDistanceScaleMin?: number;\n    /**\n     * The maximum scaling factor that may be applied to {@link TextElement}s due to their distance.\n     * If not defined the default value specified in {@link TextElementsRenderer} will be used.\n     * @default [[DEFAULT_LABEL_DISTANCE_SCALE_MAX]].\n     */\n    labelDistanceScaleMax?: number;\n\n    /**\n     * Disable all fading animations for debugging and performance measurement.\n     * @default `false`\n     */\n    disableFading?: boolean;\n\n    /**\n     * Enable that new labels are delayed until movement is finished\n     * @default `true`\n     */\n    delayLabelsUntilMovementFinished?: boolean;\n}\n\n/**\n * Initializes undefined text renderer options to default values.\n * @param options - The options to be initialized.\n */\nexport function initializeDefaultOptions(options: TextElementsRendererOptions) {\n    if (options.fontCatalog === undefined) {\n        options.fontCatalog = DEFAULT_FONT_CATALOG;\n    }\n\n    if (options.minNumGlyphs === undefined) {\n        options.minNumGlyphs = MIN_GLYPH_COUNT;\n    }\n    if (options.maxNumGlyphs === undefined) {\n        options.maxNumGlyphs = MAX_GLYPH_COUNT;\n    }\n    if (options.maxNumVisibleLabels === undefined) {\n        options.maxNumVisibleLabels = DEFAULT_MAX_NUM_RENDERED_TEXT_ELEMENTS;\n    }\n    // TODO: Unused so far.\n    if (options.numSecondChanceLabels === undefined) {\n        options.numSecondChanceLabels = DEFAULT_MAX_NUM_SECOND_CHANCE_ELEMENTS;\n    }\n    if (options.labelDistanceScaleMin === undefined) {\n        options.labelDistanceScaleMin = DEFAULT_LABEL_DISTANCE_SCALE_MIN;\n    }\n    if (options.labelDistanceScaleMax === undefined) {\n        options.labelDistanceScaleMax = DEFAULT_LABEL_DISTANCE_SCALE_MAX;\n    }\n    if (options.maxDistanceRatioForTextLabels === undefined) {\n        options.maxDistanceRatioForTextLabels = DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS;\n    }\n    if (options.maxDistanceRatioForPoiLabels === undefined) {\n        options.maxDistanceRatioForPoiLabels = DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS;\n    }\n\n    if (options.disableFading === undefined) {\n        options.disableFading = false;\n    }\n\n    if (options.delayLabelsUntilMovementFinished === undefined) {\n        options.delayLabelsUntilMovementFinished = true;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { TileKey } from \"@here/harp-geoutils\";\nimport { assert, LoggerManager, LogLevel } from \"@here/harp-utils\";\nimport { TextElement } from \"./TextElement\";\nimport { TextElementGroup } from \"./TextElementGroup\";\nimport { TextElementFilter, TextElementGroupState } from \"./TextElementGroupState\";\nimport { TextElementState } from \"./TextElementState\";\nimport { TextElementType } from \"./TextElementType\";\n\nconst logger = LoggerManager.instance.create(\"TextElementsStateCache\", { level: LogLevel.Log });\n\n/**\n * Label distance tolerance squared in meters. Point labels with the same name that are closer in\n * world space than this value are treated as the same label. Used to identify duplicate labels in\n * overlapping tiles and label replacements at different storage levels.\n */\nfunction getDedupSqDistTolerance(zoomLevel: number) {\n    // Defining here a minimum tolerance of 10m at zoom level 13 or higher.\n    const minSqTol = 100;\n    const minSqTolLevel = 13;\n    const maxLevelDelta = 4;\n    const levelDelta = Math.min(\n        maxLevelDelta,\n        minSqTolLevel - Math.min(minSqTolLevel, Math.floor(zoomLevel))\n    );\n    // Distance tolerance computed applying a factor over an arbitrary minimum tolerance for a\n    // chosen zoom level. The factor is an exponential function on zoom level delta wrt minimum\n    // tolerance zoom level.\n    // error = sqrt(sqError) = sqrt(minSqError* 2^(4d)) = minError*2^(2d)\n\n    //tslint:disable-next-line: no-bitwise\n    return minSqTol << (levelDelta << 2);\n}\n\nconst tmpCachedDuplicate: { entries: TextElementState[]; index: number } = {\n    entries: [],\n    index: -1\n};\n\nfunction getCacheKey(element: TextElement): string | number {\n    return element.hasFeatureId() ? element.featureId! : element.text;\n}\n\n/**\n * Finds a duplicate for a text element among a list of candidates using their feature ids.\n * @param elementState - The state of the text element for which the duplicate will be found.\n * @param candidates - The list of candidates to check.\n * @returns The index of the candidate chosen as duplicate, or `undefined` if none was found.\n */\nfunction findDuplicateById(\n    elementState: TextElementState,\n    candidates: TextElementState[]\n): number | undefined {\n    // Cached entries with same feature id found, find the entry with the same tile offset.\n    const element = elementState.element;\n    const duplicateIndex = candidates.findIndex(\n        entry => entry.element.tileOffset === element.tileOffset\n    );\n    if (duplicateIndex === -1) {\n        return -1;\n    }\n    const candidate = candidates[duplicateIndex].element;\n    assert(element.featureId === candidate.featureId);\n\n    if (candidate.text !== element.text) {\n        // Labels with different text shouldn't share the same feature id. This points to\n        // an issue on the map data side. Submit a ticket to the corresponding map backend\n        // issue tracking system if available (e.g. OLPRPS project in JIRA for OMV),\n        // indicating affected labels including tile keys, texts and feature id.\n        logger.debug(\n            `Text feature id ${element.featureId} collision between \"${element.text} and \\\n             ${candidate.text}`\n        );\n        return undefined;\n    }\n    return duplicateIndex;\n}\n\ntype DuplicateCmp = (\n    newCandidate: TextElement,\n    newDistance: number,\n    oldCandidate: TextElement,\n    oldDistance: number\n) => boolean;\n\n// Duplicate criteria for path labels. Candidates are better the longer their paths are.\nfunction isBetterPathDuplicate(\n    newCandidate: TextElement,\n    _newDistance: number,\n    oldCandidate: TextElement,\n    _oldDistance: number\n): boolean {\n    if (newCandidate.pathLengthSqr === undefined) {\n        return false;\n    }\n    if (oldCandidate.pathLengthSqr === undefined) {\n        return false;\n    }\n    return newCandidate.pathLengthSqr > oldCandidate.pathLengthSqr;\n}\n\n// Duplicate criteria for point labels. Candidates are better the nearer they are to the label being\n// tested for duplicates.\nfunction isBetterPointDuplicate(\n    _newCandidate: TextElement,\n    newDistance: number,\n    _oldCandidate: TextElement,\n    oldDistance: number\n): boolean {\n    return newDistance < oldDistance;\n}\n\n/**\n * Finds a duplicate for a text element among a list of candidates using their text and distances.\n * @param elementState - The state of the text element for which the duplicate will be found.\n * @param candidates - The list of candidates to check.\n * @param zoomLevel - Current zoom level.\n * @returns The index of the candidate chosen as duplicate, or `undefined` if none was found.\n */\nfunction findDuplicateByText(\n    elementState: TextElementState,\n    candidates: TextElementState[],\n    zoomLevel: number\n): number {\n    const element = elementState.element;\n    const maxSqDistError = getDedupSqDistTolerance(zoomLevel);\n    const entryCount = candidates.length;\n    const elementPosition = element.position;\n    const elementVisible = elementState.visible;\n    let dupIndex: number = -1;\n    let duplicate: TextElement | undefined;\n    let dupDistSquared: number = Infinity;\n    const isBetterDuplicate: DuplicateCmp =\n        element.type === TextElementType.PoiLabel ? isBetterPointDuplicate : isBetterPathDuplicate;\n\n    for (let i = 0; i < entryCount; ++i) {\n        const candidateEntry = candidates[i];\n        const cachedElement = candidateEntry.element;\n        const areDiffType = element.type !== cachedElement.type;\n        const areBothVisible = elementVisible && candidateEntry.visible;\n        if (areDiffType || areBothVisible) {\n            // Two text elements with different type or visible at the same time are always\n            // considered distinct.\n            continue;\n        }\n        const distSquared = elementPosition.distanceToSquared(cachedElement.position);\n        if (distSquared > maxSqDistError) {\n            // Cached text element is too far away to be a duplicate.\n            continue;\n        }\n        if (\n            duplicate === undefined ||\n            isBetterDuplicate(cachedElement, distSquared, duplicate, dupDistSquared)\n        ) {\n            dupIndex = i;\n            duplicate = cachedElement;\n            dupDistSquared = distSquared;\n        }\n    }\n\n    return dupIndex;\n}\n\n/**\n * Caches the state of text element groups currently rendered as well as the text element states\n * belonging to them, including their fading state and text deduplication information.\n */\nexport class TextElementStateCache {\n    private readonly m_referenceMap = new Map<TextElementGroup, TextElementGroupState>();\n    private m_sortedGroupStates: TextElementGroupState[] | undefined;\n\n    // Cache for point labels which may have duplicates in same tile or in neighboring tiles.\n    private readonly m_textMap = new Map<string | number, TextElementState[]>();\n\n    /**\n     * Gets the state corresponding to a given text element group or sets a newly created state if\n     * not found. It updates the states of the text elements belonging to the group using the\n     * specified parameters.\n     * @param textElementGroup - The group of which the state will be obtained.\n     * @param tileKey - The key of the tile to which the group belongs.\n     * @param textElementFilter - Filter used to decide if a text element must be initialized,\n     * @see [[TextElementGroupState]] construction.\n     * @returns Tuple with the group state as first element and a boolean indicating whether the\n     * state was found in cache (`true`) or newly created (`false`) as second element.\n     */\n    getOrSet(\n        textElementGroup: TextElementGroup,\n        tileKey: TileKey,\n        textElementFilter: TextElementFilter\n    ): [TextElementGroupState, boolean] {\n        let groupState = this.get(textElementGroup);\n\n        if (groupState !== undefined) {\n            assert(groupState.size === textElementGroup.elements.length);\n            groupState.updateElements(textElementFilter);\n            return [groupState, true];\n        }\n\n        groupState = new TextElementGroupState(textElementGroup, tileKey, textElementFilter);\n        this.set(textElementGroup, groupState);\n\n        return [groupState, false];\n    }\n\n    get size(): number {\n        return this.m_referenceMap.size;\n    }\n\n    /**\n     * @returns All text element group states in the cache by group priority.\n     */\n    get sortedGroupStates(): TextElementGroupState[] {\n        if (this.m_sortedGroupStates === undefined) {\n            this.m_sortedGroupStates = Array.from(this.m_referenceMap.values());\n            this.m_sortedGroupStates.sort((a: TextElementGroupState, b: TextElementGroupState) => {\n                return b.group.priority - a.group.priority;\n            });\n        }\n\n        assert(this.m_referenceMap.size === this.m_sortedGroupStates.length);\n        return this.m_sortedGroupStates;\n    }\n\n    /**\n     * Updates state of all cached groups, discarding those that are not needed anymore.\n     * @param time - The current time.\n     * @param disableFading - `True` if fading is currently disabled, `false` otherwise.\n     * @param findReplacements - `True` to replace each visible unvisited text element with a\n     * visited duplicate.\n     * @param zoomLevel - Current zoom level.\n     * @returns `True` if any textElementGroup was evicted from cache, false otherwise.\n     */\n    update(time: number, disableFading: boolean, findReplacements: boolean, zoomLevel: number) {\n        const replaceCallback = findReplacements\n            ? this.replaceElement.bind(this, zoomLevel)\n            : undefined;\n\n        let anyEviction = false;\n        for (const [key, groupState] of this.m_referenceMap.entries()) {\n            if (groupState.visited) {\n                groupState.updateFading(time, disableFading);\n            } else {\n                if (findReplacements) {\n                    groupState.traverseVisibleElements(replaceCallback!);\n                }\n                this.m_referenceMap.delete(key);\n                this.m_sortedGroupStates = undefined;\n                anyEviction = true;\n            }\n        }\n        return anyEviction;\n    }\n\n    /**\n     * Clears visited state for all text element groups in cache.\n     */\n    clearVisited() {\n        for (const groupState of this.m_referenceMap.values()) {\n            groupState.visited = false;\n        }\n    }\n\n    clearTextCache() {\n        this.m_textMap.clear();\n    }\n\n    /**\n     * Clears the whole cache contents.\n     */\n    clear() {\n        this.m_referenceMap.clear();\n        this.m_sortedGroupStates = undefined;\n        this.m_textMap.clear();\n    }\n\n    /**\n     * Removes duplicates for a given text element.\n     *\n     * @param zoomLevel - Current zoom level.\n     * @param elementState - State of the text element to deduplicate.\n     * @returns True if it's the remaining element after deduplication, false if it's been marked\n     * as duplicate.\n     */\n    deduplicateElement(zoomLevel: number, elementState: TextElementState): boolean {\n        const cacheResult = this.findDuplicate(elementState, zoomLevel);\n\n        if (cacheResult === undefined) {\n            // Text not found so far, add this element to cache.\n            this.m_textMap.set(getCacheKey(elementState.element), [elementState]);\n            return true;\n        }\n\n        if (cacheResult.index === -1) {\n            // No duplicate found among elements with same text,add this one to cache.\n            cacheResult.entries.push(elementState);\n            return true;\n        }\n\n        // Duplicate found, check whether there's a label already visible and keep that one.\n        const cachedDuplicate = cacheResult.entries[cacheResult.index];\n\n        if (!cachedDuplicate.visible && elementState.visible) {\n            // New label is visible, substitute the cached label.\n            cacheResult.entries[cacheResult.index] = elementState;\n            cachedDuplicate.reset();\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Replaces a visible unvisited text element with a visited duplicate.\n     * @param zoomLevel - Current zoom level.\n     * @param elementState - State of the text element to deduplicate.\n     */\n    replaceElement(zoomLevel: number, elementState: TextElementState): void {\n        assert(elementState.visible);\n        const cacheResult = this.findDuplicate(elementState, zoomLevel);\n\n        if (cacheResult === undefined || cacheResult.index === -1) {\n            // No replacement found;\n            return;\n        }\n\n        const replacement = cacheResult.entries[cacheResult.index];\n        assert(!replacement.visible);\n\n        replacement.replace(elementState);\n    }\n\n    /**\n     * Gets the state corresponding to a given text element group.\n     * @param textElementGroup - The group of which the state will be obtained.\n     * @returns The group state if cached, otherwise `undefined`.\n     */\n    private get(textElementGroup: TextElementGroup): TextElementGroupState | undefined {\n        const groupState = this.m_referenceMap.get(textElementGroup);\n\n        if (groupState !== undefined) {\n            groupState.visited = true;\n        }\n        return groupState;\n    }\n\n    /**\n     * Sets a specified state for a given text element group.\n     * @param textElementGroup -  The group of which the state will be set.\n     * @param textElementGroupState - The state to set for the group.\n     */\n    private set(textElementGroup: TextElementGroup, textElementGroupState: TextElementGroupState) {\n        assert(textElementGroup.elements.length > 0);\n        this.m_referenceMap.set(textElementGroup, textElementGroupState);\n        this.m_sortedGroupStates = undefined;\n    }\n\n    private findDuplicate(\n        elementState: TextElementState,\n        zoomLevel: number\n    ): { entries: TextElementState[]; index: number } | undefined {\n        // Point labels may have duplicates (as can path labels), Identify them\n        // and keep the one we already display.\n\n        const element = elementState.element;\n        const cachedEntries = this.m_textMap.get(getCacheKey(element));\n\n        if (cachedEntries === undefined) {\n            // No labels found with the same key.\n            return undefined;\n        }\n\n        tmpCachedDuplicate.entries = cachedEntries;\n        const index = element.hasFeatureId()\n            ? findDuplicateById(elementState, cachedEntries)\n            : findDuplicateByText(elementState, cachedEntries, zoomLevel);\n\n        if (index === undefined) {\n            // Feature id collision, try finding duplicates using text as key.\n            element.featureId = undefined;\n            return this.findDuplicate(elementState, zoomLevel);\n        }\n        tmpCachedDuplicate.index = index;\n        return tmpCachedDuplicate;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { TileKey } from \"@here/harp-geoutils\";\nimport { assert } from \"@here/harp-utils\";\nimport { TextElementGroup } from \"./TextElementGroup\";\nimport { TextElementState } from \"./TextElementState\";\n\n/**\n * Type of functions used to do early rejection of elements during group state creation or update.\n * @param textElementState - The state of the text element to check.\n * @returns `undefined` if element was rejected, otherwise its current view distance.\n */\nexport type TextElementFilter = (textElementState: TextElementState) => number | undefined;\n\n/**\n * `TextElementGroupState` keeps the state of a text element group and each element in it while\n * they're being rendered.\n */\nexport class TextElementGroupState {\n    private m_textElementStates: TextElementState[];\n    private m_visited: boolean = false;\n\n    /**\n     * Creates the state for specified group.\n     * @param group - The group of which the state will be created.\n     * @param tileKey - The key of the tile to which this group belongs.\n     * @param filter - Function used to do early rejection. @see [[TextElementFilter]].\n     */\n    constructor(\n        readonly group: TextElementGroup,\n        readonly tileKey: TileKey,\n        filter: TextElementFilter\n    ) {\n        assert(group.elements.length > 0);\n        const length = group.elements.length;\n        this.m_textElementStates = new Array(length);\n        this.m_visited = true;\n\n        // TODO: HARP-7648. Reduce number of allocations here:\n        // a) Avoid creating the state for labels that don't pass early placement checks and make\n        //    this checks more strict.\n        // b) Break label state objects into a set of arrays held at group level, one for each\n        //    primitive field in the label state.\n        for (let i = 0; i < length; ++i) {\n            const textElement = group.elements[i];\n            const state = new TextElementState(textElement);\n            const textDistance = filter(state);\n            state.update(textDistance);\n            this.m_textElementStates[i] = state;\n        }\n    }\n\n    /**\n     * Indicates whether the group has been submitted to the\n     * {@link TextElementsRenderer} in the current frame.\n     */\n    get visited(): boolean {\n        return this.m_visited;\n    }\n\n    set visited(visited: boolean) {\n        this.m_visited = visited;\n    }\n\n    /**\n     * @returns the priority of the text elements in the group.\n     */\n    get priority() {\n        return this.group.priority;\n    }\n\n    /**\n     * Updates the fading state of all text elements within the group to the specified time.\n     * @param time - The time to which the fading state will be updated.\n     * @param disableFading - `true` if fading is disabled, `false` otherwise.\n     */\n    updateFading(time: number, disableFading: boolean): void {\n        for (const elementState of this.m_textElementStates) {\n            if (elementState !== undefined) {\n                elementState.updateFading(time, disableFading);\n            }\n        }\n    }\n\n    /**\n     * Calls the specified callback for every visible text elements in the group.\n     * @param visibleElementsCallback - Functions that will be called for every visible text element\n     * in the group.\n     */\n    traverseVisibleElements(visibleElementsCallback: (e: TextElementState) => void): void {\n        for (const elementState of this.m_textElementStates) {\n            if (elementState !== undefined && elementState.visible) {\n                visibleElementsCallback(elementState);\n            }\n        }\n    }\n\n    /**\n     * Updates the states of elements within the group.\n     * @param filter - Function used to do early rejection. @see [[TextElementFilter]].\n     */\n    updateElements(filter: TextElementFilter) {\n        for (const elementState of this.m_textElementStates) {\n            const textDistance = filter(elementState);\n            elementState.update(textDistance);\n        }\n    }\n\n    get size(): number {\n        return this.m_textElementStates.length;\n    }\n\n    /**\n     * Returns text element states.\n     * @returns Array of element states.\n     */\n    get textElementStates(): TextElementState[] {\n        return this.m_textElementStates;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    hAlignFromPlacement,\n    hPlacementFromAlignment,\n    TextPlacement,\n    vAlignFromPlacement,\n    vPlacementFromAlignment\n} from \"@here/harp-text-canvas\";\nimport { assert } from \"@here/harp-utils\";\nimport { LayoutState } from \"./LayoutState\";\nimport { RenderState } from \"./RenderState\";\nimport { TextElement } from \"./TextElement\";\nimport { TextElementType } from \"./TextElementType\";\n\n/**\n * `TextElementState` keeps the current state of a text element while it's being rendered.\n */\nexport class TextElementState {\n    /**\n     * @hidden\n     * Used during label placement to reserve space from front to back.\n     */\n    private m_viewDistance: number | undefined;\n\n    /**\n     * @hidden\n     * Used during rendering. The array type is used for line markers only, which have a points\n     * array and multiple icon positions to render. Since line markers use the same renderState\n     * for text part and icon, there is no separate array of [[RenderState]]s for the text parts\n     * of the line markers.\n     */\n    private m_iconRenderStates?: RenderState | RenderState[];\n\n    /**\n     * @hidden\n     * Used during rendering.\n     */\n    private m_textRenderState?: RenderState;\n    /**\n     * @hidden\n     * Used to store recently used text layout.\n     */\n    private m_textLayoutState?: LayoutState;\n\n    constructor(readonly element: TextElement) {}\n\n    get initialized(): boolean {\n        return this.m_textRenderState !== undefined || this.m_iconRenderStates !== undefined;\n    }\n\n    /**\n     * @returns `true` if any component of the element is visible, `false` otherwise.\n     */\n    get visible(): boolean {\n        if (this.m_textRenderState !== undefined && this.m_textRenderState.isVisible()) {\n            return true;\n        }\n\n        const iconRenderState = this.iconRenderState;\n        if (iconRenderState !== undefined && iconRenderState.isVisible()) {\n            return true;\n        }\n\n        const iconRenderStates = this.iconRenderStates;\n        if (iconRenderStates === undefined) {\n            return false;\n        }\n\n        for (const state of iconRenderStates) {\n            if (state.isVisible()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return the last text placement used.\n     *\n     * If the text wasn't yet rendered or have no alternative placements it will fallback to\n     * style/theme based placement.\n     *\n     * @returns [[TextPlacement]] object containing vertical/horizontal align.\n     */\n    get textPlacement(): TextPlacement {\n        const themeLayout = this.element.layoutStyle!;\n        const stateLayout = this.m_textLayoutState;\n        // Would be good to test for persistence when getting state layout, but with this\n        // most of the isolated placement unit tests will fail.\n        const lastPlacement =\n            stateLayout !== undefined\n                ? stateLayout.textPlacement\n                : {\n                      h: hPlacementFromAlignment(themeLayout.horizontalAlignment),\n                      v: vPlacementFromAlignment(themeLayout.verticalAlignment)\n                  };\n        return lastPlacement;\n    }\n\n    /**\n     * Set text placement to be used.\n     *\n     * This may be base text anchor placement as defined by style or alternative placement.\n     *\n     * @param placement - The new [[TextPlacement]] to be used.\n     */\n    set textPlacement(placement: TextPlacement) {\n        if (this.m_textLayoutState === undefined && this.isBaseTextPlacement(placement) === true) {\n            // Do nothing, layout state is not required cause we leave the base placement.\n            return;\n        }\n        if (this.m_textLayoutState === undefined) {\n            // State is not yet defined, but we have placement to store, either alternative or\n            // not yet specified in the context of layoutStyle.\n            this.m_textLayoutState = new LayoutState(placement);\n        } else {\n            this.m_textLayoutState.textPlacement = placement;\n        }\n    }\n\n    /**\n     * Returns information if the text placement provided is the base one defined in style (theme).\n     *\n     * @param placement - The [[TextPlacement]] to check.\n     * @returns [[true]] if the placement provided is exactly the same as in theme base layout,\n     * [[false]] if it differs from the basic layout provided in style or\n     * [[undefined]] if the layout style is not yet defined so it is hard to say.\n     */\n    isBaseTextPlacement(placement: TextPlacement): boolean | undefined {\n        const themeLayout = this.element.layoutStyle;\n        if (themeLayout !== undefined) {\n            return (\n                hAlignFromPlacement(placement.h) === themeLayout.horizontalAlignment &&\n                vAlignFromPlacement(placement.v) === themeLayout.verticalAlignment\n            );\n        }\n        return undefined;\n    }\n\n    /**\n     * Resets the element to an initialized state.\n     */\n    reset() {\n        if (this.m_textRenderState !== undefined) {\n            this.m_textRenderState.reset();\n        }\n        if (this.m_textLayoutState !== undefined) {\n            if (this.element.layoutStyle !== undefined) {\n                this.m_textLayoutState.reset(this.element.layoutStyle);\n            } else {\n                this.m_textLayoutState = undefined;\n            }\n        }\n\n        if (this.iconRenderState) {\n            (this.m_iconRenderStates as RenderState).reset();\n        } else if (this.m_iconRenderStates !== undefined) {\n            for (const renderState of this.m_iconRenderStates as RenderState[]) {\n                renderState.reset();\n            }\n        }\n        this.m_viewDistance = undefined;\n        this.element.textBufferObject = undefined;\n    }\n\n    /**\n     * Replaces given text element, inheriting its current state.\n     * The predecessor text element state is erased.\n     * @param predecessor - Text element state to be replaced.\n     */\n    replace(predecessor: TextElementState) {\n        this.m_textRenderState = predecessor.m_textRenderState;\n        this.m_textLayoutState = predecessor.m_textLayoutState;\n        this.m_iconRenderStates = predecessor.m_iconRenderStates;\n        predecessor.m_textRenderState = undefined;\n        predecessor.m_textLayoutState = undefined;\n        predecessor.m_iconRenderStates = undefined;\n\n        if (this.element.glyphs === undefined) {\n            // Use the predecessor glyphs and case array until proper ones are computed.\n            this.element.glyphs = predecessor.element.glyphs;\n            this.element.glyphCaseArray = predecessor.element.glyphCaseArray;\n        }\n        this.element.bounds = undefined;\n        this.element.textBufferObject = undefined;\n    }\n\n    /**\n     * Returns the last computed distance of the text element to the camera.\n     * @returns Distance to camera.\n     */\n    get viewDistance(): number | undefined {\n        return this.m_viewDistance;\n    }\n\n    /**\n     * Updates the text element state.\n     * @param viewDistance - The new view distance to set. If `undefined`, element is considered to\n     * be out of view.\n     */\n    update(viewDistance: number | undefined) {\n        if (!this.initialized && viewDistance !== undefined) {\n            this.initializeRenderStates();\n        }\n\n        this.setViewDistance(viewDistance);\n    }\n\n    /**\n     * Sets the distance of the element to the current view center.\n     * @param viewDistance - The new view distance to set. If `undefined`, element is considered to\n     * be out of view.\n     */\n    setViewDistance(viewDistance: number | undefined) {\n        this.m_viewDistance = viewDistance;\n    }\n\n    /**\n     * Return the last distance that has been computed for sorting during placement. This may not be\n     * the actual distance if the camera is moving, as the distance is computed only during\n     * placement. If the property `alwaysOnTop` is true, the value returned is always `0`.\n     *\n     * @returns 0 or negative distance to camera.\n     */\n    get renderDistance(): number {\n        return this.element.alwaysOnTop === true\n            ? 0\n            : this.m_viewDistance !== undefined\n            ? -this.m_viewDistance\n            : 0;\n    }\n\n    /**\n     * @returns The text render state.\n     */\n    get textRenderState(): RenderState | undefined {\n        return this.m_textRenderState;\n    }\n\n    /**\n     * Returns the icon render state for the case where the text element has only one icon.\n     * @returns The icon render state if the text element has a single icon, otherwise undefined.\n     */\n    get iconRenderState(): RenderState | undefined {\n        if (this.m_iconRenderStates === undefined) {\n            return undefined;\n        }\n\n        return this.m_iconRenderStates instanceof RenderState ? this.m_iconRenderStates : undefined;\n    }\n\n    /**\n     * Returns the icon render states for text elements with multiple icons.\n     * @returns The icon render states if the text element has multiple icons, otherwise undefined.\n     */\n    get iconRenderStates(): RenderState[] | undefined {\n        if (this.m_iconRenderStates === undefined) {\n            return undefined;\n        }\n\n        return this.m_iconRenderStates instanceof RenderState\n            ? undefined\n            : (this.m_iconRenderStates as RenderState[]);\n    }\n\n    /**\n     * Updates the fading state to the specified time.\n     * @param time - The current time.\n     * @param disableFading - If `True` there will be no fading transitions, i.e., state will go\n     * directly from FadedIn to FadedOut and viceversa.\n     */\n    updateFading(time: number, disableFading: boolean): void {\n        if (this.m_textRenderState !== undefined) {\n            this.m_textRenderState.updateFading(time, disableFading);\n        }\n\n        if (this.iconRenderState !== undefined) {\n            const iconRenderState = this.m_iconRenderStates as RenderState;\n            iconRenderState.updateFading(time, disableFading);\n        } else if (this.iconRenderStates !== undefined) {\n            for (const renderState of this.m_iconRenderStates as RenderState[]) {\n                renderState.updateFading(time, disableFading);\n            }\n        }\n    }\n\n    /**\n     * Initialize text and icon render states\n     */\n    private initializeRenderStates() {\n        assert(this.m_textRenderState === undefined);\n        assert(this.m_textLayoutState === undefined);\n        assert(this.m_iconRenderStates === undefined);\n\n        const { textFadeTime } = this.element;\n        const iconFadeTime = this.element.poiInfo?.technique.iconFadeTime;\n        if (this.element.type === TextElementType.LineMarker) {\n            this.m_iconRenderStates = new Array<RenderState>();\n            for (const _point of this.element.points as THREE.Vector3[]) {\n                const iconRenderStates = this.m_iconRenderStates as RenderState[];\n                const renderState = new RenderState(iconFadeTime);\n                iconRenderStates.push(renderState);\n            }\n            return;\n        }\n\n        this.m_textRenderState = new RenderState(textFadeTime);\n\n        if (this.element.type === TextElementType.PoiLabel) {\n            this.m_iconRenderStates = new RenderState(iconFadeTime);\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    DefaultTextStyle,\n    hAlignFromPlacement,\n    HorizontalAlignment,\n    hPlacementFromAlignment,\n    TextLayoutStyle,\n    TextPlacement,\n    vAlignFromPlacement,\n    VerticalAlignment,\n    vPlacementFromAlignment\n} from \"@here/harp-text-canvas\";\n\n/**\n * Layout state of the text part of the `TextElement`.\n *\n * Used mainly for multi-anchor placement algorithm.\n * @hidden\n */\nexport class LayoutState {\n    private m_hAlign = DefaultTextStyle.DEFAULT_HORIZONTAL_ALIGNMENT;\n    private m_vAlign = DefaultTextStyle.DEFAULT_VERTICAL_ALIGNMENT;\n\n    constructor(placement: TextPlacement) {\n        this.textPlacement = placement;\n    }\n    /**\n     * Set layout based on theme style defined and optional text placement.\n     *\n     * @param placement - The optional new anchor placement.\n     */\n    set textPlacement(placement: TextPlacement) {\n        this.m_hAlign = hAlignFromPlacement(placement.h);\n        this.m_vAlign = vAlignFromPlacement(placement.v);\n    }\n\n    /**\n     * Acquire current placement setup.\n     *\n     * Function returns alternative or base placement depending on layout state.\n     *\n     * @returns The current anchor placement.\n     */\n    get textPlacement(): TextPlacement {\n        return {\n            h: hPlacementFromAlignment(this.m_hAlign),\n            v: vPlacementFromAlignment(this.m_vAlign)\n        };\n    }\n\n    /**\n     * Reset existing `LayoutState` to contain values from style/theme layout.\n     */\n    reset(layoutStyle: TextLayoutStyle) {\n        this.m_hAlign = layoutStyle.horizontalAlignment;\n        this.m_vAlign = layoutStyle.verticalAlignment;\n    }\n\n    get horizontalAlignment(): HorizontalAlignment {\n        return this.m_hAlign;\n    }\n\n    get verticalAlignment(): VerticalAlignment {\n        return this.m_vAlign;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { assert, MathUtils } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\n/**\n * State of fading.\n */\nexport enum FadingState {\n    Undefined = 0,\n    FadingIn = 1,\n    FadedIn = 2,\n    FadingOut = -1,\n    FadedOut = -2\n}\n\n/**\n * Time to fade in/fade out the labels in milliseconds.\n */\nexport const DEFAULT_FADE_TIME = 800;\n\n/**\n * State of rendering of the icon and text part of the `TextElement`. Mainly for fading the elements\n * in and out, to compute the opacity.\n *\n * @hidden\n */\nexport class RenderState {\n    /**\n     * Current fading value [0..1]\n     */\n    value: number = 0.0;\n\n    /**\n     * Timestamp the fading started.\n     */\n    startTime: number = 0;\n\n    /**\n     * Computed opacity depending on value.\n     */\n    opacity: number = 1.0;\n\n    private m_state = FadingState.Undefined;\n\n    /**\n     * Create a `RenderState`.\n     *\n     * @param fadeTime - The duration of the fading in milliseconds.\n     */\n    constructor(public fadeTime = DEFAULT_FADE_TIME) {}\n\n    /**\n     * Reset existing `RenderState` to appear like a fresh state.\n     */\n    reset() {\n        this.m_state = FadingState.Undefined;\n        this.value = 0.0;\n        this.startTime = 0.0;\n        this.opacity = 1.0;\n    }\n\n    /**\n     * @returns `true` if element state is `FadingState.Undefined`.\n     */\n    isUndefined(): boolean {\n        return this.m_state === FadingState.Undefined;\n    }\n\n    /**\n     * @returns `true` if element is either fading in or fading out.\n     */\n    isFading(): boolean {\n        const fading =\n            this.m_state === FadingState.FadingIn || this.m_state === FadingState.FadingOut;\n        return fading;\n    }\n\n    /**\n     * @returns `true` if element is fading in.\n     */\n    isFadingIn(): boolean {\n        const fadingIn = this.m_state === FadingState.FadingIn;\n        return fadingIn;\n    }\n\n    /**\n     * @returns `true` if element is fading out.\n     */\n    isFadingOut(): boolean {\n        const fadingOut = this.m_state === FadingState.FadingOut;\n        return fadingOut;\n    }\n\n    /**\n     * @returns `true` if element is done with fading in.\n     */\n    isFadedIn(): boolean {\n        const fadedIn = this.m_state === FadingState.FadedIn;\n        return fadedIn;\n    }\n\n    /**\n     * @returns `true` if element is done with fading out.\n     */\n    isFadedOut(): boolean {\n        const fadedOut = this.m_state === FadingState.FadedOut;\n        return fadedOut;\n    }\n\n    /**\n     * @returns `true` if state is neither faded out nor undefined.\n     */\n    isVisible(): boolean {\n        return this.m_state !== FadingState.FadedOut && this.m_state !== FadingState.Undefined;\n    }\n\n    /**\n     * Updates the state to [[FadingState.FadingIn]].\n     * If previous state is [[FadingState.FadingIn]] or [[FadingState.FadedIn]] it remains\n     * unchanged.\n     *\n     * @param time - Current time.\n     */\n    startFadeIn(time: number) {\n        if (this.m_state === FadingState.FadingIn || this.m_state === FadingState.FadedIn) {\n            return;\n        }\n\n        if (this.m_state === FadingState.FadingOut) {\n            // The fadeout is not complete: compute the virtual fadingStartTime in the past, to get\n            // a correct end time:\n            this.value = 1.0 - this.value;\n            this.startTime = time - this.value * this.fadeTime;\n        } else {\n            this.startTime = time;\n            this.value = 0.0;\n            this.opacity = 0;\n        }\n\n        this.m_state = FadingState.FadingIn;\n    }\n\n    /**\n     * Updates the state to [[FadingState.FadingOut]].\n     * If previous state is [[FadingState.FadingOut]] or [[FadingState.FadedOut]] it remains\n     * unchanged.\n     *\n     * @param time - Current time.\n     */\n    startFadeOut(time: number) {\n        if (this.m_state === FadingState.FadingOut || this.m_state === FadingState.FadedOut) {\n            return;\n        }\n\n        if (this.m_state === FadingState.FadingIn) {\n            // The fade-in is not complete: compute the virtual fadingStartTime in the past, to get\n            // a correct end time:\n            this.startTime = time - this.value * this.fadeTime;\n            this.value = 1.0 - this.value;\n        } else {\n            this.startTime = time;\n            this.value = 0.0;\n            this.opacity = 1;\n        }\n\n        this.m_state = FadingState.FadingOut;\n    }\n\n    /**\n     * Updates opacity to current time, changing the state to [[FadingState.FadedOut]] or\n     * [[FadingState.FadedIn]] when the opacity becomes 0 or 1 respectively.\n     * It does nothing if [[isFading]] !== `true`.\n     *\n     * @param time - Current time.\n     * @param disableFading - `true` if fading is disabled, `false` otherwise.\n     */\n    updateFading(time: number, disableFading: boolean): void {\n        if (this.m_state !== FadingState.FadingIn && this.m_state !== FadingState.FadingOut) {\n            return;\n        }\n\n        if (this.startTime === 0) {\n            this.startTime = time;\n        }\n\n        const fadingTime = time - this.startTime;\n        const startValue = this.m_state === FadingState.FadingIn ? 0 : 1;\n        const endValue = this.m_state === FadingState.FadingIn ? 1 : 0;\n\n        if (disableFading || fadingTime >= this.fadeTime) {\n            this.value = 1.0;\n            this.opacity = endValue;\n            this.m_state =\n                this.m_state === FadingState.FadingIn ? FadingState.FadedIn : FadingState.FadedOut;\n        } else {\n            // TODO: HARP-7648. Do this once for all labels (calculate the last frame value\n            // increment).\n            this.value = fadingTime / this.fadeTime;\n\n            this.opacity = THREE.MathUtils.clamp(\n                MathUtils.smootherStep(startValue, endValue, this.value),\n                0,\n                1\n            );\n            assert(this.isFading());\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { IChannel } from \"@here/harp-utils\";\nimport { PrePlacementResult } from \"./Placement\";\n\nexport class UpdateStats {\n    tiles: number = 0;\n    totalGroups: number = 0;\n    newGroups: number = 0;\n    totalLabels: number = 0;\n    results = new Array<number>(PrePlacementResult.Count);\n\n    constructor(private readonly m_logger: IChannel) {\n        this.results.fill(0);\n    }\n\n    clear() {\n        this.tiles = 0;\n        this.totalGroups = 0;\n        this.newGroups = 0;\n        this.totalLabels = 0;\n        this.results.fill(0);\n    }\n    log() {\n        this.m_logger.debug(\"Tiles\", this.tiles);\n        this.m_logger.debug(\"Total groups\", this.totalGroups);\n        this.m_logger.debug(\"New groups\", this.newGroups);\n        this.m_logger.debug(\"Total labels\", this.totalLabels);\n        this.m_logger.debug(\"Placed labels\", this.results[PrePlacementResult.Ok]);\n        this.m_logger.debug(\"Invisible\", this.results[PrePlacementResult.Invisible]);\n        this.m_logger.debug(\"Poi not ready\", this.results[PrePlacementResult.NotReady]);\n        this.m_logger.debug(\"Too far\", this.results[PrePlacementResult.TooFar]);\n        this.m_logger.debug(\"Duplicate\", this.results[PrePlacementResult.Duplicate]);\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    OrientedBox3,\n    Projection,\n    ProjectionType,\n    TileKey,\n    TilingScheme\n} from \"@here/harp-geoutils\";\nimport { assert } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\nimport { DataSource } from \"./DataSource\";\nimport { CalculationStatus, ElevationRangeSource } from \"./ElevationRangeSource\";\nimport { MapTileCuller } from \"./MapTileCuller\";\nimport { MapView } from \"./MapView\";\nimport { MapViewUtils, TileOffsetUtils } from \"./Utils\";\n\nconst tmpVectors3 = [new THREE.Vector3(), new THREE.Vector3()];\nconst tmpVector4 = new THREE.Vector4();\n\n/**\n * Represents a unique TileKey and the area it takes up on screen.\n *\n * Note, in certain tiling projections, it is possible to have an offset, which represents a tile\n * which has fully wrapped around, hence this defaults to 0 to simplify usage for projections which\n * don't require it.\n */\nexport class TileKeyEntry {\n    constructor(\n        public tileKey: TileKey,\n        public area: number,\n        public offset: number = 0,\n        public minElevation: number = 0,\n        public maxElevation: number = 0,\n        public distance: number = 0\n    ) {}\n}\n\nfunction getGeoBox(tilingScheme: TilingScheme, childTileKey: TileKey, offset: number) {\n    const geoBox = tilingScheme.getGeoBox(childTileKey);\n    const longitudeOffset = 360.0 * offset;\n    geoBox.northEast.longitude += longitudeOffset;\n    geoBox.southWest.longitude += longitudeOffset;\n    return geoBox;\n}\n\n/**\n * Map tile keys to TileKeyEntry.\n * Keys are a combination of morton code and tile offset,\n * see [[TileOffsetUtils.getKeyForTileKeyAndOffset]].\n */\ntype TileKeyEntries = Map<number, TileKeyEntry>;\n\n/**\n * Map zoom level to map of visible tile key entries\n */\ntype ZoomLevelTileKeyMap = Map<number, TileKeyEntries>;\n\n/**\n * Result of frustum intersection\n */\ninterface IntersectionResult {\n    /**\n     * Tiles intersected by the frustum per zoom level.\n     */\n    readonly tileKeyEntries: ZoomLevelTileKeyMap;\n\n    /**\n     * True if the intersection was calculated using precise elevation data, false if it's an\n     * approximation.\n     */\n    calculationFinal: boolean;\n}\n\n/**\n * Computes the tiles intersected by the frustum defined by the current camera setup.\n */\nexport class FrustumIntersection {\n    private readonly m_frustum: THREE.Frustum = new THREE.Frustum();\n    // used to project global coordinates into camera local coordinates\n    private readonly m_viewProjectionMatrix = new THREE.Matrix4();\n    private readonly m_mapTileCuller: MapTileCuller;\n    private m_rootTileKeys: TileKeyEntry[] = [];\n    private readonly m_tileKeyEntries: ZoomLevelTileKeyMap = new Map();\n\n    constructor(\n        private readonly m_camera: THREE.PerspectiveCamera,\n        readonly mapView: MapView,\n        private readonly m_extendedFrustumCulling: boolean,\n        private readonly m_tileWrappingEnabled: boolean,\n        private readonly m_enableMixedLod: boolean\n    ) {\n        this.m_mapTileCuller = new MapTileCuller(m_camera);\n    }\n\n    /**\n     * Return camera used for generating frustum.\n     */\n    get camera(): THREE.PerspectiveCamera {\n        return this.m_camera;\n    }\n\n    /**\n     * Return projection used to convert geo coordinates to world coordinates.\n     */\n    get projection(): Projection {\n        return this.mapView.projection;\n    }\n\n    /**\n     * Updates the frustum to match the current camera setup.\n     */\n    updateFrustum(projectionMatrixOverride?: THREE.Matrix4) {\n        this.m_viewProjectionMatrix.multiplyMatrices(\n            projectionMatrixOverride !== undefined\n                ? projectionMatrixOverride\n                : this.m_camera.projectionMatrix,\n            this.m_camera.matrixWorldInverse\n        );\n\n        this.m_frustum.setFromProjectionMatrix(this.m_viewProjectionMatrix);\n\n        if (this.m_extendedFrustumCulling) {\n            this.m_mapTileCuller.setup();\n        }\n        this.computeRequiredInitialRootTileKeys(this.m_camera.position);\n    }\n\n    /**\n     * Computes the tiles intersected by the updated frustum, see [[updateFrustum]].\n     *\n     * @param tilingScheme - The tiling scheme used to generate the tiles.\n     * @param elevationRangeSource - Source of elevation range data if any.\n     * @param zoomLevels - A list of zoom levels to render.\n     * @param dataSources - A list of data sources to render.\n     * @returns The computation result, see [[FrustumIntersection.Result]].\n     */\n    compute(\n        tilingScheme: TilingScheme,\n        elevationRangeSource: ElevationRangeSource | undefined,\n        zoomLevels: number[],\n        dataSources: DataSource[]\n    ): IntersectionResult {\n        this.m_tileKeyEntries.clear();\n\n        // Compute target tile area in clip space size.\n        // A tile should take up roughly 256x256 pixels on screen in accordance to\n        // the zoom level chosen by [MapViewUtils.calculateZoomLevelFromDistance].\n        assert(this.mapView.viewportHeight !== 0);\n        const targetTileArea = Math.pow(256 / this.mapView.viewportHeight, 2);\n        const useElevationRangeSource: boolean =\n            elevationRangeSource !== undefined &&\n            elevationRangeSource.getTilingScheme() === tilingScheme;\n        const obbIntersections =\n            this.mapView.projection.type === ProjectionType.Spherical || useElevationRangeSource;\n        const uniqueZoomLevels = new Set(zoomLevels);\n\n        const cache = {\n            calculationFinal: true,\n            tileBounds: obbIntersections ? new OrientedBox3() : new THREE.Box3()\n        };\n\n        // create tile key map per zoom level\n        for (const zoomLevel of uniqueZoomLevels) {\n            this.m_tileKeyEntries.set(zoomLevel, new Map());\n        }\n        for (const tileEntry of this.m_rootTileKeys) {\n            const tileKey = tileEntry.tileKey;\n            const offset = tileEntry.offset;\n\n            // We even check the root tiles against the frustum b/c it can happen that\n            // computeRequiredInitialRootTileKeys is producing false positives.\n            const tileKeyEntry = this.getTileKeyEntry(\n                tileKey,\n                offset,\n                tilingScheme,\n                cache,\n                useElevationRangeSource ? elevationRangeSource : undefined\n            );\n\n            if (tileKeyEntry !== undefined) {\n                for (const zoomLevel of uniqueZoomLevels) {\n                    const tileKeyEntries = this.m_tileKeyEntries.get(zoomLevel)!;\n                    tileKeyEntries.set(\n                        TileOffsetUtils.getKeyForTileKeyAndOffset(tileKey, offset),\n                        tileKeyEntry\n                    );\n                }\n            }\n        }\n\n        const workList = [...this.m_rootTileKeys.values()];\n        while (workList.length > 0) {\n            const tileEntry = workList.pop();\n\n            if (tileEntry === undefined) {\n                break;\n            }\n\n            // Stop subdivision if hightest visible level is reached\n            const tileKey = tileEntry.tileKey;\n            const offset = tileEntry.offset;\n            const subdivide = dataSources.some((ds, i) =>\n                ds.shouldSubdivide(zoomLevels[i], tileKey)\n            );\n            if (!subdivide) {\n                continue;\n            }\n\n            // Stop subdivision if area of tile is too small(mixed LOD only)\n            if (this.m_enableMixedLod && tileEntry.area < targetTileArea) {\n                continue;\n            }\n\n            const tileKeyAndOffset = TileOffsetUtils.getKeyForTileKeyAndOffset(tileKey, offset);\n\n            // delete parent tile key from applicable zoom levels\n            for (const zoomLevel of uniqueZoomLevels) {\n                if (tileKey.level >= zoomLevel) {\n                    continue;\n                }\n\n                const tileKeyEntries = this.m_tileKeyEntries.get(zoomLevel)!;\n                tileKeyEntries.delete(tileKeyAndOffset);\n            }\n\n            for (const subTileKey of tilingScheme.getSubTileKeys(tileKey)) {\n                const subTileEntry = this.getTileKeyEntry(\n                    subTileKey,\n                    offset,\n                    tilingScheme,\n                    cache,\n                    useElevationRangeSource ? elevationRangeSource : undefined\n                );\n\n                if (subTileEntry !== undefined) {\n                    // insert sub tile entry into tile entries map per zoom level\n                    for (const zoomLevel of uniqueZoomLevels) {\n                        if (subTileEntry.tileKey.level > zoomLevel) {\n                            continue;\n                        }\n\n                        const subTileKeyAndOffset = TileOffsetUtils.getKeyForTileKeyAndOffset(\n                            subTileKey,\n                            offset\n                        );\n                        this.m_tileKeyEntries\n                            .get(zoomLevel)!\n                            .set(subTileKeyAndOffset, subTileEntry);\n                    }\n\n                    workList.push(subTileEntry);\n                }\n            }\n        }\n        return { tileKeyEntries: this.m_tileKeyEntries, calculationFinal: cache.calculationFinal };\n    }\n\n    private getTileKeyEntry(\n        tileKey: TileKey,\n        offset: number,\n        tilingScheme: TilingScheme,\n        cache: { calculationFinal: boolean; tileBounds: OrientedBox3 | THREE.Box3 },\n        elevationRangeSource?: ElevationRangeSource\n    ): TileKeyEntry | undefined {\n        const geoBox = getGeoBox(tilingScheme, tileKey, offset);\n\n        // For tiles without elevation range source, default 0 (getGeoBox always\n        // returns box with altitude min/max equal to zero) will be propagated as\n        // min and max elevation, these tiles most probably contains features that\n        // lays directly on the ground surface.\n        if (elevationRangeSource !== undefined) {\n            const range = elevationRangeSource!.getElevationRange(tileKey);\n            geoBox.southWest.altitude = range.minElevation;\n            geoBox.northEast.altitude = range.maxElevation;\n            cache.calculationFinal =\n                cache.calculationFinal &&\n                range.calculationStatus === CalculationStatus.FinalPrecise;\n        }\n\n        this.mapView.projection.projectBox(geoBox, cache.tileBounds);\n        const { area, distance } = this.computeTileAreaAndDistance(cache.tileBounds);\n\n        if (area > 0) {\n            return new TileKeyEntry(\n                tileKey,\n                area,\n                offset,\n                geoBox.southWest.altitude, // minElevation\n                geoBox.northEast.altitude, // maxElevation\n                distance\n            );\n        }\n\n        return undefined;\n    }\n    /**\n     * Estimate screen space area of tile and distance to center of tile\n     * @param tileBounds - The bounding volume of a tile\n     * @return Area estimate and distance to tile center in clip space\n     */\n    private computeTileAreaAndDistance(\n        tileBounds: THREE.Box3 | OrientedBox3\n    ): { area: number; distance: number } {\n        if (tileBounds instanceof THREE.Box3) {\n            if (\n                (this.m_extendedFrustumCulling &&\n                    !this.m_mapTileCuller.frustumIntersectsTileBox(tileBounds)) ||\n                !this.m_frustum.intersectsBox(tileBounds)\n            ) {\n                return {\n                    area: 0,\n                    distance: Infinity\n                };\n            }\n        } else if (!tileBounds.intersects(this.m_frustum)) {\n            return {\n                area: 0,\n                distance: Infinity\n            };\n        }\n\n        // Project tile bounds center\n        const center = tileBounds.getCenter(tmpVectors3[0]);\n        const projectedPoint = tmpVector4\n            .set(center.x, center.y, center.z, 1.0)\n            .applyMatrix4(this.m_viewProjectionMatrix);\n\n        // Estimate objects screen space size with diagonal of bounds\n        // Dividing by w projects object size to screen space\n        const size = tileBounds.getSize(tmpVectors3[1]);\n        const objectSize = (0.5 * size.length()) / projectedPoint.w;\n\n        return {\n            area: objectSize * objectSize,\n            distance: projectedPoint.z / projectedPoint.w\n        };\n    }\n\n    /**\n     * Create a list of root nodes to test against the frustum. The root nodes each start at level 0\n     * and have an offset (see {@link Tile}) based on:\n     * - the current position [[worldCenter]].\n     * - the height of the camera above the world.\n     * - the field of view of the camera (the maximum value between the horizontal / vertical\n     *   values)\n     * - the tilt of the camera (because we see more tiles when tilted).\n     *\n     * @param worldCenter - The center of the camera in world space.\n     */\n    private computeRequiredInitialRootTileKeys(worldCenter: THREE.Vector3) {\n        this.m_rootTileKeys = [];\n        const rootTileKey = TileKey.fromRowColumnLevel(0, 0, 0);\n        const tileWrappingEnabled = this.mapView.projection.type === ProjectionType.Planar;\n\n        if (!tileWrappingEnabled || !this.m_tileWrappingEnabled) {\n            this.m_rootTileKeys.push(new TileKeyEntry(rootTileKey, Infinity, 0, 0));\n            return;\n        }\n\n        const worldGeoPoint = this.mapView.projection.unprojectPoint(worldCenter);\n        const startOffset = Math.round(worldGeoPoint.longitude / 360.0);\n\n        // This algorithm computes the number of offsets we need to test. The following diagram may\n        // help explain the algorithm below.\n        //\n        //   |\n        //   |.\\ .\n        //   | . \\  .\n        // z |  .  \\   .c2\n        //   |  c1.  \\b    .\n        //   |     .   \\      .\n        //___|a___d1.____\\e______.d2______f\n        //\n        // Where:\n        // -  is the camera\n        // - z is the height of the camera above the ground.\n        // - a is a right angle.\n        // - b is the look at vector of the camera.\n        // - c1 and c2 are the frustum planes of the camera.\n        // - c1 to c2 is the fov.\n        // - d1 and d2 are the intersection points of the frustum with the world plane.\n        // - e is the tilt/pitch of the camera.\n        // - f is the world\n        //\n        // The goal is to find the distance from e->d2. This is a longitude value, and we convert it\n        // to some offset range. Note e->d2 >= e->d1 (because we can't have a negative tilt).\n        // To find e->d2, we use the right triangle , a, d2 and subtract the distance a->d2 with\n        // a->e.\n        // a->d2 is found using the angle between a and d2 from the , this is simply e (because of\n        // similar triangles, angle between a,  and e equals the tilt) + half of the fov (because\n        // we need the angle between e,  and d2) and using trigonometry, result is therefore:\n        // (tan(a->d2) * z).\n        // a->e needs just the tilt and trigonometry to compute, result is: (tan(a->e) * z).\n\n        const camera = this.m_camera;\n        const cameraPitch = MapViewUtils.extractAttitude(this.mapView, camera).pitch;\n        // Ensure that the aspect is >= 1.\n        const aspect = camera.aspect > 1 ? camera.aspect : 1 / camera.aspect;\n        // Angle between a->d2, note, the fov is vertical, hence we translate to horizontal.\n        const totalAngleRad = THREE.MathUtils.degToRad((camera.fov * aspect) / 2) + cameraPitch;\n        // Length a->d2\n        const worldLengthHorizontalFull = Math.tan(totalAngleRad) * camera.position.z;\n        // Length a->e\n        const worldLengthHorizontalSmallerHalf = Math.tan(cameraPitch) * camera.position.z;\n        // Length e -> d2\n        const worldLengthHorizontal = worldLengthHorizontalFull - worldLengthHorizontalSmallerHalf;\n        const worldLeftPoint = new THREE.Vector3(\n            worldCenter.x - worldLengthHorizontal,\n            worldCenter.y,\n            worldCenter.z\n        );\n        const worldLeftGeoPoint = this.mapView.projection.unprojectPoint(worldLeftPoint);\n        // We multiply by SQRT2 because we need to account for a rotated view (in which case there\n        // are more tiles that can be seen).\n        const offsetRange = THREE.MathUtils.clamp(\n            Math.ceil(\n                Math.abs((worldGeoPoint.longitude - worldLeftGeoPoint.longitude) / 360) * Math.SQRT2\n            ),\n            0,\n            // We can store currently up to 16 unique keys(2^4, where 4 is the default bit-shift\n            // value which is used currently in the VisibleTileSet methods) hence we can have a\n            // maximum range of 7 (because 2*7+1 = 15).\n            7\n        );\n        for (\n            let offset = -offsetRange + startOffset;\n            offset <= offsetRange + startOffset;\n            offset++\n        ) {\n            this.m_rootTileKeys.push(new TileKeyEntry(rootTileKey, Infinity, offset, 0, 0));\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\n/**\n * Second step tile culling: Do additional check for intersection of box and frustum by checking if\n * the frustum is outside any plane of the tiles `bbox` (oriented, not AABB). It's in the inverse of\n * the standard frustum test, which excludes many cases where the large terrain tiles straddle the\n * planes of the frustum.\n *\n * @see http://www.iquilezles.org/www/articles/frustumcorrect/frustumcorrect.htm\n */\nexport class MapTileCuller {\n    private m_globalFrustumMin = new THREE.Vector3();\n    private m_globalFrustumMax = new THREE.Vector3();\n\n    private m_frustumCorners = [\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3()\n    ];\n\n    /**\n     * Constructs a `MapTileCuller`.\n     *\n     * @param m_camera - A `THREE.Camera`.\n     */\n    constructor(private m_camera: THREE.Camera) {}\n\n    /**\n     * Sets up culling and computes frustum corners. You mus call this function before the culling\n     * starts.\n     */\n    setup() {\n        const frustumCorners = this.getFrustumCorners();\n\n        const matrix = this.m_camera.matrixWorld;\n\n        this.m_globalFrustumMin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n        this.m_globalFrustumMax.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n\n        for (const frustumCorner of frustumCorners) {\n            frustumCorner.applyMatrix4(matrix);\n\n            this.m_globalFrustumMin.x = Math.min(this.m_globalFrustumMin.x, frustumCorner.x);\n            this.m_globalFrustumMin.y = Math.min(this.m_globalFrustumMin.y, frustumCorner.y);\n            this.m_globalFrustumMin.z = Math.min(this.m_globalFrustumMin.z, frustumCorner.z);\n\n            this.m_globalFrustumMax.x = Math.max(this.m_globalFrustumMax.x, frustumCorner.x);\n            this.m_globalFrustumMax.y = Math.max(this.m_globalFrustumMax.y, frustumCorner.y);\n            this.m_globalFrustumMax.z = Math.max(this.m_globalFrustumMax.z, frustumCorner.z);\n        }\n    }\n\n    /**\n     * Checks if the tile's bounding box intersects with the current view's frustum.\n     *\n     * @param tileBounds - The bounding box for the tile.\n     */\n    frustumIntersectsTileBox(tileBounds: THREE.Box3): boolean {\n        const globalFrustumMin = this.m_globalFrustumMin;\n        const globalFrustumMax = this.m_globalFrustumMax;\n\n        if (\n            globalFrustumMax.x < tileBounds.min.x ||\n            globalFrustumMax.y < tileBounds.min.y ||\n            globalFrustumMax.z < tileBounds.min.z ||\n            globalFrustumMin.x > tileBounds.max.x ||\n            globalFrustumMin.y > tileBounds.max.y ||\n            globalFrustumMin.z > tileBounds.max.z\n        ) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns the eight corners of the frustum.\n     */\n    private getFrustumCorners(): THREE.Vector3[] {\n        const frustumCorners = this.m_frustumCorners;\n        const invProjMatrix = (this.m_camera as any).projectionMatrixInverse as THREE.Matrix4;\n\n        let cornerIndex = 0;\n\n        function addPoint(x: number, y: number, z: number) {\n            frustumCorners[cornerIndex++].set(x, y, z).applyMatrix4(invProjMatrix);\n        }\n\n        const w = 1;\n        const h = 1;\n        const n = -1;\n        const f = 1;\n\n        // near\n        addPoint(-w, -h, n);\n        addPoint(w, -h, n);\n        addPoint(-w, h, n);\n        addPoint(w, h, n);\n\n        // far\n        addPoint(-w, -h, f);\n        addPoint(w, -h, f);\n        addPoint(-w, h, f);\n        addPoint(w, h, f);\n\n        return frustumCorners;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeometryKind, GeometryKindSet } from \"@here/harp-datasource-protocol\";\nimport { MapObjectAdapter } from \"../MapObjectAdapter\";\nimport { MapView } from \"../MapView\";\nimport { Tile } from \"../Tile\";\nimport { TileGeometryLoader } from \"./TileGeometryLoader\";\n\ntype TileUpdateCallback = (tile: Tile) => void;\n\n/**\n * Manages the content (the geometries) of a tile.\n */\nexport class TileGeometryManager {\n    /**\n     * The set of geometry kinds that is enabled. Their geometry will be created after decoding.\n     */\n    get enabledGeometryKinds(): GeometryKindSet {\n        return this.enabledKinds;\n    }\n\n    set enabledGeometryKinds(kinds: GeometryKindSet) {\n        this.enabledKinds = kinds;\n    }\n\n    /**\n     * The set of geometry kinds that is disabled. Their geometry will not be created after\n     * decoding.\n     */\n    get disabledGeometryKinds(): GeometryKindSet {\n        return this.disabledKinds;\n    }\n\n    set disabledGeometryKinds(kinds: GeometryKindSet) {\n        this.disabledKinds = kinds;\n    }\n\n    /**\n     * The set of geometry kinds that is hidden. Their geometry may be created, but it is hidden\n     * until the method `hideKind` with an argument of `addOrRemoveToHiddenSet:false` is called.\n     */\n    get hiddenGeometryKinds(): GeometryKindSet {\n        return this.hiddenKinds;\n    }\n\n    set hiddenGeometryKinds(kinds: GeometryKindSet) {\n        this.hiddenKinds = kinds;\n        this.incrementVisibilityCounter();\n    }\n\n    /**\n     * If set to `true`, the filters of enabled/disabledGeometryKinds are applied, otherwise they\n     * are ignored.\n     */\n    enableFilterByKind: boolean = true;\n\n    protected get visibilityCounter(): number {\n        return this.m_visibilityCounter;\n    }\n\n    protected enabledKinds: GeometryKindSet = new GeometryKindSet();\n    protected disabledKinds: GeometryKindSet = new GeometryKindSet();\n    protected hiddenKinds: GeometryKindSet = new GeometryKindSet();\n\n    protected m_tileUpdateCallback: TileUpdateCallback | undefined;\n\n    /**\n     * Optimization for evaluation in `update()` method. Only if a kind is hidden/unhidden, the\n     * visibility of the kinds is applied to their geometries.\n     */\n    private m_visibilityCounter: number = 1;\n\n    /**\n     * Creates an instance of `TileGeometryManager` with a reference to the {@link MapView}.\n     */\n    constructor(protected mapView: MapView) {}\n\n    /**\n     * Initialize the {@link Tile} with the TileGeometryManager.\n     */\n    initTile(tile: Tile): void {\n        if (tile.dataSource.useGeometryLoader) {\n            tile.tileGeometryLoader = new TileGeometryLoader(tile);\n        }\n    }\n\n    /**\n     * Process the {@link Tile}s for rendering. May alter the content of the tile per frame.\n     */\n    updateTiles(tiles: Tile[]): void {\n        for (const tile of tiles) {\n            const geometryLoader = tile.tileGeometryLoader;\n            if (geometryLoader !== undefined) {\n                geometryLoader.update(\n                    this.enableFilterByKind ? this.enabledGeometryKinds : undefined,\n                    this.enableFilterByKind ? this.disabledGeometryKinds : undefined\n                );\n                if (this.m_tileUpdateCallback) {\n                    this.m_tileUpdateCallback(tile);\n                }\n            }\n        }\n\n        // If the visibility status of the kinds changed since the last update, the new visibility\n        // status is applied (again).\n        if (this.updateTileObjectVisibility(tiles)) {\n            this.mapView.update();\n        }\n    }\n\n    /**\n     * Clear the enabled, disabled and hidden sets.\n     */\n    clear(): void {\n        this.enabledKinds.clear();\n        this.disabledKinds.clear();\n        this.hiddenKinds.clear();\n    }\n\n    /**\n     * Enable a [[GeometryKind]] by adding it to the enabled set, or remove it from that set.\n     *\n     * @param {(GeometryKind | GeometryKind[] | GeometryKindSet)} kind The kind to add or remove\n     *      from the enabled set.\n     * @param {boolean} addOrRemoveToEnabledSet Pass in `true` to add the kind to the set, pass in\n     *      `false` to remove from that set.\n     */\n    enableKind(\n        kind: GeometryKind | GeometryKind[] | GeometryKindSet,\n        addOrRemoveToEnabledSet: boolean = true\n    ): void {\n        this.enableDisableKinds(this.enabledKinds, kind, addOrRemoveToEnabledSet);\n    }\n\n    /**\n     * Disable a [[GeometryKind]] by adding it to the disabled set, or remove it from that set.\n     *\n     * @param {(GeometryKind | GeometryKind[] | GeometryKindSet)} kind The kind to add or remove\n     *      from the disabled set.\n     * @param {boolean} addOrRemoveToHiddenSet Pass in `true` to add the kind to the set, pass in\n     *      `false` to remove from that set.\n     */\n    disableKind(\n        kind: GeometryKind | GeometryKind[] | GeometryKindSet,\n        addOrRemoveToDisabledSet: boolean = true\n    ): void {\n        this.enableDisableKinds(this.disabledKinds, kind, addOrRemoveToDisabledSet);\n    }\n\n    /**\n     * Hide a [[GeometryKind]] by adding it to the hidden set, or remove it from that set.\n     *\n     * @param {(GeometryKind | GeometryKind[] | GeometryKindSet)} kind The kind to add or remove\n     *      from the hidden set.\n     * @param {boolean} addOrRemoveToHiddenSet Pass in `true` to hide the kind(s), `false` to show\n     *      it again.\n     */\n    hideKind(\n        kind: GeometryKind | GeometryKind[] | GeometryKindSet,\n        addOrRemoveToHiddenSet: boolean = true\n    ): void {\n        let visibilityHasChanged = false;\n\n        if (Array.isArray(kind) || kind instanceof Set) {\n            for (const oneKind of kind) {\n                const visibilityChange = this.addRemove(\n                    this.hiddenKinds,\n                    oneKind,\n                    addOrRemoveToHiddenSet\n                );\n                visibilityHasChanged = visibilityHasChanged || visibilityChange;\n            }\n        } else {\n            visibilityHasChanged = this.addRemove(this.hiddenKinds, kind, addOrRemoveToHiddenSet);\n        }\n\n        // Will be evaluated in the next update()\n        if (visibilityHasChanged) {\n            this.incrementVisibilityCounter();\n        }\n    }\n\n    /**\n     * Return all [[GeometryKind]]s that are contained in the tiles.\n     *\n     * @param {IterableIterator<Tile>} tiles The\n     * @returns {GeometryKindSet}\n     */\n    getAvailableKinds(tiles: IterableIterator<Tile>): GeometryKindSet {\n        const visibleKinds: GeometryKindSet = new GeometryKindSet();\n        for (const tile of tiles) {\n            const geometryLoader = tile.tileGeometryLoader;\n            if (geometryLoader !== undefined) {\n                const tileKinds = geometryLoader.availableGeometryKinds;\n                if (tileKinds !== undefined) {\n                    for (const kind of tileKinds) {\n                        visibleKinds.add(kind);\n                    }\n                }\n            }\n        }\n        return visibleKinds;\n    }\n\n    /**\n     * Apply the visibility status taken from the `hiddenKinds` to all geometries in the specified\n     * tiles.\n     *\n     * @param {Tile[]} tiles List of [[Tiles]] to process the visibility status of.\n     */\n    updateTileObjectVisibility(tiles: Tile[]): boolean {\n        let needUpdate = false;\n\n        for (const tile of tiles) {\n            if (tile.objects.length === 0 || tile.visibilityCounter === this.visibilityCounter) {\n                continue;\n            }\n            tile.visibilityCounter = this.visibilityCounter;\n\n            for (const object of tile.objects) {\n                const objectAdapter = MapObjectAdapter.get(object);\n                const geometryKind = objectAdapter?.kind;\n                if (geometryKind !== undefined) {\n                    const nowVisible = !geometryKind.some(kind => this.hiddenKinds.has(kind));\n                    needUpdate = needUpdate || object.visible !== nowVisible;\n                    object.visible = nowVisible;\n                }\n            }\n        }\n        return needUpdate;\n    }\n\n    /**\n     * Sets a callback that will be called for every updated tile on [[updateTiles]].\n     *\n     * @param {TileUpdateCallback} callback The callback that will be called after a tile has been\n     * updated, passing the updated tile as argument. If `undefined`, a previously set callback will\n     * be cleared.\n     */\n    setTileUpdateCallback(callback?: TileUpdateCallback): void {\n        this.m_tileUpdateCallback = callback;\n    }\n\n    protected incrementVisibilityCounter(): number {\n        return ++this.m_visibilityCounter;\n    }\n\n    /**\n     * Add or remove a kind|array of kinds|set of kinds from the specified kind set.\n     *\n     * @hidden\n     * @param {GeometryKindSet} set\n     * @param {(GeometryKind | GeometryKind[] | GeometryKindSet)} kind\n     * @param {boolean} addToSet\n     */\n    private enableDisableKinds(\n        set: GeometryKindSet,\n        kind: GeometryKind | GeometryKind[] | GeometryKindSet,\n        addToSet: boolean\n    ): void {\n        if (Array.isArray(kind)) {\n            for (const oneKind of kind as GeometryKind[]) {\n                this.addRemove(set, oneKind, addToSet);\n            }\n        } else if (kind instanceof Set) {\n            const kindSet = kind as GeometryKindSet;\n            for (const oneKind of kindSet) {\n                this.addRemove(set, oneKind, addToSet);\n            }\n        } else if (kind !== undefined) {\n            this.addRemove(set, kind, addToSet);\n        }\n    }\n\n    /**\n     * Add or remove a single kind from the specified kind set.\n     *\n     * @hidden\n     * @param {GeometryKindSet} set\n     * @param {(GeometryKind | GeometryKind[] | GeometryKindSet)} kind\n     * @param {boolean} addToSet\n     */\n    private addRemove(kindsSet: GeometryKindSet, kind: GeometryKind, addToSet: boolean): boolean {\n        if (addToSet) {\n            if (!kindsSet.has(kind)) {\n                kindsSet.add(kind);\n                return true;\n            }\n        } else {\n            if (kindsSet.has(kind)) {\n                kindsSet.delete(kind);\n                return true;\n            }\n        }\n        return false;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {\n    DecodedTile,\n    GeometryKind,\n    GeometryKindSet,\n    isExtrudedLineTechnique,\n    isExtrudedPolygonTechnique,\n    isFillTechnique,\n    isLineMarkerTechnique,\n    isLineTechnique,\n    isPoiTechnique,\n    isSegmentsTechnique,\n    isSolidLineTechnique,\n    isTextTechnique,\n    Technique\n} from \"@here/harp-datasource-protocol\";\nimport { PerformanceTimer } from \"@here/harp-utils\";\n\nimport { PerformanceStatistics } from \"../Statistics\";\nimport { Tile } from \"../Tile\";\nimport { TileGeometryCreator } from \"./TileGeometryCreator\";\n\n/**\n * Loads the geometry for its {@link Tile}. Loads all geometry in a single step.\n */\nexport class TileGeometryLoader {\n    /**\n     * Make sure that all technique have their geometryKind set, either from the theme or their\n     * default value.\n     *\n     * Also gather set of the [[GeometryKind]]s found in the techniques and return it.\n     *\n     * @param {DecodedTile} decodedTile\n     * @returns {GeometryKindSet} The set of kinds used in the decodeTile.\n     */\n    static prepareAvailableGeometryKinds(decodedTile: DecodedTile): GeometryKindSet {\n        const foundSet: GeometryKindSet = new GeometryKindSet();\n\n        for (const technique of decodedTile.techniques) {\n            const geometryKind = TileGeometryLoader.compileGeometryKind(technique);\n\n            if (geometryKind instanceof Set) {\n                for (const kind of geometryKind) {\n                    foundSet.add(kind);\n                }\n            } else {\n                foundSet.add(geometryKind);\n            }\n        }\n        return foundSet;\n    }\n\n    /**\n     * Make sure that the technique has its geometryKind set, either from the theme or their default\n     * value.\n     *\n     * @param {Technique} technique\n     */\n    static compileGeometryKind(technique: Technique): GeometryKind | GeometryKindSet {\n        // tslint:disable-next-line: deprecation\n        let geometryKind = technique.kind;\n\n        // Set default kind based on technique.\n        if (geometryKind === undefined) {\n            if (isFillTechnique(technique)) {\n                geometryKind = GeometryKind.Area;\n            } else if (\n                isLineTechnique(technique) ||\n                isSolidLineTechnique(technique) ||\n                isSegmentsTechnique(technique) ||\n                isExtrudedLineTechnique(technique)\n            ) {\n                geometryKind = GeometryKind.Line;\n            } else if (isExtrudedPolygonTechnique(technique)) {\n                geometryKind = GeometryKind.Building;\n            } else if (\n                isPoiTechnique(technique) ||\n                isLineMarkerTechnique(technique) ||\n                isTextTechnique(technique)\n            ) {\n                geometryKind = GeometryKind.Label;\n            } else {\n                geometryKind = GeometryKind.All;\n            }\n\n            // tslint:disable-next-line: deprecation\n            technique.kind = geometryKind;\n        } else if (Array.isArray(geometryKind)) {\n            // tslint:disable-next-line: deprecation\n            geometryKind = technique.kind = new GeometryKindSet(geometryKind);\n        }\n\n        return geometryKind;\n    }\n\n    private m_decodedTile?: DecodedTile;\n    private m_isFinished: boolean = false;\n    private m_availableGeometryKinds: GeometryKindSet | undefined;\n    private m_enabledKinds: GeometryKindSet | undefined;\n    private m_disabledKinds: GeometryKindSet | undefined;\n    private m_timeout: any;\n\n    constructor(private m_tile: Tile) {}\n\n    /**\n     * The {@link Tile} this `TileGeometryLoader` is managing.\n     */\n    get tile(): Tile {\n        return this.m_tile;\n    }\n\n    /**\n     * `True` if all geometry of the `Tile` has been loaded and the loading process is finished.\n     */\n    get isFinished(): boolean {\n        return this.m_isFinished;\n    }\n\n    /**\n     * `True` if geometry of a `Tile` has been loaded but is not fully processed.\n     */\n    get geometryCreationPending(): boolean {\n        // Geometry loading not yet finished and timeout already set, but not yet processing\n        // (m_timeout !== undefined), or timeout callback already in progress\n        // (m_timeout === undefined), but decoded tile still not reset.\n        return !this.isFinished && this.m_decodedTile !== undefined;\n    }\n\n    /**\n     * `True` if the basic geometry has been loaded, and the `Tile` is ready  for display.\n     */\n    get basicGeometryLoaded(): boolean {\n        return this.m_tile.hasGeometry;\n    }\n\n    /**\n     * `True` if all geometry of the `Tile` has been loaded.\n     */\n    get allGeometryLoaded(): boolean {\n        return this.m_isFinished;\n    }\n\n    /**\n     * Set the {@link @here/harp-datasource-protocol#DecodedTile} of the tile.\n     *\n     * @remarks\n     * Is called after the decoded tile has been loaded, and\n     * prepares its content for later processing in the 'updateXXX' methods.\n     *\n     * @param {DecodedTile} decodedTile The decoded tile with the flat geometry data belonging to\n     *      this tile.\n     * @returns {DecodedTile} The processed decoded tile.\n     */\n    setDecodedTile(decodedTile: DecodedTile): DecodedTile {\n        this.m_decodedTile = decodedTile;\n\n        if (this.m_decodedTile !== undefined) {\n            this.m_availableGeometryKinds = TileGeometryLoader.prepareAvailableGeometryKinds(\n                this.m_decodedTile\n            );\n        }\n        return this.m_decodedTile;\n    }\n\n    /**\n     * The kinds of geometry stored in this {@link Tile}.\n     */\n    get availableGeometryKinds(): GeometryKindSet | undefined {\n        return this.m_availableGeometryKinds;\n    }\n\n    /**\n     * Start with or continue with loading geometry. Called repeatedly until `isFinished` is `true`.\n     */\n    update(\n        enabledKinds: GeometryKindSet | undefined,\n        disabledKinds: GeometryKindSet | undefined\n    ): void {\n        const tile = this.tile;\n\n        // Cheap sanity check, do it first so no longer processing is needed.\n        if (this.isFinished) {\n            return;\n        }\n\n        // Check if tile should be already discarded (invisible, disposed).\n        // If the tile is not ready for display, or if it has become invisible while being loaded,\n        // for example by moving the camera, the tile is not finished and its geometry is not\n        // created. This is an optimization for fast camera movements and zooms.\n        if (this.discardNeedlessTile(tile)) {\n            return;\n        }\n\n        // Finish loading if tile has no data.\n        if (tile.tileLoader?.isFinished && tile.decodedTile === undefined) {\n            this.finish();\n            return;\n        }\n\n        // Geometry kinds have changed when loading, if so reset entire loading because\n        // this geometry loader generates all geometry at once.\n        if (\n            this.geometryCreationPending &&\n            !this.compareGeometryKinds(enabledKinds, disabledKinds)\n        ) {\n            this.reset();\n        }\n\n        // First time this tile is handled, or reset has been requested.\n        // Note: Finished condition already checked above.\n        if (!this.geometryCreationPending && tile.decodedTile !== undefined) {\n            TileGeometryCreator.instance.processTechniques(tile, enabledKinds, disabledKinds);\n            this.setGeometryKinds(enabledKinds, disabledKinds);\n            this.setDecodedTile(tile.decodedTile);\n            this.prepareForRender(enabledKinds, disabledKinds);\n        }\n    }\n\n    /**\n     * Dispose of any resources.\n     */\n    dispose(): void {\n        this.m_decodedTile = undefined;\n        // TODO: Release other resource: availableGeometryKind, enabled/disabled sets, timeout?\n    }\n\n    /**\n     * Reset the loader to its initial state and cancels any asynchronous work.\n     */\n    reset(): void {\n        this.m_availableGeometryKinds?.clear();\n        this.m_enabledKinds?.clear();\n        this.m_disabledKinds?.clear();\n\n        this.m_decodedTile = undefined;\n        this.m_isFinished = false;\n\n        if (this.m_timeout !== undefined) {\n            clearTimeout(this.m_timeout);\n            this.m_timeout = undefined;\n        }\n    }\n\n    private finish() {\n        this.m_tile.loadingFinished();\n        this.m_tile.removeDecodedTile();\n\n        this.m_decodedTile = undefined;\n        this.m_isFinished = true;\n\n        if (this.m_timeout !== undefined) {\n            clearTimeout(this.m_timeout);\n            this.m_timeout = undefined;\n        }\n    }\n\n    /**\n     * Called by {@link VisibleTileSet} to mark that {@link Tile} is\n     * visible and it should prepare geometry.\n     */\n    private prepareForRender(\n        enabledKinds: GeometryKindSet | undefined,\n        disabledKinds: GeometryKindSet | undefined\n    ) {\n        const tile = this.tile;\n        const decodedTile = this.m_decodedTile;\n\n        // Just a sanity check that satisfies compiler check below.\n        if (decodedTile === undefined) {\n            this.finish();\n            return;\n        }\n\n        this.m_timeout = setTimeout(() => {\n            // Reset timeout so it is untouched during processing.\n            this.m_timeout = undefined;\n\n            if (this.discardNeedlessTile(tile)) {\n                return;\n            }\n\n            const stats = PerformanceStatistics.instance;\n            let now = 0;\n            if (stats.enabled) {\n                now = PerformanceTimer.now();\n            }\n\n            const geometryCreator = TileGeometryCreator.instance;\n\n            tile.clear();\n            // Set up techniques which should be processed.\n            geometryCreator.initDecodedTile(decodedTile, enabledKinds, disabledKinds);\n            geometryCreator.createAllGeometries(tile, decodedTile);\n\n            if (stats.enabled) {\n                const geometryCreationTime = PerformanceTimer.now() - now;\n                const currentFrame = stats.currentFrame;\n\n                // Account for the geometry creation in the current frame.\n                currentFrame.addValue(\"render.fullFrameTime\", geometryCreationTime);\n                currentFrame.addValue(\"render.geometryCreationTime\", geometryCreationTime);\n\n                currentFrame.addValue(\"geometry.geometryCreationTime\", geometryCreationTime);\n                currentFrame.addValue(\"geometryCount.numGeometries\", decodedTile.geometries.length);\n                currentFrame.addValue(\"geometryCount.numTechniques\", decodedTile.techniques.length);\n                currentFrame.addValue(\n                    \"geometryCount.numPoiGeometries\",\n                    decodedTile.poiGeometries !== undefined ? decodedTile.poiGeometries.length : 0\n                );\n                currentFrame.addValue(\n                    \"geometryCount.numTextGeometries\",\n                    decodedTile.textGeometries !== undefined ? decodedTile.textGeometries.length : 0\n                );\n                currentFrame.addValue(\n                    \"geometryCount.numTextPathGeometries\",\n                    decodedTile.textPathGeometries !== undefined\n                        ? decodedTile.textPathGeometries.length\n                        : 0\n                );\n                currentFrame.addValue(\n                    \"geometryCount.numPathGeometries\",\n                    decodedTile.pathGeometries !== undefined ? decodedTile.pathGeometries.length : 0\n                );\n                currentFrame.addMessage(\n                    // tslint:disable-next-line: max-line-length\n                    `Decoded tile: ${tile.dataSource.name} # lvl=${tile.tileKey.level} col=${tile.tileKey.column} row=${tile.tileKey.row}`\n                );\n            }\n            this.finish();\n            tile.dataSource.requestUpdate();\n        }, 0);\n    }\n\n    private discardNeedlessTile(tile: Tile): boolean {\n        // If the tile has become invisible while being loaded, for example by moving the\n        // camera, the tile is not finished and its geometry is not created. This is an\n        // optimization for fast camera movements and zooms.\n        if (!tile.isVisible) {\n            // Dispose the tile from the visible set, so it can be reloaded properly next time\n            // it is needed.\n            tile.mapView.visibleTileSet.disposeTile(tile);\n\n            const stats = PerformanceStatistics.instance;\n            if (stats.enabled) {\n                stats.currentFrame.addMessage(\n                    // tslint:disable-next-line: max-line-length\n                    `Decoded tile: ${tile.dataSource.name} # lvl=${tile.tileKey.level} col=${tile.tileKey.column} row=${tile.tileKey.row} DISCARDED - invisible`\n                );\n            }\n            this.finish();\n            return true;\n        }\n        // Tile already disposed (this may potentially happen in timeout callback).\n        else if (tile.disposed) {\n            const stats = PerformanceStatistics.instance;\n            if (stats.enabled) {\n                stats.currentFrame.addMessage(\n                    // tslint:disable-next-line: max-line-length\n                    `Decoded tile: ${tile.dataSource.name} # lvl=${tile.tileKey.level} col=${tile.tileKey.column} row=${tile.tileKey.row} DISCARDED - disposed`\n                );\n            }\n            this.finish();\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Stores geometry kinds used to load decoded tile geometry.\n     *\n     * This values are stored to detect geometry kind changes during loading.\n     *\n     * @param enabledKinds - Set of geometry kinds to be displayed or undefined.\n     * @param disabledKinds - Set of geometry kinds that won't be rendered.\n     */\n    private setGeometryKinds(\n        enabledKinds: GeometryKindSet | undefined,\n        disabledKinds: GeometryKindSet | undefined\n    ): void {\n        if (enabledKinds !== undefined) {\n            this.m_enabledKinds = Object.assign(\n                this.m_enabledKinds ?? new GeometryKindSet(),\n                enabledKinds\n            );\n        }\n        if (disabledKinds !== undefined) {\n            this.m_disabledKinds = Object.assign(\n                this.m_disabledKinds ?? new GeometryKindSet(),\n                disabledKinds\n            );\n        }\n    }\n\n    /**\n     * Compare enabled and disabled geometry kinds with currently set.\n     *\n     * Method compares input sets with recently used geometry kinds in performance wise\n     * manner, taking special care of undefined and zero size sets.\n     *\n     * @param enabledKinds - Set of geometry kinds to be displayed or undefined.\n     * @param disabledKinds - Set of geometry kinds that won't be rendered.\n     * @return `true` only if sets are logically equal, meaning that undefined and empty sets\n     * may result in same geometry (techniques kind) beeing rendered.\n     */\n    private compareGeometryKinds(\n        enabledKinds: GeometryKindSet | undefined,\n        disabledKinds: GeometryKindSet | undefined\n    ): boolean {\n        const enabledSame = this.m_enabledKinds === enabledKinds;\n        const disabledSame = this.m_disabledKinds === disabledKinds;\n        // Same references, no need to compare.\n        if (enabledSame && disabledSame) {\n            return true;\n        }\n        const enabledEmpty =\n            (this.m_enabledKinds === undefined || this.m_enabledKinds.size === 0) &&\n            (enabledKinds === undefined || enabledKinds.size === 0);\n        const disabledEmpty =\n            (this.m_disabledKinds === undefined || this.m_disabledKinds.size === 0) &&\n            (disabledKinds === undefined || disabledKinds.size === 0);\n\n        // We deal only with empty, the same or undefined sets - fast return, no need to compare.\n        if (\n            (enabledEmpty && disabledEmpty) ||\n            (enabledSame && disabledEmpty) ||\n            (disabledSame && enabledEmpty)\n        ) {\n            return true;\n        }\n        // It is enough that one the the sets are different, try to spot difference otherwise\n        // return true. Compare only non-empty sets.\n        if (!enabledEmpty) {\n            // If one set undefined then other must be non-empty, for sure different.\n            if (enabledKinds === undefined || this.m_enabledKinds === undefined) {\n                return false;\n            }\n            // Both defined and non-empty, compare the sets.\n            else if (!enabledKinds.has(this.m_enabledKinds)) {\n                return false;\n            }\n        }\n        if (!disabledEmpty) {\n            // One set defined and non-empty other undefined, for sure different.\n            if (disabledKinds === undefined || this.m_disabledKinds === undefined) {\n                return false;\n            }\n            // Both defined and non-empty, compare the sets.\n            else if (!disabledKinds.has(this.m_disabledKinds)) {\n                return false;\n            }\n        }\n        // No difference found.\n        return true;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\n/**\n * Raycasting points is not supported as necessary in Three.js. This class extends a\n * [[THREE.Raycaster]] and adds the width / height of the canvas to allow picking of screen space\n * geometry.\n *\n * @internal\n */\nexport class PickingRaycaster extends THREE.Raycaster {\n    /**\n     * Constructor.\n     *\n     * @param width - the canvas width.\n     * @param height - the canvas height.\n     */\n    constructor(public width: number, public height: number) {\n        super();\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { TextCanvas } from \"@here/harp-text-canvas\";\nimport { MapView } from \"../MapView\";\nimport { PoiRenderer } from \"./PoiRenderer\";\n\nexport class PoiRendererFactory {\n    /**\n     * Creates an instance of poi renderer factory.\n     * @param m_mapView -\n     */\n    constructor(private readonly m_mapView: MapView) {}\n\n    /**\n     * Creates poi renderer\n     * @param textCanvas -\n     * @returns\n     */\n    createPoiRenderer(textCanvas: TextCanvas): PoiRenderer {\n        return new PoiRenderer(this.m_mapView, textCanvas);\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport * from \"./lib/StyleSetEvaluator\";\nexport * from \"./lib/IMeshBuffers\";\nexport * from \"./lib/Outliner\";\nexport * from \"./lib/Expr\";\nexport * from \"./lib/ThreeBufferUtils\";\nexport * from \"./lib/GeoJsonDataType\";\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { LoggerManager } from \"@here/harp-utils\";\n\nimport {\n    BooleanLiteralExpr,\n    CallExpr,\n    CaseExpr,\n    Env,\n    Expr,\n    ExprScope,\n    ExprVisitor,\n    HasAttributeExpr,\n    InterpolateExpr,\n    isJsonExpr,\n    JsonExpr,\n    LiteralExpr,\n    MatchExpr,\n    NullLiteralExpr,\n    NumberLiteralExpr,\n    ObjectLiteralExpr,\n    StepExpr,\n    StringLiteralExpr,\n    Value,\n    VarExpr\n} from \"./Expr\";\nimport { ExprPool } from \"./ExprPool\";\nimport {\n    interpolatedPropertyDefinitionToJsonExpr,\n    isInterpolatedPropertyDefinition\n} from \"./InterpolatedPropertyDefs\";\nimport { AttrScope, mergeTechniqueDescriptor } from \"./TechniqueDescriptor\";\nimport { IndexedTechnique, Technique, techniqueDescriptors } from \"./Techniques\";\nimport {\n    Definitions,\n    isActualSelectorDefinition,\n    isJsonExprReference,\n    Style,\n    StyleDeclaration,\n    StyleSelector,\n    StyleSet\n} from \"./Theme\";\n\nconst logger = LoggerManager.instance.create(\"StyleSetEvaluator\");\n\nconst emptyTechniqueDescriptor = mergeTechniqueDescriptor<Technique>({});\n\ninterface StyleInternalParams {\n    /**\n     * Optimization: Lazy creation and storage of expression in a style object.\n     */\n    _whenExpr?: Expr;\n    _minZoomLevelExpr?: Expr;\n    _maxZoomLevelExpr?: Expr;\n\n    _staticAttributes?: Array<[string, Value]>;\n\n    /**\n     * These attributes are used to instantiate Technique variants.\n     *\n     * @see [[TechiqueDescriptor.techniquePropNames]]\n     */\n    _dynamicTechniqueAttributes?: Array<[string, Expr]>;\n\n    /**\n     * These attributes must be evaluated basing with feature env.\n     *\n     * They are not propagated to rendering scope.\n     *\n     * @see [[TechniqueAttrScope.Feature]]\n     */\n    _dynamicFeatureAttributes?: Array<[string, Expr]>;\n\n    /**\n     * These attributes are forwarded as serialized by decoder to main thread, so they are resolved\n     * directly in render loop.\n     *\n     * Will contain attributes from these lists\n     *  - interpolants from [[TechiqueDescriptor.techniquePropNames]]\n     *  - expressions [[TechniqueDescriptor.dynamicPropNames]] (Future)\n     */\n    _dynamicForwardedAttributes?: Array<[string, Expr]>;\n    _dynamicTechniques?: Map<string, IndexedTechnique>;\n\n    /**\n     * Optimization: Index into table in StyleSetEvaluator.\n     * @hidden\n     */\n    _staticTechnique?: IndexedTechnique;\n\n    /**\n     * Optimization: StyleSet index.\n     * @hidden\n     */\n    _styleSetIndex?: number;\n\n    /**\n     * Optimization: Requested $geometryType.\n     * @hidden\n     */\n    _geometryType?: string;\n\n    /**\n     * `true` if any of the properties of this technique\n     * requires access to the feature's state.\n     */\n    _usesFeatureState?: boolean;\n}\n\ntype InternalStyle = Style & StyleSelector & StyleInternalParams;\n\n/**\n * [[StyleConditionClassifier]] searches for usages of `$layer` in `when` conditions\n * associated with styling rules.\n *\n * @hidden\n */\nclass StyleConditionClassifier implements ExprVisitor<Expr | undefined, Expr | undefined> {\n    private _style!: InternalStyle;\n\n    classify(style: InternalStyle) {\n        if (style._whenExpr) {\n            const savedStyle = this.switchStyle(style);\n            style._whenExpr = style._whenExpr.accept(this, undefined);\n            this._style = savedStyle;\n        }\n    }\n\n    visitNullLiteralExpr(expr: NullLiteralExpr, enclosingExpr: Expr | undefined): Expr {\n        return expr;\n    }\n\n    visitBooleanLiteralExpr(expr: BooleanLiteralExpr, enclosingExpr: Expr | undefined): Expr {\n        return expr;\n    }\n\n    visitNumberLiteralExpr(expr: NumberLiteralExpr, enclosingExpr: Expr | undefined): Expr {\n        return expr;\n    }\n\n    visitStringLiteralExpr(expr: StringLiteralExpr, enclosingExpr: Expr | undefined): Expr {\n        return expr;\n    }\n\n    visitObjectLiteralExpr(expr: ObjectLiteralExpr, enclosingExpr: Expr | undefined): Expr {\n        return expr;\n    }\n\n    visitVarExpr(expr: VarExpr, enclosingExpr: Expr | undefined): Expr {\n        return expr;\n    }\n\n    visitHasAttributeExpr(expr: HasAttributeExpr, enclosingExpr: Expr | undefined): Expr {\n        return expr;\n    }\n\n    visitMatchExpr(expr: MatchExpr, enclosingExpr: Expr | undefined): Expr {\n        return expr;\n    }\n\n    visitCaseExpr(expr: CaseExpr, enclosingExpr: Expr | undefined): Expr {\n        return expr;\n    }\n\n    visitCallExpr(call: CallExpr, enclosingExpr: Expr | undefined): Expr | undefined {\n        if (call.op === \"all\") {\n            // processing of an `[\"all\", e1, e2, ... eN]` expression. In this case\n            // search for expressions matching comparison of `$layer` and string literals\n            // in the sub expressions.\n            const children = call.args\n                .map(childExpr => childExpr.accept(this, call))\n                .filter(childExpr => childExpr !== undefined) as Expr[];\n\n            return new CallExpr(call.op, children);\n        } else if (enclosingExpr) {\n            // `call` is a direct child expression of an `\"all\"` operator.\n            const matched = this.matchVarStringComparison(call);\n\n            if (matched) {\n                if (this._style.layer === undefined && matched.name === \"$layer\") {\n                    // found a subexpression `[\"==\", [\"get\", \"$layer\"], \"some layer name\"]`\n                    // enclosed in an `[\"all\", e1...eN]` expression. Remove it from\n                    // its parent expression and store the value of the expected $layer in\n                    // [[StyleInternalParams]].\n\n                    this._style.layer = matched.value;\n\n                    // return `undefined` to remove this sub expression from its parent.\n                    return undefined;\n                } else if (\n                    this._style._geometryType === undefined &&\n                    matched.name === \"$geometryType\"\n                ) {\n                    // found a subexpression `[\"==\", [\"get\", \"$geometryType\"], \"geometry\"]`\n                    // enclosed in an `[\"all\", e1...eN]` expression. Remove it from\n                    // its parent expression and store the value of the expected $geometryType in\n                    // [[StyleInternalParams]].\n\n                    this._style._geometryType = matched.value;\n\n                    // return `undefined` to remove this sub expression from its parent.\n                    return undefined;\n                }\n            }\n        }\n\n        return call;\n    }\n\n    visitStepExpr(expr: StepExpr, enclosingExpr: Expr | undefined): Expr | undefined {\n        throw new Error(\"todo\");\n    }\n\n    visitInterpolateExpr(expr: InterpolateExpr, enclosingExpr: Expr | undefined): Expr | undefined {\n        throw new Error(\"todo\");\n    }\n\n    /**\n     * Tests if the given `call` matches the structure [\"==\", [\"get\", name], value].\n     * If a match is found returns an object containing the `name` and the `value`;\n     *\n     * @param call - The expression to match.\n     */\n    private matchVarStringComparison(call: CallExpr) {\n        if (call.op === \"==\") {\n            const left = call.args[0];\n            const right = call.args[1];\n\n            if (left instanceof VarExpr && right instanceof StringLiteralExpr) {\n                return { name: left.name, value: right.value };\n            }\n\n            if (right instanceof VarExpr && left instanceof StringLiteralExpr) {\n                return { name: right.name, value: left.value };\n            }\n        }\n\n        return undefined;\n    }\n\n    /**\n     * Sets the given `style` as current.\n     *\n     * @returns The previous `style`.\n     */\n    private switchStyle(style: InternalStyle) {\n        const saved = this._style;\n        this._style = style;\n        return saved;\n    }\n}\n\nclass OptimizedSubSetKey {\n    key: string;\n    layer: string | undefined;\n    geometryType: string | undefined;\n\n    cachedStyleSet?: InternalStyle[];\n\n    constructor(layer?: string | undefined, geometryType?: string | undefined) {\n        this.key = \"\";\n        this.set(layer, geometryType);\n    }\n\n    set(\n        layer: string | undefined,\n        geometryType: string | undefined,\n        env?: Env\n    ): OptimizedSubSetKey {\n        let keyUpdateNeeded: boolean = false;\n        if (layer === undefined) {\n            const envLayer = env !== undefined ? env.lookup(\"$layer\") : undefined;\n            layer = typeof envLayer === \"string\" ? envLayer : undefined;\n        }\n        if (this.layer !== layer) {\n            this.layer = layer;\n            keyUpdateNeeded = true;\n        }\n\n        if (geometryType === undefined) {\n            const envGeometryType = env !== undefined ? env.lookup(\"$geometryType\") : undefined;\n            geometryType = typeof envGeometryType === \"string\" ? envGeometryType : undefined;\n        }\n        if (this.geometryType !== geometryType) {\n            this.geometryType = geometryType;\n            keyUpdateNeeded = true;\n        }\n\n        if (keyUpdateNeeded) {\n            this.updateKey();\n        }\n        return this;\n    }\n\n    private updateKey() {\n        if (this.layer !== undefined) {\n            // tslint:disable-next-line:prefer-conditional-expression\n            if (this.geometryType !== undefined) {\n                this.key = `${this.layer}:${this.geometryType}`;\n            } else {\n                this.key = `${this.layer}:`;\n            }\n        } else {\n            if (this.geometryType !== undefined) {\n                this.key = `:${this.geometryType}`;\n            } else {\n                this.key = \"all\";\n            }\n        }\n        this.cachedStyleSet = undefined;\n    }\n}\n\n/**\n * Combine data from datasource and apply the rules from a specified theme to show it on the map.\n */\nexport class StyleSetEvaluator {\n    readonly styleSet: InternalStyle[];\n\n    private readonly m_techniques: IndexedTechnique[] = [];\n    private readonly m_exprPool = new ExprPool();\n    private readonly m_cachedResults = new Map<Expr, Value>();\n    private readonly m_styleConditionClassifier = new StyleConditionClassifier();\n    private readonly m_subStyleSetCache = new Map<string, InternalStyle[]>();\n    private readonly m_definitions?: Definitions;\n    private readonly m_definitionExprCache = new Map<string, Expr>();\n    private readonly m_tmpOptimizedSubSetKey: OptimizedSubSetKey = new OptimizedSubSetKey();\n    private readonly m_emptyEnv = new Env();\n    private m_featureDependencies: string[] = [];\n    private m_layer: string | undefined;\n    private m_geometryType: string | undefined;\n    private m_zoomLevel: number | undefined;\n    private m_previousResult: IndexedTechnique[] | undefined;\n    private m_previousEnv: Env | undefined;\n\n    constructor(styleSet: StyleSet, definitions?: Definitions) {\n        this.m_definitions = definitions;\n        this.styleSet = resolveReferences(styleSet, definitions);\n        computeDefaultRenderOrder(this.styleSet);\n        this.compileStyleSet();\n    }\n\n    /**\n     * Find all techniques that fit the current objects' environment.\n     * *The techniques in the resulting array may not be modified* since they are being reused for\n     * identical objects.\n     *\n     * @param env - The objects environment, i.e. the attributes that are relevant for its\n     * representation.\n     * @param layer - The optional layer name used to filter techniques.\n     * @param geometryType - The optional geometryType used to filter techniques.\n     */\n    getMatchingTechniques(\n        env: Env,\n        layer?: string | undefined,\n        geometryType?: string | undefined\n    ): IndexedTechnique[] {\n        if (\n            this.m_previousResult &&\n            this.m_previousEnv &&\n            this.m_featureDependencies.every(p => this.m_previousEnv?.lookup(p) === env.lookup(p))\n        ) {\n            return this.m_previousResult;\n        }\n\n        const result: IndexedTechnique[] = [];\n        this.m_cachedResults.clear();\n\n        const optimizedSubSetKey = this.m_tmpOptimizedSubSetKey;\n        optimizedSubSetKey.set(layer, geometryType, env);\n\n        // get the requested $layer and $geometryType, if any.\n        this.m_layer = optimizedSubSetKey.layer;\n        this.m_geometryType = optimizedSubSetKey.geometryType;\n        this.m_zoomLevel = env.lookup(\"$zoom\") as number | undefined;\n\n        const searchedStyleSet = this.getOptimizedStyleSet(optimizedSubSetKey);\n\n        for (const currStyle of searchedStyleSet) {\n            if (this.processStyle(env, currStyle, result)) {\n                break;\n            }\n        }\n\n        this.m_previousResult = result;\n        this.m_previousEnv = env;\n\n        return result;\n    }\n\n    /**\n     * Check if `styleSet` contains any rule related to `layer`.\n     *\n     * @param layer - name of layer\n     */\n    wantsLayer(layer: string): boolean {\n        return (\n            this.getOptimizedStyleSet(this.m_tmpOptimizedSubSetKey.set(layer, undefined)).length > 0\n        );\n    }\n\n    /**\n     * Check if `styleSet` contains any rule related to particular `[layer, geometryType]` pair.\n     *\n     * @param layer - name of layer\n     * @param geometryType - type of layer - `point`, `line` or `polygon`\n     */\n    wantsFeature(layer: string, geometryType?: string): boolean {\n        return (\n            this.getOptimizedStyleSet(this.m_tmpOptimizedSubSetKey.set(layer, geometryType))\n                .length > 0\n        );\n    }\n\n    /**\n     * Get the expression evaluation cache, for further feature processing.\n     *\n     * This object is valid until next `getMatchingTechniques` call.\n     */\n    get expressionEvaluatorCache() {\n        return this.m_cachedResults;\n    }\n\n    /**\n     * Reset array of techniques.\n     *\n     * Cleans technique array and indices, so it doesn't accumulate accross several decoding runs.\n     */\n    resetTechniques() {\n        for (const techinque of this.m_techniques) {\n            techinque._index = undefined!;\n        }\n        this.m_techniques.length = 0;\n        this.m_previousResult = undefined;\n        this.m_previousEnv = undefined;\n    }\n\n    /**\n     * Get the (current) array of techniques that have been created during decoding.\n     */\n    get techniques(): IndexedTechnique[] {\n        return this.m_techniques;\n    }\n\n    /**\n     * Get the (current) array of techniques that have been created during decoding.\n     */\n    get decodedTechniques(): IndexedTechnique[] {\n        return this.m_techniques.map(makeDecodedTechnique);\n    }\n\n    private getOptimizedStyleSet(subSetKey: OptimizedSubSetKey): InternalStyle[] {\n        if (subSetKey.cachedStyleSet !== undefined) {\n            return subSetKey.cachedStyleSet;\n        }\n        let optimizedStyleSet = this.m_subStyleSetCache.get(subSetKey.key);\n        if (optimizedStyleSet !== undefined) {\n            subSetKey.cachedStyleSet = optimizedStyleSet;\n            return optimizedStyleSet;\n        }\n        optimizedStyleSet = this.createPreFilteredStyleSet(subSetKey);\n        this.m_subStyleSetCache.set(subSetKey.key, optimizedStyleSet);\n        subSetKey.cachedStyleSet = optimizedStyleSet;\n        return optimizedStyleSet;\n    }\n\n    private createPreFilteredStyleSet(subSetKey: OptimizedSubSetKey) {\n        const { layer, geometryType } = subSetKey;\n\n        return this.styleSet.filter(style => {\n            if (layer !== undefined && style.layer !== undefined && style.layer !== layer) {\n                return false;\n            }\n            if (\n                geometryType !== undefined &&\n                style._geometryType !== undefined &&\n                style._geometryType !== geometryType\n            ) {\n                return false;\n            }\n            return true;\n        });\n    }\n\n    /**\n     * Compile the `when` conditions found when traversting the styling rules.\n     */\n    private compileStyleSet() {\n        this.m_featureDependencies = [\"$layer\", \"$geometryType\", \"$zoom\"];\n\n        this.styleSet.forEach(style => this.compileStyle(style));\n\n        // Create optimized styleSets for each `layer` & `geometryType` tuple.\n        this.styleSet.forEach(style => {\n            this.getOptimizedStyleSet(\n                this.m_tmpOptimizedSubSetKey.set(style.layer, style._geometryType)\n            );\n        });\n    }\n\n    /**\n     * Compile the `when` conditions reachable from the given `style`.\n     *\n     * @param style - The current style.\n     */\n    private compileStyle(style: InternalStyle) {\n        this.checkStyleDynamicAttributes(style);\n\n        if (style.when !== undefined) {\n            try {\n                style._whenExpr = Array.isArray(style.when)\n                    ? Expr.fromJSON(style.when, this.m_definitions, this.m_definitionExprCache)\n                    : // tslint:disable-next-line: deprecation\n                      Expr.parse(style.when);\n\n                // search for usages of '$layer' and any other\n                // special symbol that can be used to speed up the evaluation\n                // of the `when` conditions associated to this `style`.\n                this.m_styleConditionClassifier.classify(style);\n\n                if (style._whenExpr !== undefined) {\n                    style._whenExpr = style._whenExpr.intern(this.m_exprPool);\n                }\n\n                const deps = style._whenExpr.dependencies();\n\n                deps?.properties.forEach(prop => {\n                    if (!this.m_featureDependencies.includes(prop)) {\n                        this.m_featureDependencies.push(prop);\n                    }\n                });\n\n                if (isJsonExpr(style.minZoomLevel)) {\n                    style._minZoomLevelExpr = Expr.fromJSON(style.minZoomLevel).intern(\n                        this.m_exprPool\n                    );\n                }\n\n                if (isJsonExpr(style.maxZoomLevel)) {\n                    style._maxZoomLevelExpr = Expr.fromJSON(style.maxZoomLevel).intern(\n                        this.m_exprPool\n                    );\n                }\n            } catch (err) {\n                logger.log(\n                    \"failed to evaluate expression\",\n                    JSON.stringify(style.when),\n                    \"error\",\n                    String(err)\n                );\n            }\n        }\n    }\n\n    /**\n     * Process a style (and its sub-styles) hierarchically to look for the technique that fits the\n     * current objects' environment. The attributes of the styles are assembled to create a unique\n     * technique for every object.\n     *\n     * @param env - The objects environment, i.e. the attributes that are relevant for its\n     *            representation.\n     * @param style - Current style (could also be top of stack).\n     * @param result - The array of resulting techniques. There may be more than one technique per\n     *               object, resulting in multiple graphical objects for representation.\n     * @returns `true` if style has been found and processing is finished. `false` if not found, or\n     *          more than one technique should be applied.\n     */\n    private processStyle(env: Env, style: InternalStyle, result: Technique[]): boolean {\n        if (!this.checkZoomLevel(env, style)) {\n            return false;\n        }\n\n        if (\n            this.m_layer !== undefined &&\n            style.layer !== undefined &&\n            style.layer !== this.m_layer\n        ) {\n            return false;\n        }\n        if (\n            this.m_geometryType !== undefined &&\n            style._geometryType !== undefined &&\n            style._geometryType !== this.m_geometryType\n        ) {\n            return false;\n        }\n\n        if (style._whenExpr) {\n            try {\n                if (!style._whenExpr.evaluate(env, ExprScope.Condition, this.m_cachedResults)) {\n                    // Stop processing this styling rule. The `when` condition\n                    // associated with the current `style` evaluates to false so\n                    // no techinque defined by this style should be applied.\n                    return false;\n                }\n            } catch (error) {\n                logger.error(\n                    `failed to evaluate expression '${JSON.stringify(style.when)}': ${error}`\n                );\n                return false;\n            }\n        }\n\n        if (style.technique === undefined) {\n            return false;\n        }\n        // we found a technique!\n        if (style.technique !== \"none\") {\n            result.push(this.getTechniqueForStyleMatch(env, style));\n        }\n        // stop processing if \"final\" is set\n        return style.final === true;\n    }\n\n    private checkZoomLevel(env: Env, style: InternalStyle) {\n        if (style.minZoomLevel === undefined && style.maxZoomLevel === undefined) {\n            return true;\n        }\n\n        const zoomLevel = this.m_zoomLevel;\n        if (zoomLevel === undefined) {\n            return true;\n        }\n\n        if (style.minZoomLevel !== undefined) {\n            let minZoomLevel: Value = style.minZoomLevel;\n\n            if (style._minZoomLevelExpr) {\n                // the constraint is defined as expression, evaluate it and\n                // use its value\n                try {\n                    minZoomLevel = style._minZoomLevelExpr.evaluate(\n                        env,\n                        ExprScope.Condition,\n                        this.m_cachedResults\n                    );\n                } catch (error) {\n                    logger.error(\n                        `failed to evaluate expression '${JSON.stringify(\n                            style._minZoomLevelExpr\n                        )}': ${error}`\n                    );\n                }\n            }\n\n            if (typeof minZoomLevel === \"number\" && zoomLevel < minZoomLevel) {\n                return false;\n            }\n        }\n\n        if (style.maxZoomLevel !== undefined) {\n            let maxZoomLevel: Value = style.maxZoomLevel;\n\n            if (style._maxZoomLevelExpr) {\n                try {\n                    maxZoomLevel = style._maxZoomLevelExpr.evaluate(\n                        env,\n                        ExprScope.Condition,\n                        this.m_cachedResults\n                    );\n                } catch (error) {\n                    logger.error(\n                        `failed to evaluate expression '${JSON.stringify(\n                            style._maxZoomLevelExpr\n                        )}': ${error}`\n                    );\n                }\n            }\n\n            if (typeof maxZoomLevel === \"number\" && zoomLevel > maxZoomLevel) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private getTechniqueForStyleMatch(env: Env, style: InternalStyle) {\n        let technique: IndexedTechnique | undefined;\n        if (style._dynamicTechniques !== undefined) {\n            const dynamicAttributes = this.evaluateTechniqueProperties(style, env);\n            const key = this.getDynamicTechniqueKey(style, dynamicAttributes);\n            technique = style._dynamicTechniques!.get(key);\n            if (technique === undefined) {\n                technique = this.createTechnique(style, key, dynamicAttributes);\n                style._dynamicTechniques!.set(key, technique);\n            }\n        } else {\n            technique = style._staticTechnique;\n            if (technique === undefined) {\n                style._staticTechnique = technique = this.createTechnique(\n                    style,\n                    `${style._styleSetIndex}`,\n                    []\n                ) as IndexedTechnique;\n            }\n        }\n\n        if (technique._index === undefined) {\n            technique._index = this.m_techniques.length;\n            this.m_techniques.push(technique);\n        }\n        return technique;\n    }\n\n    private getDynamicTechniqueKey(\n        style: InternalStyle,\n        dynamicAttributes: Array<[string, Value]>\n    ) {\n        const dynamicAttrKey = dynamicAttributes\n            .map(([_attrName, attrValue]) => {\n                if (attrValue === undefined) {\n                    return \"U\";\n                } else {\n                    return JSON.stringify(attrValue);\n                }\n            })\n            .join(\":\");\n        return `${style._styleSetIndex!}:${dynamicAttrKey}`;\n    }\n\n    private checkStyleDynamicAttributes(style: InternalStyle) {\n        if (style._dynamicTechniqueAttributes !== undefined || style.technique === \"none\") {\n            return;\n        }\n\n        style._dynamicTechniqueAttributes = [];\n        style._dynamicFeatureAttributes = [];\n        style._dynamicForwardedAttributes = [];\n        style._staticAttributes = [];\n\n        const dynamicFeatureAttributes = style._dynamicFeatureAttributes;\n        const dynamicTechniqueAttributes = style._dynamicTechniqueAttributes;\n        const dynamicForwardedAttributes = style._dynamicForwardedAttributes;\n        const targetStaticAttributes = style._staticAttributes;\n\n        const techniqueDescriptor =\n            techniqueDescriptors[style.technique] || emptyTechniqueDescriptor;\n\n        const processAttribute = (attrName: string, attrValue: Value | JsonExpr | undefined) => {\n            if (attrValue === undefined) {\n                return;\n            }\n\n            if (isJsonExpr(attrValue)) {\n                attrValue = Expr.fromJSON(\n                    attrValue,\n                    this.m_definitions,\n                    this.m_definitionExprCache\n                ).intern(this.m_exprPool);\n            } else if (isInterpolatedPropertyDefinition(attrValue)) {\n                // found a property using an object-like interpolation definition.\n                attrValue = Expr.fromJSON(\n                    interpolatedPropertyDefinitionToJsonExpr(attrValue)\n                ).intern(this.m_exprPool);\n            }\n\n            if (Expr.isExpr(attrValue)) {\n                const deps = attrValue.dependencies();\n\n                if (deps.featureState) {\n                    if (attrName !== \"enabled\") {\n                        logger.log(\"feature-state is not supported in this context\");\n                    } else {\n                        style._usesFeatureState = true;\n                    }\n                }\n\n                if (deps.properties.size === 0 && !attrValue.isDynamic()) {\n                    // no data-dependencies detected.\n                    attrValue = attrValue.evaluate(this.m_emptyEnv);\n                }\n            }\n\n            if (Expr.isExpr(attrValue)) {\n                let attrScope: AttrScope | undefined = (techniqueDescriptor.attrScopes as any)[\n                    attrName as any\n                ];\n\n                if (attrScope === undefined) {\n                    // Use [[AttrScope.TechniqueGeometry]] as default scope for the attribute.\n                    attrScope = AttrScope.TechniqueGeometry;\n                }\n\n                const deps = attrValue.dependencies();\n\n                deps.properties.forEach(prop => {\n                    if (!this.m_featureDependencies.includes(prop)) {\n                        this.m_featureDependencies.push(prop);\n                    }\n                });\n\n                switch (attrScope) {\n                    case AttrScope.FeatureGeometry:\n                        dynamicFeatureAttributes.push([attrName, attrValue]);\n                        break;\n                    case AttrScope.TechniqueGeometry:\n                        dynamicTechniqueAttributes.push([attrName, attrValue]);\n                        break;\n                    case AttrScope.TechniqueRendering:\n                        if (deps.properties.size === 0) {\n                            dynamicForwardedAttributes.push([attrName, attrValue]);\n                        } else {\n                            dynamicTechniqueAttributes.push([attrName, attrValue]);\n                        }\n                        break;\n                }\n            } else if (attrValue !== undefined && attrValue !== null) {\n                targetStaticAttributes.push([attrName, attrValue]);\n            }\n        };\n\n        const replacement = new Map<string, string>([\n            [\"category\", \"_category\"],\n            [\"secondaryCategory\", \"_secondaryCategory\"]\n        ]);\n\n        for (const p in style) {\n            if (!style.hasOwnProperty(p)) {\n                continue;\n            }\n            if (p.startsWith(\"_\")) {\n                continue;\n            }\n            if ([\"when\", \"technique\", \"layer\", \"attr\", \"description\"].includes(p)) {\n                continue;\n            }\n            const pp = replacement.get(p) ?? p;\n            processAttribute(pp, (style as any)[p]);\n        }\n\n        if (style.attr !== undefined) {\n            for (const attrName in style.attr) {\n                if (!style.attr.hasOwnProperty(attrName)) {\n                    continue;\n                }\n                processAttribute(attrName, (style.attr as any)[attrName]);\n            }\n        }\n\n        if (dynamicTechniqueAttributes.length > 0) {\n            style._dynamicTechniques = new Map();\n        }\n    }\n\n    private evaluateTechniqueProperties(style: InternalStyle, env: Env): Array<[string, Value]> {\n        if (style._dynamicTechniqueAttributes === undefined) {\n            return [];\n        }\n\n        return style._dynamicTechniqueAttributes.map(([attrName, attrExpr]) => {\n            try {\n                const evaluatedValue = attrExpr.evaluate(\n                    env,\n                    ExprScope.Value,\n                    this.m_cachedResults\n                );\n                return [attrName, evaluatedValue];\n            } catch (error) {\n                logger.error(`failed to evaluate expression '${attrExpr.toJSON()}': ${error}`);\n                return [attrName, null];\n            }\n        });\n    }\n\n    private createTechnique(\n        style: InternalStyle,\n        key: string,\n        dynamicAttrs: Array<[string, Value]>\n    ) {\n        const technique: any = {};\n        technique.name = style.technique;\n        if (style._staticAttributes !== undefined) {\n            for (const [attrName, attrValue] of style._staticAttributes) {\n                if (attrValue !== null) {\n                    technique[attrName] = attrValue;\n                }\n            }\n        }\n        for (const [attrName, attrValue] of dynamicAttrs) {\n            if (attrValue !== null) {\n                technique[attrName] = attrValue;\n            }\n        }\n\n        if (style._dynamicFeatureAttributes !== undefined) {\n            for (const [attrName, attrValue] of style._dynamicFeatureAttributes) {\n                technique[attrName] = attrValue;\n            }\n        }\n\n        if (style._dynamicForwardedAttributes !== undefined) {\n            for (const [attrName, attrValue] of style._dynamicForwardedAttributes) {\n                technique[attrName] = attrValue;\n            }\n        }\n\n        technique._index = this.m_techniques.length;\n        technique._styleSetIndex = style._styleSetIndex!;\n        if (style.styleSet !== undefined) {\n            technique._styleSet = style.styleSet;\n        }\n        if (style._usesFeatureState !== undefined) {\n            technique._usesFeatureState = style._usesFeatureState;\n        }\n        this.m_techniques.push(technique as IndexedTechnique);\n        return technique as IndexedTechnique;\n    }\n}\n\nfunction computeDefaultRenderOrder(styleSet: InternalStyle[]) {\n    let techniqueRenderOrder = 0;\n    let styleSetIndex = 0;\n    for (const style of styleSet) {\n        style._styleSetIndex = styleSetIndex++;\n        if (style.technique !== undefined && style.renderOrder === undefined) {\n            style.renderOrder = techniqueRenderOrder++;\n        }\n    }\n}\n\nfunction resolveReferences(styleSet: StyleDeclaration[], definitions: Definitions | undefined) {\n    return styleSet.map(style => resolveStyleReferences(style, definitions));\n}\n\nfunction resolveStyleReferences(\n    style: StyleDeclaration,\n    definitions: Definitions | undefined\n): InternalStyle {\n    if (isJsonExpr(style)) {\n        if (!isJsonExprReference(style)) {\n            throw new Error(\"invalid expression in this context, only 'ref's are supported\");\n        }\n        // expand and instantiate references to style definitions.\n        const definitionName = style[1];\n        const def = definitions && definitions[definitionName];\n        if (!def) {\n            throw new Error(`invalid reference '${definitionName}' - not found`);\n        }\n        if (!isActualSelectorDefinition(def)) {\n            throw new Error(`invalid reference '${definitionName}' - expected style definition`);\n        }\n        // instantiate the style\n        return resolveStyleReferences(def, definitions);\n    }\n\n    return { ...style };\n}\n\n/**\n * Create transferable representation of dynamic technique.\n *\n * Converts  non-transferable {@link Expr}instances back to JSON form.\n */\nexport function makeDecodedTechnique(technique: IndexedTechnique): IndexedTechnique {\n    const result: Partial<IndexedTechnique> = {};\n    for (const attrName in technique) {\n        if (!technique.hasOwnProperty(attrName)) {\n            continue;\n        }\n\n        let attrValue: any = (technique as any)[attrName];\n\n        if (\n            typeof attrValue === \"object\" &&\n            (attrValue.isVector2 || attrValue.isVector3 || attrValue.isVector4)\n        ) {\n            attrValue = LiteralExpr.fromValue(attrValue);\n        }\n\n        if (Expr.isExpr(attrValue)) {\n            attrValue = attrValue.toJSON();\n        }\n\n        (result as any)[attrName] = attrValue;\n    }\n    return (result as any) as IndexedTechnique;\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nconst currEdgeStart = new THREE.Vector2();\nconst currEdgeGoal = new THREE.Vector2();\nconst prevEdgeStart = new THREE.Vector2();\nconst prevEdgeGoal = new THREE.Vector2();\n\n/**\n * Fills an index buffer with the indices for the edges of a polygon contour.\n *\n * @param indexBuffer - Edge index buffer to be filled.\n * @param vertexOffset - Starting offset of the vertices composing the contour.\n * @param vertexStride - Number of elements per contour vertex.\n * @param polygonContour - Vertices that compose the contour.\n * @param polygonContourEdges - Collection of booleans indicating if contour edges should be added.\n */\nexport function addPolygonEdges(\n    indexBuffer: number[],\n    vertexOffset: number,\n    vertexStride: number,\n    polygonContour: number[],\n    polygonContourEdges: boolean[],\n    isExtruded?: boolean,\n    addFootprintEdges?: boolean,\n    wallEdgeSlope?: number\n) {\n    for (let i = 0; i < polygonContourEdges.length; ++i) {\n        if (polygonContourEdges[i]) {\n            if (isExtruded === true) {\n                const vFootprint0 = vertexOffset + i * 2;\n                const vRoof0 = vFootprint0 + 1;\n                const vFootprint1 = vertexOffset + ((i + 1) % polygonContourEdges.length) * 2;\n                const vRoof1 = vFootprint1 + 1;\n\n                if (addFootprintEdges === true) {\n                    indexBuffer.push(vFootprint0, vFootprint1);\n                }\n                indexBuffer.push(vRoof0, vRoof1);\n\n                const prevEdgeIdx = (i === 0 ? polygonContourEdges.length : i) - 1;\n                if (polygonContourEdges[prevEdgeIdx]) {\n                    if (wallEdgeSlope !== undefined) {\n                        const v0x = polygonContour[i * vertexStride];\n                        const v0y = polygonContour[i * vertexStride + 1];\n                        const v1x =\n                            polygonContour[((i + 1) % polygonContourEdges.length) * vertexStride];\n                        const v1y =\n                            polygonContour[\n                                ((i + 1) % polygonContourEdges.length) * vertexStride + 1\n                            ];\n\n                        currEdgeStart.set(v0x, v0y);\n                        currEdgeGoal.set(v1x, v1y);\n                        prevEdgeStart.set(\n                            polygonContour[prevEdgeIdx * vertexStride],\n                            polygonContour[prevEdgeIdx * vertexStride + 1]\n                        );\n                        prevEdgeGoal.set(currEdgeStart.x, currEdgeStart.y);\n\n                        if (\n                            prevEdgeGoal\n                                .sub(prevEdgeStart)\n                                .normalize()\n                                .dot(currEdgeGoal.sub(currEdgeStart).normalize()) <= wallEdgeSlope\n                        ) {\n                            indexBuffer.push(vFootprint0, vRoof0);\n                        }\n                    } else {\n                        indexBuffer.push(vFootprint0, vRoof0);\n                    }\n                }\n            } else {\n                const vFoot0 = vertexOffset + i;\n                const vRoof0 = vertexOffset + ((i + 1) % polygonContourEdges.length);\n                indexBuffer.push(vFoot0, vRoof0);\n            }\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    BufferAttribute as ThreeBufferAttribute,\n    BufferGeometry as ThreeBufferGeometry,\n    InterleavedBufferAttribute as ThreeInterleavedBufferAttribute,\n    TypedArray\n} from \"three\";\nimport {\n    BufferAttribute,\n    BufferElementType,\n    Geometry,\n    GeometryType,\n    InterleavedBufferAttribute\n} from \"./DecodedTile\";\n\n/**\n * Collection of helper methods to convert\n * {@link https://threejs.org/docs/index.html#api/en/core/BufferGeometry|three.js BufferGeometry}\n * to [[Geometry]] that allows creation and transfering of THREE BufferGeometry in webworkers.\n * See also [[CustomDatasourceExample]].\n */\nexport namespace ThreeBufferUtils {\n    export function getBufferElementType(buffer: TypedArray): BufferElementType {\n        if (buffer instanceof Int8Array) {\n            return \"int8\";\n        } else if (buffer instanceof Uint8Array) {\n            return \"uint8\";\n        } else if (buffer instanceof Int16Array) {\n            return \"int16\";\n        } else if (buffer instanceof Uint16Array) {\n            return \"uint16\";\n        } else if (buffer instanceof Int32Array) {\n            return \"int32\";\n        } else if (buffer instanceof Uint32Array) {\n            return \"uint32\";\n        } else if (buffer instanceof Float32Array) {\n            return \"float\";\n        }\n\n        throw new Error(`Unsupported buffer type ${name}`);\n    }\n\n    export function fromThreeBufferAttribute(\n        bufferAttribute: ThreeBufferAttribute\n    ): BufferAttribute {\n        const buffer = (bufferAttribute.array as any) as TypedArray;\n        return {\n            name: bufferAttribute.name,\n            buffer: buffer.buffer,\n            type: getBufferElementType(buffer),\n            itemCount: bufferAttribute.itemSize,\n            normalized: bufferAttribute.normalized\n        };\n    }\n\n    export function fromThreeInterleavedBufferAttribute(\n        bufferAttribute: ThreeInterleavedBufferAttribute\n    ): InterleavedBufferAttribute {\n        throw new Error(\"Not implemented yet\");\n    }\n\n    export function fromThreeBufferGeometry(\n        bufferGeometry: ThreeBufferGeometry,\n        techniqueIndex: number\n    ): Geometry {\n        const vertexAttributes: BufferAttribute[] = [];\n        const attributeNames = Object.getOwnPropertyNames(bufferGeometry.attributes);\n        for (const name of attributeNames) {\n            const attribute = bufferGeometry.attributes[name];\n            // FIXME: Also support InterleavedBufferAttribute\n            const vertexAttribute = fromThreeBufferAttribute(attribute as ThreeBufferAttribute);\n            vertexAttribute.name = name;\n            vertexAttributes.push(vertexAttribute);\n        }\n        const index =\n            bufferGeometry.index !== null\n                ? fromThreeBufferAttribute(bufferGeometry.index)\n                : undefined;\n\n        let count = 0;\n        if (index !== undefined) {\n            count = bufferGeometry.index === null ? 0 : bufferGeometry.index.count;\n        } else {\n            // If there is no index buffer, try to deduce the count from the position attribute.\n            const posAttr = bufferGeometry.attributes.position as ThreeBufferAttribute;\n            if (posAttr === undefined) {\n                throw new Error(\"Missing position attibute to deduce item count\");\n            }\n            count = posAttr.count;\n        }\n\n        return {\n            type: GeometryType.Unspecified,\n            vertexAttributes,\n            index,\n            groups: [{ start: 0, count, technique: techniqueIndex }]\n        };\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Vector3Like } from \"@here/harp-geoutils\";\nimport * as THREE from \"three\";\n\n/**\n * Determines whether a position in NDC (Normalized Device Coordinates) is inside the screen.\n * @param ndc - The position to check.\n */\nfunction isOnScreen(ndc: THREE.Vector3) {\n    return ndc.z > -1 && ndc.z < 1 && ndc.x >= -1 && ndc.x <= 1 && ndc.y >= -1 && ndc.y <= 1;\n}\n\n/**\n * @hidden\n * Handles the projection of world coordinates to screen coordinates.\n */\nexport class ScreenProjector {\n    static tempV2 = new THREE.Vector2();\n    static tempV3 = new THREE.Vector3();\n\n    private m_width: number = 0;\n    private m_height: number = 0;\n\n    /**\n     * Constructs a new `ScreenProjector`.\n     *\n     * @param m_camera - Camera to project against.\n     */\n    constructor(private m_camera: THREE.Camera) {}\n\n    /**\n     * Height of the screen.\n     */\n    get width(): number {\n        return this.m_width;\n    }\n\n    /**\n     * Width of the screen.\n     */\n    get height(): number {\n        return this.m_height;\n    }\n\n    /**\n     * Apply current projectionViewMatrix of the camera to project the source vector into\n     * screen coordinates.\n     *\n     * @param {(Vector3Like)} source The source vector to project.\n     * @param {THREE.Vector2} target The target vector.\n     * @returns {THREE.Vector2} The projected vector (the parameter 'target') or undefined if\n     * outside the near / far plane.\n     */\n    project(\n        source: Vector3Like,\n        target: THREE.Vector2 = new THREE.Vector2()\n    ): THREE.Vector2 | undefined {\n        const p = this.projectVector(source, ScreenProjector.tempV3);\n        if (p.z > -1 && p.z < 1) {\n            return this.ndcToScreen(p, target);\n        }\n        return undefined;\n    }\n\n    /**\n     * Apply current projectionViewMatrix of the camera to project the source vector into\n     * screen coordinates.\n     *\n     * @param {(Vector3Like)} source The source vector to project.\n     * @param {THREE.Vector2} target The target vector.\n     * @returns {THREE.Vector2} The projected vector (the parameter 'target') or undefined if\n     * outside the screen.\n     */\n    projectOnScreen(\n        source: Vector3Like,\n        target: THREE.Vector2 = new THREE.Vector2()\n    ): THREE.Vector2 | undefined {\n        const p = this.projectVector(source, ScreenProjector.tempV3);\n        if (isOnScreen(p)) {\n            return this.ndcToScreen(p, target);\n        }\n        return undefined;\n    }\n\n    /**\n     * Apply current projectionViewMatrix of the camera to project the source vector into\n     * screen coordinates. The z component between -1 and 1 is also returned.\n     *\n     * @param {(Vector3Like)} source The source vector to project.\n     * @param {THREE.Vector3} target The target vector.\n     * @returns {THREE.Vector3} The projected vector (the parameter 'target') or undefined if\n     * outside the near / far plane.\n     */\n    project3(\n        source: Vector3Like,\n        target: THREE.Vector3 = new THREE.Vector3()\n    ): THREE.Vector3 | undefined {\n        const p = this.projectVector(source, ScreenProjector.tempV3);\n        if (p.z > -1 && p.z < 1) {\n            target.set((p.x * this.m_width) / 2, (p.y * this.m_height) / 2, p.z);\n            return target;\n        }\n        return undefined;\n    }\n\n    /**\n     * Apply current projectionViewMatrix of the camera to project the source vector. Stores\n     * result in NDC in the target vector.\n     *\n     * @param {(Vector3Like)} source The source vector to project.\n     * @param {THREE.Vector3} target The target vector.\n     * @returns {THREE.Vector3} The projected vector (the parameter 'target').\n     */\n    projectVector(source: Vector3Like, target: THREE.Vector3): THREE.Vector3 {\n        target.set(source.x, source.y, source.z).project(this.m_camera);\n        return target;\n    }\n\n    /**\n     * Fast test to check if projected point is on screen.\n     *\n     * @returns {boolean} `true` if point is on screen, `false` otherwise.\n     */\n    onScreen(source: Vector3Like): boolean {\n        const p = this.projectVector(source, ScreenProjector.tempV3);\n        return isOnScreen(p);\n    }\n\n    /**\n     * Update the `ScreenProjector` with the latest values of the screen and the camera.\n     *\n     * @param {THREE.Camera} camera Camera to project against.\n     * @param {number} width Width of screen/canvas.\n     * @param {number} height Height of screen/canvas.\n     */\n    update(camera: THREE.Camera, width: number, height: number) {\n        this.m_camera = camera;\n        this.m_width = width;\n        this.m_height = height;\n    }\n\n    private ndcToScreen(ndc: THREE.Vector3, screenCoords: THREE.Vector2): THREE.Vector2 {\n        return screenCoords.set((ndc.x * this.m_width) / 2, (ndc.y * this.m_height) / 2);\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CubemapSky, GradientSky } from \"@here/harp-datasource-protocol\";\nimport { ProjectionType } from \"@here/harp-geoutils\";\nimport { SkyCubemapTexture } from \"./SkyCubemapTexture\";\nimport { SkyGradientTexture } from \"./SkyGradientTexture\";\n\nimport * as THREE from \"three\";\n\n/**\n * Class that handles {@link MapView}'s sky background.\n */\nexport class SkyBackground {\n    private m_skyTexture?: SkyGradientTexture | SkyCubemapTexture;\n\n    /**\n     * Constructs a new `SkyBackground`.\n     *\n     * @param m_sky - Sky configuration parameters.\n     * @param m_projectionType - {@link MapView}'s projection type.\n     * @param camera - {@link MapView}'s camera.\n     */\n    constructor(\n        private m_sky: GradientSky | CubemapSky,\n        private m_projectionType: ProjectionType,\n        camera: THREE.Camera\n    ) {\n        switch (this.m_sky.type) {\n            case \"gradient\":\n                this.m_skyTexture = new SkyGradientTexture(this.m_sky, this.m_projectionType);\n                this.updateCamera(camera);\n                break;\n            case \"cubemap\": {\n                this.m_skyTexture = new SkyCubemapTexture(this.m_sky);\n                break;\n            }\n        }\n    }\n\n    /**\n     * Disposes allocated resources.\n     */\n    dispose() {\n        this.m_skyTexture!.dispose();\n    }\n\n    /**\n     * Sky texture.\n     */\n    get texture(): THREE.Texture {\n        return this.m_skyTexture!.texture;\n    }\n\n    /**\n     * This method updates the skybox based on the camera position (needed for some types of sky).\n     *\n     * @param camera - The camera used in the map view.\n     */\n    updateCamera(camera: THREE.Camera) {\n        if (this.m_sky.type === \"gradient\") {\n            (this.m_skyTexture! as SkyGradientTexture).update(camera);\n        }\n    }\n\n    /**\n     * Updates the sky texture with new parameters.\n     *\n     * @param params - New sky configuration parameters.\n     * @param projectionType - Which projection is used, this may also change (in which case the\n     * textures should be recreated).\n     */\n    updateTexture(params: GradientSky | CubemapSky, projectionType: ProjectionType) {\n        const isSameSkyType =\n            this.m_sky.type === params.type && this.m_projectionType === projectionType;\n        switch (params.type) {\n            case \"gradient\":\n                if (isSameSkyType) {\n                    (this.m_skyTexture! as SkyGradientTexture).updateTexture(params);\n                } else {\n                    this.m_skyTexture = new SkyGradientTexture(params, projectionType);\n                }\n                break;\n            case \"cubemap\": {\n                if (isSameSkyType) {\n                    (this.m_skyTexture! as SkyCubemapTexture).updateTexture(params);\n                } else {\n                    this.m_skyTexture = new SkyCubemapTexture(params);\n                }\n                break;\n            }\n        }\n        this.m_projectionType = projectionType;\n        this.m_sky = params;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GradientSky } from \"@here/harp-datasource-protocol\";\nimport { ProjectionType } from \"@here/harp-geoutils\";\nimport { getOptionValue } from \"@here/harp-utils\";\nimport { Color, CubeTexture, DataTexture, Line3, Plane, RGBFormat, Texture, Vector3 } from \"three\";\n\nexport const DEFAULT_TEXTURE_SIZE = 512;\nexport const DEFAULT_MONOMIAL_POWER = 1;\n\n// Vectors used for skybox bitmap computation.\nconst cameraDir = [\n    new Vector3(1, 0, 0),\n    new Vector3(-1, 0, 0),\n    new Vector3(0, -1, 0),\n    new Vector3(0, 1, 0),\n    new Vector3(0, 0, 1),\n    new Vector3(0, 0, -1)\n];\nconst cameraRight = [\n    new Vector3(0, 0, -1),\n    new Vector3(0, 0, 1),\n    new Vector3(1, 0, 0),\n    new Vector3(1, 0, 0),\n    new Vector3(1, 0, 0),\n    new Vector3(-1, 0, 0)\n];\nconst cameraUp = [\n    new Vector3(0, 1, 0),\n    new Vector3(0, 1, 0),\n    new Vector3(0, 0, 1),\n    new Vector3(0, 0, -1),\n    new Vector3(0, 1, 0),\n    new Vector3(0, 1, 0)\n];\n\n/**\n * Class tha generates a texture containing a linear gradient, to be used with [[SkyBackground]].\n *\n * The gradient is mapped onto a sphere, where `topColor` maps to the top of the upper hemisphere,\n * `bottomColor` to the bottom of the upper hemisphere, and `groundColor` fills the bottom\n *  hemisphere..\n */\nexport class SkyGradientTexture {\n    private m_width: number;\n    private m_faceCount: number;\n    private m_faces: DataTexture[];\n    private m_skybox?: CubeTexture;\n\n    // Used only in the planar case.\n    private m_farClipPlaneDividedVertically?: THREE.Line3;\n    private m_groundPlane?: THREE.Plane;\n    private m_bottomMidFarPoint?: THREE.Vector3;\n    private m_topMidFarPoint?: THREE.Vector3;\n    private m_horizonPosition?: THREE.Vector3;\n    private m_farClipPlaneCorners?: THREE.Vector3[];\n\n    /**\n     * Constructs a new `SkyGradientTexture`.\n     *\n     * @param sky - Initial [[GradientSky]] configuration.\n     * @param m_projectionType - {@link MapView}'s projection type.\n     * @param m_height - Optional height parameter.\n     */\n    constructor(\n        sky: GradientSky,\n        private m_projectionType: ProjectionType,\n        private m_height: number = DEFAULT_TEXTURE_SIZE\n    ) {\n        const topColor = new Color(sky.topColor);\n        const bottomColor = new Color(sky.bottomColor);\n        const groundColor = new Color(sky.groundColor);\n\n        this.m_width = this.m_projectionType === ProjectionType.Planar ? 1.0 : this.m_height;\n        this.m_faceCount = this.m_projectionType === ProjectionType.Planar ? 1.0 : 6.0;\n        this.m_faces = [];\n        for (let i = 0; i < this.m_faceCount; ++i) {\n            const data = new Uint8Array(3 * this.m_width * this.m_height);\n            this.fillTextureData(data, i, topColor, bottomColor, groundColor, sky.monomialPower);\n\n            const texture = new DataTexture(data, this.m_width, this.m_height, RGBFormat);\n            texture.needsUpdate = true;\n            texture.unpackAlignment = 1;\n            this.m_faces.push(texture);\n        }\n\n        if (this.m_projectionType === ProjectionType.Spherical) {\n            this.m_skybox = new CubeTexture(this.m_faces);\n            this.m_skybox.needsUpdate = true;\n        } else {\n            this.m_farClipPlaneDividedVertically = new Line3();\n            this.m_groundPlane = new Plane(new Vector3(0, 0, 1));\n            this.m_bottomMidFarPoint = new Vector3();\n            this.m_topMidFarPoint = new Vector3();\n            this.m_horizonPosition = new Vector3();\n            this.m_farClipPlaneCorners = [\n                new Vector3(),\n                new Vector3(),\n                new Vector3(),\n                new Vector3()\n            ];\n        }\n    }\n\n    /**\n     * Disposes allocated resources.\n     */\n    dispose() {\n        for (let i = 0; i < this.m_faceCount; ++i) {\n            this.m_faces[i].dispose();\n        }\n        if (this.m_projectionType === ProjectionType.Spherical) {\n            this.m_skybox!.dispose();\n        }\n    }\n\n    /**\n     * `SkyGradientTexture`'s texture resource (simple texture or cubemap depending on\n     * {@link MapView}'s projection).\n     */\n    get texture(): Texture {\n        return this.m_projectionType === ProjectionType.Planar ? this.m_faces[0] : this.m_skybox!;\n    }\n\n    /**\n     * This method updates the position of the texture depending on the camera frustum.\n     *\n     * @param camera - The camera used in the map view.\n     */\n    update(camera: THREE.Camera) {\n        if (this.m_projectionType === ProjectionType.Planar) {\n            this.setHorizonPosition(camera);\n            this.updateTexturePosition();\n        }\n    }\n\n    /**\n     * Updates the `SkyGradientTexture` with new parameters.\n     *\n     * @param params - New [[GradientSky]] configuration.\n     */\n    updateTexture(sky: GradientSky) {\n        for (let i = 0; i < this.m_faceCount; ++i) {\n            this.fillTextureData(\n                this.m_faces[i].image.data,\n                i,\n                new Color(sky.topColor),\n                new Color(sky.bottomColor),\n                new Color(sky.groundColor),\n                sky.monomialPower\n            );\n            this.m_faces[i].needsUpdate = true;\n        }\n        if (this.m_projectionType === ProjectionType.Spherical) {\n            this.m_skybox!.needsUpdate = true;\n        }\n    }\n\n    // When creating the texture, a Uint8Array is required, because the resulting texture passed\n    // to the scene as a background, is a texImage2D object, that does not accept UintClampedArray\n    // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\n    // But, when updating the texture, a Uint8ClampedArray is passed as argument, because\n    // this.m_texture.image.data returns a Uint8ClampedArray. That's why this method accepts both.\n    private fillTextureData(\n        data: Uint8ClampedArray | Uint8Array,\n        faceIdx: number,\n        topColor: Color,\n        bottomColor: Color,\n        groundColor: Color,\n        monomialPower?: number\n    ) {\n        const color = new Color();\n        const dir = new Vector3();\n        const right = new Vector3();\n        const up = new Vector3();\n\n        const upDir = new Vector3(0, 0, 1);\n        for (let i = 0; i < this.m_height; ++i) {\n            for (let j = 0; j < this.m_width; ++j) {\n                if (this.m_projectionType === ProjectionType.Spherical) {\n                    const offsetX = right\n                        .copy(cameraRight[faceIdx])\n                        .multiplyScalar(((j + 0.5) / this.m_width) * 2.0 - 1.0);\n                    const offsetY = up\n                        .copy(cameraUp[faceIdx])\n                        .multiplyScalar(((i + 0.5) / this.m_height) * 2.0 - 1.0);\n                    dir.copy(cameraDir[faceIdx])\n                        .add(offsetX)\n                        .add(offsetY)\n                        .normalize();\n                    const t = Math.max(upDir.dot(dir), 0);\n\n                    color\n                        .copy(groundColor)\n                        .lerp(bottomColor, Math.min(t * 100, 1))\n                        .lerp(topColor, t ** getOptionValue(monomialPower, DEFAULT_MONOMIAL_POWER))\n                        .multiplyScalar(255);\n                } else {\n                    const t = i / this.m_height;\n                    if (i === 0) {\n                        color.copy(groundColor).multiplyScalar(255);\n                    } else {\n                        color\n                            .copy(bottomColor)\n                            .lerp(\n                                topColor,\n                                t ** getOptionValue(monomialPower, DEFAULT_MONOMIAL_POWER)\n                            )\n                            .multiplyScalar(255);\n                    }\n                }\n\n                data[i * this.m_width * 3 + j * 3] = color.r;\n                data[i * this.m_width * 3 + j * 3 + 1] = color.g;\n                data[i * this.m_width * 3 + j * 3 + 2] = color.b;\n            }\n        }\n    }\n\n    private setHorizonPosition(camera: THREE.Camera) {\n        this.m_farClipPlaneCorners![0].set(-1, -1, 1).unproject(camera);\n        this.m_farClipPlaneCorners![1].set(1, -1, 1).unproject(camera);\n        this.m_farClipPlaneCorners![2].set(-1, 1, 1).unproject(camera);\n        this.m_farClipPlaneCorners![3].set(1, 1, 1).unproject(camera);\n\n        this.m_bottomMidFarPoint!.copy(this.m_farClipPlaneCorners![0])\n            .add(this.m_farClipPlaneCorners![1])\n            .multiplyScalar(0.5);\n        this.m_topMidFarPoint!.copy(this.m_farClipPlaneCorners![2])\n            .add(this.m_farClipPlaneCorners![3])\n            .multiplyScalar(0.5);\n        this.m_farClipPlaneDividedVertically!.set(this.m_bottomMidFarPoint, this.m_topMidFarPoint);\n\n        const hasIntersection = this.m_groundPlane!.intersectLine(\n            this.m_farClipPlaneDividedVertically!,\n            this.m_horizonPosition!\n        );\n\n        // When there is no intersection between the ground plane and the\n        // farClipPlaneDividedVertically, be sure that the horizon is reset. Otherwise a previous\n        // intersection point stored in the m_horizonPosition will be considered the valid one.\n        if (!hasIntersection) {\n            this.m_horizonPosition!.set(0.0, 0.0, 0.0);\n        }\n    }\n\n    private updateTexturePosition() {\n        const coveredBySky = this.m_bottomMidFarPoint!.distanceTo(this.m_horizonPosition!);\n        const frustumHeight = this.m_farClipPlaneDividedVertically!.distance();\n        const skyRatio = coveredBySky / frustumHeight;\n\n        // If there is no intersection between the ground plane and the line that defines the far\n        // clip plane divided vertically, it means that there is no sky visible and therefore the\n        // ground color should be displayed. When there is no intersection, the length of the\n        // this.m_horizonPosition is still equal to zero, as threejs initialize an empty vector with\n        // all the three components to zero.\n        // If there is an intersection, calculate the offset.\n        const ratio = this.m_horizonPosition!.length() === 0 ? 1 : skyRatio - 2 / this.m_height;\n\n        // If the bottom part of the far clipping plane is under the ground plane, scroll the\n        // texture down. Otherwise, the camera is looking at the sky, therefore, scroll the texture\n        // up.\n        this.m_faces[0].offset.set(0, this.m_bottomMidFarPoint!.z <= 0 ? -ratio : skyRatio);\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Theme } from \"@here/harp-datasource-protocol\";\nimport { FontCatalog } from \"@here/harp-text-canvas\";\nimport { assert, LoggerManager } from \"@here/harp-utils\";\n\nexport const DEFAULT_FONT_CATALOG_NAME = \"default\";\n\nconst logger = LoggerManager.instance.create(\"FontCatalogLoader\");\n\ntype FontCatalogCallback = (name: string, catalog: FontCatalog) => void;\n\nexport class FontCatalogLoader {\n    private m_catalogsLoading: number = 0;\n\n    constructor(private readonly m_theme: Theme) {}\n\n    /**\n     * Initializes font catalog loader.\n     * @param defaultFontCatalogUrl - Url of the font catalog that will be used by default if the\n     * theme doesn't define any font catalog.\n     * @returns Name of the default font catalog.\n     */\n    initialize(defaultFontCatalogUrl: string): string {\n        if (this.m_theme.fontCatalogs === undefined || this.m_theme.fontCatalogs.length === 0) {\n            this.m_theme.fontCatalogs = [\n                {\n                    name: DEFAULT_FONT_CATALOG_NAME,\n                    url: defaultFontCatalogUrl\n                }\n            ];\n            return DEFAULT_FONT_CATALOG_NAME;\n        }\n\n        const defaultFontCatalogName = this.m_theme.fontCatalogs[0].name;\n        return defaultFontCatalogName;\n    }\n\n    async loadCatalogs(catalogCallback: FontCatalogCallback): Promise<void[]> {\n        assert(this.m_theme.fontCatalogs !== undefined);\n        assert(this.m_theme.fontCatalogs!.length > 0);\n\n        const promises: Array<Promise<void>> = [];\n\n        this.m_theme.fontCatalogs!.forEach(fontCatalogConfig => {\n            this.m_catalogsLoading += 1;\n            const fontCatalogPromise: Promise<void> = FontCatalog.load(fontCatalogConfig.url, 1024)\n                .then<void>(catalogCallback.bind(undefined, fontCatalogConfig.name))\n                .catch((error: Error) => {\n                    logger.error(\"Failed to load FontCatalog: \", error);\n                })\n                .finally(() => {\n                    this.m_catalogsLoading -= 1;\n                });\n            promises.push(fontCatalogPromise);\n        });\n\n        return Promise.all(promises);\n    }\n\n    get loading(): boolean {\n        return this.m_catalogsLoading > 0;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Env, GeometryKindSet } from \"@here/harp-datasource-protocol\";\nimport { Projection } from \"@here/harp-geoutils\";\nimport * as THREE from \"three\";\nimport { ElevationProvider } from \"../ElevationProvider\";\nimport { MapView } from \"../MapView\";\nimport { ViewState } from \"./ViewState\";\n\n/**\n * View state obtained from a MapView instance.\n */\nexport class MapViewState implements ViewState {\n    private readonly m_lookAtVector = new THREE.Vector3();\n    constructor(\n        private readonly m_mapView: MapView,\n        private readonly m_renderedTilesChangeCheck: () => boolean\n    ) {}\n\n    get worldCenter(): THREE.Vector3 {\n        return this.m_mapView.worldCenter;\n    }\n    get cameraIsMoving(): boolean {\n        return this.m_mapView.cameraIsMoving;\n    }\n    get maxVisibilityDist(): number {\n        return this.m_mapView.viewRanges.maximum;\n    }\n    get zoomLevel(): number {\n        return this.m_mapView.zoomLevel;\n    }\n    get env(): Env {\n        return this.m_mapView.env;\n    }\n    get frameNumber(): number {\n        return this.m_mapView.frameNumber;\n    }\n    get lookAtVector(): THREE.Vector3 {\n        return this.m_mapView.camera.getWorldDirection(this.m_lookAtVector);\n    }\n    get lookAtDistance(): number {\n        return this.m_mapView.targetDistance;\n    }\n    get isDynamic(): boolean {\n        return this.m_mapView.isDynamicFrame;\n    }\n    get hiddenGeometryKinds(): GeometryKindSet | undefined {\n        return this.m_mapView.tileGeometryManager === undefined\n            ? undefined\n            : this.m_mapView.tileGeometryManager.hiddenGeometryKinds;\n    }\n\n    get renderedTilesChanged(): boolean {\n        return this.m_renderedTilesChangeCheck();\n    }\n\n    get projection(): Projection {\n        return this.m_mapView.projection;\n    }\n\n    get elevationProvider(): ElevationProvider | undefined {\n        return this.m_mapView.elevationProvider;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { FontCatalog, TextCanvas } from \"@here/harp-text-canvas\";\nimport { assert } from \"@here/harp-utils\";\n\nexport class TextCanvasFactory {\n    private m_minGlyphCount: number = 0; //Min amount of glyphs each [[TextCanvas]] layer can store.\n    private m_maxGlyphCount: number = 0; //Max amount of glyphs each [[TextCanvas]] layer can store.\n\n    /**\n     * Creates an instance of text canvas factory.\n     * @param m_renderer -\n     */\n    constructor(private readonly m_renderer: THREE.WebGLRenderer) {}\n\n    setGlyphCountLimits(min: number, max: number) {\n        this.m_minGlyphCount = min;\n        this.m_maxGlyphCount = max;\n    }\n\n    /**\n     * Creates text canvas\n     * @param fontCatalog - Initial [[FontCatalog]].\n     */\n    createTextCanvas(fontCatalog: FontCatalog): TextCanvas {\n        assert(this.m_maxGlyphCount > 0);\n\n        return new TextCanvas({\n            renderer: this.m_renderer,\n            fontCatalog,\n            minGlyphCount: this.m_minGlyphCount,\n            maxGlyphCount: this.m_maxGlyphCount\n        });\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ITransferManager, TransferManager } from \"@here/harp-transfer-manager\";\nimport {\n    AreaCopyrightInfo,\n    CopyrightCoverageProvider,\n    CopyrightCoverageResponse\n} from \"./CopyrightCoverageProvider\";\n\ninterface RequestHeaders {\n    [field: string]: string;\n}\n\n/**\n * Copyright provider which retrieves copyright coverage information from provided URL.\n */\nexport class UrlCopyrightProvider extends CopyrightCoverageProvider {\n    private m_cachedCopyrightResponse: Promise<AreaCopyrightInfo[]> | undefined;\n\n    /**\n     * Default constructor.\n     *\n     * @param m_fetchURL - URL to fetch copyrights data from.\n     * @param m_baseScheme - Scheme to get copyrights from.\n     * @param m_requestHeaders - Optional request headers for requests(e.g. Authorization)\n     */\n    constructor(\n        private m_fetchURL: string,\n        private m_baseScheme: string,\n        private m_requestHeaders?: RequestHeaders,\n        private m_transferManager: ITransferManager = TransferManager.instance()\n    ) {\n        super();\n    }\n\n    /**\n     * Sets request headers.\n     * @param headers -\n     */\n    setRequestHeaders(headers: RequestHeaders | undefined) {\n        this.m_requestHeaders = headers;\n    }\n\n    /**\n     * @inheritdoc\n     * @override\n     */\n    getCopyrightCoverageData(): Promise<AreaCopyrightInfo[]> {\n        if (this.m_cachedCopyrightResponse !== undefined) {\n            return this.m_cachedCopyrightResponse;\n        }\n\n        this.m_cachedCopyrightResponse = this.m_transferManager\n            .downloadJson<CopyrightCoverageResponse>(this.m_fetchURL, {\n                headers: this.m_requestHeaders\n            })\n            .then(json => json[this.m_baseScheme])\n            .catch(error => {\n                this.logger.error(error);\n                return [];\n            });\n\n        return this.m_cachedCopyrightResponse;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/** @module\n *\n * This module provides classes to ease downloading URLs. In particular, following redirects,\n * retrying on HTTP errors, and limiting the number of parallel concurrent downloads.\n */\n\nimport \"@here/harp-fetch\";\nimport { DeferredPromise } from \"./DeferredPromise\";\n\n/**\n * Abstract interface for a transfer manager.\n *\n * Provides functionality for downloading JSON or ArrayBuffers.\n * Implementations typically implement retry on server congestion,\n * limit the maximum amount of parallel downloads or merge duplicate\n * downloads.\n */\nexport interface ITransferManager {\n    /**\n     * Downloads a JSON object.\n     * @param url - The URL to download\n     * @param init - Optional extra parameters for the download.\n     */\n    downloadJson<T>(url: RequestInfo, init?: RequestInit): Promise<T>;\n\n    /**\n     * Downloads a binary object.\n     * @param url - The URL to download\n     * @param init - Optional extra parameters for the download\n     */\n    downloadArrayBuffer(url: RequestInfo, init?: RequestInit): Promise<ArrayBuffer>;\n\n    /**\n     * Downloads a URL and returns the response.\n     * @param url - The URL to download.\n     * @param init - Optional extra parameters for the download.\n     */\n    download(url: RequestInfo, init?: RequestInit): Promise<Response>;\n}\n\n/**\n * `TransferManager` for downloading URLs.\n *\n * Features:\n *\n * * Merges JSON downloads, for example, the same URL if requested as JSON will only be downloaded\n *   once.\n * * Limits the amount of parallel downloads, useful when requesting a large amount of URLs that\n *   would otherwise stall the browser.\n * * Retries the downloads with an increasing timeout on HTTP 503 replies.\n *\n * The static method [[instance]] can be used to get a default constructed instance.\n */\nexport class TransferManager implements ITransferManager {\n    /**\n     * The timeout in milliseconds to wait between retries. This timeout is multiplied with the\n     * number of retries. First retry waits for 0 ms, second retry for 500 ms, third for 1000 ms and\n     * so on.\n     */\n    static readonly retryTimeout = 500;\n    /**\n     * The amount of maximum parallel downloads to allow.\n     */\n    static readonly maxParallelDownloads = 16;\n    /**\n     * Returns a default instance of [[TransferManager]].\n     */\n    static instance(): TransferManager {\n        return TransferManager.defaultInstance;\n    }\n    private static readonly defaultInstance = new TransferManager();\n    private static async fetchRepeatedly(\n        fetchFunction: typeof fetch,\n        retryCount: number,\n        maxRetries: number,\n        url: RequestInfo,\n        init?: RequestInit\n    ): Promise<Response> {\n        try {\n            const response = await fetchFunction(url, init);\n            if (response.status !== 503 || retryCount > maxRetries) {\n                return response;\n            }\n        } catch (err) {\n            if (\n                err.hasOwnProperty(\"isCancelled\") ||\n                (err.hasOwnProperty(\"name\") && err.name === \"AbortError\") ||\n                retryCount > maxRetries\n            ) {\n                throw err;\n            }\n        }\n        return TransferManager.waitFor(TransferManager.retryTimeout * retryCount).then(() =>\n            TransferManager.fetchRepeatedly(fetchFunction, maxRetries, retryCount + 1, url, init)\n        );\n    }\n    private static waitFor(milliseconds: number): Promise<void> {\n        return new Promise<void>(resolve => setTimeout(resolve, milliseconds));\n    }\n    private activeDownloadCount = 0;\n    private downloadQueue = new Array<DeferredPromise<Response>>();\n    private activeDownloads = new Map<RequestInfo, Promise<any>>();\n    /**\n     * Constructs a new [[TransferManager]].\n     *\n     * @param fetchFunction - The default fetch function to use.\n     * @param maxRetries - The maximum amount to try to re-fetch a resource.\n     */\n    constructor(readonly fetchFunction = fetch, readonly maxRetries: number = 5) {}\n    /**\n     * Downloads a JSON object. Merges downloads of string URLs if requested multiple times.\n     *\n     * Note: This method merges multiple downloads of the same string URL to\n     * only one request. The init parameter is ignored if the download is merged.\n     * Call [[download]] instead to download the resource without merging.\n     *\n     * @param url - The URL or RequestInfo to download\n     * @param init - Optional extra parameters for the download.\n     */\n    downloadJson<T>(url: RequestInfo, init?: RequestInit): Promise<T> {\n        return this.downloadAs<T>(response => response.json(), url, init);\n    }\n    /**\n     * Downloads a binary object. Merges downloads of string URLS if requested multiple times.\n     *\n     * Note: This method merges multiple downloads of the same string URL to\n     * only one request. The init parameter is ignored if the download is merged.\n     * Call [[download]] instead to download the resource without merging.\n     *\n     * @param url - The URL or RequestInfo to download\n     * @param init - Optional extra parameters for the download\n     */\n    downloadArrayBuffer(url: RequestInfo, init?: RequestInit): Promise<ArrayBuffer> {\n        return this.download(url, init).then(response => response.arrayBuffer());\n    }\n    /**\n     * Downloads a URL and returns the response.\n     *\n     * Does not merge multiple requests to the same URL.\n     *\n     * @param url - The URL or RequestInfo to download.\n     * @param init - Optional extra parameters for the download.\n     */\n    download(url: RequestInfo, init?: RequestInit): Promise<Response> {\n        if (this.activeDownloadCount >= TransferManager.maxParallelDownloads) {\n            const deferred = new DeferredPromise<Response>(() => this.doDownload(url, init));\n            this.downloadQueue.push(deferred);\n            return deferred.promise;\n        }\n        return this.doDownload(url, init);\n    }\n    private async doDownload(url: RequestInfo, init?: RequestInit): Promise<Response> {\n        try {\n            ++this.activeDownloadCount;\n            const response = await TransferManager.fetchRepeatedly(\n                this.fetchFunction,\n                0,\n                this.maxRetries,\n                url,\n                init\n            );\n\n            this.onDownloadDone();\n            return response;\n        } catch (error) {\n            this.onDownloadDone();\n            throw error;\n        }\n    }\n    private onDownloadDone() {\n        --this.activeDownloadCount;\n        this.execDeferredDownload();\n    }\n    private execDeferredDownload() {\n        const future = this.downloadQueue.pop();\n        if (future === undefined) {\n            return;\n        }\n        future.exec();\n    }\n    private downloadAs<T>(\n        converter: (response: Response) => Promise<T>,\n        url: RequestInfo,\n        init?: RequestInit\n    ): Promise<T> {\n        const cacheKey = url;\n        const pendingFetch = this.activeDownloads.get(cacheKey);\n        if (pendingFetch !== undefined) {\n            return Promise.resolve(pendingFetch);\n        }\n        const newFetch = this.download(url, init)\n            .then(response => {\n                this.activeDownloads.delete(cacheKey);\n                if (response.ok) {\n                    return converter(response);\n                }\n                throw new Error(JSON.stringify(response));\n            })\n            .catch(err => {\n                this.activeDownloads.delete(cacheKey);\n                throw err;\n            });\n        this.activeDownloads.set(cacheKey, newFetch);\n        return newFetch;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n *\n * DeferredPromise takes an executor function for executing it later, when [[exec]] is called.\n * This class allows wrapping other promises or long running functions for later execution.\n * @internal\n * @hidden\n */\nexport class DeferredPromise<T> {\n    /**\n     * Internal promise to store the result of the deferred executor function.\n     */\n    readonly promise: Promise<T>;\n    private resolveFunc?: (result?: T) => void;\n    private rejectFunc?: (reason?: any) => void;\n\n    /**\n     * Constructs a new [[DeferredPromise]]\n     * @param executor - Async function that should be executed at a later point in time.\n     */\n    constructor(private readonly executor: () => Promise<T>) {\n        this.promise = new Promise<T>((resolve, reject) => {\n            this.resolveFunc = resolve;\n            this.rejectFunc = reject;\n        });\n    }\n\n    /**\n     * When `exec` is called the deferred executor function is executed.\n     */\n    exec() {\n        this.executor()\n            .then(result => this.resolveFunc!(result))\n            .catch(error => this.rejectFunc!(error));\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * `ImageItem` is used to identify an image in the {@link ImageCache}.\n */\nexport interface ImageItem {\n    /** URL of the image, or unique identifier. */\n    url: string;\n    /** Pixel data. */\n    imageData?: ImageData | ImageBitmap;\n    /** Mip maps for image data */\n    mipMaps?: ImageData[];\n    /** Turns to `true` when the data has finished loading. */\n    loaded: boolean;\n    /** `loadingPromise` is only used during loading/generating the image. */\n    loadingPromise?: Promise<ImageItem | undefined>;\n}\n\nexport namespace ImageItem {\n    /**\n     * Missing Typedoc\n     */\n    export function isLoading(imageItem: ImageItem): boolean {\n        return imageItem.loadingPromise !== undefined;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Theme } from \"@here/harp-datasource-protocol\";\nimport { EarthConstants, Projection, ProjectionType } from \"@here/harp-geoutils\";\n\nimport { GroundAtmosphereMaterial, SkyAtmosphereMaterial } from \"@here/harp-materials\";\nimport { MapAnchor, MapAnchors } from \"./MapAnchors\";\n\nimport { assert } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\nimport { TiltViewClipPlanesEvaluator } from \"./ClipPlanesEvaluator\";\n\n/**\n * Atmosphere effect variants.\n */\nenum AtmosphereVariant {\n    Ground = 0x1,\n    Sky = 0x2,\n    SkyAndGround = 0x3\n}\n\n/**\n * Atmosphere shader variants.\n */\nenum AtmosphereShadingVariant {\n    ScatteringShader,\n    SimpleColor,\n    Wireframe\n}\n\n/**\n * Lists light modes.\n */\nexport enum AtmosphereLightMode {\n    LightOverhead = 0,\n    LightDynamic = 1\n}\n\n/**\n * Maximum altitude that atmosphere reaches as the percent of the Earth radius.\n */\nconst SKY_ATMOSPHERE_ALTITUDE_FACTOR = 0.025;\n\n/**\n * Maximum altitude that ground atmosphere is visible as the percent of the Earth radius.\n */\nconst GROUND_ATMOSPHERE_ALTITUDE_FACTOR = 0.0001;\n\n/**\n * Utility cache for holding temporary values.\n */\nconst cache = {\n    clipPlanes: { near: 0, far: 0 }\n};\n\n/**\n * Class that provides {@link MapView}'s atmospheric scattering effect.\n */\nexport class MapViewAtmosphere {\n    /**\n     * User data name attribute assigned to created mesh.\n     */\n    static SkyAtmosphereUserName: string = \"SkyAtmosphere\";\n    /**\n     * User data name attribute assigned to created mesh.\n     */\n    static GroundAtmosphereUserName: string = \"GroundAtmosphere\";\n\n    /**\n     * Check if map anchors have already atmosphere effect added.\n     *\n     * @param mapAnchors - MapAnchors to check.\n     */\n    static isPresent(mapAnchors: MapAnchors): boolean {\n        for (const mapAnchor of mapAnchors.children) {\n            if (\n                mapAnchor.name === MapViewAtmosphere.SkyAtmosphereUserName ||\n                mapAnchor.name === MapViewAtmosphere.GroundAtmosphereUserName\n            ) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private m_enabled: boolean = true;\n    private m_skyGeometry?: THREE.BufferGeometry;\n    private m_skyMaterial?: THREE.Material;\n    private m_skyMesh?: THREE.Mesh;\n    private m_groundGeometry?: THREE.BufferGeometry;\n    private m_groundMaterial?: THREE.Material;\n    private m_groundMesh?: THREE.Mesh;\n\n    private m_clipPlanesEvaluator = new TiltViewClipPlanesEvaluator(\n        EarthConstants.EQUATORIAL_RADIUS * SKY_ATMOSPHERE_ALTITUDE_FACTOR,\n        0,\n        1.0,\n        0.05,\n        10000000.0\n    );\n    // TODO: Support for Theme definition should be added.\n    //private m_cachedTheme: Theme = { styles: {} };\n\n    private readonly m_lightDirection = new THREE.Vector3(0.0, 1.0, 0.0);\n\n    /**\n     * Creates and adds `Atmosphere` effects to the scene.\n     *\n     * @note Currently works only with globe projection.\n     *\n     * @param m_mapAnchors - The {@link MapAnchors} instance where the effect will be added.\n     * @param m_sceneCamera - The camera used to render entire scene.\n     * @param m_projection - The geo-projection used to transform geo coordinates to\n     *                       cartesian space.\n     * @param m_updateCallback - The optional callback to that should be called whenever atmosphere\n     * configuration changes, may be used to inform related components (`MapView`) to redraw.\n     * @param m_atmosphereVariant - The optional atmosphere configuration variant enum\n     * [[AtmosphereVariant]], which denotes where the atmosphere scattering effect should be\n     * applied, it may be ground or sky atmosphere only or most realistic for both, which is\n     * chosen by default.\n     * @param m_materialVariant - The optional material variant to be used, mainly for\n     * testing and tweaking purposes.\n     */\n    constructor(\n        private m_mapAnchors: MapAnchors,\n        private m_sceneCamera: THREE.Camera,\n        private m_projection: Projection,\n        private m_updateCallback?: () => void,\n        private m_atmosphereVariant: AtmosphereVariant = AtmosphereVariant.SkyAndGround,\n        private m_materialVariant = AtmosphereShadingVariant.ScatteringShader\n    ) {\n        // tslint:disable-next-line: no-bitwise\n        if (this.m_atmosphereVariant & AtmosphereVariant.Sky) {\n            this.createSkyGeometry();\n        }\n        // tslint:disable-next-line: no-bitwise\n        if (this.m_atmosphereVariant & AtmosphereVariant.Ground) {\n            this.createGroundGeometry();\n        }\n        this.addToMapAnchors(this.m_mapAnchors);\n    }\n\n    get skyMesh(): THREE.Mesh | undefined {\n        return this.m_skyMesh;\n    }\n\n    get groundMesh(): THREE.Mesh | undefined {\n        return this.m_groundMesh;\n    }\n\n    /**\n     * Allows to enable/disable the atmosphere effect, regardless of the theme settings.\n     *\n     * Use this method to change the setup in runtime without defining corresponding theme setup.\n     *\n     * @param enable - A boolean that specifies whether the atmosphere should be enabled or\n     *                 disabled.\n     */\n    set enabled(enable: boolean) {\n        // Check already disposed.\n        if (this.disposed) {\n            return;\n        }\n        if (this.m_enabled === enable) {\n            return;\n        }\n        this.m_enabled = enable;\n        const isAdded = MapViewAtmosphere.isPresent(this.m_mapAnchors);\n        if (enable && !isAdded) {\n            this.addToMapAnchors(this.m_mapAnchors);\n        } else if (!enable && isAdded) {\n            this.removeFromMapAnchors(this.m_mapAnchors);\n        }\n    }\n\n    /**\n     * Returns the current atmosphere status, enabled or disabled.\n     */\n    get enabled(): boolean {\n        return this.m_enabled;\n    }\n\n    set lightMode(lightMode: AtmosphereLightMode) {\n        if (this.m_materialVariant !== AtmosphereShadingVariant.ScatteringShader) {\n            return;\n        }\n        const dynamicLight = lightMode === AtmosphereLightMode.LightDynamic;\n        if (this.m_groundMaterial !== undefined) {\n            const groundMat = this.m_groundMaterial as GroundAtmosphereMaterial;\n            groundMat.setDynamicLighting(dynamicLight);\n        }\n        if (this.m_skyMaterial !== undefined) {\n            const skyMat = this.m_skyMaterial as SkyAtmosphereMaterial;\n            skyMat.setDynamicLighting(dynamicLight);\n        }\n    }\n\n    /**\n     * Disposes allocated resources.\n     */\n    dispose() {\n        // Unlink from scene and mapview anchors\n        if (this.enabled) {\n            this.enabled = false;\n        }\n\n        this.m_skyMaterial?.dispose();\n        this.m_groundMaterial?.dispose();\n\n        this.m_skyGeometry?.dispose();\n        this.m_groundGeometry?.dispose();\n\n        // After disposal we may no longer enable effect.\n        this.m_skyGeometry = undefined;\n        this.m_groundGeometry = undefined;\n\n        this.m_skyMaterial = undefined;\n        this.m_groundMaterial = undefined;\n\n        this.m_skyMesh = undefined;\n        this.m_groundMesh = undefined;\n    }\n\n    /**\n     * Sets the atmosphere depending on the\n     * {@link @here/harp-datasource-protocol#Theme} instance provided.\n     *\n     * This function is called when a theme is loaded. Atmosphere is added only if the theme\n     * contains a atmosphere definition with a:\n     * - `color` property, used to set the atmosphere color.\n     *\n     * @param theme - A {@link @here/harp-datasource-protocol#Theme} instance.\n     */\n    reset(theme: Theme) {\n        //this.m_cachedTheme = theme;\n    }\n\n    private get disposed() {\n        return this.m_skyMesh === undefined && this.m_groundMesh === undefined;\n    }\n\n    /**\n     * Handles atmosphere effect adding.\n     */\n    private addToMapAnchors(mapAnchors: MapAnchors) {\n        assert(!MapViewAtmosphere.isPresent(mapAnchors), \"Atmosphere already added\");\n        if (this.m_skyMesh !== undefined) {\n            mapAnchors.add(createMapAnchor(this.m_skyMesh, Number.MIN_SAFE_INTEGER));\n        }\n        if (this.m_groundMesh !== undefined) {\n            mapAnchors.add(createMapAnchor(this.m_groundMesh, Number.MAX_SAFE_INTEGER));\n        }\n\n        // Request an update once the anchor is added to {@link MapView}.\n        if (this.m_updateCallback) {\n            this.m_updateCallback();\n        }\n    }\n\n    /**\n     * Handles atmosphere effect removal.\n     */\n    private removeFromMapAnchors(mapAnchors: MapAnchors) {\n        if (!MapViewAtmosphere.isPresent(mapAnchors)) {\n            return;\n        }\n        let update = false;\n        if (this.m_skyMesh !== undefined) {\n            mapAnchors.remove(this.m_skyMesh);\n            update = true;\n        }\n        if (this.m_groundMesh !== undefined) {\n            mapAnchors.remove(this.m_groundMesh);\n            update = true;\n        }\n        if (update && this.m_updateCallback) {\n            this.m_updateCallback();\n        }\n    }\n\n    private createSkyGeometry() {\n        let skyGeometry: THREE.Geometry;\n        switch (this.m_projection.type) {\n            case ProjectionType.Spherical:\n                skyGeometry = new THREE.SphereGeometry(\n                    EarthConstants.EQUATORIAL_RADIUS * (1 + SKY_ATMOSPHERE_ALTITUDE_FACTOR),\n                    256,\n                    256\n                );\n                break;\n            default: {\n                skyGeometry = new THREE.PlaneGeometry(200, 200);\n                break;\n            }\n        }\n\n        skyGeometry.translate(0, 0, 0);\n        this.m_skyGeometry = new THREE.BufferGeometry();\n        this.m_skyGeometry.fromGeometry(skyGeometry);\n        skyGeometry.dispose();\n\n        if (this.m_materialVariant === AtmosphereShadingVariant.ScatteringShader) {\n            this.m_skyMaterial = new SkyAtmosphereMaterial();\n        } else if (this.m_materialVariant === AtmosphereShadingVariant.SimpleColor) {\n            this.m_skyMaterial = new THREE.MeshBasicMaterial({\n                color: new THREE.Color(0xc4f8ed),\n                opacity: 0.4,\n                transparent: false,\n                depthTest: true, // hide atmosphere behind globe (note: transparent changes order)\n                depthWrite: false,\n                side: THREE.BackSide,\n                blending: THREE.NormalBlending,\n                fog: false\n            });\n        } else {\n            this.m_skyMaterial = new THREE.MeshStandardMaterial({\n                color: 0x7fffff,\n                depthTest: false,\n                depthWrite: false,\n                normalScale: new THREE.Vector2(-1, -1),\n                side: THREE.BackSide, // not truly supported in wireframe mode\n                wireframe: true\n            });\n        }\n\n        this.m_skyMesh = new THREE.Mesh(this.m_skyGeometry, this.m_skyMaterial);\n        // Assign custom name so sky object may be easily recognized withing the scene.\n        this.m_skyMesh.name = MapViewAtmosphere.SkyAtmosphereUserName;\n        this.setupSkyForRendering();\n    }\n\n    private createGroundGeometry() {\n        let groundGeometry: THREE.Geometry;\n        switch (this.m_projection.type) {\n            case ProjectionType.Spherical:\n                groundGeometry = new THREE.SphereGeometry(\n                    EarthConstants.EQUATORIAL_RADIUS * (1 + GROUND_ATMOSPHERE_ALTITUDE_FACTOR),\n                    256,\n                    256\n                );\n                break;\n            default: {\n                groundGeometry = new THREE.PlaneGeometry(200, 200);\n                break;\n            }\n        }\n        groundGeometry.translate(0, 0, 0);\n        this.m_groundGeometry = new THREE.BufferGeometry();\n        this.m_groundGeometry.fromGeometry(groundGeometry);\n        groundGeometry.dispose();\n\n        if (this.m_materialVariant === AtmosphereShadingVariant.ScatteringShader) {\n            this.m_groundMaterial = new GroundAtmosphereMaterial();\n        } else if (this.m_materialVariant === AtmosphereShadingVariant.SimpleColor) {\n            this.m_groundMaterial = new THREE.MeshBasicMaterial({\n                color: new THREE.Color(0x00c5ff),\n                opacity: 0.4,\n                transparent: true,\n                depthTest: false,\n                depthWrite: false,\n                side: THREE.FrontSide,\n                blending: THREE.NormalBlending,\n                fog: false\n            });\n        } else {\n            this.m_groundMaterial = new THREE.MeshStandardMaterial({\n                color: 0x11899a,\n                depthTest: true, // FrontSide is not fully supported, so need depth test\n                depthWrite: false,\n                side: THREE.FrontSide,\n                wireframe: true\n            });\n        }\n\n        this.m_groundMesh = new THREE.Mesh(this.m_groundGeometry, this.m_groundMaterial);\n        // Assign name so object may be recognized withing the scene.\n        this.m_groundMesh.name = MapViewAtmosphere.GroundAtmosphereUserName;\n\n        this.setupGroundForRendering();\n    }\n\n    private setupSkyForRendering(): void {\n        if (this.m_skyMesh === undefined) {\n            return;\n        }\n        // Depending on material variant we need to update uniforms or only\n        // update camera near/far planes cause camera need to see further then\n        // actual earth geometry.\n        let onBeforeCallback: (_camera: THREE.Camera, _material: THREE.Material) => void;\n        if (this.m_materialVariant !== AtmosphereShadingVariant.ScatteringShader) {\n            // Setup only further clip planes before rendering.\n            onBeforeCallback = (camera: THREE.Camera, _material: THREE.Material) => {\n                this.overrideClipPlanes(camera);\n            };\n        } else {\n            // Setup proper clip planes and update uniforms values.\n            onBeforeCallback = (camera: THREE.Camera, material: THREE.Material) => {\n                this.overrideClipPlanes(camera);\n                // Check material wasn't swapped.\n                assert(material instanceof SkyAtmosphereMaterial);\n                const mat = this.m_skyMaterial as SkyAtmosphereMaterial;\n                mat.updateUniforms(mat, this.m_skyMesh!, camera, this.m_lightDirection);\n            };\n        }\n\n        // Sky material should be already created with mesh.\n        assert(this.m_skyMaterial !== undefined);\n        this.m_skyMesh.onBeforeRender = (\n            _renderer: THREE.WebGLRenderer,\n            _scene: THREE.Scene,\n            camera: THREE.Camera,\n            _geometry: THREE.Geometry | THREE.BufferGeometry,\n            material: THREE.Material,\n            _group: THREE.Group\n        ) => {\n            onBeforeCallback(camera, material);\n        };\n\n        this.m_skyMesh.onAfterRender = (\n            _renderer: THREE.WebGLRenderer,\n            _scene: THREE.Scene,\n            camera: THREE.Camera,\n            _geometry: THREE.Geometry | THREE.BufferGeometry,\n            _material: THREE.Material,\n            _group: THREE.Group\n        ) => {\n            this.revertClipPlanes(camera);\n        };\n    }\n\n    private setupGroundForRendering(): void {\n        if (this.m_groundMesh === undefined) {\n            return;\n        }\n        if (this.m_materialVariant !== AtmosphereShadingVariant.ScatteringShader) {\n            return;\n        }\n        // Ground material should be already created.\n        assert(this.m_groundMaterial !== undefined);\n        // Ground mesh does not need custom clip planes and uses the same camera setup as\n        // real (data source based) geometry.\n        this.m_groundMesh.onBeforeRender = (\n            _renderer: THREE.WebGLRenderer,\n            _scene: THREE.Scene,\n            camera: THREE.Camera,\n            _geometry: THREE.Geometry | THREE.BufferGeometry,\n            material: THREE.Material,\n            _group: THREE.Group\n        ) => {\n            assert(material instanceof GroundAtmosphereMaterial);\n            const mat = this.m_groundMaterial as GroundAtmosphereMaterial;\n            mat.updateUniforms(mat, this.m_groundMesh!, camera, this.m_lightDirection);\n        };\n    }\n\n    private overrideClipPlanes(rteCamera: THREE.Camera) {\n        // Store current clip planes used by global camera before modifying them.\n        const sceneCam = this.m_sceneCamera as THREE.PerspectiveCamera;\n        cache.clipPlanes.near = sceneCam.near;\n        cache.clipPlanes.far = sceneCam.far;\n        // Calculate view ranges using world camera.\n        // NOTE: ElevationProvider is not passed to evaluator, leaves min/max altitudes unchanged.\n        const viewRanges = this.m_clipPlanesEvaluator.evaluateClipPlanes(\n            this.m_sceneCamera,\n            this.m_projection\n        );\n        // Update relative to eye camera used internally in rendering.\n        assert(rteCamera instanceof THREE.PerspectiveCamera);\n        const c = rteCamera as THREE.PerspectiveCamera;\n        c.near = viewRanges.near;\n        // Small margin ensures that we never cull small triangles just below or at\n        // horizon - possible due to frustum culling in-precisions.\n        c.far = viewRanges.far + EarthConstants.EQUATORIAL_RADIUS * 0.1;\n        c.updateProjectionMatrix();\n    }\n\n    private revertClipPlanes(rteCamera: THREE.Camera) {\n        assert(rteCamera instanceof THREE.PerspectiveCamera);\n        const c = rteCamera as THREE.PerspectiveCamera;\n        // Restore scene camera clip planes.\n        c.near = cache.clipPlanes.near;\n        c.far = cache.clipPlanes.far;\n        c.updateProjectionMatrix();\n    }\n}\n\nfunction createMapAnchor(mesh: THREE.Mesh, renderOrder: number): MapAnchor<THREE.Mesh> {\n    const anchor = mesh as MapAnchor<THREE.Mesh>;\n    anchor.renderOrder = renderOrder;\n    anchor.pickable = false;\n    anchor.anchor = new THREE.Vector3(0, 0, 0);\n    return anchor;\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nexport type ExtendedMesh = THREE.Mesh & {\n    /**\n     * Distance of this object from the Tile's center.\n     */\n    displacement?: THREE.Vector3;\n};\n\n/**\n * This enum defines the possible origin points for an image.\n */\nexport enum ImageOrigin {\n    TopLeft,\n    BottomLeft\n}\n\n/**\n * Available rendering parameters for the POIs.\n */\nexport interface ImageOptions {\n    /**\n     * The point of origin of the texture as supported in [[ImageOrigin]].\n     */\n    origin?: ImageOrigin;\n\n    /**\n     * Missing Typedoc\n     */\n    width: number;\n\n    /**\n     * Missing Typedoc\n     */\n    height: number;\n\n    /**\n     * Missing Typedoc\n     */\n    xOffset?: number;\n\n    /**\n     * Missing Typedoc\n     */\n    yOffset?: number;\n\n    /**\n     * Missing Typedoc\n     */\n    flipH?: boolean;\n\n    /**\n     * Missing Typedoc\n     */\n    flipV?: boolean;\n\n    /**\n     * Missing Typedoc\n     */\n    opacity?: number;\n}\n\n// export enum TextAlign {\n//     Center,\n//     Left,\n//     Right,\n\n//     // ??? expands lines to have same length.\n//     Justify\n// }\n\n// export interface LayoutOptions {\n//     paddingH?: number;\n//     paddingV: number;\n//     transFormCenterX?: number;\n//     transFormCenterY?: number;\n//     rotation?: number;\n//     /** Set to `true` to enlarge the box after rotation to include all rotated corners. */\n//     rotationEnlargesBox: boolean;\n// }\n\n// export interface TextOptions {\n//     bgColor?: THREE.Color;\n//     wrapWords?: boolean;\n//     maxNumLines?: number;\n//     maxWidth?: number;\n//     /** Replace with ellipsis if wider than maxWidth. */\n//     addEllipsis?: boolean;\n//     /** Handle right-to-left texts */\n//     isRightToLeft?: boolean;\n\n//     textAlignH?: AlignH; // = AlignH.Center;\n//     textAlignV?: AlignV; // = AlignV.Center;\n// }\n\n// export class IconLabel {\n//     constructor(text: string, options: LayoutOptions | TextOptions) {}\n\n//     /**\n//      * Setup a box with size and padding.\n//      *\n//      * @param box - Target box to set up.\n//      */\n//     getBox(box: THREE.Box2) {}\n\n//     /**\n//      * Compute width and height from text and font.\n//      */\n//     computeBox() {}\n\n//     /**\n//      * Generate the glyphs and keep them in a buffer. Generates a fixed layout.\n//      */\n//     prepareRendering() {}\n// }\n\n// export enum AlignH {\n//     Center,\n//     Left,\n//     Right\n// }\n\n// export enum AlignV {\n//     Center,\n//     Top,\n//     Bottom\n// }\n\n// export enum AnchorTarget {\n//     /** Anchor point relative to Icon */\n//     Icon,\n//     /** Anchor point is transform center of icon */\n//     IconCenter,\n//     /** Anchor point relative to Icon including padding */\n//     IconBox,\n//     /** Anchor point relative to Label */\n//     Label,\n//     /** Anchor point relative to combination of Icon and Label */\n//     Box\n// }\n\n// export class AnchorPosition {\n//     targetH: AnchorTarget = AnchorTarget.Icon;\n//     targetV: AnchorTarget = AnchorTarget.Icon;\n//     alignH: AlignH = AlignH.Center;\n//     alignV: AlignV = AlignV.Center;\n// }\n\n// export enum IconPinMode {\n//     /** Pinned down, anchor point is the same at all angles. */\n//     PinDown,\n//     /**\n//      * Icon stands up. \"StreetLevel\"-style. The anchor point moves to the bottom of the icon when\n//      * the view direction gets parallel to the ground.\n//      */\n//     StandUp\n// }\n\n// export interface IconScaleOptions {\n//     depthScale?: boolean;\n//     minimumScale?: number;\n// }\n\n// export interface IconOptions {\n//     useScreenSpace?: boolean; // = true\n//     priority?: number;\n\n//     scaleOptions?: IconScaleOptions;\n\n//     /** Optional offset in screen space */\n//     screenOffsetX?: number;\n//     screenOffsetY?: number;\n\n//     /** Optional 3D height above terrain. */\n//     heightAboveGround?: number;\n// }\n\n// export class SimplePoiIcon {\n//     constructor(\n//         readonly pos: THREE.Vector3,\n//         readonly image ?: IconTexture,\n//         options ?: IconOptions\n//     ) { }\n// }\n\n// export class PoiIcon {\n//     constructor(\n//         readonly pos: THREE.Vector3,\n//         readonly image?: IconTexture,\n//         readonly label?: IconLabel,\n//         options?: IconOptions\n//     ) {}\n// }\n\n// export interface PoiOptions {\n//     featureId?: number;\n//     minZoomLevel?: number;\n// }\n\n// export class SimplePoi {\n//     private m_featureId?: number;\n//     private m_minZoomLevel: number = 0;\n\n//     constructor(readonly icon: SimplePoiIcon, options?: PoiOptions) {\n//         if (options !== undefined) {\n//             this.m_featureId = options.featureId;\n//             this.m_minZoomLevel = options.minZoomLevel !== undefined ? options.minZoomLevel : 0;\n//         }\n//     }\n// }\n\n// export class Poi {\n//     /** store multiple icons, one for every LOD */\n//     private m_icons: PoiIcon[] = [];\n//     private m_lod = 0;\n//     private m_featureId?: number;\n//     private m_minZoomLevel: number = 0;\n\n//     constructor(icon: PoiIcon, options?: PoiOptions) {\n//         this.m_icons.push(icon);\n\n//         if (options !== undefined) {\n//             this.m_featureId = options.featureId;\n//             this.m_minZoomLevel = options.minZoomLevel !== undefined ? options.minZoomLevel : 0;\n//         }\n//     }\n\n//     icon(): PoiIcon | undefined {\n//         return this.m_icons[this.m_lod];\n//     }\n\n//     /**\n//      * Select the level of detail that should be used.\n//      *\n//      * @param levelOfDetail - Level of detail to render.\n//      */\n//     selectIcon(levelOfDetail: number) {}\n// }\n","/*\n * Copyright (C) 2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport * as THREE from \"three\";\n\nexport interface RequestHeaders {\n    [field: string]: string;\n}\n\n/**\n * A texture loader that supports request headers(e.g. for Authorization)\n */\nexport class TextureLoader {\n    private m_textureLoader = new THREE.TextureLoader();\n\n    /**\n     * Load an image from url and create a texture\n     * @param url - URL to the image\n     * @param requestHeaders - Optional request headers to load image(e.g. Authorization)\n     * @param crossOrigin - Enable/disable CORS\n     */\n    async load(\n        url: string,\n        requestHeaders?: RequestHeaders | undefined,\n        crossOrigin: boolean = true\n    ): Promise<THREE.Texture> {\n        // Use THREE.js texture loader directly if no request header is set\n        if (requestHeaders === undefined) {\n            return this.loadWithThreeLoader(url);\n        }\n\n        // Load image with fetch API if request header is set\n        const response = await fetch(url, {\n            headers: requestHeaders,\n            mode: crossOrigin ? \"cors\" : \"no-cors\"\n        });\n        const blob = await response.blob();\n\n        // Load image from blob using THREE.js loader\n        const texture = await this.loadWithThreeLoader(URL.createObjectURL(blob));\n\n        // Set correct image format from original URL or blob mime type\n        // (object URL does not contain file format)\n        const isJPEG =\n            blob.type === \"image/jpeg/\" ||\n            url.search(/\\.jpe?g($|\\?)/i) > 0 ||\n            url.search(/^data\\:image\\/jpeg/) === 0;\n        texture.format = isJPEG ? THREE.RGBFormat : THREE.RGBAFormat;\n\n        return texture;\n    }\n\n    private loadWithThreeLoader(url: string): Promise<THREE.Texture> {\n        return new Promise<THREE.Texture>((resolve, reject) => {\n            this.m_textureLoader.setCrossOrigin(\"\");\n            this.m_textureLoader.load(\n                url,\n                texture => resolve(texture),\n                undefined,\n                () => reject(new Error(\"failed to load texture\"))\n            );\n        });\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { GeometryType, getFeatureId } from \"@here/harp-datasource-protocol\";\nimport { assert, LoggerManager } from \"@here/harp-utils\";\nimport { Tile, TileFeatureData } from \"../Tile\";\nimport {\n    BufferedGeometryLineAccessor,\n    BufferedGeometryObject3dAccessor,\n    IGeometryAccessor,\n    ILineAccessor,\n    IndexedBufferedGeometryLineAccessor,\n    IObject3dAccessor,\n    isLineAccessor,\n    isObject3dAccessor\n} from \"./TileGeometry\";\n\nconst logger = LoggerManager.instance.create(\"TileDataAccessor\");\n\n/**\n * Interface for a client visitor that is used to visit all `THREE.Object`s in a tile.\n */\nexport interface ITileDataVisitor {\n    tile: Tile;\n\n    /**\n     * Should return `true` if the visitor wants to visit the object with the specified\n     * `featureId`. This function is called before the type of the object is even known.\n     */\n    wantsFeature(featureId: number | undefined): boolean;\n\n    /**\n     * Should return `true` if the visitor wants to visit the point with the specified\n     * `featureId`.\n     */\n    wantsPoint(featureId: number | undefined): boolean;\n\n    /**\n     * Should return `true` if the visitor wants to visit the line with the specified\n     * `featureId`.\n     */\n    wantsLine(featureId: number | undefined): boolean;\n\n    /**\n     * Should return `true` if the visitor wants to visit the area object with the specified\n     * `featureId`.\n     */\n    wantsArea(featureId: number | undefined): boolean;\n\n    /**\n     * Should return `true` if the visitor wants to visit the object with the specified\n     * `featureId`.\n     */\n    wantsObject3D(featureId: number | undefined): boolean;\n\n    /**\n     * Visits a point object with the specified `featureId`; use `pointAccessor` to get the\n     * object's properties.\n     */\n    visitPoint(featureId: number | undefined): void;\n\n    /**\n     * Visits a line object with the specified `featureId`; use `pointAccessor` to get the\n     * object's properties.\n     */\n    visitLine(featureId: number | undefined, lineAccessor: ILineAccessor): void;\n\n    /**\n     * Visit an area object with the specified `featureId`; use `pointAccessor` to get the\n     * object's properties.\n     */\n    visitArea(featureId: number | undefined): void;\n\n    /**\n     * Visits a 3D object with the specified `featureId`; use `pointAccessor` to get the\n     * object's properties.\n     */\n    visitObject3D(featureId: number | undefined, object3dAccessor: IObject3dAccessor): void;\n}\n\n/**\n * An interface that provides options for {@link TileDataAccessor}.\n */\nexport interface TileDataAccessorOptions {\n    /** Limit to objects that have `featureID`s. */\n    onlyWithFeatureIds?: boolean;\n    /** Sets and overrides `wantPoints`, `wantLines`, `wantAreas`, `wantObject3D`. */\n    wantsAll?: boolean;\n    /** `true` to visit points. */\n    wantsPoints?: boolean;\n    /** `true` to visit lines. */\n    wantsLines?: boolean;\n    /** `true` to visit area objects. */\n    wantsAreas?: boolean;\n    /** `true` to visit general 3D objects. */\n    wantsObject3D?: boolean;\n}\n\n/**\n * An accessor for all geometries in a tile.\n *\n * @remarks\n * This class uses a client-provided {@link ITileDataVisitor}\n * to visit all objects, based on filtering options specified\n * by both, the `TileDataAccessor` and\n * the visitor itself.\n */\nexport class TileDataAccessor {\n    private m_wantsPoints = true;\n    private m_wantsLines = true;\n    private m_wantsAreas = true;\n    private m_wantsObject3D = true;\n\n    /**\n     * Constructs a `TileDataAccessor` instance.\n     *\n     * @param tile - The tile to access.\n     * @param visitor - The visitor.\n     * @param options - Options for the tile.\n     */\n    constructor(\n        public tile: Tile,\n        private visitor: ITileDataVisitor,\n        options: TileDataAccessorOptions\n    ) {\n        const wantsAll = options.wantsAll === true;\n        this.m_wantsPoints = wantsAll || !(options.wantsPoints === false);\n        this.m_wantsLines = wantsAll || !(options.wantsLines === false);\n        this.m_wantsAreas = wantsAll || !(options.wantsAreas === false);\n        this.m_wantsObject3D = wantsAll || !(options.wantsObject3D === false);\n    }\n\n    /**\n     * Calls the visitor on all objects in the tile.\n     */\n    visitAll(): void {\n        const objects = this.tile.objects;\n\n        for (const object of objects) {\n            this.visitObject(object);\n        }\n    }\n\n    /**\n     * Visits a single object. This function should normally be called during visiting.\n     *\n     * @param object - The object to visit.\n     */\n    protected visitObject(object: THREE.Object3D): void {\n        const featureData: TileFeatureData | undefined =\n            object.userData !== undefined\n                ? (object.userData.feature as TileFeatureData)\n                : undefined;\n\n        // early opt out if there is no feature data, or if the feature data has only a single id\n        // and the visitor wants to ignore that featureId\n        if (\n            featureData === undefined ||\n            (featureData.objInfos !== undefined &&\n                featureData.objInfos.length === 1 &&\n                !this.visitor.wantsFeature(getFeatureId(featureData.objInfos[0])))\n        ) {\n            return;\n        }\n\n        const geometryType = featureData.geometryType;\n        if (geometryType === undefined) {\n            logger.warn(\"#visitObject: visiting object failed, no geometryType\", object);\n            return;\n        }\n\n        assert(featureData.objInfos !== undefined, \"featureData.ids missing\");\n        assert(featureData.starts !== undefined, \"featureData.starts missing\");\n        assert(Array.isArray(featureData.starts), \"featureData.starts is not an array\");\n        if (featureData.objInfos !== undefined && featureData.starts !== undefined) {\n            assert(\n                featureData.objInfos.length === featureData.starts.length,\n                \"featureData.ids and featureData.starts have unequal length\"\n            );\n        }\n\n        switch (geometryType) {\n            case GeometryType.Point:\n            case GeometryType.Text:\n                if (!this.m_wantsPoints) {\n                    return;\n                }\n                break;\n            case GeometryType.SolidLine:\n            case GeometryType.ExtrudedLine:\n            case GeometryType.TextPath:\n                if (!this.m_wantsLines) {\n                    return;\n                }\n                break;\n            case GeometryType.Polygon:\n            case GeometryType.ExtrudedPolygon:\n                if (!this.m_wantsAreas) {\n                    return;\n                }\n                break;\n            case GeometryType.Object3D:\n                if (!this.m_wantsObject3D) {\n                    return;\n                }\n                break;\n            default:\n                logger.warn(\"#visitObject: invalid geometryType\");\n        }\n\n        if (object.type !== \"Mesh\") {\n            logger.warn(\"#visitObject: visiting object failed, not of type 'Mesh'\", object);\n            return;\n        }\n\n        const mesh = object as THREE.Mesh;\n\n        this.visitMesh(mesh, featureData);\n    }\n\n    /**\n     * Gets the `BufferGeometry` from the specified object. This function requires the\n     * attribute `position` in `BufferGeometry` to be set.\n     *\n     * @param object - The object from which to get the geometry.\n     * @returns the geometry of the object, or `undefined`.\n     */\n    protected getBufferGeometry(object: THREE.Mesh): THREE.BufferGeometry | undefined {\n        const geometry = object.geometry;\n\n        if (geometry.type !== \"BufferGeometry\") {\n            logger.warn(\"#visitObject: object does not have BufferGeometry\");\n            return undefined;\n        }\n\n        const bufferGeometry = geometry as THREE.BufferGeometry;\n\n        // we know its a BufferAttribute because it is a BufferGeometry\n        const position: THREE.BufferAttribute = bufferGeometry.getAttribute(\n            \"position\"\n        ) as THREE.BufferAttribute;\n\n        if (!position) {\n            logger.warn(\"#visitLines: BufferGeometry has no position attribute\");\n            return undefined;\n        }\n\n        return bufferGeometry;\n    }\n\n    /**\n     * Obtains an accessor for the nonindexed geometry. This function may return `undefined`\n     * if the accessor is not implemented.\n     *\n     * @param geometryType - The type of geometry.\n     * @param object - The object for which to access the attributes and geometry.\n     * @param bufferGeometry - The object's `BufferGeometry`.\n     * @returns an accessor for a specified object, if available.\n     */\n    protected getGeometryAccessor(\n        geometryType: GeometryType,\n        object: THREE.Mesh,\n        bufferGeometry: THREE.BufferGeometry\n    ): IGeometryAccessor | undefined {\n        switch (geometryType) {\n            case GeometryType.Point:\n            case GeometryType.Text:\n                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);\n                return undefined;\n            case GeometryType.SolidLine:\n            case GeometryType.ExtrudedLine:\n            case GeometryType.TextPath:\n                return new BufferedGeometryLineAccessor(object, geometryType, bufferGeometry);\n            case GeometryType.Polygon:\n            case GeometryType.ExtrudedPolygon:\n                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);\n                return undefined;\n            case GeometryType.Object3D:\n                return new BufferedGeometryObject3dAccessor(object, geometryType, bufferGeometry);\n            default:\n                logger.warn(\"#getGeometryAccessor: invalid geometryType\");\n        }\n        return undefined;\n    }\n\n    /**\n     * Obtains an accessor for the indexed geometry. This function may return `undefined`\n     * if the accessor is not implemented.\n     *\n     * @param geometryType - The type of geometry.\n     * @param object - The object for which to access the attributes and geometry.\n     * @param bufferGeometry - The object's `BufferGeometry`.\n     * @returns an accessor for a specified object, if available.\n     */\n    protected getIndexedGeometryAccessor(\n        geometryType: GeometryType,\n        object: THREE.Mesh,\n        bufferGeometry: THREE.BufferGeometry\n    ): IGeometryAccessor | undefined {\n        switch (geometryType) {\n            case GeometryType.Point:\n            case GeometryType.Text:\n                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);\n                return undefined;\n            case GeometryType.SolidLine:\n            case GeometryType.ExtrudedLine:\n            case GeometryType.TextPath:\n                return new IndexedBufferedGeometryLineAccessor(\n                    object,\n                    geometryType,\n                    bufferGeometry\n                );\n            case GeometryType.Polygon:\n            case GeometryType.ExtrudedPolygon:\n                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);\n                return undefined;\n            case GeometryType.Object3D:\n                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);\n                return undefined;\n            default:\n                logger.warn(\"#getIndexedGeometryAccessor: invalid geometryType\");\n        }\n        return undefined;\n    }\n\n    /**\n     * Visit the object.\n     *\n     * @param meshObject - Object of type `Mesh`.\n     * @param featureData - Dataset stored along with the object.\n     */\n    protected visitMesh(meshObject: THREE.Mesh, featureData: TileFeatureData): void {\n        const { objInfos, starts } = featureData;\n        const geometryType = featureData.geometryType;\n\n        // make linter happy: we already know that these both are valid\n        if (objInfos === undefined || starts === undefined || geometryType === undefined) {\n            return;\n        }\n\n        let geometryAccessor: IGeometryAccessor | undefined;\n\n        for (let featureIndex = 0; featureIndex < objInfos.length; featureIndex++) {\n            const featureId = getFeatureId(objInfos[featureIndex]);\n\n            if (!this.visitor.wantsFeature(featureId)) {\n                continue;\n            }\n\n            const featureStart = starts[featureIndex];\n            let featureEnd: number = -1;\n\n            // lazy creation of accessor, in case featureId was not wanted...\n            if (geometryAccessor === undefined) {\n                const bufferGeometry = this.getBufferGeometry(meshObject);\n                if (bufferGeometry === undefined) {\n                    continue;\n                }\n\n                if (bufferGeometry.index !== null) {\n                    geometryAccessor = this.getIndexedGeometryAccessor(\n                        geometryType,\n                        meshObject,\n                        bufferGeometry\n                    );\n                } else {\n                    geometryAccessor = this.getGeometryAccessor(\n                        geometryType,\n                        meshObject,\n                        bufferGeometry\n                    );\n                }\n\n                if (geometryAccessor === undefined) {\n                    logger.warn(\"#visitObject: no accessor geometryType\", geometryType);\n                    continue;\n                }\n            }\n\n            featureEnd =\n                featureIndex < starts.length - 1\n                    ? starts[featureIndex + 1]\n                    : geometryAccessor.getCount();\n\n            // setup/update the accessor for the new range of the object\n            geometryAccessor.setRange(featureStart, featureEnd);\n\n            switch (geometryType) {\n                case GeometryType.Point:\n                case GeometryType.Text:\n                    this.visitor.visitPoint(featureId);\n                    break;\n                case GeometryType.SolidLine:\n                case GeometryType.ExtrudedLine:\n                case GeometryType.TextPath:\n                    assert(isLineAccessor(geometryAccessor));\n                    this.visitor.visitLine(featureId, (geometryAccessor as any) as ILineAccessor);\n                    break;\n                case GeometryType.Polygon:\n                case GeometryType.ExtrudedPolygon:\n                    this.visitor.visitArea(featureId);\n                    break;\n                case GeometryType.Object3D:\n                    assert(isObject3dAccessor(geometryAccessor));\n                    this.visitor.visitObject3D(\n                        featureId,\n                        (geometryAccessor as any) as IObject3dAccessor\n                    );\n                    break;\n                default:\n                    logger.warn(\"#visitObject: invalid geometryType\");\n            }\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport * from \"./lib/Lines\";\nexport * from \"./lib/TriangulateLines\";\nexport * from \"./lib/HighPrecisionLines\";\nexport * from \"./lib/HighPrecisionUtils\";\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Projection } from \"@here/harp-geoutils\";\nimport { assert } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\n// Preallocate temp variables used during line generation.\nconst tmpV = new THREE.Vector3();\nconst tmpNormal = new THREE.Vector3();\nconst tmpTangent0 = new THREE.Vector3();\nconst tmpTangent1 = new THREE.Vector3();\nconst tmpBitangent = new THREE.Vector3();\nconst SEGMENT_OFFSET = 0.1;\n\n/**\n * Describes vertex attribute parameters of interleaved buffer.\n */\ninterface VertexAttributeDescriptor {\n    name: string;\n    itemSize: number;\n    offset: number;\n}\n\ninterface VertexDescriptor {\n    attributes: VertexAttributeDescriptor[];\n    stride: number;\n}\n\n/**\n * Declares all the vertex attributes used for rendering a line using the [[SolidLineMaterial]].\n */\n\n/** Base line vertex attributes. */\nconst LINE_VERTEX_ATTRIBUTES: VertexDescriptor = {\n    attributes: [\n        // The \"extrusionCoord\" is a vec4 which represents:\n        // xy: Extrusion coordinates\n        // sign(xy): Extrusion direction\n        // z: Line length\n        { name: \"extrusionCoord\", itemSize: 3, offset: 0 },\n        { name: \"position\", itemSize: 3, offset: 3 },\n        { name: \"tangent\", itemSize: 3, offset: 6 },\n        { name: \"bitangent\", itemSize: 4, offset: 9 }\n    ],\n    stride: 13\n};\n\n/** Optional normal and uv coordinates. */\nconst NORMAL_UV_VERTEX_ATTRIBUTES: VertexDescriptor = {\n    attributes: [\n        { name: \"uv\", itemSize: 2, offset: LINE_VERTEX_ATTRIBUTES.stride },\n        { name: \"normal\", itemSize: 3, offset: LINE_VERTEX_ATTRIBUTES.stride + 2 }\n    ],\n    stride: 5\n};\n\n/** Base line vertex attributes plus normals and uv coordinates. */\nconst LINE_VERTEX_ATTRIBUTES_NUV: VertexDescriptor = {\n    attributes: [...LINE_VERTEX_ATTRIBUTES.attributes, ...NORMAL_UV_VERTEX_ATTRIBUTES.attributes],\n    stride: LINE_VERTEX_ATTRIBUTES.stride + NORMAL_UV_VERTEX_ATTRIBUTES.stride\n};\n\n/**\n * Declares all the vertex attributes used for rendering a line using the\n * [[HighPrecisionLineMaterial]].\n */\nconst HP_LINE_VERTEX_ATTRIBUTES: VertexDescriptor = {\n    attributes: [\n        { name: \"extrusionCoord\", itemSize: 2, offset: 0 },\n        { name: \"position\", itemSize: 3, offset: 2 },\n        { name: \"positionLow\", itemSize: 3, offset: 5 },\n        { name: \"tangent\", itemSize: 3, offset: 8 },\n        { name: \"bitangent\", itemSize: 4, offset: 11 }\n    ],\n    stride: 15\n};\n\n/** High precision line vertex attributes plus normals and uv coordinates. */\nconst HP_LINE_VERTEX_ATTRIBUTES_NUV: VertexDescriptor = {\n    attributes: [\n        ...HP_LINE_VERTEX_ATTRIBUTES.attributes,\n        ...NORMAL_UV_VERTEX_ATTRIBUTES.attributes\n    ],\n    stride: HP_LINE_VERTEX_ATTRIBUTES.stride + NORMAL_UV_VERTEX_ATTRIBUTES.stride\n};\n\n/**\n * Class that holds the vertex and index attributes for a [[Lines]] object.\n */\nexport class LineGeometry {\n    vertices: number[] = [];\n    vertexColors: number[] = [];\n    indices: number[] = [];\n}\n\nfunction getVertexDescriptor(hasNormalsAndUvs: boolean, highPrecision: boolean): VertexDescriptor {\n    if (highPrecision) {\n        return hasNormalsAndUvs ? HP_LINE_VERTEX_ATTRIBUTES_NUV : HP_LINE_VERTEX_ATTRIBUTES;\n    } else {\n        return hasNormalsAndUvs ? LINE_VERTEX_ATTRIBUTES_NUV : LINE_VERTEX_ATTRIBUTES;\n    }\n}\n\n/**\n * Creates a [[LineGeometry]] object out of a polyline.\n *\n * @param center - Center of the polyline.\n * @param polyline - Array of `numbers` describing a polyline.\n * @param offsets - Array of `numbers` representing line segment offsets.\n * @param uvs - Array of `numbers` representing texture coordinates.\n * @param colors - Array of `numbers` describing a polyline's colors.\n * @param geometry - [[LineGeometry]] object used to store the vertex and index attributes.\n * @param highPrecision - If `true` will create high-precision vertex information.\n */\nexport function createLineGeometry(\n    center: THREE.Vector3,\n    polyline: ArrayLike<number>,\n    projection: Projection,\n    offsets?: ArrayLike<number>,\n    uvs?: ArrayLike<number>,\n    colors?: ArrayLike<number>,\n    geometry = new LineGeometry(),\n    highPrecision: boolean = false\n): LineGeometry {\n    if (polyline.length === 0) {\n        return geometry;\n    }\n\n    const stride = getVertexDescriptor(uvs !== undefined, highPrecision).stride;\n\n    const pointCount = polyline.length / 3;\n    const segments = new Array<number>(pointCount);\n    const tangents = new Array<number>(polyline.length - 3);\n    const baseVertex = geometry.vertices.length / stride;\n\n    const hasSegmentOffsets = offsets !== undefined && offsets.length > 0;\n    const hasTexCoords = uvs !== undefined && uvs.length > 0;\n    const vertexColors = colors !== undefined && colors.length && polyline.length;\n\n    assert(!hasSegmentOffsets || offsets!.length === pointCount);\n    assert(!hasTexCoords || uvs!.length / 2 === pointCount);\n    assert(!vertexColors || colors!.length === polyline.length);\n\n    // Compute segments and tangents.\n    let sum = SEGMENT_OFFSET;\n    segments[0] = sum;\n    for (let i = 0; i < pointCount - 1; ++i) {\n        let sqrLength = 0;\n        for (let j = 0; j < 3; ++j) {\n            const d = polyline[(i + 1) * 3 + j] - polyline[i * 3 + j];\n            tangents[i * 3 + j] = d;\n            sqrLength += d * d;\n        }\n        const len = Math.sqrt(sqrLength);\n        sum = sum + len;\n        segments[i + 1] = sum;\n    }\n\n    const lineCoverage = hasSegmentOffsets\n        ? Math.abs(offsets![offsets!.length - 1] - offsets![0])\n        : 1.0;\n    const lineLength = segments[segments.length - 1] / lineCoverage;\n\n    // Override the segments if offsets are explicitly provided.\n    if (hasSegmentOffsets) {\n        for (let i = 0; i < pointCount; ++i) {\n            segments[i] = offsets![i] * lineLength + SEGMENT_OFFSET;\n        }\n    }\n\n    // Check if we're working with a closed line.\n    let isClosed = true;\n    for (let j = 0; j < 3; ++j) {\n        isClosed = isClosed && polyline[j] === polyline[polyline.length - 3 + j];\n    }\n\n    const tmpVertices: number[] = [];\n\n    const addVertexPair = (\n        i: number,\n        T1: number,\n        T2: number,\n        segment: number,\n        extrusionCoord: number\n    ) => {\n        tmpVertices.length = 0;\n\n        // Store the segment and extrusionCoord attributes.\n        geometry.vertices.push(segment, extrusionCoord * -1, lineLength);\n        tmpVertices.push(segment, extrusionCoord * 1, lineLength);\n\n        // Store the position attribute (component-dependant).\n        for (let j = 0; j < 3; ++j) {\n            if (!highPrecision) {\n                geometry.vertices.push(polyline[i * 3 + j]);\n                tmpVertices.push(polyline[i * 3 + j]);\n            } else {\n                const highComp = Math.fround(polyline[i * 3 + j]);\n                const lowComp = polyline[i * 3 + j] - highComp;\n                geometry.vertices.push(highComp, lowComp);\n                tmpVertices.push(highComp, lowComp);\n            }\n            tmpNormal.setComponent(j, polyline[i * 3 + j]);\n        }\n\n        // Store the bitangent attribute (component-dependant).\n        for (let j = 0; j < 3; ++j) {\n            tmpTangent0.setComponent(j, tangents[T1 + j]);\n            tmpTangent1.setComponent(j, tangents[T2 + j]);\n        }\n        tmpTangent0.normalize();\n        geometry.vertices.push(tmpTangent0.x, tmpTangent0.y, tmpTangent0.z);\n        tmpVertices.push(tmpTangent0.x, tmpTangent0.y, tmpTangent0.z);\n        tmpNormal.add(center); // tmpNormal contains world position\n        projection.surfaceNormal(tmpNormal, tmpNormal);\n        const angle = computeBitangent(\n            tmpNormal,\n            tmpTangent0,\n            tmpTangent1.normalize(),\n            tmpBitangent\n        );\n        geometry.vertices.push(tmpBitangent.x, tmpBitangent.y, tmpBitangent.z, angle);\n        tmpVertices.push(tmpBitangent.x, tmpBitangent.y, tmpBitangent.z, angle);\n\n        if (hasTexCoords) {\n            // uvs\n            geometry.vertices.push(uvs![i * 2], uvs![i * 2 + 1]);\n            tmpVertices.push(uvs![i * 2], uvs![i * 2 + 1]);\n            // normals\n            geometry.vertices.push(tmpNormal.x, tmpNormal.y, tmpNormal.z);\n            tmpVertices.push(tmpNormal.x, tmpNormal.y, tmpNormal.z);\n        }\n\n        geometry.vertices.push(...tmpVertices);\n\n        // Add vertex colors (if supplied).\n        if (vertexColors) {\n            geometry.vertexColors.push(colors![i * 3], colors![i * 3 + 1], colors![i * 3 + 2]);\n            geometry.vertexColors.push(colors![i * 3], colors![i * 3 + 1], colors![i * 3 + 2]);\n        }\n    };\n\n    for (let i = 0; i < pointCount; ++i) {\n        // Retrieve the per-point tangents.\n        const T1 = isClosed && i === 0 ? tangents.length - 3 : Math.max(0, i - 1) * 3;\n        const T2 = isClosed && i === pointCount - 1 ? 0 : Math.min(i * 3, tangents.length - 3);\n\n        // Process v0 and v1.\n        if (i > 0) {\n            addVertexPair(i, T1, T2, segments[i - 1], segments[i]);\n        }\n\n        // Process v2 and v3.\n        if (i + 1 < pointCount) {\n            addVertexPair(\n                i,\n                T1,\n                T2,\n                segments[Math.min(i, segments.length - 1)] * -1,\n                segments[Math.min(i + 1, segments.length - 1)]\n            );\n        }\n    }\n\n    // Store the triangle indices in the final index buffer.\n    for (let i = 0; i < pointCount - 1; ++i) {\n        const base = baseVertex + i * 4;\n        geometry.indices.push(base, base + 1, base + 2, base + 2, base + 1, base + 3);\n    }\n\n    return geometry;\n}\n\n/**\n * Creates a [[LineGeometry]] object out of a polyline.\n *\n * @param polyline - Array of `numbers` describing a polyline.\n * @param colors - Array of `numbers` describing a polyline's colors.\n * @param geometry - [[LineGeometry]] object used to store the vertex and index attributes.\n */\nexport function createSimpleLineGeometry(\n    polyline: ArrayLike<number>,\n    colors?: ArrayLike<number>,\n    geometry = new LineGeometry()\n): LineGeometry {\n    if (polyline.length === 0) {\n        return geometry;\n    }\n\n    const pointCount = polyline.length / 3;\n    let index = geometry.vertices.length / 3;\n\n    const vertexColors = colors !== undefined && colors.length && polyline.length;\n\n    for (let i = 0; i < pointCount; ++i, index++) {\n        if (i > 0) {\n            geometry.indices.push(index);\n        }\n        if (i < pointCount - 1) {\n            geometry.indices.push(index);\n        }\n        for (let j = 0; j < 3; ++j) {\n            geometry.vertices.push(polyline[i * 3 + j]);\n            if (vertexColors) {\n                geometry.vertexColors.push(colors![i * 3 + j]);\n            }\n        }\n    }\n\n    return geometry;\n}\n\n/**\n * Class used to render groups (or batches) of width-variable lines (in the same tile).\n */\nexport class LineGroup {\n    /**\n     * Adds all the attribute data needed to a [[BufferGeometry]] object for rendering `Lines`.\n     *\n     * @param vertices - Array of vertex attributes.\n     * @param colors - Array of vertex colors.\n     * @param indices - Array of vertex indices.\n     * @param geometry - [[BufferGeometry]] object which will store all the `Lines` attribute data.\n     * @param hasNormalsAnUvs - Whether vertices have normal and uv coordinates as attributes.\n     * @param highPrecision - If `true` will create high-precision vertex information.\n     * @param isSimple - `true` to create simple (nonsolid, nonextruded) lines. Defaults to `false`.\n     */\n    static createGeometry(\n        vertices: ArrayLike<number>,\n        colors: ArrayLike<number>,\n        indices: ArrayLike<number>,\n        geometry: THREE.BufferGeometry,\n        hasNormalsAndUvs: boolean = false,\n        highPrecision = false,\n        isSimple = false\n    ): THREE.BufferGeometry {\n        if (isSimple) {\n            geometry.setAttribute(\n                \"position\",\n                new THREE.BufferAttribute(new Float32Array(vertices), 3)\n            );\n            if (colors.length === vertices.length) {\n                geometry.setAttribute(\n                    \"color\",\n                    new THREE.BufferAttribute(new Float32Array(colors), 3)\n                );\n            }\n            geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));\n            return geometry;\n        } else {\n            const vertexDescriptor = getVertexDescriptor(hasNormalsAndUvs, highPrecision);\n\n            const buffer = new THREE.InterleavedBuffer(\n                new Float32Array(vertices),\n                vertexDescriptor.stride\n            );\n            vertexDescriptor.attributes.forEach(descr => {\n                const attribute = new THREE.InterleavedBufferAttribute(\n                    buffer,\n                    descr.itemSize,\n                    descr.offset,\n                    false\n                );\n                geometry.setAttribute(descr.name, attribute);\n            });\n            if (colors.length === vertices.length) {\n                geometry.setAttribute(\n                    \"color\",\n                    new THREE.BufferAttribute(new Float32Array(colors), 3)\n                );\n            }\n\n            geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));\n\n            return geometry;\n        }\n    }\n\n    private readonly m_geometry: LineGeometry;\n\n    constructor(\n        readonly hasNormalsAndUvs: boolean = false,\n        readonly highPrecision: boolean = false,\n        readonly isSimple: boolean = false\n    ) {\n        this.m_geometry = new LineGeometry();\n    }\n\n    /**\n     * Clears the list of line strips.\n     */\n    clear() {\n        this.m_geometry.vertices = [];\n        this.m_geometry.vertexColors = [];\n        this.m_geometry.indices = [];\n    }\n\n    /**\n     * Add the given points to this line group.\n     *\n     * @param center - World center of the provided points.\n     * @param points - Sequence of (x,y,z) coordinates.\n     * @param offsets - Sequence of line segment offsets.\n     * @param uvs - Sequence of (u,v) texture coordinates.\n     * @param colors - Sequence of (r,g,b) color components.\n     */\n    add(\n        center: THREE.Vector3,\n        points: ArrayLike<number>,\n        projection: Projection,\n        offsets?: ArrayLike<number>,\n        uvs?: ArrayLike<number>,\n        colors?: ArrayLike<number>\n    ): this {\n        if (!this.isSimple) {\n            assert(!this.hasNormalsAndUvs || uvs !== undefined);\n            createLineGeometry(\n                center,\n                points,\n                projection,\n                offsets,\n                uvs,\n                colors,\n                this.m_geometry,\n                this.highPrecision\n            );\n        } else {\n            createSimpleLineGeometry(points, colors, this.m_geometry);\n        }\n        return this;\n    }\n\n    /**\n     * Returns the list of vertices.\n     */\n    get vertices(): number[] {\n        return this.m_geometry.vertices;\n    }\n\n    /**\n     * Returns the list of vertex colors.\n     */\n    get vertexColors(): number[] {\n        return this.m_geometry.vertexColors;\n    }\n\n    /**\n     * Returns the list of indices.\n     */\n    get indices(): number[] {\n        return this.m_geometry.indices;\n    }\n\n    /**\n     * Returns the list of [[VertexAttributeDescriptor]]s.\n     */\n    get vertexAttributes(): VertexAttributeDescriptor[] {\n        return getVertexDescriptor(this.hasNormalsAndUvs, this.highPrecision).attributes;\n    }\n\n    /**\n     * Returns the vertex attribute stride.\n     */\n    get stride(): number {\n        return getVertexDescriptor(this.hasNormalsAndUvs, this.highPrecision).stride;\n    }\n\n    /**\n     * Creates a three.js geometry.\n     */\n    createGeometry(geometry?: THREE.BufferGeometry): THREE.BufferGeometry {\n        if (geometry === undefined) {\n            geometry = new THREE.BufferGeometry();\n        }\n        return LineGroup.createGeometry(\n            this.m_geometry.vertices,\n            this.m_geometry.vertexColors,\n            this.m_geometry.indices,\n            geometry,\n            this.hasNormalsAndUvs,\n            this.highPrecision\n        );\n    }\n}\n\nfunction computeBitangent(\n    n: THREE.Vector3,\n    t0: THREE.Vector3,\n    t1: THREE.Vector3,\n    bt: THREE.Vector3\n): number {\n    let angle = 0;\n    if (!t0.equals(t1)) {\n        angle = Math.acos(t0.dot(t1)) * Math.sign(n.dot(tmpV.copy(t0).cross(t1)));\n        if (Number.isNaN(angle)) {\n            angle = 0;\n        }\n    }\n    bt.copy(t0)\n        .add(t1)\n        .normalize()\n        .cross(n)\n        .normalize();\n    return angle;\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { HighPrecisionPointMaterial } from \"@here/harp-materials\";\n\nimport { HighPrecisionObject } from \"./HighPrecisionLines\";\nimport { HighPrecisionUtils } from \"./HighPrecisionUtils\";\n\n/**\n * Class used to render high-precision points.\n */\nexport class HighPrecisionPoints extends THREE.Points implements HighPrecisionObject {\n    matrixWorldInverse: THREE.Matrix4;\n\n    /**\n     * Number of dimensions this `HighPrecisionObject` is specified in (2D/3D).\n     */\n    dimensionality?: number;\n\n    /**\n     * Creates a `HighPrecisionPoints` object.\n     *\n     * @param geometry - [[BufferGeometry]] used to render this object.\n     * @param material - [[HighPrecisionLineMaterial]] used to render this object.\n     *     instances.\n     * @param positions - Array of 2D/3D positions.\n     * @param color - Color of the rendered point.\n     * @param opacity - Opacity of the rendered point.\n     */\n    constructor(\n        geometry?: THREE.BufferGeometry,\n        material?: HighPrecisionPointMaterial,\n        positions?: number[] | THREE.Vector3[],\n        color?: THREE.Color,\n        opacity?: number\n    ) {\n        if (material === undefined) {\n            material = new HighPrecisionPointMaterial({\n                color: color ? color : HighPrecisionPointMaterial.DEFAULT_COLOR,\n                opacity: opacity !== undefined ? opacity : 1\n            });\n        }\n\n        super(geometry === undefined ? new THREE.BufferGeometry() : geometry, material);\n\n        this.matrixWorldInverse = new THREE.Matrix4();\n\n        if (positions) {\n            this.setPositions(positions);\n        }\n    }\n\n    get bufferGeometry(): THREE.BufferGeometry {\n        return this.geometry as THREE.BufferGeometry;\n    }\n\n    /**\n     * Clears the [[BufferGeometry]] used to render this point.\n     */\n    clearGeometry(): THREE.BufferGeometry {\n        return (this.geometry = new THREE.BufferGeometry());\n    }\n\n    get shaderMaterial(): THREE.ShaderMaterial {\n        return this.material as THREE.ShaderMaterial;\n    }\n\n    setPositions(positions: number[] | THREE.Vector3[]): void {\n        HighPrecisionUtils.setPositions(this, positions);\n    }\n\n    setupForRendering(): void {\n        if (\n            (this.material as any).isHighPrecisionPointsMaterial &&\n            this.dimensionality !== undefined\n        ) {\n            (this.material as any).setDimensionality(this.dimensionality);\n        }\n        this.onBeforeRender = (\n            _renderer: THREE.WebGLRenderer,\n            _scene: THREE.Scene,\n            camera: THREE.Camera,\n            _geometry: THREE.Geometry | THREE.BufferGeometry,\n            _material: THREE.Material,\n            _group: THREE.Group\n        ) => {\n            HighPrecisionUtils.updateHpUniforms(this, camera, this.shaderMaterial);\n        };\n    }\n\n    updateMatrixWorld(force: boolean) {\n        const doUpdateMatrixWorldInverse = this.matrixWorldNeedsUpdate || force;\n\n        super.updateMatrixWorld(force);\n\n        if (doUpdateMatrixWorldInverse) {\n            this.matrixWorldInverse.getInverse(this.matrixWorld);\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * HERE OMV Data source.\n *\n * @remarks\n *\n * @packageDocumentation\n */\n\nexport * from \"./lib/OmvDataFilter\";\nexport * from \"./lib/OmvDataSource\";\nexport * from \"./lib/OmvDecoderDefs\";\nexport * from \"./lib/OmvTile\";\nexport * from \"./lib/OmvDebugLabelsTile\";\nexport * from \"./lib/OmvRestClient\";\nexport * from \"./lib/GeoJsonDataProvider\";\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { GeometryKind, GeometryKindSet } from \"@here/harp-datasource-protocol\";\nimport { MapEnv } from \"@here/harp-datasource-protocol/index-decoder\";\nimport {\n    OmvFeatureFilterDescription,\n    OmvFilterDescription,\n    OmvFilterFeatureAttribute,\n    OmvFilterString,\n    OmvGeometryType,\n    OmvLayerFilterDescription\n} from \"./OmvDecoderDefs\";\n\n/**\n * The `OmvFeatureFilter` is designed to work in an `OmvVisitor`/`visitOmv` combination (for\n * example, `OmvDecoder`). Returning `false` from any of the calls terminates processing of that\n * layer or feature.\n *\n * The `OmvFeatureFilter` is an \"early-opt-out\" filter, which cannot filter individual features,\n * because at that point the features are not really decoded. Use the [[OmvFeatureModifier]] to\n * filter for individual features.\n */\nexport interface OmvFeatureFilter {\n    /**\n     * Returns `true` if the filter contains rules for specific kinds.\n     */\n    hasKindFilter: boolean;\n\n    /**\n     * Return `false` if the layer should not be processed.\n     *\n     * @param layer - Current layer.\n     * @param level - Level of tile.\n     */\n    wantsLayer(layer: string, level: number): boolean;\n\n    /**\n     * Return `false` if the point feature should not be processed.\n     *\n     * @param layer - Current layer.\n     * @param feature - Current feature.\n     * @param level - Level of tile.\n     */\n    wantsPointFeature(layer: string, geometryType: OmvGeometryType, level: number): boolean;\n\n    /**\n     * Return `false` if the line feature should not be processed.\n     *\n     * @param layer - Current layer.\n     * @param feature - Current feature.\n     * @param level - Level of tile.\n     */\n    wantsLineFeature(layer: string, geometryType: OmvGeometryType, level: number): boolean;\n\n    /**\n     * Return `false` if the polygon feature should not be processed.\n     *\n     * @param layer - Current layer.\n     * @param feature - Current feature.\n     * @param level - Level of tile.\n     */\n    wantsPolygonFeature(layer: string, geometryType: OmvGeometryType, level: number): boolean;\n\n    /**\n     * Return `false` if kind of object is not enabled and the geometry should not be created.\n     *\n     * @param {(string | string[])} kind Tag \"kind\" of the tag.\n     * @returns {boolean}\n     */\n    wantsKind(kind: string | string[]): boolean;\n}\n\n/**\n * The `OmvFeatureModifier` can be used to filter individual features. It gets passed in the [[Env]]\n * of the feature, which contains all the values that can be searched for in a style. If a filter\n * function returns false, the feature is ignored, and no geometry is being created.\n *\n * In addition to pure filtering, the `OmvFeatureModifier` can also modify the [[Env]] of the\n * feature, or even add new properties to the feature, for example, traffic states. The\n * `OmvFeatureModifier` is executed before the styles are selected, so the geometry is created with\n * the modified feature properties.\n */\nexport interface OmvFeatureModifier {\n    /**\n     * Check if the point feature described by `env` should be processed. The properties can be\n     * modified or added to.\n     *\n     * @param layer - Current layer.\n     * @param env - Properties of point feature.\n     * @param level - Level of tile.\n     * @returns `false` to ignore feature.\n     */\n    doProcessPointFeature(layer: string, env: MapEnv, level: number): boolean;\n\n    /**\n     * Check if the line feature described by `env` should be processed. The properties can be\n     * modified or added to.\n     *\n     * @param layer - Current layer.\n     * @param env - Properties of line feature.\n     * @param level - Level of tile.\n     * @returns `false` to ignore feature.\n     */\n    doProcessLineFeature(layer: string, env: MapEnv, level: number): boolean;\n\n    /**\n     * Check if the polygon feature described by `env` should be processed. The properties can be\n     * modified or added to.\n     *\n     * @param layer - Current layer.\n     * @param env - Properties of polygon feature.\n     * @param level - Level of tile.\n     * @returns `false` to ignore feature.\n     */\n    doProcessPolygonFeature(layer: string, env: MapEnv, level: number): boolean;\n}\n\n/**\n * Builds an `OmvFilterDescription` (internal type) that specifies an [[OmvFeatureFilter]] as well\n * as an [[OmvFeatureModifier]].\n *\n */\nexport class OmvFeatureFilterDescriptionBuilder {\n    private m_processLayersDefault: boolean = true;\n    private m_processPointsDefault: boolean = true;\n    private m_processLinesDefault: boolean = true;\n    private m_processPolygonsDefault: boolean = true;\n\n    private readonly m_layersToProcess = new Array<OmvLayerFilterDescription>();\n    private readonly m_layersToIgnore = new Array<OmvLayerFilterDescription>();\n    private readonly m_pointsToProcess = new Array<OmvFilterDescription>();\n    private readonly m_ignoredPoints = new Array<OmvFilterDescription>();\n    private readonly m_linesToProcess = new Array<OmvFilterDescription>();\n    private readonly m_linesToIgnore = new Array<OmvFilterDescription>();\n    private readonly m_polygonsToProcess = new Array<OmvFilterDescription>();\n    private readonly m_polygonsToIgnore = new Array<OmvFilterDescription>();\n\n    private m_kindsToProcess: string[] = [];\n    private m_kindsToIgnore: string[] = [];\n\n    /**\n     * Builds an `OmvFilterDescription` (internal type) that specifies an [[OmvFeatureFilter]] as\n     * well as an [[OmvFeatureModifier]].\n     *\n     * @param processLayersDefault - If `true`, all unspecified layers will be processed.\n     * If `false`, all unspecified layers will be ignored.\n     * @param processPointsDefault - If `true`, all unspecified point features will be processed. If\n     * `false`, all unspecified point features will be ignored.\n     * @param processLinesDefault - If `true`, all unspecified line features will be processed. If\n     * `false`, all unspecified line features will be ignored.\n     * @param processPolygonsDefault - If `true`, all unspecified polygon features will be\n     * processed. If `false`, all unspecified polygon features will be ignored.\n     */\n    constructor(\n        options?: OmvFeatureFilterDescriptionBuilder.OmvFeatureFilterDescriptionBuilderOptions\n    ) {\n        if (options) {\n            this.m_processLayersDefault =\n                options.processLayersDefault !== undefined ? options.processLayersDefault : true;\n            this.m_processPointsDefault =\n                options.processPointsDefault !== undefined ? options.processPointsDefault : true;\n            this.m_processLinesDefault =\n                options.processLinesDefault !== undefined ? options.processLinesDefault : true;\n            this.m_processPolygonsDefault =\n                options.processPolygonsDefault !== undefined\n                    ? options.processPolygonsDefault\n                    : true;\n        }\n    }\n\n    /**\n     * Add a layer that should be processed.\n     *\n     * @param layer - Layer name to be matched.\n     * @param match - Match condition.\n     */\n    processLayer(\n        layer: string,\n        match = OmvFilterString.StringMatch.Match,\n        minLevel: number = 0,\n        maxLevel: number = Infinity\n    ) {\n        this.m_layersToProcess.push({\n            name: { value: layer, match },\n            minLevel,\n            maxLevel\n        });\n    }\n\n    /**\n     * Add a layer that should be ignored.\n     *\n     * @param layer - Layer name to be matched.\n     * @param match - Match condition.\n     */\n    ignoreLayer(\n        layer: string,\n        match = OmvFilterString.StringMatch.Match,\n        minLevel: number = 0,\n        maxLevel: number = Infinity\n    ) {\n        this.m_layersToIgnore.push({\n            name: { value: layer, match },\n            minLevel,\n            maxLevel\n        });\n    }\n\n    /**\n     * Add a valid point feature.\n     *\n     * @param options - Feature options.\n     */\n    processPoint(options: OmvFeatureFilterDescriptionBuilder.FeatureOption) {\n        this.addItem(this.m_pointsToProcess, options);\n    }\n\n    /**\n     * Add valid point features.\n     *\n     * @param options - Multi feature options.\n     */\n    processPoints(options: OmvFeatureFilterDescriptionBuilder.MultiFeatureOption) {\n        this.addItems(this.m_pointsToProcess, options);\n    }\n\n    /**\n     * Add a point feature that should be ignored.\n     *\n     * @param options - Feature options.\n     */\n    ignorePoint(options: OmvFeatureFilterDescriptionBuilder.FeatureOption) {\n        this.addItem(this.m_ignoredPoints, options);\n    }\n\n    /**\n     * Add point features that should be ignored.\n     *\n     * @param options - Multi feature options.\n     */\n    ignorePoints(options: OmvFeatureFilterDescriptionBuilder.MultiFeatureOption) {\n        this.addItems(this.m_ignoredPoints, options);\n    }\n\n    /**\n     * Add a valid line feature.\n     *\n     * @param options - Feature options.\n     */\n    processLine(options: OmvFeatureFilterDescriptionBuilder.FeatureOption) {\n        this.addItem(this.m_linesToProcess, options);\n    }\n\n    /**\n     * Add valid line features.\n     *\n     * @param options - Multi feature options.\n     */\n    processLines(options: OmvFeatureFilterDescriptionBuilder.MultiFeatureOption) {\n        this.addItems(this.m_linesToProcess, options);\n    }\n\n    /**\n     * Ignore a line feature.\n     *\n     * @param options - Feature options.\n     */\n    ignoreLine(options: OmvFeatureFilterDescriptionBuilder.FeatureOption) {\n        this.addItem(this.m_linesToIgnore, options);\n    }\n\n    /**\n     * Ignore line features.\n     *\n     * @param options - Multi feature options.\n     */\n    ignoreLines(options: OmvFeatureFilterDescriptionBuilder.MultiFeatureOption) {\n        this.addItems(this.m_linesToIgnore, options);\n    }\n\n    /**\n     * Add a valid polygon feature.\n     *\n     * @param options - Feature options.\n     */\n    processPolygon(options: OmvFeatureFilterDescriptionBuilder.FeatureOption) {\n        this.addItem(this.m_polygonsToProcess, options);\n    }\n\n    /**\n     * Add valid polygon features.\n     *\n     * @param options - Multi feature options.\n     */\n    processPolygons(options: OmvFeatureFilterDescriptionBuilder.MultiFeatureOption) {\n        this.addItems(this.m_polygonsToProcess, options);\n    }\n\n    /**\n     * Ignore a valid polygon feature.\n     *\n     * @param options - Feature options.\n     */\n    ignorePolygon(options: OmvFeatureFilterDescriptionBuilder.FeatureOption) {\n        this.addItem(this.m_polygonsToIgnore, options);\n    }\n\n    /**\n     * Ignore polygon features.\n     *\n     * @param options - Multi feature options.\n     */\n    ignorePolygons(options: OmvFeatureFilterDescriptionBuilder.MultiFeatureOption) {\n        this.addItems(this.m_polygonsToIgnore, options);\n    }\n\n    /**\n     * Add all the specified strings as \"enabledKinds\".\n     *\n     * @param {string[]} enabledKinds List of kinds that should be generated.\n     */\n    processKinds(enabledKinds: string[]) {\n        this.m_kindsToProcess = this.m_kindsToProcess.concat(enabledKinds);\n    }\n\n    /**\n     * Add all the specified strings as \"disabledKinds\".\n     *\n     * @param {string[]} disabledKinds List of kinds that should _not_ be generated.\n     */\n    ignoreKinds(disabledKinds: string[]) {\n        this.m_kindsToIgnore = this.m_kindsToIgnore.concat(disabledKinds);\n    }\n\n    /**\n     * Create a filter description that can be passed as an option to the [[OmvDataSource]].\n     */\n    createDescription(): OmvFeatureFilterDescription {\n        return {\n            processLayersDefault: this.m_processLayersDefault,\n            processPointsDefault: this.m_processPointsDefault,\n            processLinesDefault: this.m_processLinesDefault,\n            processPolygonsDefault: this.m_processPolygonsDefault,\n\n            layersToProcess: this.m_layersToProcess,\n            layersToIgnore: this.m_layersToIgnore,\n            pointsToProcess: this.m_pointsToProcess,\n            pointsToIgnore: this.m_ignoredPoints,\n            linesToProcess: this.m_linesToProcess,\n            linesToIgnore: this.m_linesToIgnore,\n            polygonsToProcess: this.m_polygonsToProcess,\n            polygonsToIgnore: this.m_polygonsToIgnore,\n\n            kindsToProcess: this.m_kindsToProcess,\n            kindsToIgnore: this.m_kindsToIgnore\n        };\n    }\n\n    private addItem(\n        items: OmvFilterDescription[],\n        options: OmvFeatureFilterDescriptionBuilder.FeatureOption\n    ) {\n        if (options.minLevel === undefined || isNaN(options.minLevel)) {\n            options.minLevel = 0;\n        }\n        if (options.maxLevel === undefined || isNaN(options.maxLevel)) {\n            options.maxLevel = Infinity;\n        }\n\n        const item: OmvFilterDescription = {\n            layerName: {\n                value: options.layer,\n                match:\n                    options.matchLayer === undefined\n                        ? OmvFilterString.StringMatch.Match\n                        : options.matchLayer\n            },\n            geometryTypes:\n                options.geomType !== undefined\n                    ? Array.isArray(options.geomType)\n                        ? options.geomType\n                        : [options.geomType]\n                    : undefined,\n            classes: [\n                {\n                    value: options.featureClass,\n                    match:\n                        options.matchClass === undefined\n                            ? OmvFilterString.StringMatch.Match\n                            : options.matchClass\n                }\n            ],\n            minLevel: options.minLevel,\n            maxLevel: options.maxLevel,\n            featureAttribute: options.featureAttribute\n        };\n\n        items.push(item);\n    }\n\n    private addItems(\n        items: OmvFilterDescription[],\n        options: OmvFeatureFilterDescriptionBuilder.MultiFeatureOption\n    ) {\n        if (options.minLevel === undefined || isNaN(options.minLevel)) {\n            options.minLevel = 0;\n        }\n        if (options.maxLevel === undefined || isNaN(options.maxLevel)) {\n            options.maxLevel = Infinity;\n        }\n\n        const item: OmvFilterDescription = {\n            layerName: {\n                value: options.layer,\n                match:\n                    options.matchLayer === undefined\n                        ? OmvFilterString.StringMatch.Match\n                        : options.matchLayer\n            },\n            geometryTypes:\n                options.geomTypes !== undefined\n                    ? Array.isArray(options.geomTypes)\n                        ? options.geomTypes\n                        : [options.geomTypes]\n                    : undefined,\n            classes: options.featureClasses,\n            minLevel: options.minLevel,\n            maxLevel: options.maxLevel,\n            featureAttribute: options.featureAttribute\n        };\n\n        items.push(item);\n    }\n}\n\nexport namespace OmvFeatureFilterDescriptionBuilder {\n    /**\n     * Options for `OmvFeatureFilterDescriptionBuilder`.\n     */\n    export interface OmvFeatureFilterDescriptionBuilderOptions {\n        /**\n         * If `true`, all unspecified layers will be processed. If `false`, all unspecified layers\n         * will be ignored.\n         */\n        processLayersDefault?: boolean;\n        /**\n         * If `true`, all unspecified point features will be processed. If `false`, all unspecified\n         * point features will be ignored.\n         */\n        processPointsDefault?: boolean;\n        /**\n         * If `true`, all unspecified line features will be processed. If `false`, all unspecified\n         * line\n         * features will be ignored.\n         */\n        processLinesDefault?: boolean;\n        /**\n         * If `true`, all unspecified polygon features will be processed. If `false`, all\n         * unspecified polygon features will be ignored.\n         */\n        processPolygonsDefault?: boolean;\n    }\n\n    /**\n     * Description of a single feature.\n     */\n    export interface FeatureOption {\n        /**\n         * Layer name to be matched.\n         */\n        layer: string;\n        /**\n         * Optional geometry type to be limited to. If specified, but does not match, the feature is\n         * ignored.\n         */\n        geomType: OmvGeometryType | OmvGeometryType[] | undefined;\n        /**\n         * Optional class to match. If specified, but does not match, the feature is ignored.\n         */\n        featureClass: string;\n        /**\n         * Match condition for the layer name.\n         */\n        matchLayer?: OmvFilterString.StringMatch;\n        /**\n         * Match condition for `featureClass`.\n         */\n        matchClass?: OmvFilterString.StringMatch;\n        /**\n         * Minimum tile level to match.\n         */\n        minLevel?: number;\n        /**\n         * Maximum tile level to match.\n         */\n        maxLevel?: number;\n        /**\n         * Feature attribute to match.\n         */\n        featureAttribute?: OmvFilterFeatureAttribute;\n    }\n\n    /**\n     * Description for multiple features.\n     */\n    export interface MultiFeatureOption {\n        /**\n         * Layer name to be matched.\n         */\n        layer: string;\n        /**\n         * Optional geometry type to be limited to. If specified, but does not match, the feature is\n         * ignored.\n         */\n        geomTypes?: OmvGeometryType | OmvGeometryType[] | undefined;\n        /**\n         * Optional classes to match. If specified, but does not match, the feature is ignored.\n         */\n        featureClasses?: OmvFilterString[];\n        /**\n         * Match condition for the layer name.\n         */\n        matchLayer?: OmvFilterString.StringMatch;\n        /**\n         * Minimum tile level to match.\n         */\n        minLevel?: number;\n        /**\n         * Maximum tile level to match.\n         */\n        maxLevel?: number;\n        /**\n         * Feature attribute to match.\n         */\n        featureAttribute?: OmvFilterFeatureAttribute;\n    }\n}\n\n/**\n * `OmvFeatureFilter` implementation that uses a `OmvFeatureFilterDescription` to filter `TileData`\n * features before they are completely decoded.\n *\n * @hidden\n */\nexport class OmvGenericFeatureFilter implements OmvFeatureFilter {\n    private static matchLayer(\n        layer: string,\n        layerItems: OmvLayerFilterDescription[],\n        level: number\n    ): boolean {\n        for (const layerItem of layerItems) {\n            if (level < layerItem.minLevel || level > layerItem.maxLevel) {\n                continue;\n            }\n\n            if (OmvFilterString.matchString(layer, layerItem.name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private disabledKinds: GeometryKindSet | undefined;\n    private enabledKinds: GeometryKindSet | undefined;\n\n    constructor(private description: OmvFeatureFilterDescription) {\n        if (this.description.kindsToProcess.length > 0) {\n            this.enabledKinds = new GeometryKindSet(\n                this.description.kindsToProcess as GeometryKind[]\n            );\n        }\n        if (this.description.kindsToIgnore.length > 0) {\n            this.disabledKinds = new GeometryKindSet(\n                this.description.kindsToIgnore as GeometryKind[]\n            );\n        }\n    }\n\n    wantsLayer(layer: string, level: number): boolean {\n        if (OmvGenericFeatureFilter.matchLayer(layer, this.description.layersToProcess, level)) {\n            return true;\n        }\n\n        if (OmvGenericFeatureFilter.matchLayer(layer, this.description.layersToIgnore, level)) {\n            return false;\n        }\n\n        return this.description.processLayersDefault;\n    }\n\n    wantsPointFeature(layer: string, geometryType: OmvGeometryType, level: number): boolean {\n        return this.wantsFeature(\n            this.description.pointsToProcess,\n            this.description.pointsToIgnore,\n            layer,\n            geometryType,\n            level,\n            this.description.processPointsDefault\n        );\n    }\n\n    wantsLineFeature(layer: string, geometryType: OmvGeometryType, level: number): boolean {\n        return this.wantsFeature(\n            this.description.linesToProcess,\n            this.description.linesToIgnore,\n            layer,\n            geometryType,\n            level,\n            this.description.processLinesDefault\n        );\n    }\n\n    wantsPolygonFeature(layer: string, geometryType: OmvGeometryType, level: number): boolean {\n        return this.wantsFeature(\n            this.description.polygonsToProcess,\n            this.description.polygonsToIgnore,\n            layer,\n            geometryType,\n            level,\n            this.description.processPolygonsDefault\n        );\n    }\n\n    wantsKind(kind: string | string[]): boolean {\n        // undefined -> no way to filter\n        if (kind === undefined) {\n            return true;\n        }\n\n        return (\n            !(\n                this.disabledKinds !== undefined &&\n                this.disabledKinds.hasOrIntersects(kind as GeometryKind)\n            ) ||\n            (this.enabledKinds !== undefined &&\n                this.enabledKinds.hasOrIntersects(kind as GeometryKind))\n        );\n    }\n\n    get hasKindFilter(): boolean {\n        return this.enabledKinds !== undefined || this.disabledKinds !== undefined;\n    }\n\n    private wantsFeature(\n        itemsToProcess: OmvFilterDescription[],\n        itemsToIgnore: OmvFilterDescription[],\n        layer: string,\n        geometryType: OmvGeometryType,\n        level: number,\n        defaultResult: boolean\n    ): boolean {\n        for (const item of itemsToProcess) {\n            if (level < item.minLevel || level > item.maxLevel) {\n                continue;\n            }\n\n            if (!OmvFilterString.matchString(layer, item.layerName)) {\n                // this rule is not for this layer\n                continue;\n            }\n\n            if (item.geometryTypes !== undefined && item.geometryTypes.indexOf(geometryType) >= 0) {\n                return true;\n            }\n        }\n\n        for (const item of itemsToIgnore) {\n            if (!OmvFilterString.matchString(layer, item.layerName)) {\n                // this rule is not for this layer\n                continue;\n            }\n\n            if (item.geometryTypes !== undefined && item.geometryTypes.indexOf(geometryType) >= 0) {\n                return false;\n            }\n        }\n\n        return defaultResult;\n    }\n}\n\n/**\n * An [[OmvFeatureFilter]] implementation that delegates all filter decision\n * returning `true` for any predicate if all delegates return `true`.\n */\nexport class ComposedDataFilter implements OmvFeatureFilter {\n    constructor(readonly filters: OmvFeatureFilter[]) {}\n\n    get hasKindFilter() {\n        return this.filters.reduce<boolean>(\n            (result, filter) => result && filter.hasKindFilter,\n            true\n        );\n    }\n\n    wantsLayer(layer: string, level: number): boolean {\n        return this.filters.reduce<boolean>(\n            (result, filter) => result && filter.wantsLayer(layer, level),\n            true\n        );\n    }\n    wantsPointFeature(layer: string, geometryType: OmvGeometryType, level: number): boolean {\n        return this.filters.reduce<boolean>(\n            (result, filter) => result && filter.wantsPointFeature(layer, geometryType, level),\n            true\n        );\n    }\n    wantsLineFeature(layer: string, geometryType: OmvGeometryType, level: number): boolean {\n        return this.filters.reduce<boolean>(\n            (result, filter) => result && filter.wantsLineFeature(layer, geometryType, level),\n            true\n        );\n    }\n    wantsPolygonFeature(layer: string, geometryType: OmvGeometryType, level: number): boolean {\n        return this.filters.reduce<boolean>(\n            (result, filter) => result && filter.wantsPolygonFeature(layer, geometryType, level),\n            true\n        );\n    }\n    wantsKind(kind: string | string[]): boolean {\n        return this.filters.reduce<boolean>(\n            (result, filter) => result && filter.wantsKind(kind),\n            true\n        );\n    }\n}\n/**\n * `OmvFeatureModifier` implementation that uses a `OmvFeatureFilterDescription` to filter\n * `TileData` features before they are completely decoded.\n *\n * @hidden\n */\nexport class OmvGenericFeatureModifier implements OmvFeatureModifier {\n    static matchItems(\n        layerName: string,\n        featureClass: string,\n        items: OmvFilterDescription[]\n    ): boolean {\n        for (const item of items) {\n            if (item.classes !== undefined) {\n                if (!OmvFilterString.matchString(layerName, item.layerName)) {\n                    continue;\n                }\n                for (const matchClass of item.classes) {\n                    if (OmvFilterString.matchString(featureClass, matchClass)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    static matchAttribute(layerName: string, env: MapEnv, items: OmvFilterDescription[]): boolean {\n        for (const item of items) {\n            if (item.featureAttribute !== undefined) {\n                if (\n                    OmvFilterString.matchString(layerName, item.layerName) &&\n                    env.lookup(item.featureAttribute.key) === item.featureAttribute.value\n                ) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    constructor(private description: OmvFeatureFilterDescription) {}\n\n    doProcessPointFeature(layer: string, env: MapEnv): boolean {\n        return this.doProcessFeature(\n            this.description.pointsToProcess,\n            this.description.pointsToIgnore,\n            layer,\n            env,\n            this.description.processPointsDefault\n        );\n    }\n\n    doProcessLineFeature(layer: string, env: MapEnv): boolean {\n        return this.doProcessFeature(\n            this.description.linesToProcess,\n            this.description.linesToIgnore,\n            layer,\n            env,\n            this.description.processLinesDefault\n        );\n    }\n\n    doProcessPolygonFeature(layer: string, env: MapEnv): boolean {\n        return this.doProcessFeature(\n            this.description.polygonsToProcess,\n            this.description.polygonsToIgnore,\n            layer,\n            env,\n            this.description.processPolygonsDefault\n        );\n    }\n\n    protected doProcessFeature(\n        itemsToProcess: OmvFilterDescription[],\n        itemsToIgnore: OmvFilterDescription[],\n        layer: string,\n        env: MapEnv,\n        defaultResult: boolean\n    ): boolean {\n        if (layer === undefined || (itemsToProcess.length === 0 && itemsToIgnore.length === 0)) {\n            return defaultResult;\n        }\n\n        let featureClass: string | undefined;\n        const featureClassThing = env.lookup(\"class\");\n\n        if (featureClassThing !== undefined && featureClassThing !== null) {\n            featureClass = featureClassThing.toString();\n        }\n\n        if (\n            featureClass &&\n            OmvGenericFeatureModifier.matchItems(layer, featureClass, itemsToProcess)\n        ) {\n            return true;\n        }\n\n        if (\n            featureClass &&\n            OmvGenericFeatureModifier.matchItems(layer, featureClass, itemsToIgnore)\n        ) {\n            return false;\n        }\n\n        if (OmvGenericFeatureModifier.matchAttribute(layer, env, itemsToProcess)) {\n            return true;\n        }\n\n        if (OmvGenericFeatureModifier.matchAttribute(layer, env, itemsToIgnore)) {\n            return false;\n        }\n\n        return defaultResult;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    AttributeMap,\n    Definitions,\n    GeometryType,\n    ITileDecoder,\n    OptionsMap,\n    StyleSet,\n    WorkerServiceProtocol\n} from \"@here/harp-datasource-protocol\";\nimport { EarthConstants, TileKey, webMercatorTilingScheme } from \"@here/harp-geoutils\";\nimport { LineGroup } from \"@here/harp-lines\";\nimport { CopyrightInfo, CopyrightProvider, DataSourceOptions } from \"@here/harp-mapview\";\nimport {\n    DataProvider,\n    TileDataSource,\n    TileDataSourceOptions,\n    TileFactory\n} from \"@here/harp-mapview-decoder\";\nimport { getOptionValue, LoggerManager } from \"@here/harp-utils\";\nimport {\n    FeatureModifierId,\n    OmvDecoderOptions,\n    OmvFeatureFilterDescription,\n    OMV_TILE_DECODER_SERVICE_TYPE\n} from \"./OmvDecoderDefs\";\nimport {\n    APIFormat,\n    AuthenticationMethod,\n    OmvRestClient,\n    OmvRestClientParameters\n} from \"./OmvRestClient\";\nimport { OmvTile } from \"./OmvTile\";\n\nconst logger = LoggerManager.instance.create(\"OmvDataSource\");\n\nexport interface LinesGeometry {\n    type: GeometryType;\n    lines: LineGroup;\n    technique: number;\n\n    /**\n     * Optional array of objects. It can be used to pass user data from the geometry to the mesh.\n     */\n    objInfos?: AttributeMap[];\n\n    /**\n     * Optional list of feature start indices. The indices point into the index attribute.\n     */\n    featureStarts?: number[];\n}\n\nexport interface OmvTileFactory {\n    /** Create an instance of [[OmvTile]] or a subclass. */\n    createTile(dataSource: OmvDataSource, tileKey: TileKey): OmvTile;\n}\n\nexport interface OmvDataSourceParameters extends DataSourceOptions {\n    /**\n     * If set to `true`, features that have no technique in the theme will be printed to the console\n     * (can be excessive!).\n     */\n    showMissingTechniques?: boolean;\n\n    /**\n     * @deprecated Tile info is not decoded anymore. The same information can be generated\n     * implementing a [[IGeometryProcessor]] and using [[OmvProtobufDataAdapter]] to decode OMV\n     * data.\n     */\n    createTileInfo?: boolean;\n\n    /**\n     * Specify the decoder that should be used. If not supplied, the default will be used.\n     */\n    decoder?: ITileDecoder;\n\n    /**\n     * Optionally specify the DataProvider that should be used.\n     */\n    dataProvider?: DataProvider;\n\n    /**\n     * Specify the URL to the decoder bundle. If not supplied, the default will be used.\n     */\n    concurrentDecoderScriptUrl?: string;\n\n    /**\n     * Gather feature IDs from `OmvData`. Defaults to `false`.\n     * @deprecated FeatureIds are always gathered, use [[gatherFeatureAttributes]] to gather\n     * all feature attributes.\n     */\n    gatherFeatureIds?: boolean;\n\n    /**\n     * Gather feature attributes from `OmvData`. Defaults to `false`.\n     */\n    gatherFeatureAttributes?: boolean;\n\n    /**\n     * @deprecated Tile info is not decoded anymore. The same information can be generated\n     * implementing a [[IGeometryProcessor]] and using [[OmvProtobufDataAdapter]] to decode OMV\n     * data.\n     */\n    gatherRoadSegments?: boolean;\n\n    /**\n     * If not set to `false`, very short text labels will be skipped during decoding based on a\n     * heuristic.\n     */\n    skipShortLabels?: boolean;\n\n    /**\n     * A description for the feature filter that can be safely passed down to the web workers. It\n     * has to be generated with the help of the [[OmvFeatureFilterDescriptionBuilder]] (to guarantee\n     * correctness). This parameter gets applied to the decoder used in the [[OmvDataSource]]\n     * which might be shared between various [[OmvDataSource]]s.\n     */\n    filterDescr?: OmvFeatureFilterDescription;\n\n    /**\n     * Optional, custom factory for [[Tile]] instances created by this [[OmvDataSource]].\n     */\n    tileFactory?: TileFactory<OmvTile>;\n\n    /**\n     * Identifier used to choose [[OmvFeatureModifier]]s to be applied.\n     *\n     * If left `undefined` at least [[OmvGenericFeatureModifier]] will be applied.\n     * The list of feature modifiers may be extended internally by some data source options\n     * such as [[politicalView]] which adds [[OmvPoliticalViewFeatureModifier]].\n     *\n     * @note This parameter gets applied to the decoder used in the [[OmvDataSource]] which might\n     * be shared between various [[OmvDataSource]]s.\n     */\n    featureModifierId?: FeatureModifierId;\n\n    /**\n     * Expresses specific country point of view that is used when rendering disputed features,\n     * like borders, names, etc. If undefined \"defacto\" or most widely accepted political view\n     * will be presented.\n     *\n     * @see featureModifiers\n     */\n    politicalView?: string;\n\n    /**\n     * Optional, default copyright information of tiles provided by this data source.\n     * Implementation should provide this information from the source data if possible.\n     */\n    copyrightInfo?: CopyrightInfo[];\n\n    /**\n     * Optional copyright info provider for tiles provided by this data source.\n     */\n    copyrightProvider?: CopyrightProvider;\n\n    /**\n     * Maximum geometry height above groud level this `OmvDataSource` can produce.\n     *\n     * Used in first stage of frustum culling before [[Tile.maxGeometryHeight]] data is available.\n     *\n     * @default [[EarthConstants.MAX_BUILDING_HEIGHT]].\n     */\n    maxGeometryHeight?: number;\n\n    /**\n     * Indicates whether overlay on elevation is enabled. Defaults to `false`.\n     */\n    enableElevationOverlay?: boolean;\n\n    /**\n     * Indicates whether to add a ground plane to cover the tile completely. This is necessary for\n     * the fallback logic, such that the parent fall back tiles don't overlap the children tiles.\n     * Default is true (i.e. if not defined it is taken to be true)\n     */\n    addGroundPlane?: boolean;\n}\n\n/**\n * A helper function to retrieve the [[DataProvider]] from the [[OmvDataSource]]s parameters.\n *\n * @param params - The parameters passed into the OmvDataSource.\n */\nfunction getDataProvider(params: OmvWithRestClientParams | OmvWithCustomDataProvider) {\n    if ((params as OmvWithCustomDataProvider).dataProvider) {\n        return (params as OmvWithCustomDataProvider).dataProvider;\n    } else if (\n        (params as OmvWithRestClientParams).baseUrl ||\n        (params as OmvWithRestClientParams).url\n    ) {\n        return new OmvRestClient(params as OmvRestClientParameters);\n    } else {\n        throw new Error(\"OmvDataSource: missing url, baseUrl or dataProvider params\");\n    }\n}\n\nexport type OmvWithRestClientParams = OmvRestClientParameters & OmvDataSourceParameters;\nexport type OmvWithCustomDataProvider = OmvDataSourceParameters & { dataProvider: DataProvider };\n\nlet missingOmvDecoderServiceInfoEmitted: boolean = false;\n\n/**\n * The default vector tile service.\n */\nconst hereVectorTileBaseUrl = \"https://vector.hereapi.com/v2/vectortiles/base/mc\";\n\n/**\n * Default options for the HERE Vector Tile service.\n */\nconst hereVectoTileDefaultOptions: OmvWithRestClientParams = {\n    baseUrl: hereVectorTileBaseUrl,\n    apiFormat: APIFormat.XYZOMV,\n    styleSetName: \"tilezen\",\n    authenticationMethod: {\n        method: AuthenticationMethod.QueryString,\n        name: \"apikey\"\n    },\n    copyrightInfo: [\n        {\n            id: \"here.com\",\n            year: new Date().getFullYear(),\n            label: \"HERE\",\n            link: \"https://legal.here.com/terms\"\n        }\n    ]\n};\n\nconst defaultOptions = new Map<string, OmvWithRestClientParams>([\n    [hereVectorTileBaseUrl, hereVectoTileDefaultOptions]\n]);\n\n/**\n * Tests if the given object has custom data provider.\n * @param object -\n */\nfunction hasCustomDataProvider(\n    object: Partial<OmvWithCustomDataProvider>\n): object is OmvWithCustomDataProvider {\n    return object.dataProvider !== undefined;\n}\n\n/**\n * Add service specific default values.\n *\n * @param params - The configuration settings of the data source.\n */\nfunction completeDataSourceParameters(\n    params: OmvWithRestClientParams | OmvWithCustomDataProvider\n): TileDataSourceOptions {\n    if (!hasCustomDataProvider(params) && params.url === undefined) {\n        const baseUrl = params.baseUrl ?? hereVectorTileBaseUrl;\n\n        const completedParams = {\n            ...defaultOptions.get(baseUrl),\n            ...params\n        };\n\n        return {\n            ...completedParams,\n            tilingScheme: webMercatorTilingScheme,\n            dataProvider: new OmvRestClient(completedParams)\n        };\n    }\n\n    return {\n        ...params,\n        tilingScheme: webMercatorTilingScheme,\n        dataProvider: getDataProvider(params)\n    };\n}\n\nexport class OmvDataSource extends TileDataSource<OmvTile> {\n    private readonly m_decoderOptions: OmvDecoderOptions;\n\n    constructor(private m_params: OmvWithRestClientParams | OmvWithCustomDataProvider) {\n        super(m_params.tileFactory || new TileFactory(OmvTile), {\n            styleSetName: m_params.styleSetName ?? \"omv\",\n            concurrentDecoderServiceName: OMV_TILE_DECODER_SERVICE_TYPE,\n            minDataLevel: m_params.minDataLevel ?? 1,\n            maxDataLevel: m_params.maxDataLevel ?? 17,\n            storageLevelOffset: m_params.storageLevelOffset ?? -1,\n            ...completeDataSourceParameters(m_params)\n        });\n\n        this.cacheable = true;\n        this.addGroundPlane =\n            m_params.addGroundPlane === undefined || m_params.addGroundPlane === true;\n\n        this.m_decoderOptions = {\n            showMissingTechniques: this.m_params.showMissingTechniques === true,\n            filterDescription: this.m_params.filterDescr,\n            gatherFeatureAttributes: this.m_params.gatherFeatureAttributes === true,\n            featureModifiers: this.m_params.featureModifierId\n                ? [this.m_params.featureModifierId]\n                : undefined,\n            politicalView: this.m_params.politicalView,\n            skipShortLabels: this.m_params.skipShortLabels,\n            storageLevelOffset: m_params.storageLevelOffset ?? -1,\n            enableElevationOverlay: this.m_params.enableElevationOverlay === true\n        };\n\n        this.maxGeometryHeight = getOptionValue(\n            m_params.maxGeometryHeight,\n            EarthConstants.MAX_BUILDING_HEIGHT\n        );\n    }\n\n    /** @override */\n    async connect() {\n        try {\n            await super.connect();\n        } catch (error) {\n            if (\n                WorkerServiceProtocol.isUnknownServiceError(error) &&\n                !missingOmvDecoderServiceInfoEmitted\n            ) {\n                logger.info(\n                    \"Unable to create decoder service in worker. Use \" +\n                        \" 'OmvTileDecoderService.start();' in decoder script.\"\n                );\n                missingOmvDecoderServiceInfoEmitted = true;\n            }\n            throw error;\n        }\n        this.configureDecoder(undefined, undefined, undefined, this.m_decoderOptions);\n    }\n\n    /**\n     * Remove the current data filter.\n     * Will be applied to the decoder, which might be shared with other omv datasources.\n     */\n    removeDataFilter(): void {\n        this.configureDecoder(undefined, undefined, undefined, {\n            filterDescription: null\n        });\n    }\n\n    /**\n     * Set a new data filter. Can also be done during the creation of an [[OmvDataSource]].\n     * Will be applied to the decoder, which might be shared with other omv datasources.\n     *\n     * @param filterDescription - Data filter description created with\n     * [[OmvFeatureFilterDescriptionBuilder]].\n     */\n    setDataFilter(filterDescription: OmvFeatureFilterDescription): void {\n        this.m_decoderOptions.filterDescription =\n            filterDescription !== null ? filterDescription : undefined;\n\n        this.configureDecoder(undefined, undefined, undefined, {\n            filterDescription,\n            featureModifiers: this.m_decoderOptions.featureModifiers,\n            politicalView: this.m_decoderOptions.politicalView\n        });\n    }\n\n    /** @override */\n    shouldPreloadTiles(): boolean {\n        return true;\n    }\n\n    /** @override */\n    setLanguages(languages?: string[]): void {\n        if (languages !== undefined) {\n            this.configureDecoder(undefined, undefined, languages, undefined);\n        }\n    }\n\n    /** @override */\n    setPoliticalView(politicalView?: string): void {\n        // Just in case users mess with letters' casing.\n        politicalView = politicalView?.toLowerCase();\n        if (this.m_decoderOptions.politicalView !== politicalView) {\n            this.m_decoderOptions.politicalView = politicalView;\n            this.configureDecoder(undefined, undefined, undefined, {\n                filterDescription: this.m_decoderOptions.filterDescription,\n                featureModifiers: this.m_decoderOptions.featureModifiers,\n                politicalView: politicalView !== undefined ? politicalView : \"\"\n            });\n        }\n    }\n\n    /** @override */\n    get storageLevelOffset() {\n        return super.storageLevelOffset;\n    }\n\n    /** @override */\n    set storageLevelOffset(levelOffset: number) {\n        super.storageLevelOffset = levelOffset;\n        this.m_decoderOptions.storageLevelOffset = this.storageLevelOffset;\n        this.configureDecoder(undefined, undefined, undefined, {\n            storageLevelOffset: this.storageLevelOffset\n        });\n    }\n\n    /** @override */\n    setEnableElevationOverlay(enable: boolean) {\n        if (this.m_decoderOptions.enableElevationOverlay !== enable) {\n            this.m_decoderOptions.enableElevationOverlay = enable;\n            this.configureDecoder(undefined, undefined, undefined, {\n                enableElevationOverlay: enable\n            });\n        }\n    }\n\n    private configureDecoder(\n        styleSet?: StyleSet,\n        definitions?: Definitions,\n        languages?: string[],\n        options?: OptionsMap\n    ) {\n        this.clearCache();\n        this.decoder.configure(styleSet, definitions, languages, options);\n        this.mapView.markTilesDirty(this);\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Decoder worker for {@ref MapView}.\n *\n * @remarks\n *\n * @packageDocumentation\n */\n\nexport * from \"./lib/DataProvider\";\nexport * from \"./lib/TileDataSource\";\nexport * from \"./lib/TileLoader\";\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport \"@here/harp-fetch\";\nimport { TileKey } from \"@here/harp-geoutils\";\n\n/**\n * Interface for all `DataProvider` subclasses. The `DataProvider` is an abstraction of the tile\n * loader which is only responsible for loading the binary data of a specific tile, without any\n * relation to displaying or even decoding the data.\n */\nexport interface DataProvider {\n    /**\n     * Connect to the data source. Returns a promise to wait for successful (or failed) connection.\n     *\n     * @returns A promise which is resolved when the connection has been established.\n     */\n    connect(): Promise<void>;\n\n    /**\n     * Returns `true` if it has been connected successfully.\n     */\n    ready(): boolean;\n\n    /**\n     * Load the data of a [[Tile]] asynchronously in form of an [[ArrayBufferLike]].\n     *\n     * @param tileKey - Address of a tile.\n     * @param abortSignal - Optional AbortSignal to cancel the request.\n     * @returns A promise delivering the data as an [[ArrayBufferLike]], or any object.\n     */\n    getTile(tileKey: TileKey, abortSignal?: AbortSignal): Promise<ArrayBufferLike | {}>;\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    Definitions,\n    ITileDecoder,\n    StyleSet,\n    Theme,\n    TileInfo\n} from \"@here/harp-datasource-protocol\";\nimport { TileKey, TilingScheme } from \"@here/harp-geoutils\";\nimport {\n    ConcurrentDecoderFacade,\n    CopyrightInfo,\n    CopyrightProvider,\n    DataSource,\n    DataSourceOptions,\n    Tile,\n    TileLoaderState\n} from \"@here/harp-mapview\";\nimport { ILogger, LoggerManager } from \"@here/harp-utils\";\nimport { DataProvider } from \"./DataProvider\";\nimport { TileInfoLoader, TileLoader } from \"./TileLoader\";\n\n/**\n * Set of common options for all [[TileDataSource]]s.\n */\nexport interface TileDataSourceOptions extends DataSourceOptions {\n    /**\n     * The [[TilingScheme]] the data source is using.\n     */\n    tilingScheme: TilingScheme;\n\n    /**\n     * The [[DataProvider]] to use for downloading the actual data.\n     */\n    dataProvider: DataProvider;\n\n    /**\n     * Optional: Specify [[ITileDecoder]] instance.\n     */\n    decoder?: ITileDecoder;\n\n    /**\n     * Optional name of decoder service class.\n     * @see [[ConcurrentDecoderFacade]]\n     * @see [[ConcurrentWorkerSet]]\n     */\n    concurrentDecoderServiceName?: string;\n\n    /**\n     * Optional URL for decoder bundle to be loaded into web worker.\n     */\n    concurrentDecoderScriptUrl?: string;\n\n    /**\n     * Optional count of web workers to use with the decoder bundle.\n     */\n    concurrentDecoderWorkerCount?: number;\n\n    /**\n     * Optional, default copyright information of tiles provided by this data source.\n     * Implementation should provide this information from the source data if possible.\n     */\n    copyrightInfo?: CopyrightInfo[];\n\n    /**\n     * Optional copyright info provider for tiles provided by this data source. Copyrights from\n     * provider are concatenated with default ones from `copyrightInfo`.\n     */\n    copyrightProvider?: CopyrightProvider;\n}\n\n/**\n * Templated factory class to create instances of [[Tile]].\n */\nexport class TileFactory<TileType extends Tile> {\n    /**\n     * Initialize the factory using the constructor of the element to be called when a [[Tile]] is\n     * created.\n     *\n     * @param m_modelConstructor - Constructor of (subclass of) [[Tile]].\n     */\n    constructor(\n        private m_modelConstructor: new (dataSource: DataSource, tileKey: TileKey) => TileType\n    ) {}\n\n    /**\n     * Create an instance of (subclass of) [[Tile]]. The required parameters are passed as arguments\n     * to the constructor of [[Tile]].\n     *\n     * @param dataSource - [[Datasource]] this class belongs to.\n     * @param tileKey - Quadtree address of the [[Tile]].\n     */\n    create(dataSource: DataSource, tileKey: TileKey): TileType {\n        return new this.m_modelConstructor(dataSource, tileKey);\n    }\n}\n\n/**\n * Common base class for the typical [[DataSource]] which uses an [[ITileDecoder]] to decode the\n * tile content asynchronously. The decoder can be passed in as an option, or a default\n * asynchronous one is generated.\n */\nexport class TileDataSource<TileType extends Tile> extends DataSource {\n    protected readonly logger: ILogger = LoggerManager.instance.create(\"TileDataSource\");\n    protected readonly m_decoder: ITileDecoder;\n    private m_isReady: boolean = false;\n\n    /**\n     * Set up the `TileDataSource`.\n     *\n     * @param m_tileFactory - Factory to create the [[Tile]] instances.\n     * @param m_options - Options specifying the parameters of the [[DataSource]].\n     */\n    constructor(\n        private readonly m_tileFactory: TileFactory<TileType>,\n        private readonly m_options: TileDataSourceOptions\n    ) {\n        super({\n            name: m_options.name,\n            styleSetName: m_options.styleSetName,\n            // tslint:disable-next-line: deprecation\n            minZoomLevel: m_options.minZoomLevel,\n            // tslint:disable-next-line: deprecation\n            maxZoomLevel: m_options.maxZoomLevel,\n            minDataLevel: m_options.minDataLevel,\n            maxDataLevel: m_options.maxDataLevel,\n            minDisplayLevel: m_options.minDisplayLevel,\n            maxDisplayLevel: m_options.maxDisplayLevel,\n            storageLevelOffset: m_options.storageLevelOffset,\n            allowOverlappingTiles: m_options.allowOverlappingTiles\n        });\n        if (m_options.decoder) {\n            this.m_decoder = m_options.decoder;\n        } else if (m_options.concurrentDecoderServiceName) {\n            this.m_decoder = ConcurrentDecoderFacade.getTileDecoder(\n                m_options.concurrentDecoderServiceName,\n                m_options.concurrentDecoderScriptUrl,\n                m_options.concurrentDecoderWorkerCount\n            );\n        } else {\n            throw new Error(\n                `TileDataSource[${this.name}]: unable to create, missing decoder or ` +\n                    `concurrentDecoderServiceName`\n            );\n        }\n        this.useGeometryLoader = true;\n        this.cacheable = true;\n    }\n\n    /** @override */\n    dispose() {\n        this.decoder.dispose();\n    }\n\n    /** @override */\n    ready(): boolean {\n        return this.m_isReady && this.m_options.dataProvider.ready();\n    }\n\n    /**\n     * Get the [[ITileDecoder]] of this `ITileDataSource`, which has either been passed in with\n     * the options, or has been supplied by the [[ConcurrentDecoderFacade]].\n     */\n    get decoder(): ITileDecoder {\n        return this.m_decoder;\n    }\n\n    /** @override */\n    async connect() {\n        await Promise.all([this.m_options.dataProvider.connect(), this.m_decoder.connect()]);\n        this.m_isReady = true;\n\n        this.m_decoder.configure(undefined, undefined, undefined, {\n            storageLevelOffset: this.m_options.storageLevelOffset\n        });\n    }\n\n    /** @override */\n    setStyleSet(styleSet?: StyleSet, definitions?: Definitions, languages?: string[]): void {\n        this.m_decoder.configure(styleSet, definitions, languages);\n        this.mapView.markTilesDirty(this);\n    }\n\n    /**\n     * Apply the [[Theme]] to this data source.\n     *\n     * Applies new [[StyleSet]] and definitions from theme only if matching styleset (see\n     * `styleSetName` property) is found in `theme`.\n     * @override\n     */\n    setTheme(theme: Theme, languages?: string[]): void {\n        const styleSet =\n            this.styleSetName !== undefined && theme.styles\n                ? theme.styles[this.styleSetName]\n                : undefined;\n\n        if (styleSet !== undefined) {\n            this.setStyleSet(styleSet, theme.definitions, languages);\n        }\n    }\n\n    /**\n     * Get the [[DataProvider]] that has been passed in with the options.\n     */\n    dataProvider(): DataProvider {\n        return this.m_options.dataProvider;\n    }\n\n    /** @override */\n    getTilingScheme(): TilingScheme {\n        return this.m_options.tilingScheme;\n    }\n\n    /**\n     * Create a [[Tile]] and start the asynchronous download of the tile content. The [[Tile]] will\n     * be empty, but the download and decoding will be scheduled immediately. [[Tile]] instance is\n     * initialized with default copyrights, concatenated with copyrights from copyright provider of\n     * this data source.\n     *\n     * @param tileKey - Quadtree address of the requested tile.\n     * @override\n     */\n    getTile(tileKey: TileKey): TileType | undefined {\n        const tile = this.m_tileFactory.create(this, tileKey);\n        tile.tileLoader = new TileLoader(\n            this,\n            tileKey,\n            this.m_options.dataProvider,\n            this.decoder,\n            0\n        );\n        tile.copyrightInfo = this.m_options.copyrightInfo;\n        if (this.m_options.copyrightProvider !== undefined) {\n            this.m_options.copyrightProvider\n                .getCopyrights(tile.geoBox, tileKey.level)\n                .then(copyrightInfo => {\n                    tile.copyrightInfo =\n                        tile.copyrightInfo === undefined\n                            ? copyrightInfo\n                            : [...tile.copyrightInfo, ...copyrightInfo];\n                    this.requestUpdate();\n                });\n        }\n        tile.load();\n\n        return tile;\n    }\n\n    /**\n     * Get [[TileInfo]] of a tile.\n     *\n     * @param tileKey - Quadtree address of the requested tile.\n     * @returns A promise which will contain the [[TileInfo]] when resolved.\n     */\n    getTileInfo(tileKey: TileKey): Promise<TileInfo | undefined> {\n        const promise = new Promise<TileInfo | undefined>((resolve, reject) => {\n            const tileLoader = new TileInfoLoader(\n                this,\n                tileKey,\n                this.m_options.dataProvider,\n                this.decoder,\n                0\n            );\n\n            tileLoader.loadAndDecode().then(loaderState => {\n                if (loaderState === TileLoaderState.Ready) {\n                    resolve(tileLoader.tileInfo);\n                } else {\n                    reject(\n                        new Error(`TileDataSource#getInfoTile wrong final state: ${loaderState}`)\n                    );\n                }\n            });\n        });\n\n        return promise;\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { getPropertyValue, isTextTechnique } from \"@here/harp-datasource-protocol\";\nimport { TileKey } from \"@here/harp-geoutils/lib/tiling/TileKey\";\nimport { DataSource, TextElement } from \"@here/harp-mapview\";\nimport { debugContext } from \"@here/harp-mapview/lib/DebugContext\";\nimport {\n    ContextualArabicConverter,\n    FontUnit,\n    TextLayoutStyle,\n    TextRenderStyle\n} from \"@here/harp-text-canvas\";\nimport * as THREE from \"three\";\n\nimport { TileGeometryCreator } from \"@here/harp-mapview/lib/geometry/TileGeometryCreator\";\nimport { OmvTile } from \"./OmvTile\";\n\nconst debugMaterial = new THREE.LineBasicMaterial({\n    color: 0x000000,\n    linewidth: 1,\n    depthTest: false,\n    depthFunc: THREE.NeverDepth\n});\n\nconst debugCircleMaterial = new THREE.MeshBasicMaterial({\n    color: 0xff0000,\n    depthTest: false,\n    depthFunc: THREE.NeverDepth\n});\n\nconst debugCircleMaterialWF = new THREE.MeshBasicMaterial({\n    color: 0xff0000,\n    depthTest: false,\n    depthFunc: THREE.NeverDepth\n});\ndebugCircleMaterialWF.wireframe = true;\n\nconst debugCircleMaterial2WF = new THREE.MeshBasicMaterial({\n    color: 0x8080ff,\n    depthTest: false,\n    depthFunc: THREE.NeverDepth\n});\ndebugCircleMaterial2WF.wireframe = true;\n\nconst debugBlackCircleMaterial = new THREE.MeshBasicMaterial({\n    color: 0x000000,\n    depthTest: false,\n    depthFunc: THREE.NeverDepth\n});\n\nconst debugBlueCircleMaterial = new THREE.MeshBasicMaterial({\n    color: 0x0000ff,\n    depthTest: false,\n    depthFunc: THREE.NeverDepth,\n    opacity: 0.75,\n    transparent: true\n});\n\nconst textRenderStyle = new TextRenderStyle();\nconst textLayoutStyle = new TextLayoutStyle();\n\ntextRenderStyle.fontSize = {\n    unit: FontUnit.Point,\n    size: 9,\n    backgroundSize: 0\n};\ntextRenderStyle.opacity = 0.75;\ntextRenderStyle.backgroundOpacity = 0.75;\ntextRenderStyle.color = new THREE.Color(0.8, 0.2, 0.2);\n\n// Set maximum priority.\nconst PRIORITY_ALWAYS = Number.MAX_SAFE_INTEGER;\n\nexport class OmvDebugLabelsTile extends OmvTile {\n    constructor(dataSource: DataSource, tileKey: TileKey) {\n        super(dataSource, tileKey);\n    }\n\n    /** @override */\n    loadingFinished() {\n        this.addLabelDebugInfo();\n    }\n\n    /**\n     * Create [[TextElement]] objects from the given decoded [[Tile]] and list of materials.\n     */\n    private addLabelDebugInfo() {\n        // activate in the browser with:\n        // window.__debugContext.setValue(\"DEBUG_TEXT_PATHS\", true)\n        const debugTextPaths = debugContext.getValue(\"DEBUG_TEXT_PATHS\");\n        const debugTextPathsFull = debugContext.getValue(\"DEBUG_TEXT_PATHS_FULL\");\n        const debugTextPoisFull = debugContext.getValue(\"DEBUG_TEXT_POIS_FULL\");\n\n        if (!(debugTextPaths || debugTextPathsFull) || this.decodedTile === undefined) {\n            return;\n        }\n\n        const tileGeometryCreator = TileGeometryCreator.instance;\n        const decodedTile = this.decodedTile!;\n\n        tileGeometryCreator.createTextElements(this, decodedTile);\n\n        const colorMap = new Map<number, THREE.Color>();\n\n        // allow limiting to specific names and/or index. There can be many paths with the same text\n        const textFilter = debugContext.getValue(\"DEBUG_TEXT_PATHS.FILTER.TEXT\");\n        const indexFilter = debugContext.getValue(\"DEBUG_TEXT_PATHS.FILTER.INDEX\");\n        const env = this.mapView.env;\n\n        if (decodedTile.textPathGeometries !== undefined) {\n            this.preparedTextPaths = tileGeometryCreator.prepareTextPaths(\n                decodedTile.textPathGeometries,\n                decodedTile\n            );\n        }\n\n        const centerX = this.center.x;\n        const centerY = this.center.y;\n        const centerZ = this.center.z;\n        const pointScale = this.mapView.pixelToWorld;\n        const worldOffsetX = this.computeWorldOffsetX();\n\n        let pointLabelIndex = 0;\n\n        if (this.textElementGroups.count() > 0) {\n            const bluePointGeometry = new THREE.BufferGeometry();\n            const bluePointIndices = new Array<number>();\n            const bluePointPositions = new Array<number>();\n\n            const addedTextElements: TextElement[] = [];\n\n            this.textElementGroups.forEach((textElement: TextElement) => {\n                if (textElement.path !== undefined) {\n                    return;\n                }\n\n                const x = textElement.position.x - centerX;\n                const y = textElement.position.y - centerY;\n                const z = 5 - centerZ;\n\n                // bluePointIndices.push(bluePointPositions.length / 3);\n                // bluePointPositions.push(x, y, z);\n\n                const pointSize = pointScale * 3;\n\n                bluePointPositions.push(x, y - pointSize, z);\n                bluePointPositions.push(x + pointSize, y, z);\n                bluePointPositions.push(x, y + pointSize, z);\n                bluePointPositions.push(x - pointSize, y, z);\n\n                const pointIndex = bluePointPositions.length / 3;\n\n                bluePointIndices.push(pointIndex - 4);\n                bluePointIndices.push(pointIndex - 3);\n                bluePointIndices.push(pointIndex - 2);\n                bluePointIndices.push(pointIndex - 4);\n                bluePointIndices.push(pointIndex - 2);\n                bluePointIndices.push(pointIndex - 1);\n\n                if (debugTextPoisFull) {\n                    const offsetXY = pointSize * 0.5;\n                    const label: string = `${textElement.text} [${pointLabelIndex}]`;\n\n                    const labelElement = new TextElement(\n                        ContextualArabicConverter.instance.convert(label),\n                        new THREE.Vector3(\n                            x + worldOffsetX + centerX + offsetXY,\n                            y + centerY + offsetXY,\n                            z + centerZ\n                        ),\n                        textRenderStyle,\n                        textLayoutStyle,\n                        PRIORITY_ALWAYS,\n                        0.0,\n                        0.0\n                    );\n                    labelElement.minZoomLevel = 0;\n                    labelElement.mayOverlap = true;\n                    labelElement.reserveSpace = false;\n                    labelElement.alwaysOnTop = true;\n                    labelElement.ignoreDistance = true;\n                    labelElement.priority = TextElement.HIGHEST_PRIORITY;\n\n                    (labelElement as any)._isDebug = true;\n\n                    addedTextElements.push(labelElement);\n                }\n\n                pointLabelIndex++;\n            });\n\n            for (const labelElement of addedTextElements) {\n                this.addTextElement(labelElement);\n            }\n\n            if (bluePointIndices.length > 0) {\n                bluePointGeometry.addGroup(0, bluePointIndices.length, 0);\n\n                bluePointGeometry.setAttribute(\n                    \"position\",\n                    new THREE.BufferAttribute(new Float32Array(bluePointPositions), 3)\n                );\n\n                bluePointGeometry.setIndex(\n                    new THREE.BufferAttribute(new Uint32Array(bluePointIndices), 1)\n                );\n                const bluePointMesh = new THREE.Mesh(bluePointGeometry, debugBlueCircleMaterial);\n                bluePointMesh.renderOrder = PRIORITY_ALWAYS;\n                this.objects.push(bluePointMesh);\n            }\n        }\n\n        if (this.preparedTextPaths !== undefined) {\n            const lineGeometry = new THREE.BufferGeometry();\n            const lineIndices = new Array<number>();\n            const linePositions = new Array<number>();\n\n            const redPointGeometry = new THREE.BufferGeometry();\n            const redPointIndices = new Array<number>();\n            const redPointPositions = new Array<number>();\n\n            const blackPointGeometry = new THREE.BufferGeometry();\n            const blackPointIndices = new Array<number>();\n            const blackPointPositions = new Array<number>();\n\n            let baseVertex = 0;\n\n            for (const textPath of this.preparedTextPaths) {\n                const technique = decodedTile.techniques[textPath.technique];\n                if (!isTextTechnique(technique) || (textPath as any)._isDebug !== undefined) {\n                    continue;\n                }\n                if (technique.color !== undefined) {\n                    colorMap.set(\n                        textPath.technique,\n                        new THREE.Color(getPropertyValue(technique.color, env))\n                    );\n                }\n\n                baseVertex = linePositions.length / 3;\n\n                const text = textPath.text;\n\n                const elementIndex = this.preparedTextPaths.indexOf(textPath);\n\n                const createDebugInfo =\n                    (!textFilter || (text && text.indexOf(textFilter) >= 0)) &&\n                    (indexFilter === undefined || indexFilter === elementIndex);\n\n                if (createDebugInfo) {\n                    const zHeight = 10;\n\n                    for (let i = 0; i < textPath.path.length; i += 3) {\n                        const pathIndex = i / 3;\n                        const x = textPath.path[i] - centerX;\n                        const y = textPath.path[i + 1] - centerY;\n                        // raise it a bit, so we get identify connectivity visually by tilting\n                        const z = zHeight + textPath.path[i + 2] + i / 3 - centerZ;\n\n                        if (debugTextPaths) {\n                            linePositions.push(x, y, z);\n                        }\n\n                        const isRedPoint = i === 0;\n\n                        if (debugTextPathsFull || isRedPoint) {\n                            const pointSize = pointScale * (isRedPoint ? 6 : 4);\n\n                            const positions = isRedPoint ? redPointPositions : blackPointPositions;\n                            const indices = isRedPoint ? redPointIndices : blackPointIndices;\n\n                            positions.push(x, y - pointSize, z);\n                            positions.push(x + pointSize, y, z);\n                            positions.push(x, y + pointSize, z);\n                            positions.push(x - pointSize, y, z);\n\n                            const pointIndex = positions.length / 3;\n\n                            indices.push(pointIndex - 4);\n                            indices.push(pointIndex - 3);\n                            indices.push(pointIndex - 2);\n                            indices.push(pointIndex - 4);\n                            indices.push(pointIndex - 2);\n                            indices.push(pointIndex - 1);\n\n                            if (debugTextPathsFull) {\n                                // give point index a label\n                                const label: string =\n                                    pathIndex % 5 === 0\n                                        ? text + \":\" + pathIndex\n                                        : Number(pathIndex).toString();\n                                const labelElement = new TextElement(\n                                    ContextualArabicConverter.instance.convert(label),\n                                    new THREE.Vector3(\n                                        x + worldOffsetX + centerX,\n                                        y + centerY,\n                                        z + centerZ\n                                    ),\n                                    textRenderStyle,\n                                    textLayoutStyle,\n                                    getPropertyValue(technique.priority || 0, env),\n                                    technique.xOffset || 0.0,\n                                    technique.yOffset || 0.0\n                                );\n                                labelElement.minZoomLevel = technique.minZoomLevel;\n                                labelElement.mayOverlap = true;\n                                labelElement.reserveSpace = false;\n                                labelElement.alwaysOnTop = true;\n                                labelElement.ignoreDistance = true;\n                                labelElement.priority = TextElement.HIGHEST_PRIORITY;\n                                this.addTextElement(labelElement);\n                            }\n                        }\n                    }\n\n                    // the lines of a path share a common geometry\n                    const N = textPath.path.length / 3;\n                    for (let i = 0; i < N; ++i) {\n                        if (i > 0) {\n                            lineIndices.push(baseVertex + i);\n                        }\n                        if (i + 1 < N) {\n                            lineIndices.push(baseVertex + i);\n                        }\n                    }\n                }\n            }\n\n            if (lineIndices.length > 0) {\n                lineGeometry.addGroup(0, lineIndices.length, 0);\n\n                lineGeometry.setAttribute(\n                    \"position\",\n                    new THREE.BufferAttribute(new Float32Array(linePositions), 3)\n                );\n\n                lineGeometry.setIndex(new THREE.BufferAttribute(new Uint32Array(lineIndices), 1));\n                const lineMesh = new THREE.LineSegments(lineGeometry, debugMaterial);\n                lineMesh.renderOrder = PRIORITY_ALWAYS - 2;\n                this.objects.push(lineMesh);\n            }\n\n            if (redPointIndices.length > 0) {\n                redPointGeometry.addGroup(0, redPointIndices.length, 0);\n\n                redPointGeometry.setAttribute(\n                    \"position\",\n                    new THREE.BufferAttribute(new Float32Array(redPointPositions), 3)\n                );\n\n                redPointGeometry.setIndex(\n                    new THREE.BufferAttribute(new Uint32Array(redPointIndices), 1)\n                );\n                const redPointMesh = new THREE.Mesh(redPointGeometry, debugCircleMaterial);\n                redPointMesh.renderOrder = PRIORITY_ALWAYS;\n                this.objects.push(redPointMesh);\n            }\n\n            if (blackPointIndices.length > 0) {\n                blackPointGeometry.addGroup(0, blackPointIndices.length, 0);\n\n                blackPointGeometry.setAttribute(\n                    \"position\",\n                    new THREE.BufferAttribute(new Float32Array(blackPointPositions), 3)\n                );\n\n                blackPointGeometry.setIndex(\n                    new THREE.BufferAttribute(new Uint32Array(blackPointIndices), 1)\n                );\n                const blackPointMesh = new THREE.Mesh(blackPointGeometry, debugBlackCircleMaterial);\n                blackPointMesh.renderOrder = PRIORITY_ALWAYS - 1;\n                this.objects.push(blackPointMesh);\n            }\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeoJson, ITiler, WorkerServiceProtocol } from \"@here/harp-datasource-protocol\";\nimport \"@here/harp-fetch\";\nimport { TileKey } from \"@here/harp-geoutils\";\nimport { ConcurrentTilerFacade } from \"@here/harp-mapview\";\nimport { DataProvider } from \"@here/harp-mapview-decoder\";\nimport { LoggerManager } from \"@here/harp-utils\";\n\nconst logger = LoggerManager.instance.create(\"GeoJsonDataProvider\");\n\nexport interface GeoJsonDataProviderOptions {\n    /**\n     * Worker script hosting [[Tiler Service]]\n     * @default `./decoder.bundle.ts`\n     */\n    workerTilerUrl?: string;\n\n    /**\n     * Custom tiler instance.\n     * If not provided, [[GeoJsonDataProvider]] will obtain [[WorkerBasedTiler]]\n     * from [[ConcurrentTilerFacade]].\n     */\n    tiler?: ITiler;\n}\n\nlet missingTilerServiceInfoEmitted: boolean = false;\n\n/**\n * GeoJson [[DataProvider]]. Automatically handles tiling and simplification of static GeoJson.\n */\nexport class GeoJsonDataProvider implements DataProvider {\n    private m_tiler: ITiler;\n    private m_registered = false;\n\n    /**\n     * Constructs a new `GeoJsonDataProvider`.\n     *\n     * @param name - Name to be used to reference this `DataProvider`\n     * @param input - URL of the GeoJSON, or a GeoJSON.\n     * @param options - Optional\n     * @returns New `GeoJsonDataProvider`.\n     */\n    constructor(\n        readonly name: string,\n        public input: URL | GeoJson,\n        options?: GeoJsonDataProviderOptions\n    ) {\n        this.m_tiler =\n            (options && options.tiler) ||\n            ConcurrentTilerFacade.getTiler(\"omv-tiler\", options && options.workerTilerUrl);\n    }\n\n    async connect(): Promise<void> {\n        try {\n            await this.m_tiler.connect();\n        } catch (error) {\n            if (\n                WorkerServiceProtocol.isUnknownServiceError(error) &&\n                !missingTilerServiceInfoEmitted\n            ) {\n                logger.info(\n                    \"Unable to start GeoJson tiler service in worker. Use \" +\n                        \" 'OmvTilerService.start();' in decoder script.\"\n                );\n                missingTilerServiceInfoEmitted = true;\n            }\n            throw error;\n        }\n\n        await this.m_tiler.registerIndex(this.name, this.input);\n        this.m_registered = true;\n    }\n\n    updateInput(input: URL | GeoJson) {\n        this.input = input;\n        this.m_tiler.updateIndex(this.name, this.input);\n    }\n\n    ready(): boolean {\n        return this.m_registered;\n    }\n\n    async getTile(tileKey: TileKey): Promise<{}> {\n        return this.m_tiler.getTile(this.name, tileKey);\n    }\n}\n","/*\n * Copyright (C) 2017-2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/** @hidden */\nexport const apikey = \"J0IJdYzKDYS3nHVDDEWETIqK3nAcxqW42vz7xeSq61M\";\n\n/** @hidden */\nexport const copyrightInfo = [\n    {\n        id: \"here.com\",\n        year: new Date().getFullYear(),\n        label: \"HERE\",\n        link: \"https://legal.here.com/terms\"\n    }\n];\n"],"sourceRoot":""}